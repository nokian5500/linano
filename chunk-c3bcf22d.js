var wn = Object.defineProperty
  , Sn = Object.defineProperties;
var Cn = Object.getOwnPropertyDescriptors;
var Xr = Object.getOwnPropertySymbols;
var cn = Object.prototype.hasOwnProperty
  , dn = Object.prototype.propertyIsEnumerable;
var Hr = (_,k)=>{
    if (k = Symbol[_])
        return k;
    throw Error("Symbol." + _ + " is not defined")
}
;
var un = (_,k,J)=>k in _ ? wn(_, k, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: J
}) : _[k] = J
  , $t = (_,k)=>{
    for (var J in k || (k = {}))
        cn.call(k, J) && un(_, J, k[J]);
    if (Xr)
        for (var J of Xr(k))
            dn.call(k, J) && un(_, J, k[J]);
    return _
}
  , _t = (_,k)=>Sn(_, Cn(k));
var Kt = (_,k)=>{
    var J = {};
    for (var et in _)
        cn.call(_, et) && k.indexOf(et) < 0 && (J[et] = _[et]);
    if (_ != null && Xr)
        for (var et of Xr(_))
            k.indexOf(et) < 0 && dn.call(_, et) && (J[et] = _[et]);
    return J
}
;
var zr = function(_, k) {
    this[0] = _,
    this[1] = k
}
  , pn = (_,k,J)=>{
    var et = (nt,ot,it,at)=>{
        try {
            var lt = J[nt](ot)
              , st = (ot = lt.value)instanceof zr
              , ut = lt.done;
            Promise.resolve(st ? ot[0] : ot).then(ct=>st ? et(nt === "return" ? nt : "next", ot[1] ? {
                done: ct.done,
                value: ct.value
            } : ct, it, at) : it({
                value: ct,
                done: ut
            })).catch(ct=>et("throw", ct, it, at))
        } catch (ct) {
            at(ct)
        }
    }
      , tt = nt=>rt[nt] = ot=>new Promise((it,at)=>et(nt, ot, it, at))
      , rt = {};
    return J = J.apply(_, k),
    rt[Symbol.asyncIterator] = ()=>rt,
    tt("next"),
    tt("throw"),
    tt("return"),
    rt
}
  , fn = _=>{
    var k = _[Hr("asyncIterator")], J = !1, et, tt = {};
    return k == null ? (k = _[Hr("iterator")](),
    et = rt=>tt[rt] = nt=>k[rt](nt)) : (k = k.call(_),
    et = rt=>tt[rt] = nt=>{
        if (J) {
            if (J = !1,
            rt === "throw")
                throw nt;
            return nt
        }
        return J = !0,
        {
            done: !1,
            value: new zr(new Promise(ot=>{
                var it = k[rt](nt);
                if (!(it instanceof Object))
                    throw TypeError("Object expected");
                ot(it)
            }
            ),1)
        }
    }
    ),
    tt[Hr("iterator")] = ()=>tt,
    et("next"),
    "throw"in k ? et("throw") : tt.throw = rt=>{
        throw rt
    }
    ,
    "return"in k && et("return"),
    tt
}
  , hn = (_,k,J)=>(k = _[Hr("asyncIterator")]) ? k.call(_) : (_ = _[Hr("iterator")](),
k = {},
J = (et,tt)=>(tt = _[et]) && (k[et] = rt=>new Promise((nt,ot,it)=>(rt = tt.call(_, rt),
it = rt.done,
Promise.resolve(rt.value).then(at=>nt({
    value: at,
    done: it
}), ot)))),
J("next"),
J("return"),
k);
import {_ as __vitePreload} from "./chunk-cf010ec4.js";
import {r as reactExports, R as React, g as getDefaultExportFromCjs$1, a as react} from "./chunk-73e80d68.js";
let baseIsMatch, baseGetAllKeys, getTag$1, nodeUtil$1, baseUnary, isBuffer$3, Stack, getAllKeys, arrayMap, baseIteratee, isTypedArray$2, isArguments$1, isFunction$1, SetCache, cacheHas, baseSlice, mapToArray, basePropertyOf, arrayFilter, Symbol$2, hasPath, Uint8Array$2, toFinite, WeakMap$2, baseGet, castPath, baseKeys, baseIsEqual, app, camelToDash, getMatchData, coreJsData$1, stubFalse, baseIsNative, baseMatches, baseMatchesProperty, setToArray, arraySome, baseProperty, hasIn, mix, moveItem, motion, interpolate, useMotionValue, useIsomorphicLayoutEffect$2, cancelFrame, frame, collectMotionValues, isMotionValue, createDomVisualElement, animations, gestureAnimations, drag, layout, animateValue, frameData, millisecondsToSeconds, resolveElements, progress, velocityPerSecond, defaultOffset, warning$1, motionValue, MotionValue, transformProps, isCSSVariableName, baseSortedIndexBy, baseTimes, stringToPath$1, baseTrim, trimmedEndIndex, Set$2, chunk, sortedIndexBy, now$1, before, debounce, memoize$1, once$1, throttle$1, isLength, unescape$2, property, createMotionProxy, createDomMotionConfig, loadExternalIsValidProp, MotionConfigContext, useConstant, loadFeatures, LazyContext, LayoutGroupContext, useForceUpdate$1, baseToString, mirrorEasing, addUniqueItem, removeItem, hasReducedMotionListener, initPrefersReducedMotion, prefersReducedMotion, useUnmountEffect, createScopedAnimate, wrap, addDomEvent, motionComponentSymbol, animationControls, anticipate, backIn, backInOut, backOut, buildTransform, calcLength, circIn, circInOut, circOut, clamp, color, complex, createDomMotionComponent, createMotionComponent, cubicBezier, delay$1, distance, distance2D, easeIn, easeInOut, easeOut, filterProps, invariant$1, isBrowser$1, isDragActive, isValidMotionProp, rootProjectionNode, instantAnimationState, optimizedAppearDataId, animateStyle, noop$4, makeUseVisualState, animateVisualElement, VisualElement, createBox, getOrigin, checkTargetForNewValues, MotionContext, observeTimeline, supportsScrollTimeline, easingDefinitionToFunction, stepsOrder, AnimatePresence, DragControls, FlatTree, MotionGlobalConfig, PresenceContext, SwitchLayoutGroupContext, addPointerEvent, addPointerInfo, addScaleCorrector, animate$1, identity, RadioBase, optimizedAppearDataAttribute, pipe, px, resolveMotionValue, reverseEasing, spring, steps, useAnimation, useAnimationControls, useDragControls, Empty, ErrorBoundary, ErrorCode$1, ErrorWithTip, EventEmitter$2, FileSelect, FlatList$1, HttpResponseError, I18nProvider, Icon, Image$1, Imgix, Input, InputNumber, InputPassword, InputWrap, LayoutSizeProvider, LazyImage, Link, Loading$1, Long, Lottie, Overlayer, Pagination, Pop, Portal, Radio, useIsPresent, usePresence, visualElementStore, howler, Active, ActiveProvider, AnimatedNumber, AppProvider, BC, Badge, Breadcrumb, Button2, ButtonGroup, Carousel$1, CircleCountdown, CloseIcon, CodeSegment, Confirm, Content, Countdown$1, Decimal$1, DecimalUtils, Dialog, DialogHeader, DialogTable, DragDialog, isObject$2, useInOverlayer, ScrollView, Select$1, SelectBase, Slider, State, SuspenseData, SuspenseSource, Swiper, Switch$1, Table, pickLazyComponent, pickLazyFunction, pop, minimal$3, requestRecaptcha, settingStore, socket, subscribePageContext, supportSocket, system, systemStore, useAccount, useActiveMemo, useAnimatedFrames, useAsync, useAsyncFn, useAsyncNode, useAutoRemove, useBcd, useChangeLang, useCurrencyConfig, useDelayHover, useDialog, useDisableBodyScroll, useDisableParentScroll, useForceUpdate, useHover, Tabs$1, Text, Textarea, ToggleView, Tooltip, TooltipBase, Trans, UpdateInView$1, User, VipLevelStatus, WithOutSsr, accountStore, addUserReceiptEvent, AsyncQueue$1, bcdStore, createI18nT, dialog, env, formateContent, http, instance, langsLocaleToISO6391, lazyLoad, notify, parseI18Locales, isObjectLike, useInView, useIntersection, useIsActive, useIsDarken, useIsFirstRender, useIsMobile, useIsomorphicEffect, useLayoutSize, useLinkIntercept, useLocalCurrency, valtio, wallet, walletStore, F, ReactDOM, reactDomExports, react_dom, gsap, gsapWithCSS, react_router_dom, useLocation$1, commonjsGlobal, getDefaultExportFromCjs, useLocation, useMergeRefs, useMountedState, useNavigate, useNotify, useOnClickOutside, usePageContext, usePageProps, usePop, usePortalContext, usePortalList, usePrevious, useQrcode, useResize, useRootClassName, useSetSearch, useSetState, useSetting, useSmoothList, useSystem, useToggleDarken, useTranslation, useWallet, useWindowSize, userSocket, index$1, isIndex, getNative, eq, isSymbol, isIterateeCall, isPrototype, isArrayLike, keys$1, n0, arrayLikeKeys, get$1, overArg, root$1, baseGetTag, toInteger, toKey, toNumber, toString$5, getSymbols$1, stubArray, arrayPush, __tla = (async()=>{
    function _mergeNamespaces(_, k) {
        for (var J = 0; J < k.length; J++) {
            const et = k[J];
            if (typeof et != "string" && !Array.isArray(et)) {
                for (const tt in et)
                    if (tt !== "default" && !(tt in _)) {
                        const rt = Object.getOwnPropertyDescriptor(et, tt);
                        rt && Object.defineProperty(_, tt, rt.get ? rt : {
                            enumerable: !0,
                            get: ()=>et[tt]
                        })
                    }
            }
        }
        return Object.assign(Object.defineProperty(_, Symbol.toStringTag, {
            value: "Module"
        }))
    }
    function _assertThisInitialized(_) {
        if (_ === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return _
    }
    function _inheritsLoose(_, k) {
        _.prototype = Object.create(k.prototype),
        _.prototype.constructor = _,
        _.__proto__ = k
    }
    var _config = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    }, _defaults = {
        duration: .5,
        overwrite: !1,
        delay: 0
    }, _suppressOverwrites, _reverting$1, _context, _bigNum$1 = 1e8, _tinyNum = 1 / _bigNum$1, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function(_) {
        return typeof _ == "string"
    }, _isFunction = function(_) {
        return typeof _ == "function"
    }, _isNumber = function(_) {
        return typeof _ == "number"
    }, _isUndefined = function(_) {
        return typeof _ > "u"
    }, _isObject = function(_) {
        return typeof _ == "object"
    }, _isNotFalse = function(_) {
        return _ !== !1
    }, _windowExists$1 = function() {
        return typeof window < "u"
    }, _isFuncOrString = function(_) {
        return _isFunction(_) || _isString(_)
    }, _isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {}
    , _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$1, _coreInitted, _doc$1, _globals = {}, _installScope = {}, _coreReady, _install = function(_) {
        return (_installScope = _merge(_, _globals)) && gsap$1
    }, _missingPlugin = function(_, k) {}, _warn = function(_, k) {
        return !k && void 0
    }, _addGlobal = function(_, k) {
        return _ && (_globals[_] = k) && _installScope && (_installScope[_] = k) || _globals
    }, _emptyFunc = function() {
        return 0
    }, _startAtRevertConfig = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    }, _revertConfigNoKill = {
        suppressEvents: !0,
        kill: !1
    }, _revertConfig = {
        suppressEvents: !0
    }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function(_) {
        var k = _[0], J, et;
        if (_isObject(k) || _isFunction(k) || (_ = [_]),
        !(J = (k._gsap || {}).harness)) {
            for (et = _harnessPlugins.length; et-- && !_harnessPlugins[et].targetTest(k); )
                ;
            J = _harnessPlugins[et]
        }
        for (et = _.length; et--; )
            _[et] && (_[et]._gsap || (_[et]._gsap = new GSCache(_[et],J))) || _.splice(et, 1);
        return _
    }, _getCache = function(_) {
        return _._gsap || _harness(toArray$2(_))[0]._gsap
    }, _getProperty = function(_, k, J) {
        return (J = _[k]) && _isFunction(J) ? _[k]() : _isUndefined(J) && _.getAttribute && _.getAttribute(k) || J
    }, _forEachName = function(_, k) {
        return (_ = _.split(",")).forEach(k) || _
    }, _round = function(_) {
        return Math.round(_ * 1e5) / 1e5 || 0
    }, _roundPrecise = function(_) {
        return Math.round(_ * 1e7) / 1e7 || 0
    }, _parseRelative = function(_, k) {
        var J = k.charAt(0)
          , et = parseFloat(k.substr(2));
        return _ = parseFloat(_),
        J === "+" ? _ + et : J === "-" ? _ - et : J === "*" ? _ * et : _ / et
    }, _arrayContainsAny = function(_, k) {
        for (var J = k.length, et = 0; _.indexOf(k[et]) < 0 && ++et < J; )
            ;
        return et < J
    }, _lazyRender = function() {
        var _ = _lazyTweens.length, k = _lazyTweens.slice(0), J, et;
        for (_lazyLookup = {},
        _lazyTweens.length = 0,
        J = 0; J < _; J++)
            et = k[J],
            et && et._lazy && (et.render(et._lazy[0], et._lazy[1], !0)._lazy = 0)
    }, _lazySafeRender = function(_, k, J, et) {
        _lazyTweens.length && !_reverting$1 && _lazyRender(),
        _.render(k, J, et || _reverting$1 && k < 0 && (_._initted || _._startAt)),
        _lazyTweens.length && !_reverting$1 && _lazyRender()
    }, _numericIfPossible = function(_) {
        var k = parseFloat(_);
        return (k || k === 0) && (_ + "").match(_delimitedValueExp).length < 2 ? k : _isString(_) ? _.trim() : _
    }, _passThrough = function(_) {
        return _
    }, _setDefaults = function(_, k) {
        for (var J in k)
            J in _ || (_[J] = k[J]);
        return _
    }, _setKeyframeDefaults = function(_) {
        return function(k, J) {
            for (var et in J)
                et in k || et === "duration" && _ || et === "ease" || (k[et] = J[et])
        }
    }, _merge = function(_, k) {
        for (var J in k)
            _[J] = k[J];
        return _
    }, _mergeDeep = function _(k, J) {
        for (var et in J)
            et !== "__proto__" && et !== "constructor" && et !== "prototype" && (k[et] = _isObject(J[et]) ? _(k[et] || (k[et] = {}), J[et]) : J[et]);
        return k
    }, _copyExcluding = function(_, k) {
        var J = {}, et;
        for (et in _)
            et in k || (J[et] = _[et]);
        return J
    }, _inheritDefaults = function(_) {
        var k = _.parent || _globalTimeline
          , J = _.keyframes ? _setKeyframeDefaults(_isArray(_.keyframes)) : _setDefaults;
        if (_isNotFalse(_.inherit))
            for (; k; )
                J(_, k.vars.defaults),
                k = k.parent || k._dp;
        return _
    }, _arraysMatch = function(_, k) {
        for (var J = _.length, et = J === k.length; et && J-- && _[J] === k[J]; )
            ;
        return J < 0
    }, _addLinkedListItem = function(_, k, J, et, tt) {
        J === void 0 && (J = "_first"),
        et === void 0 && (et = "_last");
        var rt = _[et], nt;
        if (tt)
            for (nt = k[tt]; rt && rt[tt] > nt; )
                rt = rt._prev;
        return rt ? (k._next = rt._next,
        rt._next = k) : (k._next = _[J],
        _[J] = k),
        k._next ? k._next._prev = k : _[et] = k,
        k._prev = rt,
        k.parent = k._dp = _,
        k
    }, _removeLinkedListItem = function(_, k, J, et) {
        J === void 0 && (J = "_first"),
        et === void 0 && (et = "_last");
        var tt = k._prev
          , rt = k._next;
        tt ? tt._next = rt : _[J] === k && (_[J] = rt),
        rt ? rt._prev = tt : _[et] === k && (_[et] = tt),
        k._next = k._prev = k.parent = null
    }, _removeFromParent = function(_, k) {
        _.parent && (!k || _.parent.autoRemoveChildren) && _.parent.remove && _.parent.remove(_),
        _._act = 0
    }, _uncache = function(_, k) {
        if (_ && (!k || k._end > _._dur || k._start < 0))
            for (var J = _; J; )
                J._dirty = 1,
                J = J.parent;
        return _
    }, _recacheAncestors = function(_) {
        for (var k = _.parent; k && k.parent; )
            k._dirty = 1,
            k.totalDuration(),
            k = k.parent;
        return _
    }, _rewindStartAt = function(_, k, J, et) {
        return _._startAt && (_reverting$1 ? _._startAt.revert(_revertConfigNoKill) : _.vars.immediateRender && !_.vars.autoRevert || _._startAt.render(k, !0, et))
    }, _hasNoPausedAncestors = function _(k) {
        return !k || k._ts && _(k.parent)
    }, _elapsedCycleDuration = function(_) {
        return _._repeat ? _animationCycle(_._tTime, _ = _.duration() + _._rDelay) * _ : 0
    }, _animationCycle = function(_, k) {
        var J = Math.floor(_ /= k);
        return _ && J === _ ? J - 1 : J
    }, _parentToChildTotalTime = function(_, k) {
        return (_ - k._start) * k._ts + (k._ts >= 0 ? 0 : k._dirty ? k.totalDuration() : k._tDur)
    }, _setEnd = function(_) {
        return _._end = _roundPrecise(_._start + (_._tDur / Math.abs(_._ts || _._rts || _tinyNum) || 0))
    }, _alignPlayhead = function(_, k) {
        var J = _._dp;
        return J && J.smoothChildTiming && _._ts && (_._start = _roundPrecise(J._time - (_._ts > 0 ? k / _._ts : ((_._dirty ? _.totalDuration() : _._tDur) - k) / -_._ts)),
        _setEnd(_),
        J._dirty || _uncache(J, _)),
        _
    }, _postAddChecks = function(_, k) {
        var J;
        if ((k._time || !k._dur && k._initted || k._start < _._time && (k._dur || !k.add)) && (J = _parentToChildTotalTime(_.rawTime(), k),
        (!k._dur || _clamp(0, k.totalDuration(), J) - k._tTime > _tinyNum) && k.render(J, !0)),
        _uncache(_, k)._dp && _._initted && _._time >= _._dur && _._ts) {
            if (_._dur < _.duration())
                for (J = _; J._dp; )
                    J.rawTime() >= 0 && J.totalTime(J._tTime),
                    J = J._dp;
            _._zTime = -_tinyNum
        }
    }, _addToTimeline = function(_, k, J, et) {
        return k.parent && _removeFromParent(k),
        k._start = _roundPrecise((_isNumber(J) ? J : J || _ !== _globalTimeline ? _parsePosition(_, J, k) : _._time) + k._delay),
        k._end = _roundPrecise(k._start + (k.totalDuration() / Math.abs(k.timeScale()) || 0)),
        _addLinkedListItem(_, k, "_first", "_last", _._sort ? "_start" : 0),
        _isFromOrFromStart(k) || (_._recent = k),
        et || _postAddChecks(_, k),
        _._ts < 0 && _alignPlayhead(_, _._tTime),
        _
    }, _scrollTrigger = function(_, k) {
        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", k)) && _globals.ScrollTrigger.create(k, _)
    }, _attemptInitTween = function(_, k, J, et, tt) {
        if (_initTween(_, k, tt),
        !_._initted)
            return 1;
        if (!J && _._pt && !_reverting$1 && (_._dur && _.vars.lazy !== !1 || !_._dur && _.vars.lazy) && _lastRenderedFrame !== _ticker.frame)
            return _lazyTweens.push(_),
            _._lazy = [tt, et],
            1
    }, _parentPlayheadIsBeforeStart = function _(k) {
        var J = k.parent;
        return J && J._ts && J._initted && !J._lock && (J.rawTime() < 0 || _(J))
    }, _isFromOrFromStart = function(_) {
        var k = _.data;
        return k === "isFromStart" || k === "isStart"
    }, _renderZeroDurationTween = function(_, k, J, et) {
        var tt = _.ratio, rt = k < 0 || !k && (!_._start && _parentPlayheadIsBeforeStart(_) && !(!_._initted && _isFromOrFromStart(_)) || (_._ts < 0 || _._dp._ts < 0) && !_isFromOrFromStart(_)) ? 0 : 1, nt = _._rDelay, ot = 0, it, at, lt;
        if (nt && _._repeat && (ot = _clamp(0, _._tDur, k),
        at = _animationCycle(ot, nt),
        _._yoyo && at & 1 && (rt = 1 - rt),
        at !== _animationCycle(_._tTime, nt) && (tt = 1 - rt,
        _.vars.repeatRefresh && _._initted && _.invalidate())),
        rt !== tt || _reverting$1 || et || _._zTime === _tinyNum || !k && _._zTime) {
            if (!_._initted && _attemptInitTween(_, k, et, J, ot))
                return;
            for (lt = _._zTime,
            _._zTime = k || (J ? _tinyNum : 0),
            J || (J = k && !lt),
            _.ratio = rt,
            _._from && (rt = 1 - rt),
            _._time = 0,
            _._tTime = ot,
            it = _._pt; it; )
                it.r(rt, it.d),
                it = it._next;
            k < 0 && _rewindStartAt(_, k, J, !0),
            _._onUpdate && !J && _callback(_, "onUpdate"),
            ot && _._repeat && !J && _.parent && _callback(_, "onRepeat"),
            (k >= _._tDur || k < 0) && _.ratio === rt && (rt && _removeFromParent(_, 1),
            !J && !_reverting$1 && (_callback(_, rt ? "onComplete" : "onReverseComplete", !0),
            _._prom && _._prom()))
        } else
            _._zTime || (_._zTime = k)
    }, _findNextPauseTween = function(_, k, J) {
        var et;
        if (J > k)
            for (et = _._first; et && et._start <= J; ) {
                if (et.data === "isPause" && et._start > k)
                    return et;
                et = et._next
            }
        else
            for (et = _._last; et && et._start >= J; ) {
                if (et.data === "isPause" && et._start < k)
                    return et;
                et = et._prev
            }
    }, _setDuration = function(_, k, J, et) {
        var tt = _._repeat
          , rt = _roundPrecise(k) || 0
          , nt = _._tTime / _._tDur;
        return nt && !et && (_._time *= rt / _._dur),
        _._dur = rt,
        _._tDur = tt ? tt < 0 ? 1e10 : _roundPrecise(rt * (tt + 1) + _._rDelay * tt) : rt,
        nt > 0 && !et && _alignPlayhead(_, _._tTime = _._tDur * nt),
        _.parent && _setEnd(_),
        J || _uncache(_.parent, _),
        _
    }, _onUpdateTotalDuration = function(_) {
        return _ instanceof Timeline ? _uncache(_) : _setDuration(_, _._dur)
    }, _zeroPosition = {
        _start: 0,
        endTime: _emptyFunc,
        totalDuration: _emptyFunc
    }, _parsePosition = function _(k, J, et) {
        var tt = k.labels, rt = k._recent || _zeroPosition, nt = k.duration() >= _bigNum$1 ? rt.endTime(!1) : k._dur, ot, it, at;
        return _isString(J) && (isNaN(J) || J in tt) ? (it = J.charAt(0),
        at = J.substr(-1) === "%",
        ot = J.indexOf("="),
        it === "<" || it === ">" ? (ot >= 0 && (J = J.replace(/=/, "")),
        (it === "<" ? rt._start : rt.endTime(rt._repeat >= 0)) + (parseFloat(J.substr(1)) || 0) * (at ? (ot < 0 ? rt : et).totalDuration() / 100 : 1)) : ot < 0 ? (J in tt || (tt[J] = nt),
        tt[J]) : (it = parseFloat(J.charAt(ot - 1) + J.substr(ot + 1)),
        at && et && (it = it / 100 * (_isArray(et) ? et[0] : et).totalDuration()),
        ot > 1 ? _(k, J.substr(0, ot - 1), et) + it : nt + it)) : J == null ? nt : +J
    }, _createTweenType = function(_, k, J) {
        var et = _isNumber(k[1]), tt = (et ? 2 : 1) + (_ < 2 ? 0 : 1), rt = k[tt], nt, ot;
        if (et && (rt.duration = k[1]),
        rt.parent = J,
        _) {
            for (nt = rt,
            ot = J; ot && !("immediateRender"in nt); )
                nt = ot.vars.defaults || {},
                ot = _isNotFalse(ot.vars.inherit) && ot.parent;
            rt.immediateRender = _isNotFalse(nt.immediateRender),
            _ < 2 ? rt.runBackwards = 1 : rt.startAt = k[tt - 1]
        }
        return new Tween(k[0],rt,k[tt + 1])
    }, _conditionalReturn = function(_, k) {
        return _ || _ === 0 ? k(_) : k
    }, _clamp = function(_, k, J) {
        return J < _ ? _ : J > k ? k : J
    }, getUnit = function(_, k) {
        return !_isString(_) || !(k = _unitExp.exec(_)) ? "" : k[1]
    }, clamp$1 = function(_, k, J) {
        return _conditionalReturn(J, function(et) {
            return _clamp(_, k, et)
        })
    }, _slice = [].slice, _isArrayLike = function(_, k) {
        return _ && _isObject(_) && "length"in _ && (!k && !_.length || _.length - 1 in _ && _isObject(_[0])) && !_.nodeType && _ !== _win$1
    }, _flatten = function(_, k, J) {
        return J === void 0 && (J = []),
        _.forEach(function(et) {
            var tt;
            return _isString(et) && !k || _isArrayLike(et, 1) ? (tt = J).push.apply(tt, toArray$2(et)) : J.push(et)
        }) || J
    }, toArray$2 = function(_, k, J) {
        return _context && !k && _context.selector ? _context.selector(_) : _isString(_) && !J && (_coreInitted || !_wake()) ? _slice.call((k || _doc$1).querySelectorAll(_), 0) : _isArray(_) ? _flatten(_, J) : _isArrayLike(_) ? _slice.call(_, 0) : _ ? [_] : []
    }, selector = function(_) {
        return _ = toArray$2(_)[0] || _warn("Invalid scope") || {},
        function(k) {
            var J = _.current || _.nativeElement || _;
            return toArray$2(k, J.querySelectorAll ? J : J === _ ? _warn("Invalid scope") || _doc$1.createElement("div") : _)
        }
    }, shuffle = function(_) {
        return _.sort(function() {
            return .5 - Math.random()
        })
    }, distribute = function(_) {
        if (_isFunction(_))
            return _;
        var k = _isObject(_) ? _ : {
            each: _
        }
          , J = _parseEase(k.ease)
          , et = k.from || 0
          , tt = parseFloat(k.base) || 0
          , rt = {}
          , nt = et > 0 && et < 1
          , ot = isNaN(et) || nt
          , it = k.axis
          , at = et
          , lt = et;
        return _isString(et) ? at = lt = {
            center: .5,
            edges: .5,
            end: 1
        }[et] || 0 : !nt && ot && (at = et[0],
        lt = et[1]),
        function(st, ut, ct) {
            var pt = (ct || k).length, ft = rt[pt], yt, ht, gt, mt, vt, bt, Et, xt, wt;
            if (!ft) {
                if (wt = k.grid === "auto" ? 0 : (k.grid || [1, _bigNum$1])[1],
                !wt) {
                    for (Et = -_bigNum$1; Et < (Et = ct[wt++].getBoundingClientRect().left) && wt < pt; )
                        ;
                    wt < pt && wt--
                }
                for (ft = rt[pt] = [],
                yt = ot ? Math.min(wt, pt) * at - .5 : et % wt,
                ht = wt === _bigNum$1 ? 0 : ot ? pt * lt / wt - .5 : et / wt | 0,
                Et = 0,
                xt = _bigNum$1,
                bt = 0; bt < pt; bt++)
                    gt = bt % wt - yt,
                    mt = ht - (bt / wt | 0),
                    ft[bt] = vt = it ? Math.abs(it === "y" ? mt : gt) : _sqrt(gt * gt + mt * mt),
                    vt > Et && (Et = vt),
                    vt < xt && (xt = vt);
                et === "random" && shuffle(ft),
                ft.max = Et - xt,
                ft.min = xt,
                ft.v = pt = (parseFloat(k.amount) || parseFloat(k.each) * (wt > pt ? pt - 1 : it ? it === "y" ? pt / wt : wt : Math.max(wt, pt / wt)) || 0) * (et === "edges" ? -1 : 1),
                ft.b = pt < 0 ? tt - pt : tt,
                ft.u = getUnit(k.amount || k.each) || 0,
                J = J && pt < 0 ? _invertEase(J) : J
            }
            return pt = (ft[st] - ft.min) / ft.max || 0,
            _roundPrecise(ft.b + (J ? J(pt) : pt) * ft.v) + ft.u
        }
    }, _roundModifier = function(_) {
        var k = Math.pow(10, ((_ + "").split(".")[1] || "").length);
        return function(J) {
            var et = _roundPrecise(Math.round(parseFloat(J) / _) * _ * k);
            return (et - et % 1) / k + (_isNumber(J) ? 0 : getUnit(J))
        }
    }, snap = function(_, k) {
        var J = _isArray(_), et, tt;
        return !J && _isObject(_) && (et = J = _.radius || _bigNum$1,
        _.values ? (_ = toArray$2(_.values),
        (tt = !_isNumber(_[0])) && (et *= et)) : _ = _roundModifier(_.increment)),
        _conditionalReturn(k, J ? _isFunction(_) ? function(rt) {
            return tt = _(rt),
            Math.abs(tt - rt) <= et ? tt : rt
        }
        : function(rt) {
            for (var nt = parseFloat(tt ? rt.x : rt), ot = parseFloat(tt ? rt.y : 0), it = _bigNum$1, at = 0, lt = _.length, st, ut; lt--; )
                tt ? (st = _[lt].x - nt,
                ut = _[lt].y - ot,
                st = st * st + ut * ut) : st = Math.abs(_[lt] - nt),
                st < it && (it = st,
                at = lt);
            return at = !et || it <= et ? _[at] : rt,
            tt || at === rt || _isNumber(rt) ? at : at + getUnit(rt)
        }
        : _roundModifier(_))
    }, random$1 = function(_, k, J, et) {
        return _conditionalReturn(_isArray(_) ? !k : J === !0 ? !!(J = 0) : !et, function() {
            return _isArray(_) ? _[~~(Math.random() * _.length)] : (J = J || 1e-5) && (et = J < 1 ? Math.pow(10, (J + "").length - 2) : 1) && Math.floor(Math.round((_ - J / 2 + Math.random() * (k - _ + J * .99)) / J) * J * et) / et
        })
    }, pipe$1 = function() {
        for (var _ = arguments.length, k = new Array(_), J = 0; J < _; J++)
            k[J] = arguments[J];
        return function(et) {
            return k.reduce(function(tt, rt) {
                return rt(tt)
            }, et)
        }
    }, unitize = function(_, k) {
        return function(J) {
            return _(parseFloat(J)) + (k || getUnit(J))
        }
    }, normalize = function(_, k, J) {
        return mapRange(_, k, 0, 1, J)
    }, _wrapArray = function(_, k, J) {
        return _conditionalReturn(J, function(et) {
            return _[~~k(et)]
        })
    }, wrap$1 = function _(k, J, et) {
        var tt = J - k;
        return _isArray(k) ? _wrapArray(k, _(0, k.length), J) : _conditionalReturn(et, function(rt) {
            return (tt + (rt - k) % tt) % tt + k
        })
    }, wrapYoyo = function _(k, J, et) {
        var tt = J - k
          , rt = tt * 2;
        return _isArray(k) ? _wrapArray(k, _(0, k.length - 1), J) : _conditionalReturn(et, function(nt) {
            return nt = (rt + (nt - k) % rt) % rt || 0,
            k + (nt > tt ? rt - nt : nt)
        })
    }, _replaceRandom = function(_) {
        for (var k = 0, J = "", et, tt, rt, nt; ~(et = _.indexOf("random(", k)); )
            rt = _.indexOf(")", et),
            nt = _.charAt(et + 7) === "[",
            tt = _.substr(et + 7, rt - et - 7).match(nt ? _delimitedValueExp : _strictNumExp),
            J += _.substr(k, et - k) + random$1(nt ? tt : +tt[0], nt ? 0 : +tt[1], +tt[2] || 1e-5),
            k = rt + 1;
        return J + _.substr(k, _.length - k)
    }, mapRange = function(_, k, J, et, tt) {
        var rt = k - _
          , nt = et - J;
        return _conditionalReturn(tt, function(ot) {
            return J + ((ot - _) / rt * nt || 0)
        })
    }, interpolate$1 = function _(k, J, et, tt) {
        var rt = isNaN(k + J) ? 0 : function(ct) {
            return (1 - ct) * k + ct * J
        }
        ;
        if (!rt) {
            var nt = _isString(k), ot = {}, it, at, lt, st, ut;
            if (et === !0 && (tt = 1) && (et = null),
            nt)
                k = {
                    p: k
                },
                J = {
                    p: J
                };
            else if (_isArray(k) && !_isArray(J)) {
                for (lt = [],
                st = k.length,
                ut = st - 2,
                at = 1; at < st; at++)
                    lt.push(_(k[at - 1], k[at]));
                st--,
                rt = function(ct) {
                    ct *= st;
                    var pt = Math.min(ut, ~~ct);
                    return lt[pt](ct - pt)
                }
                ,
                et = J
            } else
                tt || (k = _merge(_isArray(k) ? [] : {}, k));
            if (!lt) {
                for (it in J)
                    _addPropTween.call(ot, k, it, "get", J[it]);
                rt = function(ct) {
                    return _renderPropTweens(ct, ot) || (nt ? k.p : k)
                }
            }
        }
        return _conditionalReturn(et, rt)
    }, _getLabelInDirection = function(_, k, J) {
        var et = _.labels, tt = _bigNum$1, rt, nt, ot;
        for (rt in et)
            nt = et[rt] - k,
            nt < 0 == !!J && nt && tt > (nt = Math.abs(nt)) && (ot = rt,
            tt = nt);
        return ot
    }, _callback = function(_, k, J) {
        var et = _.vars, tt = et[k], rt = _context, nt = _._ctx, ot, it, at;
        if (tt)
            return ot = et[k + "Params"],
            it = et.callbackScope || _,
            J && _lazyTweens.length && _lazyRender(),
            nt && (_context = nt),
            at = ot ? tt.apply(it, ot) : tt.call(it),
            _context = rt,
            at
    }, _interrupt = function(_) {
        return _removeFromParent(_),
        _.scrollTrigger && _.scrollTrigger.kill(!!_reverting$1),
        _.progress() < 1 && _callback(_, "onInterrupt"),
        _
    }, _quickTween, _registerPluginQueue = [], _createPlugin = function(_) {
        if (_)
            if (_ = !_.name && _.default || _,
            _windowExists$1() || _.headless) {
                var k = _.name
                  , J = _isFunction(_)
                  , et = k && !J && _.init ? function() {
                    this._props = []
                }
                : _
                  , tt = {
                    init: _emptyFunc,
                    render: _renderPropTweens,
                    add: _addPropTween,
                    kill: _killPropTweensOf,
                    modifier: _addPluginModifier,
                    rawVars: 0
                }
                  , rt = {
                    targetTest: 0,
                    get: 0,
                    getSetter: _getSetter,
                    aliases: {},
                    register: 0
                };
                if (_wake(),
                _ !== et) {
                    if (_plugins[k])
                        return;
                    _setDefaults(et, _setDefaults(_copyExcluding(_, tt), rt)),
                    _merge(et.prototype, _merge(tt, _copyExcluding(_, rt))),
                    _plugins[et.prop = k] = et,
                    _.targetTest && (_harnessPlugins.push(et),
                    _reservedProps[k] = 1),
                    k = (k === "css" ? "CSS" : k.charAt(0).toUpperCase() + k.substr(1)) + "Plugin"
                }
                _addGlobal(k, et),
                _.register && _.register(gsap$1, et, PropTween)
            } else
                _registerPluginQueue.push(_)
    }, _255 = 255, _colorLookup = {
        aqua: [0, _255, _255],
        lime: [0, _255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, _255],
        navy: [0, 0, 128],
        white: [_255, _255, _255],
        olive: [128, 128, 0],
        yellow: [_255, _255, 0],
        orange: [_255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [_255, 0, 0],
        pink: [_255, 192, 203],
        cyan: [0, _255, _255],
        transparent: [_255, _255, _255, 0]
    }, _hue = function(_, k, J) {
        return _ += _ < 0 ? 1 : _ > 1 ? -1 : 0,
        (_ * 6 < 1 ? k + (J - k) * _ * 6 : _ < .5 ? J : _ * 3 < 2 ? k + (J - k) * (2 / 3 - _) * 6 : k) * _255 + .5 | 0
    }, splitColor$1 = function(_, k, J) {
        var et = _ ? _isNumber(_) ? [_ >> 16, _ >> 8 & _255, _ & _255] : 0 : _colorLookup.black, tt, rt, nt, ot, it, at, lt, st, ut, ct;
        if (!et) {
            if (_.substr(-1) === "," && (_ = _.substr(0, _.length - 1)),
            _colorLookup[_])
                et = _colorLookup[_];
            else if (_.charAt(0) === "#") {
                if (_.length < 6 && (tt = _.charAt(1),
                rt = _.charAt(2),
                nt = _.charAt(3),
                _ = "#" + tt + tt + rt + rt + nt + nt + (_.length === 5 ? _.charAt(4) + _.charAt(4) : "")),
                _.length === 9)
                    return et = parseInt(_.substr(1, 6), 16),
                    [et >> 16, et >> 8 & _255, et & _255, parseInt(_.substr(7), 16) / 255];
                _ = parseInt(_.substr(1), 16),
                et = [_ >> 16, _ >> 8 & _255, _ & _255]
            } else if (_.substr(0, 3) === "hsl") {
                if (et = ct = _.match(_strictNumExp),
                !k)
                    ot = +et[0] % 360 / 360,
                    it = +et[1] / 100,
                    at = +et[2] / 100,
                    rt = at <= .5 ? at * (it + 1) : at + it - at * it,
                    tt = at * 2 - rt,
                    et.length > 3 && (et[3] *= 1),
                    et[0] = _hue(ot + 1 / 3, tt, rt),
                    et[1] = _hue(ot, tt, rt),
                    et[2] = _hue(ot - 1 / 3, tt, rt);
                else if (~_.indexOf("="))
                    return et = _.match(_numExp),
                    J && et.length < 4 && (et[3] = 1),
                    et
            } else
                et = _.match(_strictNumExp) || _colorLookup.transparent;
            et = et.map(Number)
        }
        return k && !ct && (tt = et[0] / _255,
        rt = et[1] / _255,
        nt = et[2] / _255,
        lt = Math.max(tt, rt, nt),
        st = Math.min(tt, rt, nt),
        at = (lt + st) / 2,
        lt === st ? ot = it = 0 : (ut = lt - st,
        it = at > .5 ? ut / (2 - lt - st) : ut / (lt + st),
        ot = lt === tt ? (rt - nt) / ut + (rt < nt ? 6 : 0) : lt === rt ? (nt - tt) / ut + 2 : (tt - rt) / ut + 4,
        ot *= 60),
        et[0] = ~~(ot + .5),
        et[1] = ~~(it * 100 + .5),
        et[2] = ~~(at * 100 + .5)),
        J && et.length < 4 && (et[3] = 1),
        et
    }, _colorOrderData = function(_) {
        var k = []
          , J = []
          , et = -1;
        return _.split(_colorExp).forEach(function(tt) {
            var rt = tt.match(_numWithUnitExp) || [];
            k.push.apply(k, rt),
            J.push(et += rt.length + 1)
        }),
        k.c = J,
        k
    }, _formatColors = function(_, k, J) {
        var et = "", tt = (_ + et).match(_colorExp), rt = k ? "hsla(" : "rgba(", nt = 0, ot, it, at, lt;
        if (!tt)
            return _;
        if (tt = tt.map(function(st) {
            return (st = splitColor$1(st, k, 1)) && rt + (k ? st[0] + "," + st[1] + "%," + st[2] + "%," + st[3] : st.join(",")) + ")"
        }),
        J && (at = _colorOrderData(_),
        ot = J.c,
        ot.join(et) !== at.c.join(et)))
            for (it = _.replace(_colorExp, "1").split(_numWithUnitExp),
            lt = it.length - 1; nt < lt; nt++)
                et += it[nt] + (~ot.indexOf(nt) ? tt.shift() || rt + "0,0,0,0)" : (at.length ? at : tt.length ? tt : J).shift());
        if (!it)
            for (it = _.split(_colorExp),
            lt = it.length - 1; nt < lt; nt++)
                et += it[nt] + tt[nt];
        return et + it[lt]
    }, _colorExp = function() {
        var _ = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", k;
        for (k in _colorLookup)
            _ += "|" + k + "\\b";
        return new RegExp(_ + ")","gi")
    }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function(_) {
        var k = _.join(" "), J;
        if (_colorExp.lastIndex = 0,
        _colorExp.test(k))
            return J = _hslExp.test(k),
            _[1] = _formatColors(_[1], J),
            _[0] = _formatColors(_[0], J, _colorOrderData(_[1])),
            !0
    }, _tickerActive, _ticker = function() {
        var _ = Date.now, k = 500, J = 33, et = _(), tt = et, rt = 1e3 / 240, nt = rt, ot = [], it, at, lt, st, ut, ct, pt = function ft(yt) {
            var ht = _() - tt, gt = yt === !0, mt, vt, bt, Et;
            if ((ht > k || ht < 0) && (et += ht - J),
            tt += ht,
            bt = tt - et,
            mt = bt - nt,
            (mt > 0 || gt) && (Et = ++st.frame,
            ut = bt - st.time * 1e3,
            st.time = bt = bt / 1e3,
            nt += mt + (mt >= rt ? 4 : rt - mt),
            vt = 1),
            gt || (it = at(ft)),
            vt)
                for (ct = 0; ct < ot.length; ct++)
                    ot[ct](bt, ut, Et, yt)
        };
        return st = {
            time: 0,
            frame: 0,
            tick: function() {
                pt(!0)
            },
            deltaRatio: function(ft) {
                return ut / (1e3 / (ft || 60))
            },
            wake: function() {
                _coreReady && (!_coreInitted && _windowExists$1() && (_win$1 = _coreInitted = window,
                _doc$1 = _win$1.document || {},
                _globals.gsap = gsap$1,
                (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap$1.version),
                _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {}),
                _registerPluginQueue.forEach(_createPlugin)),
                lt = typeof requestAnimationFrame < "u" && requestAnimationFrame,
                it && st.sleep(),
                at = lt || function(ft) {
                    return setTimeout(ft, nt - st.time * 1e3 + 1 | 0)
                }
                ,
                _tickerActive = 1,
                pt(2))
            },
            sleep: function() {
                (lt ? cancelAnimationFrame : clearTimeout)(it),
                _tickerActive = 0,
                at = _emptyFunc
            },
            lagSmoothing: function(ft, yt) {
                k = ft || 1 / 0,
                J = Math.min(yt || 33, k)
            },
            fps: function(ft) {
                rt = 1e3 / (ft || 240),
                nt = st.time * 1e3 + rt
            },
            add: function(ft, yt, ht) {
                var gt = yt ? function(mt, vt, bt, Et) {
                    ft(mt, vt, bt, Et),
                    st.remove(gt)
                }
                : ft;
                return st.remove(ft),
                ot[ht ? "unshift" : "push"](gt),
                _wake(),
                gt
            },
            remove: function(ft, yt) {
                ~(yt = ot.indexOf(ft)) && ot.splice(yt, 1) && ct >= yt && ct--
            },
            _listeners: ot
        },
        st
    }(), _wake = function() {
        return !_tickerActive && _ticker.wake()
    }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function(_) {
        for (var k = {}, J = _.substr(1, _.length - 3).split(":"), et = J[0], tt = 1, rt = J.length, nt, ot, it; tt < rt; tt++)
            ot = J[tt],
            nt = tt !== rt - 1 ? ot.lastIndexOf(",") : ot.length,
            it = ot.substr(0, nt),
            k[et] = isNaN(it) ? it.replace(_quotesExp, "").trim() : +it,
            et = ot.substr(nt + 1).trim();
        return k
    }, _valueInParentheses = function(_) {
        var k = _.indexOf("(") + 1
          , J = _.indexOf(")")
          , et = _.indexOf("(", k);
        return _.substring(k, ~et && et < J ? _.indexOf(")", J + 1) : J)
    }, _configEaseFromString = function(_) {
        var k = (_ + "").split("(")
          , J = _easeMap[k[0]];
        return J && k.length > 1 && J.config ? J.config.apply(null, ~_.indexOf("{") ? [_parseObjectInString(k[1])] : _valueInParentheses(_).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(_) ? _easeMap._CE("", _) : J
    }, _invertEase = function(_) {
        return function(k) {
            return 1 - _(1 - k)
        }
    }, _propagateYoyoEase = function _(k, J) {
        for (var et = k._first, tt; et; )
            et instanceof Timeline ? _(et, J) : et.vars.yoyoEase && (!et._yoyo || !et._repeat) && et._yoyo !== J && (et.timeline ? _(et.timeline, J) : (tt = et._ease,
            et._ease = et._yEase,
            et._yEase = tt,
            et._yoyo = J)),
            et = et._next
    }, _parseEase = function(_, k) {
        return _ && (_isFunction(_) ? _ : _easeMap[_] || _configEaseFromString(_)) || k
    }, _insertEase = function(_, k, J, et) {
        J === void 0 && (J = function(nt) {
            return 1 - k(1 - nt)
        }
        ),
        et === void 0 && (et = function(nt) {
            return nt < .5 ? k(nt * 2) / 2 : 1 - k((1 - nt) * 2) / 2
        }
        );
        var tt = {
            easeIn: k,
            easeOut: J,
            easeInOut: et
        }, rt;
        return _forEachName(_, function(nt) {
            _easeMap[nt] = _globals[nt] = tt,
            _easeMap[rt = nt.toLowerCase()] = J;
            for (var ot in tt)
                _easeMap[rt + (ot === "easeIn" ? ".in" : ot === "easeOut" ? ".out" : ".inOut")] = _easeMap[nt + "." + ot] = tt[ot]
        }),
        tt
    }, _easeInOutFromOut = function(_) {
        return function(k) {
            return k < .5 ? (1 - _(1 - k * 2)) / 2 : .5 + _((k - .5) * 2) / 2
        }
    }, _configElastic = function _(k, J, et) {
        var tt = J >= 1 ? J : 1
          , rt = (et || (k ? .3 : .45)) / (J < 1 ? J : 1)
          , nt = rt / _2PI * (Math.asin(1 / tt) || 0)
          , ot = function(at) {
            return at === 1 ? 1 : tt * Math.pow(2, -10 * at) * _sin((at - nt) * rt) + 1
        }
          , it = k === "out" ? ot : k === "in" ? function(at) {
            return 1 - ot(1 - at)
        }
        : _easeInOutFromOut(ot);
        return rt = _2PI / rt,
        it.config = function(at, lt) {
            return _(k, at, lt)
        }
        ,
        it
    }, _configBack = function _(k, J) {
        J === void 0 && (J = 1.70158);
        var et = function(rt) {
            return rt ? --rt * rt * ((J + 1) * rt + J) + 1 : 0
        }
          , tt = k === "out" ? et : k === "in" ? function(rt) {
            return 1 - et(1 - rt)
        }
        : _easeInOutFromOut(et);
        return tt.config = function(rt) {
            return _(k, rt)
        }
        ,
        tt
    };
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(_, k) {
        var J = k < 5 ? k + 1 : k;
        _insertEase(_ + ",Power" + (J - 1), k ? function(et) {
            return Math.pow(et, J)
        }
        : function(et) {
            return et
        }
        , function(et) {
            return 1 - Math.pow(1 - et, J)
        }, function(et) {
            return et < .5 ? Math.pow(et * 2, J) / 2 : 1 - Math.pow((1 - et) * 2, J) / 2
        })
    }),
    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn,
    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic()),
    function(_, k) {
        var J = 1 / k
          , et = 2 * J
          , tt = 2.5 * J
          , rt = function(nt) {
            return nt < J ? _ * nt * nt : nt < et ? _ * Math.pow(nt - 1.5 / k, 2) + .75 : nt < tt ? _ * (nt -= 2.25 / k) * nt + .9375 : _ * Math.pow(nt - 2.625 / k, 2) + .984375
        };
        _insertEase("Bounce", function(nt) {
            return 1 - rt(1 - nt)
        }, rt)
    }(7.5625, 2.75),
    _insertEase("Expo", function(_) {
        return _ ? Math.pow(2, 10 * (_ - 1)) : 0
    }),
    _insertEase("Circ", function(_) {
        return -(_sqrt(1 - _ * _) - 1)
    }),
    _insertEase("Sine", function(_) {
        return _ === 1 ? 1 : -_cos(_ * _HALF_PI) + 1
    }),
    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack()),
    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
        config: function(_, k) {
            _ === void 0 && (_ = 1);
            var J = 1 / _
              , et = _ + (k ? 0 : 1)
              , tt = k ? 1 : 0
              , rt = 1 - _tinyNum;
            return function(nt) {
                return ((et * _clamp(0, rt, nt) | 0) + tt) * J
            }
        }
    },
    _defaults.ease = _easeMap["quad.out"],
    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(_) {
        return _callbackNames += _ + "," + _ + "Params,"
    });
    var GSCache = function(_, k) {
        this.id = _gsID++,
        _._gsap = this,
        this.target = _,
        this.harness = k,
        this.get = k ? k.get : _getProperty,
        this.set = k ? k.getSetter : _getSetter
    }
      , Animation = function() {
        function _(J) {
            this.vars = J,
            this._delay = +J.delay || 0,
            (this._repeat = J.repeat === 1 / 0 ? -2 : J.repeat || 0) && (this._rDelay = J.repeatDelay || 0,
            this._yoyo = !!J.yoyo || !!J.yoyoEase),
            this._ts = 1,
            _setDuration(this, +J.duration, 1, 1),
            this.data = J.data,
            _context && (this._ctx = _context,
            _context.data.push(this)),
            _tickerActive || _ticker.wake()
        }
        var k = _.prototype;
        return k.delay = function(J) {
            return J || J === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + J - this._delay),
            this._delay = J,
            this) : this._delay
        }
        ,
        k.duration = function(J) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? J + (J + this._rDelay) * this._repeat : J) : this.totalDuration() && this._dur
        }
        ,
        k.totalDuration = function(J) {
            return arguments.length ? (this._dirty = 0,
            _setDuration(this, this._repeat < 0 ? J : (J - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }
        ,
        k.totalTime = function(J, et) {
            if (_wake(),
            !arguments.length)
                return this._tTime;
            var tt = this._dp;
            if (tt && tt.smoothChildTiming && this._ts) {
                for (_alignPlayhead(this, J),
                !tt._dp || tt.parent || _postAddChecks(tt, this); tt && tt.parent; )
                    tt.parent._time !== tt._start + (tt._ts >= 0 ? tt._tTime / tt._ts : (tt.totalDuration() - tt._tTime) / -tt._ts) && tt.totalTime(tt._tTime, !0),
                    tt = tt.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && J < this._tDur || this._ts < 0 && J > 0 || !this._tDur && !J) && _addToTimeline(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== J || !this._dur && !et || this._initted && Math.abs(this._zTime) === _tinyNum || !J && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = J),
            _lazySafeRender(this, J, et)),
            this
        }
        ,
        k.time = function(J, et) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), J + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (J ? this._dur : 0), et) : this._time
        }
        ,
        k.totalProgress = function(J, et) {
            return arguments.length ? this.totalTime(this.totalDuration() * J, et) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
        }
        ,
        k.progress = function(J, et) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - J : J) + _elapsedCycleDuration(this), et) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }
        ,
        k.iteration = function(J, et) {
            var tt = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (J - 1) * tt, et) : this._repeat ? _animationCycle(this._tTime, tt) + 1 : 1
        }
        ,
        k.timeScale = function(J, et) {
            if (!arguments.length)
                return this._rts === -_tinyNum ? 0 : this._rts;
            if (this._rts === J)
                return this;
            var tt = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
            return this._rts = +J || 0,
            this._ts = this._ps || J === -_tinyNum ? 0 : this._rts,
            this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tt), et !== !1),
            _setEnd(this),
            _recacheAncestors(this)
        }
        ,
        k.paused = function(J) {
            return arguments.length ? (this._ps !== J && (this._ps = J,
            J ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
            this._ts = this._act = 0) : (_wake(),
            this._ts = this._rts,
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)))),
            this) : this._ps
        }
        ,
        k.startTime = function(J) {
            if (arguments.length) {
                this._start = J;
                var et = this.parent || this._dp;
                return et && (et._sort || !this.parent) && _addToTimeline(et, this, J - this._delay),
                this
            }
            return this._start
        }
        ,
        k.endTime = function(J) {
            return this._start + (_isNotFalse(J) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }
        ,
        k.rawTime = function(J) {
            var et = this.parent || this._dp;
            return et ? J && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(et.rawTime(J), this) : this._tTime : this._tTime
        }
        ,
        k.revert = function(J) {
            J === void 0 && (J = _revertConfig);
            var et = _reverting$1;
            return _reverting$1 = J,
            (this._initted || this._startAt) && (this.timeline && this.timeline.revert(J),
            this.totalTime(-.01, J.suppressEvents)),
            this.data !== "nested" && J.kill !== !1 && this.kill(),
            _reverting$1 = et,
            this
        }
        ,
        k.globalTime = function(J) {
            for (var et = this, tt = arguments.length ? J : et.rawTime(); et; )
                tt = et._start + tt / (Math.abs(et._ts) || 1),
                et = et._dp;
            return !this.parent && this._sat ? this._sat.globalTime(J) : tt
        }
        ,
        k.repeat = function(J) {
            return arguments.length ? (this._repeat = J === 1 / 0 ? -2 : J,
            _onUpdateTotalDuration(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }
        ,
        k.repeatDelay = function(J) {
            if (arguments.length) {
                var et = this._time;
                return this._rDelay = J,
                _onUpdateTotalDuration(this),
                et ? this.time(et) : this
            }
            return this._rDelay
        }
        ,
        k.yoyo = function(J) {
            return arguments.length ? (this._yoyo = J,
            this) : this._yoyo
        }
        ,
        k.seek = function(J, et) {
            return this.totalTime(_parsePosition(this, J), _isNotFalse(et))
        }
        ,
        k.restart = function(J, et) {
            return this.play().totalTime(J ? -this._delay : 0, _isNotFalse(et))
        }
        ,
        k.play = function(J, et) {
            return J != null && this.seek(J, et),
            this.reversed(!1).paused(!1)
        }
        ,
        k.reverse = function(J, et) {
            return J != null && this.seek(J || this.totalDuration(), et),
            this.reversed(!0).paused(!1)
        }
        ,
        k.pause = function(J, et) {
            return J != null && this.seek(J, et),
            this.paused(!0)
        }
        ,
        k.resume = function() {
            return this.paused(!1)
        }
        ,
        k.reversed = function(J) {
            return arguments.length ? (!!J !== this.reversed() && this.timeScale(-this._rts || (J ? -_tinyNum : 0)),
            this) : this._rts < 0
        }
        ,
        k.invalidate = function() {
            return this._initted = this._act = 0,
            this._zTime = -_tinyNum,
            this
        }
        ,
        k.isActive = function() {
            var J = this.parent || this._dp, et = this._start, tt;
            return !!(!J || this._ts && this._initted && J.isActive() && (tt = J.rawTime(!0)) >= et && tt < this.endTime(!0) - _tinyNum)
        }
        ,
        k.eventCallback = function(J, et, tt) {
            var rt = this.vars;
            return arguments.length > 1 ? (et ? (rt[J] = et,
            tt && (rt[J + "Params"] = tt),
            J === "onUpdate" && (this._onUpdate = et)) : delete rt[J],
            this) : rt[J]
        }
        ,
        k.then = function(J) {
            var et = this;
            return new Promise(function(tt) {
                var rt = _isFunction(J) ? J : _passThrough
                  , nt = function() {
                    var ot = et.then;
                    et.then = null,
                    _isFunction(rt) && (rt = rt(et)) && (rt.then || rt === et) && (et.then = ot),
                    tt(rt),
                    et.then = ot
                };
                et._initted && et.totalProgress() === 1 && et._ts >= 0 || !et._tTime && et._ts < 0 ? nt() : et._prom = nt
            }
            )
        }
        ,
        k.kill = function() {
            _interrupt(this)
        }
        ,
        _
    }();
    _setDefaults(Animation.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -_tinyNum,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var Timeline = function(_) {
        _inheritsLoose(k, _);
        function k(et, tt) {
            var rt;
            return et === void 0 && (et = {}),
            rt = _.call(this, et) || this,
            rt.labels = {},
            rt.smoothChildTiming = !!et.smoothChildTiming,
            rt.autoRemoveChildren = !!et.autoRemoveChildren,
            rt._sort = _isNotFalse(et.sortChildren),
            _globalTimeline && _addToTimeline(et.parent || _globalTimeline, _assertThisInitialized(rt), tt),
            et.reversed && rt.reverse(),
            et.paused && rt.paused(!0),
            et.scrollTrigger && _scrollTrigger(_assertThisInitialized(rt), et.scrollTrigger),
            rt
        }
        var J = k.prototype;
        return J.to = function(et, tt, rt) {
            return _createTweenType(0, arguments, this),
            this
        }
        ,
        J.from = function(et, tt, rt) {
            return _createTweenType(1, arguments, this),
            this
        }
        ,
        J.fromTo = function(et, tt, rt, nt) {
            return _createTweenType(2, arguments, this),
            this
        }
        ,
        J.set = function(et, tt, rt) {
            return tt.duration = 0,
            tt.parent = this,
            _inheritDefaults(tt).repeatDelay || (tt.repeat = 0),
            tt.immediateRender = !!tt.immediateRender,
            new Tween(et,tt,_parsePosition(this, rt),1),
            this
        }
        ,
        J.call = function(et, tt, rt) {
            return _addToTimeline(this, Tween.delayedCall(0, et, tt), rt)
        }
        ,
        J.staggerTo = function(et, tt, rt, nt, ot, it, at) {
            return rt.duration = tt,
            rt.stagger = rt.stagger || nt,
            rt.onComplete = it,
            rt.onCompleteParams = at,
            rt.parent = this,
            new Tween(et,rt,_parsePosition(this, ot)),
            this
        }
        ,
        J.staggerFrom = function(et, tt, rt, nt, ot, it, at) {
            return rt.runBackwards = 1,
            _inheritDefaults(rt).immediateRender = _isNotFalse(rt.immediateRender),
            this.staggerTo(et, tt, rt, nt, ot, it, at)
        }
        ,
        J.staggerFromTo = function(et, tt, rt, nt, ot, it, at, lt) {
            return nt.startAt = rt,
            _inheritDefaults(nt).immediateRender = _isNotFalse(nt.immediateRender),
            this.staggerTo(et, tt, nt, ot, it, at, lt)
        }
        ,
        J.render = function(et, tt, rt) {
            var nt = this._time, ot = this._dirty ? this.totalDuration() : this._tDur, it = this._dur, at = et <= 0 ? 0 : _roundPrecise(et), lt = this._zTime < 0 != et < 0 && (this._initted || !it), st, ut, ct, pt, ft, yt, ht, gt, mt, vt, bt, Et;
            if (this !== _globalTimeline && at > ot && et >= 0 && (at = ot),
            at !== this._tTime || rt || lt) {
                if (nt !== this._time && it && (at += this._time - nt,
                et += this._time - nt),
                st = at,
                mt = this._start,
                gt = this._ts,
                yt = !gt,
                lt && (it || (nt = this._zTime),
                (et || !tt) && (this._zTime = et)),
                this._repeat) {
                    if (bt = this._yoyo,
                    ft = it + this._rDelay,
                    this._repeat < -1 && et < 0)
                        return this.totalTime(ft * 100 + et, tt, rt);
                    if (st = _roundPrecise(at % ft),
                    at === ot ? (pt = this._repeat,
                    st = it) : (pt = ~~(at / ft),
                    pt && pt === at / ft && (st = it,
                    pt--),
                    st > it && (st = it)),
                    vt = _animationCycle(this._tTime, ft),
                    !nt && this._tTime && vt !== pt && this._tTime - vt * ft - this._dur <= 0 && (vt = pt),
                    bt && pt & 1 && (st = it - st,
                    Et = 1),
                    pt !== vt && !this._lock) {
                        var xt = bt && vt & 1
                          , wt = xt === (bt && pt & 1);
                        if (pt < vt && (xt = !xt),
                        nt = xt ? 0 : at % it ? it : at,
                        this._lock = 1,
                        this.render(nt || (Et ? 0 : _roundPrecise(pt * ft)), tt, !it)._lock = 0,
                        this._tTime = at,
                        !tt && this.parent && _callback(this, "onRepeat"),
                        this.vars.repeatRefresh && !Et && (this.invalidate()._lock = 1),
                        nt && nt !== this._time || yt !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                            return this;
                        if (it = this._dur,
                        ot = this._tDur,
                        wt && (this._lock = 2,
                        nt = xt ? it : -1e-4,
                        this.render(nt, !0),
                        this.vars.repeatRefresh && !Et && this.invalidate()),
                        this._lock = 0,
                        !this._ts && !yt)
                            return this;
                        _propagateYoyoEase(this, Et)
                    }
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (ht = _findNextPauseTween(this, _roundPrecise(nt), _roundPrecise(st)),
                ht && (at -= st - (st = ht._start))),
                this._tTime = at,
                this._time = st,
                this._act = !gt,
                this._initted || (this._onUpdate = this.vars.onUpdate,
                this._initted = 1,
                this._zTime = et,
                nt = 0),
                !nt && st && !tt && !pt && (_callback(this, "onStart"),
                this._tTime !== at))
                    return this;
                if (st >= nt && et >= 0)
                    for (ut = this._first; ut; ) {
                        if (ct = ut._next,
                        (ut._act || st >= ut._start) && ut._ts && ht !== ut) {
                            if (ut.parent !== this)
                                return this.render(et, tt, rt);
                            if (ut.render(ut._ts > 0 ? (st - ut._start) * ut._ts : (ut._dirty ? ut.totalDuration() : ut._tDur) + (st - ut._start) * ut._ts, tt, rt),
                            st !== this._time || !this._ts && !yt) {
                                ht = 0,
                                ct && (at += this._zTime = -_tinyNum);
                                break
                            }
                        }
                        ut = ct
                    }
                else {
                    ut = this._last;
                    for (var St = et < 0 ? et : st; ut; ) {
                        if (ct = ut._prev,
                        (ut._act || St <= ut._end) && ut._ts && ht !== ut) {
                            if (ut.parent !== this)
                                return this.render(et, tt, rt);
                            if (ut.render(ut._ts > 0 ? (St - ut._start) * ut._ts : (ut._dirty ? ut.totalDuration() : ut._tDur) + (St - ut._start) * ut._ts, tt, rt || _reverting$1 && (ut._initted || ut._startAt)),
                            st !== this._time || !this._ts && !yt) {
                                ht = 0,
                                ct && (at += this._zTime = St ? -_tinyNum : _tinyNum);
                                break
                            }
                        }
                        ut = ct
                    }
                }
                if (ht && !tt && (this.pause(),
                ht.render(st >= nt ? 0 : -_tinyNum)._zTime = st >= nt ? 1 : -1,
                this._ts))
                    return this._start = mt,
                    _setEnd(this),
                    this.render(et, tt, rt);
                this._onUpdate && !tt && _callback(this, "onUpdate", !0),
                (at === ot && this._tTime >= this.totalDuration() || !at && nt) && (mt === this._start || Math.abs(gt) !== Math.abs(this._ts)) && (this._lock || ((et || !it) && (at === ot && this._ts > 0 || !at && this._ts < 0) && _removeFromParent(this, 1),
                !tt && !(et < 0 && !nt) && (at || nt || !ot) && (_callback(this, at === ot && et >= 0 ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(at < ot && this.timeScale() > 0) && this._prom())))
            }
            return this
        }
        ,
        J.add = function(et, tt) {
            var rt = this;
            if (_isNumber(tt) || (tt = _parsePosition(this, tt, et)),
            !(et instanceof Animation)) {
                if (_isArray(et))
                    return et.forEach(function(nt) {
                        return rt.add(nt, tt)
                    }),
                    this;
                if (_isString(et))
                    return this.addLabel(et, tt);
                if (_isFunction(et))
                    et = Tween.delayedCall(0, et);
                else
                    return this
            }
            return this !== et ? _addToTimeline(this, et, tt) : this
        }
        ,
        J.getChildren = function(et, tt, rt, nt) {
            et === void 0 && (et = !0),
            tt === void 0 && (tt = !0),
            rt === void 0 && (rt = !0),
            nt === void 0 && (nt = -_bigNum$1);
            for (var ot = [], it = this._first; it; )
                it._start >= nt && (it instanceof Tween ? tt && ot.push(it) : (rt && ot.push(it),
                et && ot.push.apply(ot, it.getChildren(!0, tt, rt)))),
                it = it._next;
            return ot
        }
        ,
        J.getById = function(et) {
            for (var tt = this.getChildren(1, 1, 1), rt = tt.length; rt--; )
                if (tt[rt].vars.id === et)
                    return tt[rt]
        }
        ,
        J.remove = function(et) {
            return _isString(et) ? this.removeLabel(et) : _isFunction(et) ? this.killTweensOf(et) : (_removeLinkedListItem(this, et),
            et === this._recent && (this._recent = this._last),
            _uncache(this))
        }
        ,
        J.totalTime = function(et, tt) {
            return arguments.length ? (this._forcing = 1,
            !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? et / this._ts : (this.totalDuration() - et) / -this._ts))),
            _.prototype.totalTime.call(this, et, tt),
            this._forcing = 0,
            this) : this._tTime
        }
        ,
        J.addLabel = function(et, tt) {
            return this.labels[et] = _parsePosition(this, tt),
            this
        }
        ,
        J.removeLabel = function(et) {
            return delete this.labels[et],
            this
        }
        ,
        J.addPause = function(et, tt, rt) {
            var nt = Tween.delayedCall(0, tt || _emptyFunc, rt);
            return nt.data = "isPause",
            this._hasPause = 1,
            _addToTimeline(this, nt, _parsePosition(this, et))
        }
        ,
        J.removePause = function(et) {
            var tt = this._first;
            for (et = _parsePosition(this, et); tt; )
                tt._start === et && tt.data === "isPause" && _removeFromParent(tt),
                tt = tt._next
        }
        ,
        J.killTweensOf = function(et, tt, rt) {
            for (var nt = this.getTweensOf(et, rt), ot = nt.length; ot--; )
                _overwritingTween !== nt[ot] && nt[ot].kill(et, tt);
            return this
        }
        ,
        J.getTweensOf = function(et, tt) {
            for (var rt = [], nt = toArray$2(et), ot = this._first, it = _isNumber(tt), at; ot; )
                ot instanceof Tween ? _arrayContainsAny(ot._targets, nt) && (it ? (!_overwritingTween || ot._initted && ot._ts) && ot.globalTime(0) <= tt && ot.globalTime(ot.totalDuration()) > tt : !tt || ot.isActive()) && rt.push(ot) : (at = ot.getTweensOf(nt, tt)).length && rt.push.apply(rt, at),
                ot = ot._next;
            return rt
        }
        ,
        J.tweenTo = function(et, tt) {
            tt = tt || {};
            var rt = this, nt = _parsePosition(rt, et), ot = tt, it = ot.startAt, at = ot.onStart, lt = ot.onStartParams, st = ot.immediateRender, ut, ct = Tween.to(rt, _setDefaults({
                ease: tt.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: nt,
                overwrite: "auto",
                duration: tt.duration || Math.abs((nt - (it && "time"in it ? it.time : rt._time)) / rt.timeScale()) || _tinyNum,
                onStart: function() {
                    if (rt.pause(),
                    !ut) {
                        var pt = tt.duration || Math.abs((nt - (it && "time"in it ? it.time : rt._time)) / rt.timeScale());
                        ct._dur !== pt && _setDuration(ct, pt, 0, 1).render(ct._time, !0, !0),
                        ut = 1
                    }
                    at && at.apply(ct, lt || [])
                }
            }, tt));
            return st ? ct.render(0) : ct
        }
        ,
        J.tweenFromTo = function(et, tt, rt) {
            return this.tweenTo(tt, _setDefaults({
                startAt: {
                    time: _parsePosition(this, et)
                }
            }, rt))
        }
        ,
        J.recent = function() {
            return this._recent
        }
        ,
        J.nextLabel = function(et) {
            return et === void 0 && (et = this._time),
            _getLabelInDirection(this, _parsePosition(this, et))
        }
        ,
        J.previousLabel = function(et) {
            return et === void 0 && (et = this._time),
            _getLabelInDirection(this, _parsePosition(this, et), 1)
        }
        ,
        J.currentLabel = function(et) {
            return arguments.length ? this.seek(et, !0) : this.previousLabel(this._time + _tinyNum)
        }
        ,
        J.shiftChildren = function(et, tt, rt) {
            rt === void 0 && (rt = 0);
            for (var nt = this._first, ot = this.labels, it; nt; )
                nt._start >= rt && (nt._start += et,
                nt._end += et),
                nt = nt._next;
            if (tt)
                for (it in ot)
                    ot[it] >= rt && (ot[it] += et);
            return _uncache(this)
        }
        ,
        J.invalidate = function(et) {
            var tt = this._first;
            for (this._lock = 0; tt; )
                tt.invalidate(et),
                tt = tt._next;
            return _.prototype.invalidate.call(this, et)
        }
        ,
        J.clear = function(et) {
            et === void 0 && (et = !0);
            for (var tt = this._first, rt; tt; )
                rt = tt._next,
                this.remove(tt),
                tt = rt;
            return this._dp && (this._time = this._tTime = this._pTime = 0),
            et && (this.labels = {}),
            _uncache(this)
        }
        ,
        J.totalDuration = function(et) {
            var tt = 0, rt = this, nt = rt._last, ot = _bigNum$1, it, at, lt;
            if (arguments.length)
                return rt.timeScale((rt._repeat < 0 ? rt.duration() : rt.totalDuration()) / (rt.reversed() ? -et : et));
            if (rt._dirty) {
                for (lt = rt.parent; nt; )
                    it = nt._prev,
                    nt._dirty && nt.totalDuration(),
                    at = nt._start,
                    at > ot && rt._sort && nt._ts && !rt._lock ? (rt._lock = 1,
                    _addToTimeline(rt, nt, at - nt._delay, 1)._lock = 0) : ot = at,
                    at < 0 && nt._ts && (tt -= at,
                    (!lt && !rt._dp || lt && lt.smoothChildTiming) && (rt._start += at / rt._ts,
                    rt._time -= at,
                    rt._tTime -= at),
                    rt.shiftChildren(-at, !1, -1 / 0),
                    ot = 0),
                    nt._end > tt && nt._ts && (tt = nt._end),
                    nt = it;
                _setDuration(rt, rt === _globalTimeline && rt._time > tt ? rt._time : tt, 1, 1),
                rt._dirty = 0
            }
            return rt._tDur
        }
        ,
        k.updateRoot = function(et) {
            if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(et, _globalTimeline)),
            _lastRenderedFrame = _ticker.frame),
            _ticker.frame >= _nextGCFrame) {
                _nextGCFrame += _config.autoSleep || 120;
                var tt = _globalTimeline._first;
                if ((!tt || !tt._ts) && _config.autoSleep && _ticker._listeners.length < 2) {
                    for (; tt && !tt._ts; )
                        tt = tt._next;
                    tt || _ticker.sleep()
                }
            }
        }
        ,
        k
    }(Animation);
    _setDefaults(Timeline.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var _addComplexStringPropTween = function(_, k, J, et, tt, rt, nt) {
        var ot = new PropTween(this._pt,_,k,0,1,_renderComplexString,null,tt), it = 0, at = 0, lt, st, ut, ct, pt, ft, yt, ht;
        for (ot.b = J,
        ot.e = et,
        J += "",
        et += "",
        (yt = ~et.indexOf("random(")) && (et = _replaceRandom(et)),
        rt && (ht = [J, et],
        rt(ht, _, k),
        J = ht[0],
        et = ht[1]),
        st = J.match(_complexStringNumExp) || []; lt = _complexStringNumExp.exec(et); )
            ct = lt[0],
            pt = et.substring(it, lt.index),
            ut ? ut = (ut + 1) % 5 : pt.substr(-5) === "rgba(" && (ut = 1),
            ct !== st[at++] && (ft = parseFloat(st[at - 1]) || 0,
            ot._pt = {
                _next: ot._pt,
                p: pt || at === 1 ? pt : ",",
                s: ft,
                c: ct.charAt(1) === "=" ? _parseRelative(ft, ct) - ft : parseFloat(ct) - ft,
                m: ut && ut < 4 ? Math.round : 0
            },
            it = _complexStringNumExp.lastIndex);
        return ot.c = it < et.length ? et.substring(it, et.length) : "",
        ot.fp = nt,
        (_relExp.test(et) || yt) && (ot.e = 0),
        this._pt = ot,
        ot
    }, _addPropTween = function(_, k, J, et, tt, rt, nt, ot, it, at) {
        _isFunction(et) && (et = et(tt || 0, _, rt));
        var lt = _[k], st = J !== "get" ? J : _isFunction(lt) ? it ? _[k.indexOf("set") || !_isFunction(_["get" + k.substr(3)]) ? k : "get" + k.substr(3)](it) : _[k]() : lt, ut = _isFunction(lt) ? it ? _setterFuncWithParam : _setterFunc : _setterPlain, ct;
        if (_isString(et) && (~et.indexOf("random(") && (et = _replaceRandom(et)),
        et.charAt(1) === "=" && (ct = _parseRelative(st, et) + (getUnit(st) || 0),
        (ct || ct === 0) && (et = ct))),
        !at || st !== et || _forceAllPropTweens)
            return !isNaN(st * et) && et !== "" ? (ct = new PropTween(this._pt,_,k,+st || 0,et - (st || 0),typeof lt == "boolean" ? _renderBoolean : _renderPlain,0,ut),
            it && (ct.fp = it),
            nt && ct.modifier(nt, this, _),
            this._pt = ct) : (!lt && !(k in _) && _missingPlugin(k, et),
            _addComplexStringPropTween.call(this, _, k, st, et, ut, ot || _config.stringFilter, it))
    }, _processVars = function(_, k, J, et, tt) {
        if (_isFunction(_) && (_ = _parseFuncOrString(_, tt, k, J, et)),
        !_isObject(_) || _.style && _.nodeType || _isArray(_) || _isTypedArray(_))
            return _isString(_) ? _parseFuncOrString(_, tt, k, J, et) : _;
        var rt = {}, nt;
        for (nt in _)
            rt[nt] = _parseFuncOrString(_[nt], tt, k, J, et);
        return rt
    }, _checkPlugin = function(_, k, J, et, tt, rt) {
        var nt, ot, it, at;
        if (_plugins[_] && (nt = new _plugins[_]).init(tt, nt.rawVars ? k[_] : _processVars(k[_], et, tt, rt, J), J, et, rt) !== !1 && (J._pt = ot = new PropTween(J._pt,tt,_,0,1,nt.render,nt,0,nt.priority),
        J !== _quickTween))
            for (it = J._ptLookup[J._targets.indexOf(tt)],
            at = nt._props.length; at--; )
                it[nt._props[at]] = ot;
        return nt
    }, _overwritingTween, _forceAllPropTweens, _initTween = function _(k, J, et) {
        var tt = k.vars, rt = tt.ease, nt = tt.startAt, ot = tt.immediateRender, it = tt.lazy, at = tt.onUpdate, lt = tt.runBackwards, st = tt.yoyoEase, ut = tt.keyframes, ct = tt.autoRevert, pt = k._dur, ft = k._startAt, yt = k._targets, ht = k.parent, gt = ht && ht.data === "nested" ? ht.vars.targets : yt, mt = k._overwrite === "auto" && !_suppressOverwrites, vt = k.timeline, bt, Et, xt, wt, St, Pt, Rt, At, Nt, Ot, It, Mt, Wt;
        if (vt && (!ut || !rt) && (rt = "none"),
        k._ease = _parseEase(rt, _defaults.ease),
        k._yEase = st ? _invertEase(_parseEase(st === !0 ? rt : st, _defaults.ease)) : 0,
        st && k._yoyo && !k._repeat && (st = k._yEase,
        k._yEase = k._ease,
        k._ease = st),
        k._from = !vt && !!tt.runBackwards,
        !vt || ut && !tt.stagger) {
            if (At = yt[0] ? _getCache(yt[0]).harness : 0,
            Mt = At && tt[At.prop],
            bt = _copyExcluding(tt, _reservedProps),
            ft && (ft._zTime < 0 && ft.progress(1),
            J < 0 && lt && ot && !ct ? ft.render(-1, !0) : ft.revert(lt && pt ? _revertConfigNoKill : _startAtRevertConfig),
            ft._lazy = 0),
            nt) {
                if (_removeFromParent(k._startAt = Tween.set(yt, _setDefaults({
                    data: "isStart",
                    overwrite: !1,
                    parent: ht,
                    immediateRender: !0,
                    lazy: !ft && _isNotFalse(it),
                    startAt: null,
                    delay: 0,
                    onUpdate: at && function() {
                        return _callback(k, "onUpdate")
                    }
                    ,
                    stagger: 0
                }, nt))),
                k._startAt._dp = 0,
                k._startAt._sat = k,
                J < 0 && (_reverting$1 || !ot && !ct) && k._startAt.revert(_revertConfigNoKill),
                ot && pt && J <= 0 && et <= 0) {
                    J && (k._zTime = J);
                    return
                }
            } else if (lt && pt && !ft) {
                if (J && (ot = !1),
                xt = _setDefaults({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: ot && !ft && _isNotFalse(it),
                    immediateRender: ot,
                    stagger: 0,
                    parent: ht
                }, bt),
                Mt && (xt[At.prop] = Mt),
                _removeFromParent(k._startAt = Tween.set(yt, xt)),
                k._startAt._dp = 0,
                k._startAt._sat = k,
                J < 0 && (_reverting$1 ? k._startAt.revert(_revertConfigNoKill) : k._startAt.render(-1, !0)),
                k._zTime = J,
                !ot)
                    _(k._startAt, _tinyNum, _tinyNum);
                else if (!J)
                    return
            }
            for (k._pt = k._ptCache = 0,
            it = pt && _isNotFalse(it) || it && !pt,
            Et = 0; Et < yt.length; Et++) {
                if (St = yt[Et],
                Rt = St._gsap || _harness(yt)[Et]._gsap,
                k._ptLookup[Et] = Ot = {},
                _lazyLookup[Rt.id] && _lazyTweens.length && _lazyRender(),
                It = gt === yt ? Et : gt.indexOf(St),
                At && (Nt = new At).init(St, Mt || bt, k, It, gt) !== !1 && (k._pt = wt = new PropTween(k._pt,St,Nt.name,0,1,Nt.render,Nt,0,Nt.priority),
                Nt._props.forEach(function(jt) {
                    Ot[jt] = wt
                }),
                Nt.priority && (Pt = 1)),
                !At || Mt)
                    for (xt in bt)
                        _plugins[xt] && (Nt = _checkPlugin(xt, bt, k, It, St, gt)) ? Nt.priority && (Pt = 1) : Ot[xt] = wt = _addPropTween.call(k, St, xt, "get", bt[xt], It, gt, 0, tt.stringFilter);
                k._op && k._op[Et] && k.kill(St, k._op[Et]),
                mt && k._pt && (_overwritingTween = k,
                _globalTimeline.killTweensOf(St, Ot, k.globalTime(J)),
                Wt = !k.parent,
                _overwritingTween = 0),
                k._pt && it && (_lazyLookup[Rt.id] = 1)
            }
            Pt && _sortPropTweensByPriority(k),
            k._onInit && k._onInit(k)
        }
        k._onUpdate = at,
        k._initted = (!k._op || k._pt) && !Wt,
        ut && J <= 0 && vt.render(_bigNum$1, !0, !0)
    }, _updatePropTweens = function(_, k, J, et, tt, rt, nt, ot) {
        var it = (_._pt && _._ptCache || (_._ptCache = {}))[k], at, lt, st, ut;
        if (!it)
            for (it = _._ptCache[k] = [],
            st = _._ptLookup,
            ut = _._targets.length; ut--; ) {
                if (at = st[ut][k],
                at && at.d && at.d._pt)
                    for (at = at.d._pt; at && at.p !== k && at.fp !== k; )
                        at = at._next;
                if (!at)
                    return _forceAllPropTweens = 1,
                    _.vars[k] = "+=0",
                    _initTween(_, nt),
                    _forceAllPropTweens = 0,
                    ot ? _warn(k + " not eligible for reset") : 1;
                it.push(at)
            }
        for (ut = it.length; ut--; )
            lt = it[ut],
            at = lt._pt || lt,
            at.s = (et || et === 0) && !tt ? et : at.s + (et || 0) + rt * at.c,
            at.c = J - at.s,
            lt.e && (lt.e = _round(J) + getUnit(lt.e)),
            lt.b && (lt.b = at.s + getUnit(lt.b))
    }, _addAliasesToVars = function(_, k) {
        var J = _[0] ? _getCache(_[0]).harness : 0, et = J && J.aliases, tt, rt, nt, ot;
        if (!et)
            return k;
        tt = _merge({}, k);
        for (rt in et)
            if (rt in tt)
                for (ot = et[rt].split(","),
                nt = ot.length; nt--; )
                    tt[ot[nt]] = tt[rt];
        return tt
    }, _parseKeyframe = function(_, k, J, et) {
        var tt = k.ease || et || "power1.inOut", rt, nt;
        if (_isArray(k))
            nt = J[_] || (J[_] = []),
            k.forEach(function(ot, it) {
                return nt.push({
                    t: it / (k.length - 1) * 100,
                    v: ot,
                    e: tt
                })
            });
        else
            for (rt in k)
                nt = J[rt] || (J[rt] = []),
                rt === "ease" || nt.push({
                    t: parseFloat(_),
                    v: k[rt],
                    e: tt
                })
    }, _parseFuncOrString = function(_, k, J, et, tt) {
        return _isFunction(_) ? _.call(k, J, et, tt) : _isString(_) && ~_.indexOf("random(") ? _replaceRandom(_) : _
    }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(_) {
        return _staggerPropsToSkip[_] = 1
    });
    var Tween = function(_) {
        _inheritsLoose(k, _);
        function k(et, tt, rt, nt) {
            var ot;
            typeof tt == "number" && (rt.duration = tt,
            tt = rt,
            rt = null),
            ot = _.call(this, nt ? tt : _inheritDefaults(tt)) || this;
            var it = ot.vars, at = it.duration, lt = it.delay, st = it.immediateRender, ut = it.stagger, ct = it.overwrite, pt = it.keyframes, ft = it.defaults, yt = it.scrollTrigger, ht = it.yoyoEase, gt = tt.parent || _globalTimeline, mt = (_isArray(et) || _isTypedArray(et) ? _isNumber(et[0]) : "length"in tt) ? [et] : toArray$2(et), vt, bt, Et, xt, wt, St, Pt, Rt;
            if (ot._targets = mt.length ? _harness(mt) : _warn("GSAP target " + et + " not found. https://gsap.com", !_config.nullTargetWarn) || [],
            ot._ptLookup = [],
            ot._overwrite = ct,
            pt || ut || _isFuncOrString(at) || _isFuncOrString(lt)) {
                if (tt = ot.vars,
                vt = ot.timeline = new Timeline({
                    data: "nested",
                    defaults: ft || {},
                    targets: gt && gt.data === "nested" ? gt.vars.targets : mt
                }),
                vt.kill(),
                vt.parent = vt._dp = _assertThisInitialized(ot),
                vt._start = 0,
                ut || _isFuncOrString(at) || _isFuncOrString(lt)) {
                    if (xt = mt.length,
                    Pt = ut && distribute(ut),
                    _isObject(ut))
                        for (wt in ut)
                            ~_staggerTweenProps.indexOf(wt) && (Rt || (Rt = {}),
                            Rt[wt] = ut[wt]);
                    for (bt = 0; bt < xt; bt++)
                        Et = _copyExcluding(tt, _staggerPropsToSkip),
                        Et.stagger = 0,
                        ht && (Et.yoyoEase = ht),
                        Rt && _merge(Et, Rt),
                        St = mt[bt],
                        Et.duration = +_parseFuncOrString(at, _assertThisInitialized(ot), bt, St, mt),
                        Et.delay = (+_parseFuncOrString(lt, _assertThisInitialized(ot), bt, St, mt) || 0) - ot._delay,
                        !ut && xt === 1 && Et.delay && (ot._delay = lt = Et.delay,
                        ot._start += lt,
                        Et.delay = 0),
                        vt.to(St, Et, Pt ? Pt(bt, St, mt) : 0),
                        vt._ease = _easeMap.none;
                    vt.duration() ? at = lt = 0 : ot.timeline = 0
                } else if (pt) {
                    _inheritDefaults(_setDefaults(vt.vars.defaults, {
                        ease: "none"
                    })),
                    vt._ease = _parseEase(pt.ease || tt.ease || "none");
                    var At = 0, Nt, Ot, It;
                    if (_isArray(pt))
                        pt.forEach(function(Mt) {
                            return vt.to(mt, Mt, ">")
                        }),
                        vt.duration();
                    else {
                        Et = {};
                        for (wt in pt)
                            wt === "ease" || wt === "easeEach" || _parseKeyframe(wt, pt[wt], Et, pt.easeEach);
                        for (wt in Et)
                            for (Nt = Et[wt].sort(function(Mt, Wt) {
                                return Mt.t - Wt.t
                            }),
                            At = 0,
                            bt = 0; bt < Nt.length; bt++)
                                Ot = Nt[bt],
                                It = {
                                    ease: Ot.e,
                                    duration: (Ot.t - (bt ? Nt[bt - 1].t : 0)) / 100 * at
                                },
                                It[wt] = Ot.v,
                                vt.to(mt, It, At),
                                At += It.duration;
                        vt.duration() < at && vt.to({}, {
                            duration: at - vt.duration()
                        })
                    }
                }
                at || ot.duration(at = vt.duration())
            } else
                ot.timeline = 0;
            return ct === !0 && !_suppressOverwrites && (_overwritingTween = _assertThisInitialized(ot),
            _globalTimeline.killTweensOf(mt),
            _overwritingTween = 0),
            _addToTimeline(gt, _assertThisInitialized(ot), rt),
            tt.reversed && ot.reverse(),
            tt.paused && ot.paused(!0),
            (st || !at && !pt && ot._start === _roundPrecise(gt._time) && _isNotFalse(st) && _hasNoPausedAncestors(_assertThisInitialized(ot)) && gt.data !== "nested") && (ot._tTime = -_tinyNum,
            ot.render(Math.max(0, -lt) || 0)),
            yt && _scrollTrigger(_assertThisInitialized(ot), yt),
            ot
        }
        var J = k.prototype;
        return J.render = function(et, tt, rt) {
            var nt = this._time, ot = this._tDur, it = this._dur, at = et < 0, lt = et > ot - _tinyNum && !at ? ot : et < _tinyNum ? 0 : et, st, ut, ct, pt, ft, yt, ht, gt, mt;
            if (!it)
                _renderZeroDurationTween(this, et, tt, rt);
            else if (lt !== this._tTime || !et || rt || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== at) {
                if (st = lt,
                gt = this.timeline,
                this._repeat) {
                    if (pt = it + this._rDelay,
                    this._repeat < -1 && at)
                        return this.totalTime(pt * 100 + et, tt, rt);
                    if (st = _roundPrecise(lt % pt),
                    lt === ot ? (ct = this._repeat,
                    st = it) : (ct = ~~(lt / pt),
                    ct && ct === _roundPrecise(lt / pt) && (st = it,
                    ct--),
                    st > it && (st = it)),
                    yt = this._yoyo && ct & 1,
                    yt && (mt = this._yEase,
                    st = it - st),
                    ft = _animationCycle(this._tTime, pt),
                    st === nt && !rt && this._initted && ct === ft)
                        return this._tTime = lt,
                        this;
                    ct !== ft && (gt && this._yEase && _propagateYoyoEase(gt, yt),
                    this.vars.repeatRefresh && !yt && !this._lock && this._time !== pt && this._initted && (this._lock = rt = 1,
                    this.render(_roundPrecise(pt * ct), !0).invalidate()._lock = 0))
                }
                if (!this._initted) {
                    if (_attemptInitTween(this, at ? et : st, rt, tt, lt))
                        return this._tTime = 0,
                        this;
                    if (nt !== this._time && !(rt && this.vars.repeatRefresh && ct !== ft))
                        return this;
                    if (it !== this._dur)
                        return this.render(et, tt, rt)
                }
                if (this._tTime = lt,
                this._time = st,
                !this._act && this._ts && (this._act = 1,
                this._lazy = 0),
                this.ratio = ht = (mt || this._ease)(st / it),
                this._from && (this.ratio = ht = 1 - ht),
                st && !nt && !tt && !ct && (_callback(this, "onStart"),
                this._tTime !== lt))
                    return this;
                for (ut = this._pt; ut; )
                    ut.r(ht, ut.d),
                    ut = ut._next;
                gt && gt.render(et < 0 ? et : gt._dur * gt._ease(st / this._dur), tt, rt) || this._startAt && (this._zTime = et),
                this._onUpdate && !tt && (at && _rewindStartAt(this, et, tt, rt),
                _callback(this, "onUpdate")),
                this._repeat && ct !== ft && this.vars.onRepeat && !tt && this.parent && _callback(this, "onRepeat"),
                (lt === this._tDur || !lt) && this._tTime === lt && (at && !this._onUpdate && _rewindStartAt(this, et, !0, !0),
                (et || !it) && (lt === this._tDur && this._ts > 0 || !lt && this._ts < 0) && _removeFromParent(this, 1),
                !tt && !(at && !nt) && (lt || nt || yt) && (_callback(this, lt === ot ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(lt < ot && this.timeScale() > 0) && this._prom()))
            }
            return this
        }
        ,
        J.targets = function() {
            return this._targets
        }
        ,
        J.invalidate = function(et) {
            return (!et || !this.vars.runBackwards) && (this._startAt = 0),
            this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
            this._ptLookup = [],
            this.timeline && this.timeline.invalidate(et),
            _.prototype.invalidate.call(this, et)
        }
        ,
        J.resetTo = function(et, tt, rt, nt, ot) {
            _tickerActive || _ticker.wake(),
            this._ts || this.play();
            var it = Math.min(this._dur, (this._dp._time - this._start) * this._ts), at;
            return this._initted || _initTween(this, it),
            at = this._ease(it / this._dur),
            _updatePropTweens(this, et, tt, rt, nt, at, it, ot) ? this.resetTo(et, tt, rt, nt, 1) : (_alignPlayhead(this, 0),
            this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
            this.render(0))
        }
        ,
        J.kill = function(et, tt) {
            if (tt === void 0 && (tt = "all"),
            !et && (!tt || tt === "all"))
                return this._lazy = this._pt = 0,
                this.parent ? _interrupt(this) : this;
            if (this.timeline) {
                var rt = this.timeline.totalDuration();
                return this.timeline.killTweensOf(et, tt, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this),
                this.parent && rt !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / rt, 0, 1),
                this
            }
            var nt = this._targets, ot = et ? toArray$2(et) : nt, it = this._ptLookup, at = this._pt, lt, st, ut, ct, pt, ft, yt;
            if ((!tt || tt === "all") && _arraysMatch(nt, ot))
                return tt === "all" && (this._pt = 0),
                _interrupt(this);
            for (lt = this._op = this._op || [],
            tt !== "all" && (_isString(tt) && (pt = {},
            _forEachName(tt, function(ht) {
                return pt[ht] = 1
            }),
            tt = pt),
            tt = _addAliasesToVars(nt, tt)),
            yt = nt.length; yt--; )
                if (~ot.indexOf(nt[yt])) {
                    st = it[yt],
                    tt === "all" ? (lt[yt] = tt,
                    ct = st,
                    ut = {}) : (ut = lt[yt] = lt[yt] || {},
                    ct = tt);
                    for (pt in ct)
                        ft = st && st[pt],
                        ft && ((!("kill"in ft.d) || ft.d.kill(pt) === !0) && _removeLinkedListItem(this, ft, "_pt"),
                        delete st[pt]),
                        ut !== "all" && (ut[pt] = 1)
                }
            return this._initted && !this._pt && at && _interrupt(this),
            this
        }
        ,
        k.to = function(et, tt) {
            return new k(et,tt,arguments[2])
        }
        ,
        k.from = function(et, tt) {
            return _createTweenType(1, arguments)
        }
        ,
        k.delayedCall = function(et, tt, rt, nt) {
            return new k(tt,0,{
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: et,
                onComplete: tt,
                onReverseComplete: tt,
                onCompleteParams: rt,
                onReverseCompleteParams: rt,
                callbackScope: nt
            })
        }
        ,
        k.fromTo = function(et, tt, rt) {
            return _createTweenType(2, arguments)
        }
        ,
        k.set = function(et, tt) {
            return tt.duration = 0,
            tt.repeatDelay || (tt.repeat = 0),
            new k(et,tt)
        }
        ,
        k.killTweensOf = function(et, tt, rt) {
            return _globalTimeline.killTweensOf(et, tt, rt)
        }
        ,
        k
    }(Animation);
    _setDefaults(Tween.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }),
    _forEachName("staggerTo,staggerFrom,staggerFromTo", function(_) {
        Tween[_] = function() {
            var k = new Timeline
              , J = _slice.call(arguments, 0);
            return J.splice(_ === "staggerFromTo" ? 5 : 4, 0, 0),
            k[_].apply(k, J)
        }
    });
    var _setterPlain = function(_, k, J) {
        return _[k] = J
    }
      , _setterFunc = function(_, k, J) {
        return _[k](J)
    }
      , _setterFuncWithParam = function(_, k, J, et) {
        return _[k](et.fp, J)
    }
      , _setterAttribute = function(_, k, J) {
        return _.setAttribute(k, J)
    }
      , _getSetter = function(_, k) {
        return _isFunction(_[k]) ? _setterFunc : _isUndefined(_[k]) && _.setAttribute ? _setterAttribute : _setterPlain
    }
      , _renderPlain = function(_, k) {
        return k.set(k.t, k.p, Math.round((k.s + k.c * _) * 1e6) / 1e6, k)
    }
      , _renderBoolean = function(_, k) {
        return k.set(k.t, k.p, !!(k.s + k.c * _), k)
    }
      , _renderComplexString = function(_, k) {
        var J = k._pt
          , et = "";
        if (!_ && k.b)
            et = k.b;
        else if (_ === 1 && k.e)
            et = k.e;
        else {
            for (; J; )
                et = J.p + (J.m ? J.m(J.s + J.c * _) : Math.round((J.s + J.c * _) * 1e4) / 1e4) + et,
                J = J._next;
            et += k.c
        }
        k.set(k.t, k.p, et, k)
    }
      , _renderPropTweens = function(_, k) {
        for (var J = k._pt; J; )
            J.r(_, J.d),
            J = J._next
    }
      , _addPluginModifier = function(_, k, J, et) {
        for (var tt = this._pt, rt; tt; )
            rt = tt._next,
            tt.p === et && tt.modifier(_, k, J),
            tt = rt
    }
      , _killPropTweensOf = function(_) {
        for (var k = this._pt, J, et; k; )
            et = k._next,
            k.p === _ && !k.op || k.op === _ ? _removeLinkedListItem(this, k, "_pt") : k.dep || (J = 1),
            k = et;
        return !J
    }
      , _setterWithModifier = function(_, k, J, et) {
        et.mSet(_, k, et.m.call(et.tween, J, et.mt), et)
    }
      , _sortPropTweensByPriority = function(_) {
        for (var k = _._pt, J, et, tt, rt; k; ) {
            for (J = k._next,
            et = tt; et && et.pr > k.pr; )
                et = et._next;
            (k._prev = et ? et._prev : rt) ? k._prev._next = k : tt = k,
            (k._next = et) ? et._prev = k : rt = k,
            k = J
        }
        _._pt = tt
    }
      , PropTween = function() {
        function _(J, et, tt, rt, nt, ot, it, at, lt) {
            this.t = et,
            this.s = rt,
            this.c = nt,
            this.p = tt,
            this.r = ot || _renderPlain,
            this.d = it || this,
            this.set = at || _setterPlain,
            this.pr = lt || 0,
            this._next = J,
            J && (J._prev = this)
        }
        var k = _.prototype;
        return k.modifier = function(J, et, tt) {
            this.mSet = this.mSet || this.set,
            this.set = _setterWithModifier,
            this.m = J,
            this.mt = tt,
            this.tween = et
        }
        ,
        _
    }();
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(_) {
        return _reservedProps[_] = 1
    }),
    _globals.TweenMax = _globals.TweenLite = Tween,
    _globals.TimelineLite = _globals.TimelineMax = Timeline,
    _globalTimeline = new Timeline({
        sortChildren: !1,
        defaults: _defaults,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }),
    _config.stringFilter = _colorStringFilter;
    var _media = []
      , _listeners$1 = {}
      , _emptyArray = []
      , _lastMediaTime = 0
      , _contextID = 0
      , _dispatch = function(_) {
        return (_listeners$1[_] || _emptyArray).map(function(k) {
            return k()
        })
    }
      , _onMediaChange = function() {
        var _ = Date.now()
          , k = [];
        _ - _lastMediaTime > 2 && (_dispatch("matchMediaInit"),
        _media.forEach(function(J) {
            var et = J.queries, tt = J.conditions, rt, nt, ot, it;
            for (nt in et)
                rt = _win$1.matchMedia(et[nt]).matches,
                rt && (ot = 1),
                rt !== tt[nt] && (tt[nt] = rt,
                it = 1);
            it && (J.revert(),
            ot && k.push(J))
        }),
        _dispatch("matchMediaRevert"),
        k.forEach(function(J) {
            return J.onMatch(J, function(et) {
                return J.add(null, et)
            })
        }),
        _lastMediaTime = _,
        _dispatch("matchMedia"))
    }
      , Context$1 = function() {
        function _(J, et) {
            this.selector = et && selector(et),
            this.data = [],
            this._r = [],
            this.isReverted = !1,
            this.id = _contextID++,
            J && this.add(J)
        }
        var k = _.prototype;
        return k.add = function(J, et, tt) {
            _isFunction(J) && (tt = et,
            et = J,
            J = _isFunction);
            var rt = this
              , nt = function() {
                var ot = _context, it = rt.selector, at;
                return ot && ot !== rt && ot.data.push(rt),
                tt && (rt.selector = selector(tt)),
                _context = rt,
                at = et.apply(rt, arguments),
                _isFunction(at) && rt._r.push(at),
                _context = ot,
                rt.selector = it,
                rt.isReverted = !1,
                at
            };
            return rt.last = nt,
            J === _isFunction ? nt(rt, function(ot) {
                return rt.add(null, ot)
            }) : J ? rt[J] = nt : nt
        }
        ,
        k.ignore = function(J) {
            var et = _context;
            _context = null,
            J(this),
            _context = et
        }
        ,
        k.getTweens = function() {
            var J = [];
            return this.data.forEach(function(et) {
                return et instanceof _ ? J.push.apply(J, et.getTweens()) : et instanceof Tween && !(et.parent && et.parent.data === "nested") && J.push(et)
            }),
            J
        }
        ,
        k.clear = function() {
            this._r.length = this.data.length = 0
        }
        ,
        k.kill = function(J, et) {
            var tt = this;
            if (J ? function() {
                for (var nt = tt.getTweens(), ot = tt.data.length, it; ot--; )
                    it = tt.data[ot],
                    it.data === "isFlip" && (it.revert(),
                    it.getChildren(!0, !0, !1).forEach(function(at) {
                        return nt.splice(nt.indexOf(at), 1)
                    }));
                for (nt.map(function(at) {
                    return {
                        g: at._dur || at._delay || at._sat && !at._sat.vars.immediateRender ? at.globalTime(0) : -1 / 0,
                        t: at
                    }
                }).sort(function(at, lt) {
                    return lt.g - at.g || -1 / 0
                }).forEach(function(at) {
                    return at.t.revert(J)
                }),
                ot = tt.data.length; ot--; )
                    it = tt.data[ot],
                    it instanceof Timeline ? it.data !== "nested" && (it.scrollTrigger && it.scrollTrigger.revert(),
                    it.kill()) : !(it instanceof Tween) && it.revert && it.revert(J);
                tt._r.forEach(function(at) {
                    return at(J, tt)
                }),
                tt.isReverted = !0
            }() : this.data.forEach(function(nt) {
                return nt.kill && nt.kill()
            }),
            this.clear(),
            et)
                for (var rt = _media.length; rt--; )
                    _media[rt].id === this.id && _media.splice(rt, 1)
        }
        ,
        k.revert = function(J) {
            this.kill(J || {})
        }
        ,
        _
    }()
      , MatchMedia = function() {
        function _(J) {
            this.contexts = [],
            this.scope = J,
            _context && _context.data.push(this)
        }
        var k = _.prototype;
        return k.add = function(J, et, tt) {
            _isObject(J) || (J = {
                matches: J
            });
            var rt = new Context$1(0,tt || this.scope), nt = rt.conditions = {}, ot, it, at;
            _context && !rt.selector && (rt.selector = _context.selector),
            this.contexts.push(rt),
            et = rt.add("onMatch", et),
            rt.queries = J;
            for (it in J)
                it === "all" ? at = 1 : (ot = _win$1.matchMedia(J[it]),
                ot && (_media.indexOf(rt) < 0 && _media.push(rt),
                (nt[it] = ot.matches) && (at = 1),
                ot.addListener ? ot.addListener(_onMediaChange) : ot.addEventListener("change", _onMediaChange)));
            return at && et(rt, function(lt) {
                return rt.add(null, lt)
            }),
            this
        }
        ,
        k.revert = function(J) {
            this.kill(J || {})
        }
        ,
        k.kill = function(J) {
            this.contexts.forEach(function(et) {
                return et.kill(J, !0)
            })
        }
        ,
        _
    }()
      , _gsap = {
        registerPlugin: function() {
            for (var _ = arguments.length, k = new Array(_), J = 0; J < _; J++)
                k[J] = arguments[J];
            k.forEach(function(et) {
                return _createPlugin(et)
            })
        },
        timeline: function(_) {
            return new Timeline(_)
        },
        getTweensOf: function(_, k) {
            return _globalTimeline.getTweensOf(_, k)
        },
        getProperty: function(_, k, J, et) {
            _isString(_) && (_ = toArray$2(_)[0]);
            var tt = _getCache(_ || {}).get
              , rt = J ? _passThrough : _numericIfPossible;
            return J === "native" && (J = ""),
            _ && (k ? rt((_plugins[k] && _plugins[k].get || tt)(_, k, J, et)) : function(nt, ot, it) {
                return rt((_plugins[nt] && _plugins[nt].get || tt)(_, nt, ot, it))
            }
            )
        },
        quickSetter: function(_, k, J) {
            if (_ = toArray$2(_),
            _.length > 1) {
                var et = _.map(function(at) {
                    return gsap$1.quickSetter(at, k, J)
                })
                  , tt = et.length;
                return function(at) {
                    for (var lt = tt; lt--; )
                        et[lt](at)
                }
            }
            _ = _[0] || {};
            var rt = _plugins[k]
              , nt = _getCache(_)
              , ot = nt.harness && (nt.harness.aliases || {})[k] || k
              , it = rt ? function(at) {
                var lt = new rt;
                _quickTween._pt = 0,
                lt.init(_, J ? at + J : at, _quickTween, 0, [_]),
                lt.render(1, lt),
                _quickTween._pt && _renderPropTweens(1, _quickTween)
            }
            : nt.set(_, ot);
            return rt ? it : function(at) {
                return it(_, ot, J ? at + J : at, nt, 1)
            }
        },
        quickTo: function(_, k, J) {
            var et, tt = gsap$1.to(_, _merge((et = {},
            et[k] = "+=0.1",
            et.paused = !0,
            et), J || {})), rt = function(nt, ot, it) {
                return tt.resetTo(k, nt, ot, it)
            };
            return rt.tween = tt,
            rt
        },
        isTweening: function(_) {
            return _globalTimeline.getTweensOf(_, !0).length > 0
        },
        defaults: function(_) {
            return _ && _.ease && (_.ease = _parseEase(_.ease, _defaults.ease)),
            _mergeDeep(_defaults, _ || {})
        },
        config: function(_) {
            return _mergeDeep(_config, _ || {})
        },
        registerEffect: function(_) {
            var k = _.name
              , J = _.effect
              , et = _.plugins
              , tt = _.defaults
              , rt = _.extendTimeline;
            (et || "").split(",").forEach(function(nt) {
                return nt && !_plugins[nt] && !_globals[nt] && _warn(k + " effect requires " + nt + " plugin.")
            }),
            _effects[k] = function(nt, ot, it) {
                return J(toArray$2(nt), _setDefaults(ot || {}, tt), it)
            }
            ,
            rt && (Timeline.prototype[k] = function(nt, ot, it) {
                return this.add(_effects[k](nt, _isObject(ot) ? ot : (it = ot) && {}, this), it)
            }
            )
        },
        registerEase: function(_, k) {
            _easeMap[_] = _parseEase(k)
        },
        parseEase: function(_, k) {
            return arguments.length ? _parseEase(_, k) : _easeMap
        },
        getById: function(_) {
            return _globalTimeline.getById(_)
        },
        exportRoot: function(_, k) {
            _ === void 0 && (_ = {});
            var J = new Timeline(_), et, tt;
            for (J.smoothChildTiming = _isNotFalse(_.smoothChildTiming),
            _globalTimeline.remove(J),
            J._dp = 0,
            J._time = J._tTime = _globalTimeline._time,
            et = _globalTimeline._first; et; )
                tt = et._next,
                (k || !(!et._dur && et instanceof Tween && et.vars.onComplete === et._targets[0])) && _addToTimeline(J, et, et._start - et._delay),
                et = tt;
            return _addToTimeline(_globalTimeline, J, 0),
            J
        },
        context: function(_, k) {
            return _ ? new Context$1(_,k) : _context
        },
        matchMedia: function(_) {
            return new MatchMedia(_)
        },
        matchMediaRefresh: function() {
            return _media.forEach(function(_) {
                var k = _.conditions, J, et;
                for (et in k)
                    k[et] && (k[et] = !1,
                    J = 1);
                J && _.revert()
            }) || _onMediaChange()
        },
        addEventListener: function(_, k) {
            var J = _listeners$1[_] || (_listeners$1[_] = []);
            ~J.indexOf(k) || J.push(k)
        },
        removeEventListener: function(_, k) {
            var J = _listeners$1[_]
              , et = J && J.indexOf(k);
            et >= 0 && J.splice(et, 1)
        },
        utils: {
            wrap: wrap$1,
            wrapYoyo,
            distribute,
            random: random$1,
            snap,
            normalize,
            getUnit,
            clamp: clamp$1,
            splitColor: splitColor$1,
            toArray: toArray$2,
            selector,
            mapRange,
            pipe: pipe$1,
            unitize,
            interpolate: interpolate$1,
            shuffle
        },
        install: _install,
        effects: _effects,
        ticker: _ticker,
        updateRoot: Timeline.updateRoot,
        plugins: _plugins,
        globalTimeline: _globalTimeline,
        core: {
            PropTween,
            globals: _addGlobal,
            Tween,
            Timeline,
            Animation,
            getCache: _getCache,
            _removeLinkedListItem,
            reverting: function() {
                return _reverting$1
            },
            context: function(_) {
                return _ && _context && (_context.data.push(_),
                _._ctx = _context),
                _context
            },
            suppressOverwrites: function(_) {
                return _suppressOverwrites = _
            }
        }
    };
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(_) {
        return _gsap[_] = Tween[_]
    }),
    _ticker.add(Timeline.updateRoot),
    _quickTween = _gsap.to({}, {
        duration: 0
    });
    var _getPluginPropTween = function(_, k) {
        for (var J = _._pt; J && J.p !== k && J.op !== k && J.fp !== k; )
            J = J._next;
        return J
    }
      , _addModifiers = function(_, k) {
        var J = _._targets, et, tt, rt;
        for (et in k)
            for (tt = J.length; tt--; )
                rt = _._ptLookup[tt][et],
                rt && (rt = rt.d) && (rt._pt && (rt = _getPluginPropTween(rt, et)),
                rt && rt.modifier && rt.modifier(k[et], _, J[tt], et))
    }
      , _buildModifierPlugin = function(_, k) {
        return {
            name: _,
            rawVars: 1,
            init: function(J, et, tt) {
                tt._onInit = function(rt) {
                    var nt, ot;
                    if (_isString(et) && (nt = {},
                    _forEachName(et, function(it) {
                        return nt[it] = 1
                    }),
                    et = nt),
                    k) {
                        nt = {};
                        for (ot in et)
                            nt[ot] = k(et[ot]);
                        et = nt
                    }
                    _addModifiers(rt, et)
                }
            }
        }
    }
      , gsap$1 = _gsap.registerPlugin({
        name: "attr",
        init: function(_, k, J, et, tt) {
            var rt, nt, ot;
            this.tween = J;
            for (rt in k)
                ot = _.getAttribute(rt) || "",
                nt = this.add(_, "setAttribute", (ot || 0) + "", k[rt], et, tt, 0, 0, rt),
                nt.op = rt,
                nt.b = ot,
                this._props.push(rt)
        },
        render: function(_, k) {
            for (var J = k._pt; J; )
                _reverting$1 ? J.set(J.t, J.p, J.b, J) : J.r(_, J.d),
                J = J._next
        }
    }, {
        name: "endArray",
        init: function(_, k) {
            for (var J = k.length; J--; )
                this.add(_, J, _[J] || 0, k[J], 0, 0, 0, 0, 0, 1)
        }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap$1.version = "3.12.5",
    _coreReady = 1,
    _windowExists$1() && _wake();
    var Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ, _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists = function() {
        return typeof window < "u"
    }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    }, _renderCSSProp = function(_, k) {
        return k.set(k.t, k.p, Math.round((k.s + k.c * _) * 1e4) / 1e4 + k.u, k)
    }, _renderPropWithEnd = function(_, k) {
        return k.set(k.t, k.p, _ === 1 ? k.e : Math.round((k.s + k.c * _) * 1e4) / 1e4 + k.u, k)
    }, _renderCSSPropWithBeginning = function(_, k) {
        return k.set(k.t, k.p, _ ? Math.round((k.s + k.c * _) * 1e4) / 1e4 + k.u : k.b, k)
    }, _renderRoundedCSSProp = function(_, k) {
        var J = k.s + k.c * _;
        k.set(k.t, k.p, ~~(J + (J < 0 ? -.5 : .5)) + k.u, k)
    }, _renderNonTweeningValue = function(_, k) {
        return k.set(k.t, k.p, _ ? k.e : k.b, k)
    }, _renderNonTweeningValueOnlyAtEnd = function(_, k) {
        return k.set(k.t, k.p, _ !== 1 ? k.b : k.e, k)
    }, _setterCSSStyle = function(_, k, J) {
        return _.style[k] = J
    }, _setterCSSProp = function(_, k, J) {
        return _.style.setProperty(k, J)
    }, _setterTransform = function(_, k, J) {
        return _._gsap[k] = J
    }, _setterScale = function(_, k, J) {
        return _._gsap.scaleX = _._gsap.scaleY = J
    }, _setterScaleWithRender = function(_, k, J, et, tt) {
        var rt = _._gsap;
        rt.scaleX = rt.scaleY = J,
        rt.renderTransform(tt, rt)
    }, _setterTransformWithRender = function(_, k, J, et, tt) {
        var rt = _._gsap;
        rt[k] = J,
        rt.renderTransform(tt, rt)
    }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _saveStyle = function _(k, J) {
        var et = this
          , tt = this.target
          , rt = tt.style
          , nt = tt._gsap;
        if (k in _transformProps && rt) {
            if (this.tfm = this.tfm || {},
            k !== "transform")
                k = _propertyAliases[k] || k,
                ~k.indexOf(",") ? k.split(",").forEach(function(ot) {
                    return et.tfm[ot] = _get(tt, ot)
                }) : this.tfm[k] = nt.x ? nt[k] : _get(tt, k),
                k === _transformOriginProp && (this.tfm.zOrigin = nt.zOrigin);
            else
                return _propertyAliases.transform.split(",").forEach(function(ot) {
                    return _.call(et, ot, J)
                });
            if (this.props.indexOf(_transformProp) >= 0)
                return;
            nt.svg && (this.svgo = tt.getAttribute("data-svg-origin"),
            this.props.push(_transformOriginProp, J, "")),
            k = _transformProp
        }
        (rt || J) && this.props.push(k, J, rt[k])
    }, _removeIndependentTransforms = function(_) {
        _.translate && (_.removeProperty("translate"),
        _.removeProperty("scale"),
        _.removeProperty("rotate"))
    }, _revertStyle = function() {
        var _ = this.props, k = this.target, J = k.style, et = k._gsap, tt, rt;
        for (tt = 0; tt < _.length; tt += 3)
            _[tt + 1] ? k[_[tt]] = _[tt + 2] : _[tt + 2] ? J[_[tt]] = _[tt + 2] : J.removeProperty(_[tt].substr(0, 2) === "--" ? _[tt] : _[tt].replace(_capsExp, "-$1").toLowerCase());
        if (this.tfm) {
            for (rt in this.tfm)
                et[rt] = this.tfm[rt];
            et.svg && (et.renderTransform(),
            k.setAttribute("data-svg-origin", this.svgo || "")),
            tt = _reverting(),
            (!tt || !tt.isStart) && !J[_transformProp] && (_removeIndependentTransforms(J),
            et.zOrigin && J[_transformOriginProp] && (J[_transformOriginProp] += " " + et.zOrigin + "px",
            et.zOrigin = 0,
            et.renderTransform()),
            et.uncache = 1)
        }
    }, _getStyleSaver = function(_, k) {
        var J = {
            target: _,
            props: [],
            revert: _revertStyle,
            save: _saveStyle
        };
        return _._gsap || gsap$1.core.getCache(_),
        k && k.split(",").forEach(function(et) {
            return J.save(et)
        }),
        J
    }, _supports3D, _createElement = function(_, k) {
        var J = _doc.createElementNS ? _doc.createElementNS((k || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), _) : _doc.createElement(_);
        return J && J.style ? J : _doc.createElement(_)
    }, _getComputedProperty = function _(k, J, et) {
        var tt = getComputedStyle(k);
        return tt[J] || tt.getPropertyValue(J.replace(_capsExp, "-$1").toLowerCase()) || tt.getPropertyValue(J) || !et && _(k, _checkPropPrefix(J) || J, 1) || ""
    }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function(_, k, J) {
        var et = k || _tempDiv
          , tt = et.style
          , rt = 5;
        if (_ in tt && !J)
            return _;
        for (_ = _.charAt(0).toUpperCase() + _.substr(1); rt-- && !(_prefixes[rt] + _ in tt); )
            ;
        return rt < 0 ? null : (rt === 3 ? "ms" : rt >= 0 ? _prefixes[rt] : "") + _
    }, _initCore = function() {
        _windowExists() && window.document && (_win = window,
        _doc = _win.document,
        _docElement = _doc.documentElement,
        _tempDiv = _createElement("div") || {
            style: {}
        },
        _createElement("div"),
        _transformProp = _checkPropPrefix(_transformProp),
        _transformOriginProp = _transformProp + "Origin",
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
        _supports3D = !!_checkPropPrefix("perspective"),
        _reverting = gsap$1.core.reverting,
        _pluginInitted = 1)
    }, _getBBoxHack = function _(k) {
        var J = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), et = this.parentNode, tt = this.nextSibling, rt = this.style.cssText, nt;
        if (_docElement.appendChild(J),
        J.appendChild(this),
        this.style.display = "block",
        k)
            try {
                nt = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = _
            } catch (ot) {}
        else
            this._gsapBBox && (nt = this._gsapBBox());
        return et && (tt ? et.insertBefore(this, tt) : et.appendChild(this)),
        _docElement.removeChild(J),
        this.style.cssText = rt,
        nt
    }, _getAttributeFallbacks = function(_, k) {
        for (var J = k.length; J--; )
            if (_.hasAttribute(k[J]))
                return _.getAttribute(k[J])
    }, _getBBox = function(_) {
        var k;
        try {
            k = _.getBBox()
        } catch (J) {
            k = _getBBoxHack.call(_, !0)
        }
        return k && (k.width || k.height) || _.getBBox === _getBBoxHack || (k = _getBBoxHack.call(_, !0)),
        k && !k.width && !k.x && !k.y ? {
            x: +_getAttributeFallbacks(_, ["x", "cx", "x1"]) || 0,
            y: +_getAttributeFallbacks(_, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : k
    }, _isSVG = function(_) {
        return !!(_.getCTM && (!_.parentNode || _.ownerSVGElement) && _getBBox(_))
    }, _removeProperty = function(_, k) {
        if (k) {
            var J = _.style, et;
            k in _transformProps && k !== _transformOriginProp && (k = _transformProp),
            J.removeProperty ? (et = k.substr(0, 2),
            (et === "ms" || k.substr(0, 6) === "webkit") && (k = "-" + k),
            J.removeProperty(et === "--" ? k : k.replace(_capsExp, "-$1").toLowerCase())) : J.removeAttribute(k)
        }
    }, _addNonTweeningPT = function(_, k, J, et, tt, rt) {
        var nt = new PropTween(_._pt,k,J,0,1,rt ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
        return _._pt = nt,
        nt.b = et,
        nt.e = tt,
        _._props.push(J),
        nt
    }, _nonConvertibleUnits = {
        deg: 1,
        rad: 1,
        turn: 1
    }, _nonStandardLayouts = {
        grid: 1,
        flex: 1
    }, _convertToUnit = function _(k, J, et, tt) {
        var rt = parseFloat(et) || 0, nt = (et + "").trim().substr((rt + "").length) || "px", ot = _tempDiv.style, it = _horizontalExp.test(J), at = k.tagName.toLowerCase() === "svg", lt = (at ? "client" : "offset") + (it ? "Width" : "Height"), st = 100, ut = tt === "px", ct = tt === "%", pt, ft, yt, ht;
        if (tt === nt || !rt || _nonConvertibleUnits[tt] || _nonConvertibleUnits[nt])
            return rt;
        if (nt !== "px" && !ut && (rt = _(k, J, et, "px")),
        ht = k.getCTM && _isSVG(k),
        (ct || nt === "%") && (_transformProps[J] || ~J.indexOf("adius")))
            return pt = ht ? k.getBBox()[it ? "width" : "height"] : k[lt],
            _round(ct ? rt / pt * st : rt / 100 * pt);
        if (ot[it ? "width" : "height"] = st + (ut ? nt : tt),
        ft = ~J.indexOf("adius") || tt === "em" && k.appendChild && !at ? k : k.parentNode,
        ht && (ft = (k.ownerSVGElement || {}).parentNode),
        (!ft || ft === _doc || !ft.appendChild) && (ft = _doc.body),
        yt = ft._gsap,
        yt && ct && yt.width && it && yt.time === _ticker.time && !yt.uncache)
            return _round(rt / yt.width * st);
        if (ct && (J === "height" || J === "width")) {
            var gt = k.style[J];
            k.style[J] = st + tt,
            pt = k[lt],
            gt ? k.style[J] = gt : _removeProperty(k, J)
        } else
            (ct || nt === "%") && !_nonStandardLayouts[_getComputedProperty(ft, "display")] && (ot.position = _getComputedProperty(k, "position")),
            ft === k && (ot.position = "static"),
            ft.appendChild(_tempDiv),
            pt = _tempDiv[lt],
            ft.removeChild(_tempDiv),
            ot.position = "absolute";
        return it && ct && (yt = _getCache(ft),
        yt.time = _ticker.time,
        yt.width = ft[lt]),
        _round(ut ? pt * rt / st : pt && rt ? st / pt * rt : 0)
    }, _get = function(_, k, J, et) {
        var tt;
        return _pluginInitted || _initCore(),
        k in _propertyAliases && k !== "transform" && (k = _propertyAliases[k],
        ~k.indexOf(",") && (k = k.split(",")[0])),
        _transformProps[k] && k !== "transform" ? (tt = _parseTransform(_, et),
        tt = k !== "transformOrigin" ? tt[k] : tt.svg ? tt.origin : _firstTwoOnly(_getComputedProperty(_, _transformOriginProp)) + " " + tt.zOrigin + "px") : (tt = _.style[k],
        (!tt || tt === "auto" || et || ~(tt + "").indexOf("calc(")) && (tt = _specialProps[k] && _specialProps[k](_, k, J) || _getComputedProperty(_, k) || _getProperty(_, k) || (k === "opacity" ? 1 : 0))),
        J && !~(tt + "").trim().indexOf(" ") ? _convertToUnit(_, k, tt, J) + J : tt
    }, _tweenComplexCSSString = function(_, k, J, et) {
        if (!J || J === "none") {
            var tt = _checkPropPrefix(k, _, 1)
              , rt = tt && _getComputedProperty(_, tt, 1);
            rt && rt !== J ? (k = tt,
            J = rt) : k === "borderColor" && (J = _getComputedProperty(_, "borderTopColor"))
        }
        var nt = new PropTween(this._pt,_.style,k,0,1,_renderComplexString), ot = 0, it = 0, at, lt, st, ut, ct, pt, ft, yt, ht, gt, mt, vt;
        if (nt.b = J,
        nt.e = et,
        J += "",
        et += "",
        et === "auto" && (pt = _.style[k],
        _.style[k] = et,
        et = _getComputedProperty(_, k) || et,
        pt ? _.style[k] = pt : _removeProperty(_, k)),
        at = [J, et],
        _colorStringFilter(at),
        J = at[0],
        et = at[1],
        st = J.match(_numWithUnitExp) || [],
        vt = et.match(_numWithUnitExp) || [],
        vt.length) {
            for (; lt = _numWithUnitExp.exec(et); )
                ft = lt[0],
                ht = et.substring(ot, lt.index),
                ct ? ct = (ct + 1) % 5 : (ht.substr(-5) === "rgba(" || ht.substr(-5) === "hsla(") && (ct = 1),
                ft !== (pt = st[it++] || "") && (ut = parseFloat(pt) || 0,
                mt = pt.substr((ut + "").length),
                ft.charAt(1) === "=" && (ft = _parseRelative(ut, ft) + mt),
                yt = parseFloat(ft),
                gt = ft.substr((yt + "").length),
                ot = _numWithUnitExp.lastIndex - gt.length,
                gt || (gt = gt || _config.units[k] || mt,
                ot === et.length && (et += gt,
                nt.e += gt)),
                mt !== gt && (ut = _convertToUnit(_, k, pt, gt) || 0),
                nt._pt = {
                    _next: nt._pt,
                    p: ht || it === 1 ? ht : ",",
                    s: ut,
                    c: yt - ut,
                    m: ct && ct < 4 || k === "zIndex" ? Math.round : 0
                });
            nt.c = ot < et.length ? et.substring(ot, et.length) : ""
        } else
            nt.r = k === "display" && et === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
        return _relExp.test(et) && (nt.e = 0),
        this._pt = nt,
        nt
    }, _keywordToPercent = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    }, _convertKeywordsToPercentages = function(_) {
        var k = _.split(" ")
          , J = k[0]
          , et = k[1] || "50%";
        return (J === "top" || J === "bottom" || et === "left" || et === "right") && (_ = J,
        J = et,
        et = _),
        k[0] = _keywordToPercent[J] || J,
        k[1] = _keywordToPercent[et] || et,
        k.join(" ")
    }, _renderClearProps = function(_, k) {
        if (k.tween && k.tween._time === k.tween._dur) {
            var J = k.t, et = J.style, tt = k.u, rt = J._gsap, nt, ot, it;
            if (tt === "all" || tt === !0)
                et.cssText = "",
                ot = 1;
            else
                for (tt = tt.split(","),
                it = tt.length; --it > -1; )
                    nt = tt[it],
                    _transformProps[nt] && (ot = 1,
                    nt = nt === "transformOrigin" ? _transformOriginProp : _transformProp),
                    _removeProperty(J, nt);
            ot && (_removeProperty(J, _transformProp),
            rt && (rt.svg && J.removeAttribute("transform"),
            _parseTransform(J, 1),
            rt.uncache = 1,
            _removeIndependentTransforms(et)))
        }
    }, _specialProps = {
        clearProps: function(_, k, J, et, tt) {
            if (tt.data !== "isFromStart") {
                var rt = _._pt = new PropTween(_._pt,k,J,0,0,_renderClearProps);
                return rt.u = et,
                rt.pr = -10,
                rt.tween = tt,
                _._props.push(J),
                1
            }
        }
    }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function(_) {
        return _ === "matrix(1, 0, 0, 1, 0, 0)" || _ === "none" || !_
    }, _getComputedTransformMatrixAsArray = function(_) {
        var k = _getComputedProperty(_, _transformProp);
        return _isNullTransform(k) ? _identity2DMatrix : k.substr(7).match(_numExp).map(_round)
    }, _getMatrix = function(_, k) {
        var J = _._gsap || _getCache(_), et = _.style, tt = _getComputedTransformMatrixAsArray(_), rt, nt, ot, it;
        return J.svg && _.getAttribute("transform") ? (ot = _.transform.baseVal.consolidate().matrix,
        tt = [ot.a, ot.b, ot.c, ot.d, ot.e, ot.f],
        tt.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : tt) : (tt === _identity2DMatrix && !_.offsetParent && _ !== _docElement && !J.svg && (ot = et.display,
        et.display = "block",
        rt = _.parentNode,
        (!rt || !_.offsetParent) && (it = 1,
        nt = _.nextElementSibling,
        _docElement.appendChild(_)),
        tt = _getComputedTransformMatrixAsArray(_),
        ot ? et.display = ot : _removeProperty(_, "display"),
        it && (nt ? rt.insertBefore(_, nt) : rt ? rt.appendChild(_) : _docElement.removeChild(_))),
        k && tt.length > 6 ? [tt[0], tt[1], tt[4], tt[5], tt[12], tt[13]] : tt)
    }, _applySVGOrigin = function(_, k, J, et, tt, rt) {
        var nt = _._gsap, ot = tt || _getMatrix(_, !0), it = nt.xOrigin || 0, at = nt.yOrigin || 0, lt = nt.xOffset || 0, st = nt.yOffset || 0, ut = ot[0], ct = ot[1], pt = ot[2], ft = ot[3], yt = ot[4], ht = ot[5], gt = k.split(" "), mt = parseFloat(gt[0]) || 0, vt = parseFloat(gt[1]) || 0, bt, Et, xt, wt;
        J ? ot !== _identity2DMatrix && (Et = ut * ft - ct * pt) && (xt = mt * (ft / Et) + vt * (-pt / Et) + (pt * ht - ft * yt) / Et,
        wt = mt * (-ct / Et) + vt * (ut / Et) - (ut * ht - ct * yt) / Et,
        mt = xt,
        vt = wt) : (bt = _getBBox(_),
        mt = bt.x + (~gt[0].indexOf("%") ? mt / 100 * bt.width : mt),
        vt = bt.y + (~(gt[1] || gt[0]).indexOf("%") ? vt / 100 * bt.height : vt)),
        et || et !== !1 && nt.smooth ? (yt = mt - it,
        ht = vt - at,
        nt.xOffset = lt + (yt * ut + ht * pt) - yt,
        nt.yOffset = st + (yt * ct + ht * ft) - ht) : nt.xOffset = nt.yOffset = 0,
        nt.xOrigin = mt,
        nt.yOrigin = vt,
        nt.smooth = !!et,
        nt.origin = k,
        nt.originIsAbsolute = !!J,
        _.style[_transformOriginProp] = "0px 0px",
        rt && (_addNonTweeningPT(rt, nt, "xOrigin", it, mt),
        _addNonTweeningPT(rt, nt, "yOrigin", at, vt),
        _addNonTweeningPT(rt, nt, "xOffset", lt, nt.xOffset),
        _addNonTweeningPT(rt, nt, "yOffset", st, nt.yOffset)),
        _.setAttribute("data-svg-origin", mt + " " + vt)
    }, _parseTransform = function(_, k) {
        var J = _._gsap || new GSCache(_);
        if ("x"in J && !k && !J.uncache)
            return J;
        var et = _.style, tt = J.scaleX < 0, rt = "px", nt = "deg", ot = getComputedStyle(_), it = _getComputedProperty(_, _transformOriginProp) || "0", at, lt, st, ut, ct, pt, ft, yt, ht, gt, mt, vt, bt, Et, xt, wt, St, Pt, Rt, At, Nt, Ot, It, Mt, Wt, jt, Bt, Ut, Xt, Yt, Gt, er;
        return at = lt = st = pt = ft = yt = ht = gt = mt = 0,
        ut = ct = 1,
        J.svg = !!(_.getCTM && _isSVG(_)),
        ot.translate && ((ot.translate !== "none" || ot.scale !== "none" || ot.rotate !== "none") && (et[_transformProp] = (ot.translate !== "none" ? "translate3d(" + (ot.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (ot.rotate !== "none" ? "rotate(" + ot.rotate + ") " : "") + (ot.scale !== "none" ? "scale(" + ot.scale.split(" ").join(",") + ") " : "") + (ot[_transformProp] !== "none" ? ot[_transformProp] : "")),
        et.scale = et.rotate = et.translate = "none"),
        Et = _getMatrix(_, J.svg),
        J.svg && (J.uncache ? (Wt = _.getBBox(),
        it = J.xOrigin - Wt.x + "px " + (J.yOrigin - Wt.y) + "px",
        Mt = "") : Mt = !k && _.getAttribute("data-svg-origin"),
        _applySVGOrigin(_, Mt || it, !!Mt || J.originIsAbsolute, J.smooth !== !1, Et)),
        vt = J.xOrigin || 0,
        bt = J.yOrigin || 0,
        Et !== _identity2DMatrix && (Pt = Et[0],
        Rt = Et[1],
        At = Et[2],
        Nt = Et[3],
        at = Ot = Et[4],
        lt = It = Et[5],
        Et.length === 6 ? (ut = Math.sqrt(Pt * Pt + Rt * Rt),
        ct = Math.sqrt(Nt * Nt + At * At),
        pt = Pt || Rt ? _atan2(Rt, Pt) * _RAD2DEG : 0,
        ht = At || Nt ? _atan2(At, Nt) * _RAD2DEG + pt : 0,
        ht && (ct *= Math.abs(Math.cos(ht * _DEG2RAD))),
        J.svg && (at -= vt - (vt * Pt + bt * At),
        lt -= bt - (vt * Rt + bt * Nt))) : (er = Et[6],
        Yt = Et[7],
        Bt = Et[8],
        Ut = Et[9],
        Xt = Et[10],
        Gt = Et[11],
        at = Et[12],
        lt = Et[13],
        st = Et[14],
        xt = _atan2(er, Xt),
        ft = xt * _RAD2DEG,
        xt && (wt = Math.cos(-xt),
        St = Math.sin(-xt),
        Mt = Ot * wt + Bt * St,
        Wt = It * wt + Ut * St,
        jt = er * wt + Xt * St,
        Bt = Ot * -St + Bt * wt,
        Ut = It * -St + Ut * wt,
        Xt = er * -St + Xt * wt,
        Gt = Yt * -St + Gt * wt,
        Ot = Mt,
        It = Wt,
        er = jt),
        xt = _atan2(-At, Xt),
        yt = xt * _RAD2DEG,
        xt && (wt = Math.cos(-xt),
        St = Math.sin(-xt),
        Mt = Pt * wt - Bt * St,
        Wt = Rt * wt - Ut * St,
        jt = At * wt - Xt * St,
        Gt = Nt * St + Gt * wt,
        Pt = Mt,
        Rt = Wt,
        At = jt),
        xt = _atan2(Rt, Pt),
        pt = xt * _RAD2DEG,
        xt && (wt = Math.cos(xt),
        St = Math.sin(xt),
        Mt = Pt * wt + Rt * St,
        Wt = Ot * wt + It * St,
        Rt = Rt * wt - Pt * St,
        It = It * wt - Ot * St,
        Pt = Mt,
        Ot = Wt),
        ft && Math.abs(ft) + Math.abs(pt) > 359.9 && (ft = pt = 0,
        yt = 180 - yt),
        ut = _round(Math.sqrt(Pt * Pt + Rt * Rt + At * At)),
        ct = _round(Math.sqrt(It * It + er * er)),
        xt = _atan2(Ot, It),
        ht = Math.abs(xt) > 2e-4 ? xt * _RAD2DEG : 0,
        mt = Gt ? 1 / (Gt < 0 ? -Gt : Gt) : 0),
        J.svg && (Mt = _.getAttribute("transform"),
        J.forceCSS = _.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(_, _transformProp)),
        Mt && _.setAttribute("transform", Mt))),
        Math.abs(ht) > 90 && Math.abs(ht) < 270 && (tt ? (ut *= -1,
        ht += pt <= 0 ? 180 : -180,
        pt += pt <= 0 ? 180 : -180) : (ct *= -1,
        ht += ht <= 0 ? 180 : -180)),
        k = k || J.uncache,
        J.x = at - ((J.xPercent = at && (!k && J.xPercent || (Math.round(_.offsetWidth / 2) === Math.round(-at) ? -50 : 0))) ? _.offsetWidth * J.xPercent / 100 : 0) + rt,
        J.y = lt - ((J.yPercent = lt && (!k && J.yPercent || (Math.round(_.offsetHeight / 2) === Math.round(-lt) ? -50 : 0))) ? _.offsetHeight * J.yPercent / 100 : 0) + rt,
        J.z = st + rt,
        J.scaleX = _round(ut),
        J.scaleY = _round(ct),
        J.rotation = _round(pt) + nt,
        J.rotationX = _round(ft) + nt,
        J.rotationY = _round(yt) + nt,
        J.skewX = ht + nt,
        J.skewY = gt + nt,
        J.transformPerspective = mt + rt,
        (J.zOrigin = parseFloat(it.split(" ")[2]) || !k && J.zOrigin || 0) && (et[_transformOriginProp] = _firstTwoOnly(it)),
        J.xOffset = J.yOffset = 0,
        J.force3D = _config.force3D,
        J.renderTransform = J.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms,
        J.uncache = 0,
        J
    }, _firstTwoOnly = function(_) {
        return (_ = _.split(" "))[0] + " " + _[1]
    }, _addPxTranslate = function(_, k, J) {
        var et = getUnit(k);
        return _round(parseFloat(k) + parseFloat(_convertToUnit(_, "x", J + "px", et))) + et
    }, _renderNon3DTransforms = function(_, k) {
        k.z = "0px",
        k.rotationY = k.rotationX = "0deg",
        k.force3D = 0,
        _renderCSSTransforms(_, k)
    }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function(_, k) {
        var J = k || this
          , et = J.xPercent
          , tt = J.yPercent
          , rt = J.x
          , nt = J.y
          , ot = J.z
          , it = J.rotation
          , at = J.rotationY
          , lt = J.rotationX
          , st = J.skewX
          , ut = J.skewY
          , ct = J.scaleX
          , pt = J.scaleY
          , ft = J.transformPerspective
          , yt = J.force3D
          , ht = J.target
          , gt = J.zOrigin
          , mt = ""
          , vt = yt === "auto" && _ && _ !== 1 || yt === !0;
        if (gt && (lt !== _zeroDeg || at !== _zeroDeg)) {
            var bt = parseFloat(at) * _DEG2RAD, Et = Math.sin(bt), xt = Math.cos(bt), wt;
            bt = parseFloat(lt) * _DEG2RAD,
            wt = Math.cos(bt),
            rt = _addPxTranslate(ht, rt, Et * wt * -gt),
            nt = _addPxTranslate(ht, nt, -Math.sin(bt) * -gt),
            ot = _addPxTranslate(ht, ot, xt * wt * -gt + gt)
        }
        ft !== _zeroPx && (mt += "perspective(" + ft + _endParenthesis),
        (et || tt) && (mt += "translate(" + et + "%, " + tt + "%) "),
        (vt || rt !== _zeroPx || nt !== _zeroPx || ot !== _zeroPx) && (mt += ot !== _zeroPx || vt ? "translate3d(" + rt + ", " + nt + ", " + ot + ") " : "translate(" + rt + ", " + nt + _endParenthesis),
        it !== _zeroDeg && (mt += "rotate(" + it + _endParenthesis),
        at !== _zeroDeg && (mt += "rotateY(" + at + _endParenthesis),
        lt !== _zeroDeg && (mt += "rotateX(" + lt + _endParenthesis),
        (st !== _zeroDeg || ut !== _zeroDeg) && (mt += "skew(" + st + ", " + ut + _endParenthesis),
        (ct !== 1 || pt !== 1) && (mt += "scale(" + ct + ", " + pt + _endParenthesis),
        ht.style[_transformProp] = mt || "translate(0, 0)"
    }, _renderSVGTransforms = function(_, k) {
        var J = k || this, et = J.xPercent, tt = J.yPercent, rt = J.x, nt = J.y, ot = J.rotation, it = J.skewX, at = J.skewY, lt = J.scaleX, st = J.scaleY, ut = J.target, ct = J.xOrigin, pt = J.yOrigin, ft = J.xOffset, yt = J.yOffset, ht = J.forceCSS, gt = parseFloat(rt), mt = parseFloat(nt), vt, bt, Et, xt, wt;
        ot = parseFloat(ot),
        it = parseFloat(it),
        at = parseFloat(at),
        at && (at = parseFloat(at),
        it += at,
        ot += at),
        ot || it ? (ot *= _DEG2RAD,
        it *= _DEG2RAD,
        vt = Math.cos(ot) * lt,
        bt = Math.sin(ot) * lt,
        Et = Math.sin(ot - it) * -st,
        xt = Math.cos(ot - it) * st,
        it && (at *= _DEG2RAD,
        wt = Math.tan(it - at),
        wt = Math.sqrt(1 + wt * wt),
        Et *= wt,
        xt *= wt,
        at && (wt = Math.tan(at),
        wt = Math.sqrt(1 + wt * wt),
        vt *= wt,
        bt *= wt)),
        vt = _round(vt),
        bt = _round(bt),
        Et = _round(Et),
        xt = _round(xt)) : (vt = lt,
        xt = st,
        bt = Et = 0),
        (gt && !~(rt + "").indexOf("px") || mt && !~(nt + "").indexOf("px")) && (gt = _convertToUnit(ut, "x", rt, "px"),
        mt = _convertToUnit(ut, "y", nt, "px")),
        (ct || pt || ft || yt) && (gt = _round(gt + ct - (ct * vt + pt * Et) + ft),
        mt = _round(mt + pt - (ct * bt + pt * xt) + yt)),
        (et || tt) && (wt = ut.getBBox(),
        gt = _round(gt + et / 100 * wt.width),
        mt = _round(mt + tt / 100 * wt.height)),
        wt = "matrix(" + vt + "," + bt + "," + Et + "," + xt + "," + gt + "," + mt + ")",
        ut.setAttribute("transform", wt),
        ht && (ut.style[_transformProp] = wt)
    }, _addRotationalPropTween = function(_, k, J, et, tt) {
        var rt = 360, nt = _isString(tt), ot = parseFloat(tt) * (nt && ~tt.indexOf("rad") ? _RAD2DEG : 1), it = ot - et, at = et + it + "deg", lt, st;
        return nt && (lt = tt.split("_")[1],
        lt === "short" && (it %= rt,
        it !== it % (rt / 2) && (it += it < 0 ? rt : -rt)),
        lt === "cw" && it < 0 ? it = (it + rt * _bigNum) % rt - ~~(it / rt) * rt : lt === "ccw" && it > 0 && (it = (it - rt * _bigNum) % rt - ~~(it / rt) * rt)),
        _._pt = st = new PropTween(_._pt,k,J,et,it,_renderPropWithEnd),
        st.e = at,
        st.u = "deg",
        _._props.push(J),
        st
    }, _assign = function(_, k) {
        for (var J in k)
            _[J] = k[J];
        return _
    }, _addRawTransformPTs = function(_, k, J) {
        var et = _assign({}, J._gsap), tt = "perspective,force3D,transformOrigin,svgOrigin", rt = J.style, nt, ot, it, at, lt, st, ut, ct;
        et.svg ? (it = J.getAttribute("transform"),
        J.setAttribute("transform", ""),
        rt[_transformProp] = k,
        nt = _parseTransform(J, 1),
        _removeProperty(J, _transformProp),
        J.setAttribute("transform", it)) : (it = getComputedStyle(J)[_transformProp],
        rt[_transformProp] = k,
        nt = _parseTransform(J, 1),
        rt[_transformProp] = it);
        for (ot in _transformProps)
            it = et[ot],
            at = nt[ot],
            it !== at && tt.indexOf(ot) < 0 && (ut = getUnit(it),
            ct = getUnit(at),
            lt = ut !== ct ? _convertToUnit(J, ot, it, ct) : parseFloat(it),
            st = parseFloat(at),
            _._pt = new PropTween(_._pt,nt,ot,lt,st - lt,_renderCSSProp),
            _._pt.u = ct || 0,
            _._props.push(ot));
        _assign(nt, et)
    };
    _forEachName("padding,margin,Width,Radius", function(_, k) {
        var J = "Top"
          , et = "Right"
          , tt = "Bottom"
          , rt = "Left"
          , nt = (k < 3 ? [J, et, tt, rt] : [J + rt, J + et, tt + et, tt + rt]).map(function(ot) {
            return k < 2 ? _ + ot : "border" + ot + _
        });
        _specialProps[k > 1 ? "border" + _ : _] = function(ot, it, at, lt, st) {
            var ut, ct;
            if (arguments.length < 4)
                return ut = nt.map(function(pt) {
                    return _get(ot, pt, at)
                }),
                ct = ut.join(" "),
                ct.split(ut[0]).length === 5 ? ut[0] : ct;
            ut = (lt + "").split(" "),
            ct = {},
            nt.forEach(function(pt, ft) {
                return ct[pt] = ut[ft] = ut[ft] || ut[(ft - 1) / 2 | 0]
            }),
            ot.init(it, ct, st)
        }
    });
    var CSSPlugin = {
        name: "css",
        register: _initCore,
        targetTest: function(_) {
            return _.style && _.nodeType
        },
        init: function(_, k, J, et, tt) {
            var rt = this._props, nt = _.style, ot = J.vars.startAt, it, at, lt, st, ut, ct, pt, ft, yt, ht, gt, mt, vt, bt, Et, xt;
            _pluginInitted || _initCore(),
            this.styles = this.styles || _getStyleSaver(_),
            xt = this.styles.props,
            this.tween = J;
            for (pt in k)
                if (pt !== "autoRound" && (at = k[pt],
                !(_plugins[pt] && _checkPlugin(pt, k, J, et, _, tt)))) {
                    if (ut = typeof at,
                    ct = _specialProps[pt],
                    ut === "function" && (at = at.call(J, et, _, tt),
                    ut = typeof at),
                    ut === "string" && ~at.indexOf("random(") && (at = _replaceRandom(at)),
                    ct)
                        ct(this, _, pt, at, J) && (Et = 1);
                    else if (pt.substr(0, 2) === "--")
                        it = (getComputedStyle(_).getPropertyValue(pt) + "").trim(),
                        at += "",
                        _colorExp.lastIndex = 0,
                        _colorExp.test(it) || (ft = getUnit(it),
                        yt = getUnit(at)),
                        yt ? ft !== yt && (it = _convertToUnit(_, pt, it, yt) + yt) : ft && (at += ft),
                        this.add(nt, "setProperty", it, at, et, tt, 0, 0, pt),
                        rt.push(pt),
                        xt.push(pt, 0, nt[pt]);
                    else if (ut !== "undefined") {
                        if (ot && pt in ot ? (it = typeof ot[pt] == "function" ? ot[pt].call(J, et, _, tt) : ot[pt],
                        _isString(it) && ~it.indexOf("random(") && (it = _replaceRandom(it)),
                        getUnit(it + "") || it === "auto" || (it += _config.units[pt] || getUnit(_get(_, pt)) || ""),
                        (it + "").charAt(1) === "=" && (it = _get(_, pt))) : it = _get(_, pt),
                        st = parseFloat(it),
                        ht = ut === "string" && at.charAt(1) === "=" && at.substr(0, 2),
                        ht && (at = at.substr(2)),
                        lt = parseFloat(at),
                        pt in _propertyAliases && (pt === "autoAlpha" && (st === 1 && _get(_, "visibility") === "hidden" && lt && (st = 0),
                        xt.push("visibility", 0, nt.visibility),
                        _addNonTweeningPT(this, nt, "visibility", st ? "inherit" : "hidden", lt ? "inherit" : "hidden", !lt)),
                        pt !== "scale" && pt !== "transform" && (pt = _propertyAliases[pt],
                        ~pt.indexOf(",") && (pt = pt.split(",")[0]))),
                        gt = pt in _transformProps,
                        gt) {
                            if (this.styles.save(pt),
                            mt || (vt = _._gsap,
                            vt.renderTransform && !k.parseTransform || _parseTransform(_, k.parseTransform),
                            bt = k.smoothOrigin !== !1 && vt.smooth,
                            mt = this._pt = new PropTween(this._pt,nt,_transformProp,0,1,vt.renderTransform,vt,0,-1),
                            mt.dep = 1),
                            pt === "scale")
                                this._pt = new PropTween(this._pt,vt,"scaleY",vt.scaleY,(ht ? _parseRelative(vt.scaleY, ht + lt) : lt) - vt.scaleY || 0,_renderCSSProp),
                                this._pt.u = 0,
                                rt.push("scaleY", pt),
                                pt += "X";
                            else if (pt === "transformOrigin") {
                                xt.push(_transformOriginProp, 0, nt[_transformOriginProp]),
                                at = _convertKeywordsToPercentages(at),
                                vt.svg ? _applySVGOrigin(_, at, 0, bt, 0, this) : (yt = parseFloat(at.split(" ")[2]) || 0,
                                yt !== vt.zOrigin && _addNonTweeningPT(this, vt, "zOrigin", vt.zOrigin, yt),
                                _addNonTweeningPT(this, nt, pt, _firstTwoOnly(it), _firstTwoOnly(at)));
                                continue
                            } else if (pt === "svgOrigin") {
                                _applySVGOrigin(_, at, 1, bt, 0, this);
                                continue
                            } else if (pt in _rotationalProperties) {
                                _addRotationalPropTween(this, vt, pt, st, ht ? _parseRelative(st, ht + at) : at);
                                continue
                            } else if (pt === "smoothOrigin") {
                                _addNonTweeningPT(this, vt, "smooth", vt.smooth, at);
                                continue
                            } else if (pt === "force3D") {
                                vt[pt] = at;
                                continue
                            } else if (pt === "transform") {
                                _addRawTransformPTs(this, at, _);
                                continue
                            }
                        } else
                            pt in nt || (pt = _checkPropPrefix(pt) || pt);
                        if (gt || (lt || lt === 0) && (st || st === 0) && !_complexExp.test(at) && pt in nt)
                            ft = (it + "").substr((st + "").length),
                            lt || (lt = 0),
                            yt = getUnit(at) || (pt in _config.units ? _config.units[pt] : ft),
                            ft !== yt && (st = _convertToUnit(_, pt, it, yt)),
                            this._pt = new PropTween(this._pt,gt ? vt : nt,pt,st,(ht ? _parseRelative(st, ht + lt) : lt) - st,!gt && (yt === "px" || pt === "zIndex") && k.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp),
                            this._pt.u = yt || 0,
                            ft !== yt && yt !== "%" && (this._pt.b = it,
                            this._pt.r = _renderCSSPropWithBeginning);
                        else if (pt in nt)
                            _tweenComplexCSSString.call(this, _, pt, it, ht ? ht + at : at);
                        else if (pt in _)
                            this.add(_, pt, it || _[pt], ht ? ht + at : at, et, tt);
                        else if (pt !== "parseTransform") {
                            _missingPlugin(pt, at);
                            continue
                        }
                        gt || (pt in nt ? xt.push(pt, 0, nt[pt]) : xt.push(pt, 1, it || _[pt])),
                        rt.push(pt)
                    }
                }
            Et && _sortPropTweensByPriority(this)
        },
        render: function(_, k) {
            if (k.tween._time || !_reverting())
                for (var J = k._pt; J; )
                    J.r(_, J.d),
                    J = J._next;
            else
                k.styles.revert()
        },
        get: _get,
        aliases: _propertyAliases,
        getSetter: function(_, k, J) {
            var et = _propertyAliases[k];
            return et && et.indexOf(",") < 0 && (k = et),
            k in _transformProps && k !== _transformOriginProp && (_._gsap.x || _get(_, "x")) ? J && _recentSetterPlugin === J ? k === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = J || {}) && (k === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : _.style && !_isUndefined(_.style[k]) ? _setterCSSStyle : ~k.indexOf("-") ? _setterCSSProp : _getSetter(_, k)
        },
        core: {
            _removeProperty,
            _getMatrix
        }
    };
    gsap$1.utils.checkPrefix = _checkPropPrefix,
    gsap$1.core.getStyleSaver = _getStyleSaver,
    function(_, k, J, et) {
        var tt = _forEachName(_ + "," + k + "," + J, function(rt) {
            _transformProps[rt] = 1
        });
        _forEachName(k, function(rt) {
            _config.units[rt] = "deg",
            _rotationalProperties[rt] = 1
        }),
        _propertyAliases[tt[13]] = _ + "," + k,
        _forEachName(et, function(rt) {
            var nt = rt.split(":");
            _propertyAliases[nt[1]] = tt[nt[0]]
        })
    }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"),
    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(_) {
        _config.units[_] = "px"
    }),
    gsap$1.registerPlugin(CSSPlugin);
    let TweenMaxWithCSS;
    gsapWithCSS = gsap$1.registerPlugin(CSSPlugin) || gsap$1,
    TweenMaxWithCSS = gsapWithCSS.core.Tween,
    gsap = Object.assign(Object.defineProperty({
        
        Back,
        Bounce,
        CSSPlugin,
        Circ,
        Cubic,
        Elastic,
        Expo,
        Linear,
        Power0,
        Power1,
        Power2,
        Power3,
        Power4,
        Quad,
        Quart,
        Quint,
        Sine,
        SteppedEase,
        Strong,
        TimelineLite: Timeline,
        TimelineMax: Timeline,
        TweenLite: Tween,
        TweenMax: TweenMaxWithCSS,
        default: gsapWithCSS,
        gsap: gsapWithCSS
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self
      , root = freeGlobal$1 || freeSelf || Function("return this")();
    root$1 = root;
    var Symbol$1 = root$1.Symbol;
    Symbol$2 = Symbol$1;
    var objectProto$b = Object.prototype
      , hasOwnProperty$9 = objectProto$b.hasOwnProperty
      , nativeObjectToString$1 = objectProto$b.toString
      , symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(_) {
        var k = hasOwnProperty$9.call(_, symToStringTag$1)
          , J = _[symToStringTag$1];
        try {
            _[symToStringTag$1] = void 0;
            var et = !0
        } catch (rt) {}
        var tt = nativeObjectToString$1.call(_);
        return et && (k ? _[symToStringTag$1] = J : delete _[symToStringTag$1]),
        tt
    }
    var objectProto$a = Object.prototype
      , nativeObjectToString = objectProto$a.toString;
    function objectToString(_) {
        return nativeObjectToString.call(_)
    }
    var nullTag = "[object Null]"
      , undefinedTag = "[object Undefined]"
      , symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    baseGetTag = function(_) {
        return _ == null ? _ === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(_) ? getRawTag(_) : objectToString(_)
    }
    ,
    isObjectLike = function(_) {
        return _ != null && typeof _ == "object"
    }
    ;
    var symbolTag$1 = "[object Symbol]";
    isSymbol = function(_) {
        return typeof _ == "symbol" || isObjectLike(_) && baseGetTag(_) == symbolTag$1
    }
    ,
    arrayMap = function(_, k) {
        for (var J = -1, et = _ == null ? 0 : _.length, tt = Array(et); ++J < et; )
            tt[J] = k(_[J], J, _);
        return tt
    }
    ;
    var isArray$3 = Array.isArray;
    n0 = isArray$3;
    var INFINITY$2 = 1 / 0
      , symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0
      , symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    baseToString = function(_) {
        if (typeof _ == "string")
            return _;
        if (n0(_))
            return arrayMap(_, baseToString) + "";
        if (isSymbol(_))
            return symbolToString ? symbolToString.call(_) : "";
        var k = _ + "";
        return k == "0" && 1 / _ == -INFINITY$2 ? "-0" : k
    }
    ;
    var reWhitespace = /\s/;
    trimmedEndIndex = function(_) {
        for (var k = _.length; k-- && reWhitespace.test(_.charAt(k)); )
            ;
        return k
    }
    ;
    var reTrimStart = /^\s+/;
    baseTrim = function(_) {
        return _ && _.slice(0, trimmedEndIndex(_) + 1).replace(reTrimStart, "")
    }
    ,
    isObject$2 = function(_) {
        var k = typeof _;
        return _ != null && (k == "object" || k == "function")
    }
    ;
    var NAN = 0 / 0
      , reIsBadHex = /^[-+]0x[0-9a-f]+$/i
      , reIsBinary = /^0b[01]+$/i
      , reIsOctal = /^0o[0-7]+$/i
      , freeParseInt = parseInt;
    toNumber = function(_) {
        if (typeof _ == "number")
            return _;
        if (isSymbol(_))
            return NAN;
        if (isObject$2(_)) {
            var k = typeof _.valueOf == "function" ? _.valueOf() : _;
            _ = isObject$2(k) ? k + "" : k
        }
        if (typeof _ != "string")
            return _ === 0 ? _ : +_;
        _ = baseTrim(_);
        var J = reIsBinary.test(_);
        return J || reIsOctal.test(_) ? freeParseInt(_.slice(2), J ? 2 : 8) : reIsBadHex.test(_) ? NAN : +_
    }
    ;
    var INFINITY$1 = 1 / 0
      , MAX_INTEGER = 17976931348623157e292;
    toFinite = function(_) {
        if (!_)
            return _ === 0 ? _ : 0;
        if (_ = toNumber(_),
        _ === INFINITY$1 || _ === -INFINITY$1) {
            var k = _ < 0 ? -1 : 1;
            return k * MAX_INTEGER
        }
        return _ === _ ? _ : 0
    }
    ,
    toInteger = function(_) {
        var k = toFinite(_)
          , J = k % 1;
        return k === k ? J ? k - J : k : 0
    }
    ,
    identity = function(_) {
        return _
    }
    ;
    var asyncTag = "[object AsyncFunction]"
      , funcTag$1 = "[object Function]"
      , genTag = "[object GeneratorFunction]"
      , proxyTag = "[object Proxy]";
    isFunction$1 = function(_) {
        if (!isObject$2(_))
            return !1;
        var k = baseGetTag(_);
        return k == funcTag$1 || k == genTag || k == asyncTag || k == proxyTag
    }
    ;
    var coreJsData = root$1["__core-js_shared__"];
    coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
        var _ = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return _ ? "Symbol(src)_1." + _ : ""
    }();
    function isMasked(_) {
        return !!maskSrcKey && maskSrcKey in _
    }
    var funcProto$1 = Function.prototype
      , funcToString$1 = funcProto$1.toString;
    function toSource(_) {
        if (_ != null) {
            try {
                return funcToString$1.call(_)
            } catch (k) {}
            try {
                return _ + ""
            } catch (k) {}
        }
        return ""
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g
      , reIsHostCtor = /^\[object .+?Constructor\]$/
      , funcProto = Function.prototype
      , objectProto$9 = Object.prototype
      , funcToString = funcProto.toString
      , hasOwnProperty$8 = objectProto$9.hasOwnProperty
      , reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    baseIsNative = function(_) {
        if (!isObject$2(_) || isMasked(_))
            return !1;
        var k = isFunction$1(_) ? reIsNative : reIsHostCtor;
        return k.test(toSource(_))
    }
    ;
    function getValue(_, k) {
        return _ == null ? void 0 : _[k]
    }
    getNative = function(_, k) {
        var J = getValue(_, k);
        return baseIsNative(J) ? J : void 0
    }
    ;
    var WeakMap$1 = getNative(root$1, "WeakMap");
    WeakMap$2 = WeakMap$1;
    var MAX_SAFE_INTEGER$2 = 9007199254740991
      , reIsUint = /^(?:0|[1-9]\d*)$/;
    isIndex = function(_, k) {
        var J = typeof _;
        return k = k != null ? k : MAX_SAFE_INTEGER$2,
        !!k && (J == "number" || J != "symbol" && reIsUint.test(_)) && _ > -1 && _ % 1 == 0 && _ < k
    }
    ,
    eq = function(_, k) {
        return _ === k || _ !== _ && k !== k
    }
    ;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    isLength = function(_) {
        return typeof _ == "number" && _ > -1 && _ % 1 == 0 && _ <= MAX_SAFE_INTEGER$1
    }
    ,
    isArrayLike = function(_) {
        return _ != null && isLength(_.length) && !isFunction$1(_)
    }
    ,
    isIterateeCall = function(_, k, J) {
        if (!isObject$2(J))
            return !1;
        var et = typeof k;
        return (et == "number" ? isArrayLike(J) && isIndex(k, J.length) : et == "string" && k in J) ? eq(J[k], _) : !1
    }
    ;
    var objectProto$8 = Object.prototype;
    isPrototype = function(_) {
        var k = _ && _.constructor
          , J = typeof k == "function" && k.prototype || objectProto$8;
        return _ === J
    }
    ,
    baseTimes = function(_, k) {
        for (var J = -1, et = Array(_); ++J < _; )
            et[J] = k(J);
        return et
    }
    ;
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(_) {
        return isObjectLike(_) && baseGetTag(_) == argsTag$2
    }
    var objectProto$7 = Object.prototype
      , hasOwnProperty$7 = objectProto$7.hasOwnProperty
      , propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable
      , isArguments = baseIsArguments(function() {
        return arguments
    }()) ? baseIsArguments : function(_) {
        return isObjectLike(_) && hasOwnProperty$7.call(_, "callee") && !propertyIsEnumerable$1.call(_, "callee")
    }
    ;
    isArguments$1 = isArguments,
    stubFalse = function() {
        return !1
    }
    ;
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports
      , freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module
      , moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1
      , Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0
      , nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0
      , isBuffer$2 = nativeIsBuffer || stubFalse;
    isBuffer$3 = isBuffer$2;
    var argsTag$1 = "[object Arguments]"
      , arrayTag$1 = "[object Array]"
      , boolTag$1 = "[object Boolean]"
      , dateTag$1 = "[object Date]"
      , errorTag$1 = "[object Error]"
      , funcTag = "[object Function]"
      , mapTag$2 = "[object Map]"
      , numberTag$1 = "[object Number]"
      , objectTag$2 = "[object Object]"
      , regexpTag$1 = "[object RegExp]"
      , setTag$2 = "[object Set]"
      , stringTag$1 = "[object String]"
      , weakMapTag$1 = "[object WeakMap]"
      , arrayBufferTag$1 = "[object ArrayBuffer]"
      , dataViewTag$2 = "[object DataView]"
      , float32Tag = "[object Float32Array]"
      , float64Tag = "[object Float64Array]"
      , int8Tag = "[object Int8Array]"
      , int16Tag = "[object Int16Array]"
      , int32Tag = "[object Int32Array]"
      , uint8Tag = "[object Uint8Array]"
      , uint8ClampedTag = "[object Uint8ClampedArray]"
      , uint16Tag = "[object Uint16Array]"
      , uint32Tag = "[object Uint32Array]"
      , typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0,
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = !1;
    function baseIsTypedArray(_) {
        return isObjectLike(_) && isLength(_.length) && !!typedArrayTags[baseGetTag(_)]
    }
    baseUnary = function(_) {
        return function(k) {
            return _(k)
        }
    }
    ;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports
      , freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module
      , moduleExports = freeModule && freeModule.exports === freeExports
      , freeProcess = moduleExports && freeGlobal$1.process
      , nodeUtil = function() {
        try {
            var _ = freeModule && freeModule.require && freeModule.require("util").types;
            return _ || freeProcess && freeProcess.binding && freeProcess.binding("util")
        } catch (k) {}
    }();
    nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray
      , isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    isTypedArray$2 = isTypedArray$1;
    var objectProto$6 = Object.prototype
      , hasOwnProperty$6 = objectProto$6.hasOwnProperty;
    arrayLikeKeys = function(_, k) {
        var J = n0(_)
          , et = !J && isArguments$1(_)
          , tt = !J && !et && isBuffer$3(_)
          , rt = !J && !et && !tt && isTypedArray$2(_)
          , nt = J || et || tt || rt
          , ot = nt ? baseTimes(_.length, String) : []
          , it = ot.length;
        for (var at in _)
            (k || hasOwnProperty$6.call(_, at)) && !(nt && (at == "length" || tt && (at == "offset" || at == "parent") || rt && (at == "buffer" || at == "byteLength" || at == "byteOffset") || isIndex(at, it))) && ot.push(at);
        return ot
    }
    ,
    overArg = function(_, k) {
        return function(J) {
            return _(k(J))
        }
    }
    ;
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$5 = Object.prototype
      , hasOwnProperty$5 = objectProto$5.hasOwnProperty;
    baseKeys = function(_) {
        if (!isPrototype(_))
            return nativeKeys$1(_);
        var k = [];
        for (var J in Object(_))
            hasOwnProperty$5.call(_, J) && J != "constructor" && k.push(J);
        return k
    }
    ,
    keys$1 = function(_) {
        return isArrayLike(_) ? arrayLikeKeys(_) : baseKeys(_)
    }
    ;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
      , reIsPlainProp = /^\w*$/;
    function isKey(_, k) {
        if (n0(_))
            return !1;
        var J = typeof _;
        return J == "number" || J == "symbol" || J == "boolean" || _ == null || isSymbol(_) ? !0 : reIsPlainProp.test(_) || !reIsDeepProp.test(_) || k != null && _ in Object(k)
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {},
        this.size = 0
    }
    function hashDelete(_) {
        var k = this.has(_) && delete this.__data__[_];
        return this.size -= k ? 1 : 0,
        k
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__"
      , objectProto$4 = Object.prototype
      , hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    function hashGet(_) {
        var k = this.__data__;
        if (nativeCreate$1) {
            var J = k[_];
            return J === HASH_UNDEFINED$2 ? void 0 : J
        }
        return hasOwnProperty$4.call(k, _) ? k[_] : void 0
    }
    var objectProto$3 = Object.prototype
      , hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function hashHas(_) {
        var k = this.__data__;
        return nativeCreate$1 ? k[_] !== void 0 : hasOwnProperty$3.call(k, _)
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(_, k) {
        var J = this.__data__;
        return this.size += this.has(_) ? 0 : 1,
        J[_] = nativeCreate$1 && k === void 0 ? HASH_UNDEFINED$1 : k,
        this
    }
    function Hash(_) {
        var k = -1
          , J = _ == null ? 0 : _.length;
        for (this.clear(); ++k < J; ) {
            var et = _[k];
            this.set(et[0], et[1])
        }
    }
    Hash.prototype.clear = hashClear,
    Hash.prototype.delete = hashDelete,
    Hash.prototype.get = hashGet,
    Hash.prototype.has = hashHas,
    Hash.prototype.set = hashSet;
    function listCacheClear() {
        this.__data__ = [],
        this.size = 0
    }
    function assocIndexOf(_, k) {
        for (var J = _.length; J--; )
            if (eq(_[J][0], k))
                return J;
        return -1
    }
    var arrayProto = Array.prototype
      , splice = arrayProto.splice;
    function listCacheDelete(_) {
        var k = this.__data__
          , J = assocIndexOf(k, _);
        if (J < 0)
            return !1;
        var et = k.length - 1;
        return J == et ? k.pop() : splice.call(k, J, 1),
        --this.size,
        !0
    }
    function listCacheGet(_) {
        var k = this.__data__
          , J = assocIndexOf(k, _);
        return J < 0 ? void 0 : k[J][1]
    }
    function listCacheHas(_) {
        return assocIndexOf(this.__data__, _) > -1
    }
    function listCacheSet(_, k) {
        var J = this.__data__
          , et = assocIndexOf(J, _);
        return et < 0 ? (++this.size,
        J.push([_, k])) : J[et][1] = k,
        this
    }
    function ListCache(_) {
        var k = -1
          , J = _ == null ? 0 : _.length;
        for (this.clear(); ++k < J; ) {
            var et = _[k];
            this.set(et[0], et[1])
        }
    }
    ListCache.prototype.clear = listCacheClear,
    ListCache.prototype.delete = listCacheDelete,
    ListCache.prototype.get = listCacheGet,
    ListCache.prototype.has = listCacheHas,
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    const Map$2 = Map$1;
    function mapCacheClear() {
        this.size = 0,
        this.__data__ = {
            hash: new Hash,
            map: new (Map$2 || ListCache),
            string: new Hash
        }
    }
    function isKeyable(_) {
        var k = typeof _;
        return k == "string" || k == "number" || k == "symbol" || k == "boolean" ? _ !== "__proto__" : _ === null
    }
    function getMapData(_, k) {
        var J = _.__data__;
        return isKeyable(k) ? J[typeof k == "string" ? "string" : "hash"] : J.map
    }
    function mapCacheDelete(_) {
        var k = getMapData(this, _).delete(_);
        return this.size -= k ? 1 : 0,
        k
    }
    function mapCacheGet(_) {
        return getMapData(this, _).get(_)
    }
    function mapCacheHas(_) {
        return getMapData(this, _).has(_)
    }
    function mapCacheSet(_, k) {
        var J = getMapData(this, _)
          , et = J.size;
        return J.set(_, k),
        this.size += J.size == et ? 0 : 1,
        this
    }
    function MapCache(_) {
        var k = -1
          , J = _ == null ? 0 : _.length;
        for (this.clear(); ++k < J; ) {
            var et = _[k];
            this.set(et[0], et[1])
        }
    }
    MapCache.prototype.clear = mapCacheClear,
    MapCache.prototype.delete = mapCacheDelete,
    MapCache.prototype.get = mapCacheGet,
    MapCache.prototype.has = mapCacheHas,
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$4 = "Expected a function";
    memoize$1 = function(_, k) {
        if (typeof _ != "function" || k != null && typeof k != "function")
            throw new TypeError(FUNC_ERROR_TEXT$4);
        var J = function() {
            var et = arguments
              , tt = k ? k.apply(this, et) : et[0]
              , rt = J.cache;
            if (rt.has(tt))
                return rt.get(tt);
            var nt = _.apply(this, et);
            return J.cache = rt.set(tt, nt) || rt,
            nt
        };
        return J.cache = new (memoize$1.Cache || MapCache),
        J
    }
    ,
    memoize$1.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(_) {
        var k = memoize$1(_, function(et) {
            return J.size === MAX_MEMOIZE_SIZE && J.clear(),
            et
        })
          , J = k.cache;
        return k
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
      , reEscapeChar = /\\(\\)?/g
      , stringToPath = memoizeCapped(function(_) {
        var k = [];
        return _.charCodeAt(0) === 46 && k.push(""),
        _.replace(rePropName, function(J, et, tt, rt) {
            k.push(tt ? rt.replace(reEscapeChar, "$1") : et || J)
        }),
        k
    });
    stringToPath$1 = stringToPath,
    toString$5 = function(_) {
        return _ == null ? "" : baseToString(_)
    }
    ,
    castPath = function(_, k) {
        return n0(_) ? _ : isKey(_, k) ? [_] : stringToPath$1(toString$5(_))
    }
    ;
    var INFINITY = 1 / 0;
    toKey = function(_) {
        if (typeof _ == "string" || isSymbol(_))
            return _;
        var k = _ + "";
        return k == "0" && 1 / _ == -INFINITY ? "-0" : k
    }
    ,
    baseGet = function(_, k) {
        k = castPath(k, _);
        for (var J = 0, et = k.length; _ != null && J < et; )
            _ = _[toKey(k[J++])];
        return J && J == et ? _ : void 0
    }
    ,
    get$1 = function(_, k, J) {
        var et = _ == null ? void 0 : baseGet(_, k);
        return et === void 0 ? J : et
    }
    ,
    arrayPush = function(_, k) {
        for (var J = -1, et = k.length, tt = _.length; ++J < et; )
            _[tt + J] = k[J];
        return _
    }
    ;
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    before = function(_, k) {
        var J;
        if (typeof k != "function")
            throw new TypeError(FUNC_ERROR_TEXT$3);
        return _ = toInteger(_),
        function() {
            return --_ > 0 && (J = k.apply(this, arguments)),
            _ <= 1 && (k = void 0),
            J
        }
    }
    ,
    baseSlice = function(_, k, J) {
        var et = -1
          , tt = _.length;
        k < 0 && (k = -k > tt ? 0 : tt + k),
        J = J > tt ? tt : J,
        J < 0 && (J += tt),
        tt = k > J ? 0 : J - k >>> 0,
        k >>>= 0;
        for (var rt = Array(tt); ++et < tt; )
            rt[et] = _[et + k];
        return rt
    }
    ,
    basePropertyOf = function(_) {
        return function(k) {
            return _ == null ? void 0 : _[k]
        }
    }
    ;
    var nativeCeil = Math.ceil
      , nativeMax$1 = Math.max;
    chunk = function(_, k, J) {
        (J ? isIterateeCall(_, k, J) : k === void 0) ? k = 1 : k = nativeMax$1(toInteger(k), 0);
        var et = _ == null ? 0 : _.length;
        if (!et || k < 1)
            return [];
        for (var tt = 0, rt = 0, nt = Array(nativeCeil(et / k)); tt < et; )
            nt[rt++] = baseSlice(_, tt, tt += k);
        return nt
    }
    ;
    function stackClear() {
        this.__data__ = new ListCache,
        this.size = 0
    }
    function stackDelete(_) {
        var k = this.__data__
          , J = k.delete(_);
        return this.size = k.size,
        J
    }
    function stackGet(_) {
        return this.__data__.get(_)
    }
    function stackHas(_) {
        return this.__data__.has(_)
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(_, k) {
        var J = this.__data__;
        if (J instanceof ListCache) {
            var et = J.__data__;
            if (!Map$2 || et.length < LARGE_ARRAY_SIZE - 1)
                return et.push([_, k]),
                this.size = ++J.size,
                this;
            J = this.__data__ = new MapCache(et)
        }
        return J.set(_, k),
        this.size = J.size,
        this
    }
    Stack = function(_) {
        var k = this.__data__ = new ListCache(_);
        this.size = k.size
    }
    ,
    Stack.prototype.clear = stackClear,
    Stack.prototype.delete = stackDelete,
    Stack.prototype.get = stackGet,
    Stack.prototype.has = stackHas,
    Stack.prototype.set = stackSet,
    arrayFilter = function(_, k) {
        for (var J = -1, et = _ == null ? 0 : _.length, tt = 0, rt = []; ++J < et; ) {
            var nt = _[J];
            k(nt, J, _) && (rt[tt++] = nt)
        }
        return rt
    }
    ,
    stubArray = function() {
        return []
    }
    ;
    var objectProto$2 = Object.prototype
      , propertyIsEnumerable = objectProto$2.propertyIsEnumerable
      , nativeGetSymbols = Object.getOwnPropertySymbols
      , getSymbols = nativeGetSymbols ? function(_) {
        return _ == null ? [] : (_ = Object(_),
        arrayFilter(nativeGetSymbols(_), function(k) {
            return propertyIsEnumerable.call(_, k)
        }))
    }
    : stubArray;
    getSymbols$1 = getSymbols,
    baseGetAllKeys = function(_, k, J) {
        var et = k(_);
        return n0(_) ? et : arrayPush(et, J(_))
    }
    ,
    getAllKeys = function(_) {
        return baseGetAllKeys(_, keys$1, getSymbols$1)
    }
    ;
    var DataView$1 = getNative(root$1, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$1, "Promise");
    const Promise$2 = Promise$1;
    var Set$1 = getNative(root$1, "Set");
    Set$2 = Set$1;
    var mapTag$1 = "[object Map]"
      , objectTag$1 = "[object Object]"
      , promiseTag = "[object Promise]"
      , setTag$1 = "[object Set]"
      , weakMapTag = "[object WeakMap]"
      , dataViewTag$1 = "[object DataView]"
      , dataViewCtorString = toSource(DataView$2)
      , mapCtorString = toSource(Map$2)
      , promiseCtorString = toSource(Promise$2)
      , setCtorString = toSource(Set$2)
      , weakMapCtorString = toSource(WeakMap$2)
      , getTag = baseGetTag;
    (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2) != weakMapTag) && (getTag = function(_) {
        var k = baseGetTag(_)
          , J = k == objectTag$1 ? _.constructor : void 0
          , et = J ? toSource(J) : "";
        if (et)
            switch (et) {
            case dataViewCtorString:
                return dataViewTag$1;
            case mapCtorString:
                return mapTag$1;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag$1;
            case weakMapCtorString:
                return weakMapTag
            }
        return k
    }
    ),
    getTag$1 = getTag;
    var Uint8Array$1 = root$1.Uint8Array;
    Uint8Array$2 = Uint8Array$1;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(_) {
        return this.__data__.set(_, HASH_UNDEFINED),
        this
    }
    function setCacheHas(_) {
        return this.__data__.has(_)
    }
    SetCache = function(_) {
        var k = -1
          , J = _ == null ? 0 : _.length;
        for (this.__data__ = new MapCache; ++k < J; )
            this.add(_[k])
    }
    ,
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd,
    SetCache.prototype.has = setCacheHas,
    arraySome = function(_, k) {
        for (var J = -1, et = _ == null ? 0 : _.length; ++J < et; )
            if (k(_[J], J, _))
                return !0;
        return !1
    }
    ,
    cacheHas = function(_, k) {
        return _.has(k)
    }
    ;
    var COMPARE_PARTIAL_FLAG$5 = 1
      , COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(_, k, J, et, tt, rt) {
        var nt = J & COMPARE_PARTIAL_FLAG$5
          , ot = _.length
          , it = k.length;
        if (ot != it && !(nt && it > ot))
            return !1;
        var at = rt.get(_)
          , lt = rt.get(k);
        if (at && lt)
            return at == k && lt == _;
        var st = -1
          , ut = !0
          , ct = J & COMPARE_UNORDERED_FLAG$3 ? new SetCache : void 0;
        for (rt.set(_, k),
        rt.set(k, _); ++st < ot; ) {
            var pt = _[st]
              , ft = k[st];
            if (et)
                var yt = nt ? et(ft, pt, st, k, _, rt) : et(pt, ft, st, _, k, rt);
            if (yt !== void 0) {
                if (yt)
                    continue;
                ut = !1;
                break
            }
            if (ct) {
                if (!arraySome(k, function(ht, gt) {
                    if (!cacheHas(ct, gt) && (pt === ht || tt(pt, ht, J, et, rt)))
                        return ct.push(gt)
                })) {
                    ut = !1;
                    break
                }
            } else if (!(pt === ft || tt(pt, ft, J, et, rt))) {
                ut = !1;
                break
            }
        }
        return rt.delete(_),
        rt.delete(k),
        ut
    }
    mapToArray = function(_) {
        var k = -1
          , J = Array(_.size);
        return _.forEach(function(et, tt) {
            J[++k] = [tt, et]
        }),
        J
    }
    ,
    setToArray = function(_) {
        var k = -1
          , J = Array(_.size);
        return _.forEach(function(et) {
            J[++k] = et
        }),
        J
    }
    ;
    var COMPARE_PARTIAL_FLAG$4 = 1
      , COMPARE_UNORDERED_FLAG$2 = 2
      , boolTag = "[object Boolean]"
      , dateTag = "[object Date]"
      , errorTag = "[object Error]"
      , mapTag = "[object Map]"
      , numberTag = "[object Number]"
      , regexpTag = "[object RegExp]"
      , setTag = "[object Set]"
      , stringTag = "[object String]"
      , symbolTag = "[object Symbol]"
      , arrayBufferTag = "[object ArrayBuffer]"
      , dataViewTag = "[object DataView]"
      , symbolProto = Symbol$2 ? Symbol$2.prototype : void 0
      , symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(_, k, J, et, tt, rt, nt) {
        switch (J) {
        case dataViewTag:
            if (_.byteLength != k.byteLength || _.byteOffset != k.byteOffset)
                return !1;
            _ = _.buffer,
            k = k.buffer;
        case arrayBufferTag:
            return !(_.byteLength != k.byteLength || !rt(new Uint8Array$2(_), new Uint8Array$2(k)));
        case boolTag:
        case dateTag:
        case numberTag:
            return eq(+_, +k);
        case errorTag:
            return _.name == k.name && _.message == k.message;
        case regexpTag:
        case stringTag:
            return _ == k + "";
        case mapTag:
            var ot = mapToArray;
        case setTag:
            var it = et & COMPARE_PARTIAL_FLAG$4;
            if (ot || (ot = setToArray),
            _.size != k.size && !it)
                return !1;
            var at = nt.get(_);
            if (at)
                return at == k;
            et |= COMPARE_UNORDERED_FLAG$2,
            nt.set(_, k);
            var lt = equalArrays(ot(_), ot(k), et, tt, rt, nt);
            return nt.delete(_),
            lt;
        case symbolTag:
            if (symbolValueOf)
                return symbolValueOf.call(_) == symbolValueOf.call(k)
        }
        return !1
    }
    var COMPARE_PARTIAL_FLAG$3 = 1
      , objectProto$1 = Object.prototype
      , hasOwnProperty$2 = objectProto$1.hasOwnProperty;
    function equalObjects(_, k, J, et, tt, rt) {
        var nt = J & COMPARE_PARTIAL_FLAG$3
          , ot = getAllKeys(_)
          , it = ot.length
          , at = getAllKeys(k)
          , lt = at.length;
        if (it != lt && !nt)
            return !1;
        for (var st = it; st--; ) {
            var ut = ot[st];
            if (!(nt ? ut in k : hasOwnProperty$2.call(k, ut)))
                return !1
        }
        var ct = rt.get(_)
          , pt = rt.get(k);
        if (ct && pt)
            return ct == k && pt == _;
        var ft = !0;
        rt.set(_, k),
        rt.set(k, _);
        for (var yt = nt; ++st < it; ) {
            ut = ot[st];
            var ht = _[ut]
              , gt = k[ut];
            if (et)
                var mt = nt ? et(gt, ht, ut, k, _, rt) : et(ht, gt, ut, _, k, rt);
            if (!(mt === void 0 ? ht === gt || tt(ht, gt, J, et, rt) : mt)) {
                ft = !1;
                break
            }
            yt || (yt = ut == "constructor")
        }
        if (ft && !yt) {
            var vt = _.constructor
              , bt = k.constructor;
            vt != bt && "constructor"in _ && "constructor"in k && !(typeof vt == "function" && vt instanceof vt && typeof bt == "function" && bt instanceof bt) && (ft = !1)
        }
        return rt.delete(_),
        rt.delete(k),
        ft
    }
    var COMPARE_PARTIAL_FLAG$2 = 1
      , argsTag = "[object Arguments]"
      , arrayTag = "[object Array]"
      , objectTag = "[object Object]"
      , objectProto = Object.prototype
      , hasOwnProperty$1 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(_, k, J, et, tt, rt) {
        var nt = n0(_)
          , ot = n0(k)
          , it = nt ? arrayTag : getTag$1(_)
          , at = ot ? arrayTag : getTag$1(k);
        it = it == argsTag ? objectTag : it,
        at = at == argsTag ? objectTag : at;
        var lt = it == objectTag
          , st = at == objectTag
          , ut = it == at;
        if (ut && isBuffer$3(_)) {
            if (!isBuffer$3(k))
                return !1;
            nt = !0,
            lt = !1
        }
        if (ut && !lt)
            return rt || (rt = new Stack),
            nt || isTypedArray$2(_) ? equalArrays(_, k, J, et, tt, rt) : equalByTag(_, k, it, J, et, tt, rt);
        if (!(J & COMPARE_PARTIAL_FLAG$2)) {
            var ct = lt && hasOwnProperty$1.call(_, "__wrapped__")
              , pt = st && hasOwnProperty$1.call(k, "__wrapped__");
            if (ct || pt) {
                var ft = ct ? _.value() : _
                  , yt = pt ? k.value() : k;
                return rt || (rt = new Stack),
                tt(ft, yt, J, et, rt)
            }
        }
        return ut ? (rt || (rt = new Stack),
        equalObjects(_, k, J, et, tt, rt)) : !1
    }
    baseIsEqual = function(_, k, J, et, tt) {
        return _ === k ? !0 : _ == null || k == null || !isObjectLike(_) && !isObjectLike(k) ? _ !== _ && k !== k : baseIsEqualDeep(_, k, J, et, baseIsEqual, tt)
    }
    ;
    var COMPARE_PARTIAL_FLAG$1 = 1
      , COMPARE_UNORDERED_FLAG$1 = 2;
    baseIsMatch = function(_, k, J, et) {
        var tt = J.length
          , rt = tt
          , nt = !et;
        if (_ == null)
            return !rt;
        for (_ = Object(_); tt--; ) {
            var ot = J[tt];
            if (nt && ot[2] ? ot[1] !== _[ot[0]] : !(ot[0]in _))
                return !1
        }
        for (; ++tt < rt; ) {
            ot = J[tt];
            var it = ot[0]
              , at = _[it]
              , lt = ot[1];
            if (nt && ot[2]) {
                if (at === void 0 && !(it in _))
                    return !1
            } else {
                var st = new Stack;
                if (et)
                    var ut = et(at, lt, it, _, k, st);
                if (!(ut === void 0 ? baseIsEqual(lt, at, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, et, st) : ut))
                    return !1
            }
        }
        return !0
    }
    ;
    function isStrictComparable(_) {
        return _ === _ && !isObject$2(_)
    }
    getMatchData = function(_) {
        for (var k = keys$1(_), J = k.length; J--; ) {
            var et = k[J]
              , tt = _[et];
            k[J] = [et, tt, isStrictComparable(tt)]
        }
        return k
    }
    ;
    function matchesStrictComparable(_, k) {
        return function(J) {
            return J == null ? !1 : J[_] === k && (k !== void 0 || _ in Object(J))
        }
    }
    baseMatches = function(_) {
        var k = getMatchData(_);
        return k.length == 1 && k[0][2] ? matchesStrictComparable(k[0][0], k[0][1]) : function(J) {
            return J === _ || baseIsMatch(J, _, k)
        }
    }
    ;
    function baseHasIn(_, k) {
        return _ != null && k in Object(_)
    }
    hasPath = function(_, k, J) {
        k = castPath(k, _);
        for (var et = -1, tt = k.length, rt = !1; ++et < tt; ) {
            var nt = toKey(k[et]);
            if (!(rt = _ != null && J(_, nt)))
                break;
            _ = _[nt]
        }
        return rt || ++et != tt ? rt : (tt = _ == null ? 0 : _.length,
        !!tt && isLength(tt) && isIndex(nt, tt) && (n0(_) || isArguments$1(_)))
    }
    ,
    hasIn = function(_, k) {
        return _ != null && hasPath(_, k, baseHasIn)
    }
    ;
    var COMPARE_PARTIAL_FLAG = 1
      , COMPARE_UNORDERED_FLAG = 2;
    baseMatchesProperty = function(_, k) {
        return isKey(_) && isStrictComparable(k) ? matchesStrictComparable(toKey(_), k) : function(J) {
            var et = get$1(J, _);
            return et === void 0 && et === k ? hasIn(J, _) : baseIsEqual(k, et, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
        }
    }
    ,
    baseProperty = function(_) {
        return function(k) {
            return k == null ? void 0 : k[_]
        }
    }
    ;
    function basePropertyDeep(_) {
        return function(k) {
            return baseGet(k, _)
        }
    }
    property = function(_) {
        return isKey(_) ? baseProperty(toKey(_)) : basePropertyDeep(_)
    }
    ,
    baseIteratee = function(_) {
        return typeof _ == "function" ? _ : _ == null ? identity : typeof _ == "object" ? n0(_) ? baseMatchesProperty(_[0], _[1]) : baseMatches(_) : property(_)
    }
    ;
    var now = function() {
        return root$1.Date.now()
    };
    now$1 = now;
    var FUNC_ERROR_TEXT$2 = "Expected a function"
      , nativeMax = Math.max
      , nativeMin$1 = Math.min;
    debounce = function(_, k, J) {
        var et, tt, rt, nt, ot, it, at = 0, lt = !1, st = !1, ut = !0;
        if (typeof _ != "function")
            throw new TypeError(FUNC_ERROR_TEXT$2);
        k = toNumber(k) || 0,
        isObject$2(J) && (lt = !!J.leading,
        st = "maxWait"in J,
        rt = st ? nativeMax(toNumber(J.maxWait) || 0, k) : rt,
        ut = "trailing"in J ? !!J.trailing : ut);
        function ct(Et) {
            var xt = et
              , wt = tt;
            return et = tt = void 0,
            at = Et,
            nt = _.apply(wt, xt),
            nt
        }
        function pt(Et) {
            return at = Et,
            ot = setTimeout(ht, k),
            lt ? ct(Et) : nt
        }
        function ft(Et) {
            var xt = Et - it
              , wt = Et - at
              , St = k - xt;
            return st ? nativeMin$1(St, rt - wt) : St
        }
        function yt(Et) {
            var xt = Et - it
              , wt = Et - at;
            return it === void 0 || xt >= k || xt < 0 || st && wt >= rt
        }
        function ht() {
            var Et = now$1();
            if (yt(Et))
                return gt(Et);
            ot = setTimeout(ht, ft(Et))
        }
        function gt(Et) {
            return ot = void 0,
            ut && et ? ct(Et) : (et = tt = void 0,
            nt)
        }
        function mt() {
            ot !== void 0 && clearTimeout(ot),
            at = 0,
            et = it = tt = ot = void 0
        }
        function vt() {
            return ot === void 0 ? nt : gt(now$1())
        }
        function bt() {
            var Et = now$1()
              , xt = yt(Et);
            if (et = arguments,
            tt = this,
            it = Et,
            xt) {
                if (ot === void 0)
                    return pt(it);
                if (st)
                    return clearTimeout(ot),
                    ot = setTimeout(ht, k),
                    ct(it)
            }
            return ot === void 0 && (ot = setTimeout(ht, k)),
            nt
        }
        return bt.cancel = mt,
        bt.flush = vt,
        bt
    }
    ,
    once$1 = function(_) {
        return before(2, _)
    }
    ;
    var MAX_ARRAY_LENGTH = 4294967295
      , MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1
      , nativeFloor = Math.floor
      , nativeMin = Math.min;
    baseSortedIndexBy = function(_, k, J, et) {
        var tt = 0
          , rt = _ == null ? 0 : _.length;
        if (rt === 0)
            return 0;
        k = J(k);
        for (var nt = k !== k, ot = k === null, it = isSymbol(k), at = k === void 0; tt < rt; ) {
            var lt = nativeFloor((tt + rt) / 2)
              , st = J(_[lt])
              , ut = st !== void 0
              , ct = st === null
              , pt = st === st
              , ft = isSymbol(st);
            if (nt)
                var yt = et || pt;
            else
                at ? yt = pt && (et || ut) : ot ? yt = pt && ut && (et || !ct) : it ? yt = pt && ut && !ct && (et || !ft) : ct || ft ? yt = !1 : yt = et ? st <= k : st < k;
            yt ? tt = lt + 1 : rt = lt
        }
        return nativeMin(rt, MAX_ARRAY_INDEX)
    }
    ,
    sortedIndexBy = function(_, k, J) {
        return baseSortedIndexBy(_, k, baseIteratee(J))
    }
    ;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    throttle$1 = function(_, k, J) {
        var et = !0
          , tt = !0;
        if (typeof _ != "function")
            throw new TypeError(FUNC_ERROR_TEXT$1);
        return isObject$2(J) && (et = "leading"in J ? !!J.leading : et,
        tt = "trailing"in J ? !!J.trailing : tt),
        debounce(_, k, {
            leading: et,
            maxWait: k,
            trailing: tt
        })
    }
    ;
    var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
    }
      , unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    const unescapeHtmlChar$1 = unescapeHtmlChar;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g
      , reHasEscapedHtml = RegExp(reEscapedHtml.source);
    unescape$2 = function(_) {
        return _ = toString$5(_),
        _ && reHasEscapedHtml.test(_) ? _.replace(reEscapedHtml, unescapeHtmlChar$1) : _
    }
    ;
    function bind$1(_, k) {
        return function() {
            return _.apply(k, arguments)
        }
    }
    const {toString: toString$4} = Object.prototype
      , {getPrototypeOf} = Object
      , kindOf = (_=>k=>{
        const J = toString$4.call(k);
        return _[J] || (_[J] = J.slice(8, -1).toLowerCase())
    }
    )(Object.create(null))
      , kindOfTest = _=>(_ = _.toLowerCase(),
    k=>kindOf(k) === _)
      , typeOfTest = _=>k=>typeof k === _
      , {isArray: isArray$2} = Array
      , isUndefined = typeOfTest("undefined");
    function isBuffer$1(_) {
        return _ !== null && !isUndefined(_) && _.constructor !== null && !isUndefined(_.constructor) && isFunction(_.constructor.isBuffer) && _.constructor.isBuffer(_)
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(_) {
        let k;
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? k = ArrayBuffer.isView(_) : k = _ && _.buffer && isArrayBuffer(_.buffer),
        k
    }
    const isString$1 = typeOfTest("string")
      , isFunction = typeOfTest("function")
      , isNumber$1 = typeOfTest("number")
      , isObject$1 = _=>_ !== null && typeof _ == "object"
      , isBoolean = _=>_ === !0 || _ === !1
      , isPlainObject = _=>{
        if (kindOf(_) !== "object")
            return !1;
        const k = getPrototypeOf(_);
        return (k === null || k === Object.prototype || Object.getPrototypeOf(k) === null) && !(Symbol.toStringTag in _) && !(Symbol.iterator in _)
    }
      , isDate = kindOfTest("Date")
      , isFile = kindOfTest("File")
      , isBlob = kindOfTest("Blob")
      , isFileList = kindOfTest("FileList")
      , isStream = _=>isObject$1(_) && isFunction(_.pipe)
      , isFormData = _=>{
        let k;
        return _ && (typeof FormData == "function" && _ instanceof FormData || isFunction(_.append) && ((k = kindOf(_)) === "formdata" || k === "object" && isFunction(_.toString) && _.toString() === "[object FormData]"))
    }
      , isURLSearchParams = kindOfTest("URLSearchParams")
      , [isReadableStream,isRequest,isResponse$1,isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest)
      , trim = _=>_.trim ? _.trim() : _.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(_, k, {allOwnKeys: J=!1}={}) {
        if (_ === null || typeof _ > "u")
            return;
        let et, tt;
        if (typeof _ != "object" && (_ = [_]),
        isArray$2(_))
            for (et = 0,
            tt = _.length; et < tt; et++)
                k.call(null, _[et], et, _);
        else {
            const rt = J ? Object.getOwnPropertyNames(_) : Object.keys(_)
              , nt = rt.length;
            let ot;
            for (et = 0; et < nt; et++)
                ot = rt[et],
                k.call(null, _[ot], ot, _)
        }
    }
    function findKey(_, k) {
        k = k.toLowerCase();
        const J = Object.keys(_);
        let et = J.length, tt;
        for (; et-- > 0; )
            if (tt = J[et],
            k === tt.toLowerCase())
                return tt;
        return null
    }
    const _global = (()=>typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)()
      , isContextDefined = _=>!isUndefined(_) && _ !== _global;
    function merge() {
        const {caseless: _} = isContextDefined(this) && this || {}
          , k = {}
          , J = (et,tt)=>{
            const rt = _ && findKey(k, tt) || tt;
            isPlainObject(k[rt]) && isPlainObject(et) ? k[rt] = merge(k[rt], et) : isPlainObject(et) ? k[rt] = merge({}, et) : isArray$2(et) ? k[rt] = et.slice() : k[rt] = et
        }
        ;
        for (let et = 0, tt = arguments.length; et < tt; et++)
            arguments[et] && forEach(arguments[et], J);
        return k
    }
    const extend = (_,k,J,{allOwnKeys: et}={})=>(forEach(k, (tt,rt)=>{
        J && isFunction(tt) ? _[rt] = bind$1(tt, J) : _[rt] = tt
    }
    , {
        allOwnKeys: et
    }),
    _)
      , stripBOM = _=>(_.charCodeAt(0) === 65279 && (_ = _.slice(1)),
    _)
      , inherits = (_,k,J,et)=>{
        _.prototype = Object.create(k.prototype, et),
        _.prototype.constructor = _,
        Object.defineProperty(_, "super", {
            value: k.prototype
        }),
        J && Object.assign(_.prototype, J)
    }
      , toFlatObject = (_,k,J,et)=>{
        let tt, rt, nt;
        const ot = {};
        if (k = k || {},
        _ == null)
            return k;
        do {
            for (tt = Object.getOwnPropertyNames(_),
            rt = tt.length; rt-- > 0; )
                nt = tt[rt],
                (!et || et(nt, _, k)) && !ot[nt] && (k[nt] = _[nt],
                ot[nt] = !0);
            _ = J !== !1 && getPrototypeOf(_)
        } while (_ && (!J || J(_, k)) && _ !== Object.prototype);
        return k
    }
      , endsWith = (_,k,J)=>{
        _ = String(_),
        (J === void 0 || J > _.length) && (J = _.length),
        J -= k.length;
        const et = _.indexOf(k, J);
        return et !== -1 && et === J
    }
      , toArray$1 = _=>{
        if (!_)
            return null;
        if (isArray$2(_))
            return _;
        let k = _.length;
        if (!isNumber$1(k))
            return null;
        const J = new Array(k);
        for (; k-- > 0; )
            J[k] = _[k];
        return J
    }
      , isTypedArray = (_=>k=>_ && k instanceof _)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array))
      , forEachEntry = (_,k)=>{
        const J = (_ && _[Symbol.iterator]).call(_);
        let et;
        for (; (et = J.next()) && !et.done; ) {
            const tt = et.value;
            k.call(_, tt[0], tt[1])
        }
    }
      , matchAll = (_,k)=>{
        let J;
        const et = [];
        for (; (J = _.exec(k)) !== null; )
            et.push(J);
        return et
    }
      , isHTMLForm = kindOfTest("HTMLFormElement")
      , toCamelCase = _=>_.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(k, J, et) {
        return J.toUpperCase() + et
    })
      , hasOwnProperty = (({hasOwnProperty: _})=>(k,J)=>_.call(k, J))(Object.prototype)
      , isRegExp = kindOfTest("RegExp")
      , reduceDescriptors = (_,k)=>{
        const J = Object.getOwnPropertyDescriptors(_)
          , et = {};
        forEach(J, (tt,rt)=>{
            let nt;
            (nt = k(tt, rt, _)) !== !1 && (et[rt] = nt || tt)
        }
        ),
        Object.defineProperties(_, et)
    }
      , freezeMethods = _=>{
        reduceDescriptors(_, (k,J)=>{
            if (isFunction(_) && ["arguments", "caller", "callee"].indexOf(J) !== -1)
                return !1;
            const et = _[J];
            if (isFunction(et)) {
                if (k.enumerable = !1,
                "writable"in k) {
                    k.writable = !1;
                    return
                }
                k.set || (k.set = ()=>{
                    throw Error("Can not rewrite read-only method '" + J + "'")
                }
                )
            }
        }
        )
    }
      , toObjectSet = (_,k)=>{
        const J = {}
          , et = tt=>{
            tt.forEach(rt=>{
                J[rt] = !0
            }
            )
        }
        ;
        return isArray$2(_) ? et(_) : et(String(_).split(k)),
        J
    }
      , noop$5 = ()=>{}
      , toFiniteNumber = (_,k)=>_ != null && Number.isFinite(_ = +_) ? _ : k
      , ALPHA = "abcdefghijklmnopqrstuvwxyz"
      , DIGIT = "0123456789"
      , ALPHABET = {
        DIGIT,
        ALPHA,
        ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    }
      , generateString = (_=16,k=ALPHABET.ALPHA_DIGIT)=>{
        let J = "";
        const {length: et} = k;
        for (; _--; )
            J += k[Math.random() * et | 0];
        return J
    }
    ;
    function isSpecCompliantForm(_) {
        return !!(_ && isFunction(_.append) && _[Symbol.toStringTag] === "FormData" && _[Symbol.iterator])
    }
    const toJSONObject = _=>{
        const k = new Array(10)
          , J = (et,tt)=>{
            if (isObject$1(et)) {
                if (k.indexOf(et) >= 0)
                    return;
                if (!("toJSON"in et)) {
                    k[tt] = et;
                    const rt = isArray$2(et) ? [] : {};
                    return forEach(et, (nt,ot)=>{
                        const it = J(nt, tt + 1);
                        !isUndefined(it) && (rt[ot] = it)
                    }
                    ),
                    k[tt] = void 0,
                    rt
                }
            }
            return et
        }
        ;
        return J(_, 0)
    }
      , isAsyncFn = kindOfTest("AsyncFunction")
      , isThenable = _=>_ && (isObject$1(_) || isFunction(_)) && isFunction(_.then) && isFunction(_.catch)
      , utils$1 = {
        isArray: isArray$2,
        isArrayBuffer,
        isBuffer: isBuffer$1,
        isFormData,
        isArrayBufferView,
        isString: isString$1,
        isNumber: isNumber$1,
        isBoolean,
        isObject: isObject$1,
        isPlainObject,
        isReadableStream,
        isRequest,
        isResponse: isResponse$1,
        isHeaders,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray: toArray$1,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop: noop$5,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        ALPHABET,
        generateString,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable
    };
    function AxiosError(_, k, J, et, tt) {
        Error.call(this),
        Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
        this.message = _,
        this.name = "AxiosError",
        k && (this.code = k),
        J && (this.config = J),
        et && (this.request = et),
        tt && (this.response = tt)
    }
    utils$1.inherits(AxiosError, Error, {
        toJSON: function() {
            return {
                message: this.message,
                name: this.name,
                description: this.description,
                number: this.number,
                fileName: this.fileName,
                lineNumber: this.lineNumber,
                columnNumber: this.columnNumber,
                stack: this.stack,
                config: utils$1.toJSONObject(this.config),
                code: this.code,
                status: this.response && this.response.status ? this.response.status : null
            }
        }
    });
    const prototype$1 = AxiosError.prototype
      , descriptors = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(_=>{
        descriptors[_] = {
            value: _
        }
    }
    ),
    Object.defineProperties(AxiosError, descriptors),
    Object.defineProperty(prototype$1, "isAxiosError", {
        value: !0
    }),
    AxiosError.from = (_,k,J,et,tt,rt)=>{
        const nt = Object.create(prototype$1);
        return utils$1.toFlatObject(_, nt, function(ot) {
            return ot !== Error.prototype
        }, ot=>ot !== "isAxiosError"),
        AxiosError.call(nt, _.message, k, J, et, tt),
        nt.cause = _,
        nt.name = _.name,
        rt && Object.assign(nt, rt),
        nt
    }
    ;
    const httpAdapter = null;
    function isVisitable(_) {
        return utils$1.isPlainObject(_) || utils$1.isArray(_)
    }
    function removeBrackets(_) {
        return utils$1.endsWith(_, "[]") ? _.slice(0, -2) : _
    }
    function renderKey(_, k, J) {
        return _ ? _.concat(k).map(function(et, tt) {
            return et = removeBrackets(et),
            !J && tt ? "[" + et + "]" : et
        }).join(J ? "." : "") : k
    }
    function isFlatArray(_) {
        return utils$1.isArray(_) && !_.some(isVisitable)
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function(_) {
        return /^is[A-Z]/.test(_)
    });
    function toFormData(_, k, J) {
        if (!utils$1.isObject(_))
            throw new TypeError("target must be an object");
        k = k || new FormData,
        J = utils$1.toFlatObject(J, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
        }, !1, function(ct, pt) {
            return !utils$1.isUndefined(pt[ct])
        });
        const et = J.metaTokens
          , tt = J.visitor || at
          , rt = J.dots
          , nt = J.indexes
          , ot = (J.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(k);
        if (!utils$1.isFunction(tt))
            throw new TypeError("visitor must be a function");
        function it(ct) {
            if (ct === null)
                return "";
            if (utils$1.isDate(ct))
                return ct.toISOString();
            if (!ot && utils$1.isBlob(ct))
                throw new AxiosError("Blob is not supported. Use a Buffer instead.");
            return utils$1.isArrayBuffer(ct) || utils$1.isTypedArray(ct) ? ot && typeof Blob == "function" ? new Blob([ct]) : Buffer.from(ct) : ct
        }
        function at(ct, pt, ft) {
            let yt = ct;
            if (ct && !ft && typeof ct == "object") {
                if (utils$1.endsWith(pt, "{}"))
                    pt = et ? pt : pt.slice(0, -2),
                    ct = JSON.stringify(ct);
                else if (utils$1.isArray(ct) && isFlatArray(ct) || (utils$1.isFileList(ct) || utils$1.endsWith(pt, "[]")) && (yt = utils$1.toArray(ct)))
                    return pt = removeBrackets(pt),
                    yt.forEach(function(ht, gt) {
                        !(utils$1.isUndefined(ht) || ht === null) && k.append(nt === !0 ? renderKey([pt], gt, rt) : nt === null ? pt : pt + "[]", it(ht))
                    }),
                    !1
            }
            return isVisitable(ct) ? !0 : (k.append(renderKey(ft, pt, rt), it(ct)),
            !1)
        }
        const lt = []
          , st = Object.assign(predicates, {
            defaultVisitor: at,
            convertValue: it,
            isVisitable
        });
        function ut(ct, pt) {
            if (!utils$1.isUndefined(ct)) {
                if (lt.indexOf(ct) !== -1)
                    throw Error("Circular reference detected in " + pt.join("."));
                lt.push(ct),
                utils$1.forEach(ct, function(ft, yt) {
                    (!(utils$1.isUndefined(ft) || ft === null) && tt.call(k, ft, utils$1.isString(yt) ? yt.trim() : yt, pt, st)) === !0 && ut(ft, pt ? pt.concat(yt) : [yt])
                }),
                lt.pop()
            }
        }
        if (!utils$1.isObject(_))
            throw new TypeError("data must be an object");
        return ut(_),
        k
    }
    function encode$2(_) {
        const k = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
        };
        return encodeURIComponent(_).replace(/[!'()~]|%20|%00/g, function(J) {
            return k[J]
        })
    }
    function AxiosURLSearchParams(_, k) {
        this._pairs = [],
        _ && toFormData(_, this, k)
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function(_, k) {
        this._pairs.push([_, k])
    }
    ,
    prototype.toString = function(_) {
        const k = _ ? function(J) {
            return _.call(this, J, encode$2)
        }
        : encode$2;
        return this._pairs.map(function(J) {
            return k(J[0]) + "=" + k(J[1])
        }, "").join("&")
    }
    ;
    function encode$1(_) {
        return encodeURIComponent(_).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }
    function buildURL(_, k, J) {
        if (!k)
            return _;
        const et = J && J.encode || encode$1
          , tt = J && J.serialize;
        let rt;
        if (tt ? rt = tt(k, J) : rt = utils$1.isURLSearchParams(k) ? k.toString() : new AxiosURLSearchParams(k,J).toString(et),
        rt) {
            const nt = _.indexOf("#");
            nt !== -1 && (_ = _.slice(0, nt)),
            _ += (_.indexOf("?") === -1 ? "?" : "&") + rt
        }
        return _
    }
    class InterceptorManager {
        constructor() {
            this.handlers = []
        }
        use(k, J, et) {
            return this.handlers.push({
                fulfilled: k,
                rejected: J,
                synchronous: et ? et.synchronous : !1,
                runWhen: et ? et.runWhen : null
            }),
            this.handlers.length - 1
        }
        eject(k) {
            this.handlers[k] && (this.handlers[k] = null)
        }
        clear() {
            this.handlers && (this.handlers = [])
        }
        forEach(k) {
            utils$1.forEach(this.handlers, function(J) {
                J !== null && k(J)
            })
        }
    }
    const InterceptorManager$1 = InterceptorManager
      , transitionalDefaults = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    }
      , URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams
      , FormData$1 = typeof FormData < "u" ? FormData : null
      , Blob$1 = typeof Blob < "u" ? Blob : null
      , platform$1 = {
        isBrowser: !0,
        classes: {
            URLSearchParams: URLSearchParams$1,
            FormData: FormData$1,
            Blob: Blob$1
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    }
      , hasBrowserEnv = typeof window < "u" && typeof document < "u"
      , hasStandardBrowserEnv = (_=>hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(_) < 0)(typeof navigator < "u" && navigator.product)
      , hasStandardBrowserWebWorkerEnv = (()=>typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")()
      , origin = hasBrowserEnv && window.location.href || "http://localhost"
      , utils = Object.assign(Object.defineProperty({
        
        hasBrowserEnv,
        hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv,
        origin
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , platform = $t($t({}, utils), platform$1);
    function toURLEncodedForm(_, k) {
        return toFormData(_, new platform.classes.URLSearchParams, Object.assign({
            visitor: function(J, et, tt, rt) {
                return platform.isNode && utils$1.isBuffer(J) ? (this.append(et, J.toString("base64")),
                !1) : rt.defaultVisitor.apply(this, arguments)
            }
        }, k))
    }
    function parsePropPath(_) {
        return utils$1.matchAll(/\w+|\[(\w*)]/g, _).map(k=>k[0] === "[]" ? "" : k[1] || k[0])
    }
    function arrayToObject(_) {
        const k = {}
          , J = Object.keys(_);
        let et;
        const tt = J.length;
        let rt;
        for (et = 0; et < tt; et++)
            rt = J[et],
            k[rt] = _[rt];
        return k
    }
    function formDataToJSON(_) {
        function k(J, et, tt, rt) {
            let nt = J[rt++];
            if (nt === "__proto__")
                return !0;
            const ot = Number.isFinite(+nt)
              , it = rt >= J.length;
            return nt = !nt && utils$1.isArray(tt) ? tt.length : nt,
            it ? (utils$1.hasOwnProp(tt, nt) ? tt[nt] = [tt[nt], et] : tt[nt] = et,
            !ot) : ((!tt[nt] || !utils$1.isObject(tt[nt])) && (tt[nt] = []),
            k(J, et, tt[nt], rt) && utils$1.isArray(tt[nt]) && (tt[nt] = arrayToObject(tt[nt])),
            !ot)
        }
        if (utils$1.isFormData(_) && utils$1.isFunction(_.entries)) {
            const J = {};
            return utils$1.forEachEntry(_, (et,tt)=>{
                k(parsePropPath(et), tt, J, 0)
            }
            ),
            J
        }
        return null
    }
    function stringifySafely(_, k, J) {
        if (utils$1.isString(_))
            try {
                return (k || JSON.parse)(_),
                utils$1.trim(_)
            } catch (et) {
                if (et.name !== "SyntaxError")
                    throw et
            }
        return (J || JSON.stringify)(_)
    }
    const defaults$1 = {
        transitional: transitionalDefaults,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function(_, k) {
            const J = k.getContentType() || ""
              , et = J.indexOf("application/json") > -1
              , tt = utils$1.isObject(_);
            if (tt && utils$1.isHTMLForm(_) && (_ = new FormData(_)),
            utils$1.isFormData(_))
                return et ? JSON.stringify(formDataToJSON(_)) : _;
            if (utils$1.isArrayBuffer(_) || utils$1.isBuffer(_) || utils$1.isStream(_) || utils$1.isFile(_) || utils$1.isBlob(_) || utils$1.isReadableStream(_))
                return _;
            if (utils$1.isArrayBufferView(_))
                return _.buffer;
            if (utils$1.isURLSearchParams(_))
                return k.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                _.toString();
            let rt;
            if (tt) {
                if (J.indexOf("application/x-www-form-urlencoded") > -1)
                    return toURLEncodedForm(_, this.formSerializer).toString();
                if ((rt = utils$1.isFileList(_)) || J.indexOf("multipart/form-data") > -1) {
                    const nt = this.env && this.env.FormData;
                    return toFormData(rt ? {
                        "files[]": _
                    } : _, nt && new nt, this.formSerializer)
                }
            }
            return tt || et ? (k.setContentType("application/json", !1),
            stringifySafely(_)) : _
        }
        ],
        transformResponse: [function(_) {
            const k = this.transitional || defaults$1.transitional
              , J = k && k.forcedJSONParsing
              , et = this.responseType === "json";
            if (utils$1.isResponse(_) || utils$1.isReadableStream(_))
                return _;
            if (_ && utils$1.isString(_) && (J && !this.responseType || et)) {
                const tt = !(k && k.silentJSONParsing) && et;
                try {
                    return JSON.parse(_)
                } catch (rt) {
                    if (tt)
                        throw rt.name === "SyntaxError" ? AxiosError.from(rt, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : rt
                }
            }
            return _
        }
        ],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
            FormData: platform.classes.FormData,
            Blob: platform.classes.Blob
        },
        validateStatus: function(_) {
            return _ >= 200 && _ < 300
        },
        headers: {
            common: {
                Accept: "application/json, text/plain, */*",
                "Content-Type": void 0
            }
        }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], _=>{
        defaults$1.headers[_] = {}
    }
    );
    const defaults$2 = defaults$1
      , ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
      , parseHeaders = _=>{
        const k = {};
        let J, et, tt;
        return _ && _.split(`
`).forEach(function(rt) {
            tt = rt.indexOf(":"),
            J = rt.substring(0, tt).trim().toLowerCase(),
            et = rt.substring(tt + 1).trim(),
            !(!J || k[J] && ignoreDuplicateOf[J]) && (J === "set-cookie" ? k[J] ? k[J].push(et) : k[J] = [et] : k[J] = k[J] ? k[J] + ", " + et : et)
        }),
        k
    }
      , $internals = Symbol("internals");
    function normalizeHeader(_) {
        return _ && String(_).trim().toLowerCase()
    }
    function normalizeValue(_) {
        return _ === !1 || _ == null ? _ : utils$1.isArray(_) ? _.map(normalizeValue) : String(_)
    }
    function parseTokens(_) {
        const k = Object.create(null)
          , J = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
        let et;
        for (; et = J.exec(_); )
            k[et[1]] = et[2];
        return k
    }
    const isValidHeaderName = _=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(_.trim());
    function matchHeaderValue(_, k, J, et, tt) {
        if (utils$1.isFunction(et))
            return et.call(this, k, J);
        if (tt && (k = J),
        !!utils$1.isString(k)) {
            if (utils$1.isString(et))
                return k.indexOf(et) !== -1;
            if (utils$1.isRegExp(et))
                return et.test(k)
        }
    }
    function formatHeader(_) {
        return _.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (k,J,et)=>J.toUpperCase() + et)
    }
    function buildAccessors(_, k) {
        const J = utils$1.toCamelCase(" " + k);
        ["get", "set", "has"].forEach(et=>{
            Object.defineProperty(_, et + J, {
                value: function(tt, rt, nt) {
                    return this[et].call(this, k, tt, rt, nt)
                },
                configurable: !0
            })
        }
        )
    }
    class AxiosHeaders {
        constructor(k) {
            k && this.set(k)
        }
        set(k, J, et) {
            const tt = this;
            function rt(ot, it, at) {
                const lt = normalizeHeader(it);
                if (!lt)
                    throw new Error("header name must be a non-empty string");
                const st = utils$1.findKey(tt, lt);
                (!st || tt[st] === void 0 || at === !0 || at === void 0 && tt[st] !== !1) && (tt[st || it] = normalizeValue(ot))
            }
            const nt = (ot,it)=>utils$1.forEach(ot, (at,lt)=>rt(at, lt, it));
            if (utils$1.isPlainObject(k) || k instanceof this.constructor)
                nt(k, J);
            else if (utils$1.isString(k) && (k = k.trim()) && !isValidHeaderName(k))
                nt(parseHeaders(k), J);
            else if (utils$1.isHeaders(k))
                for (const [ot,it] of k.entries())
                    rt(it, ot, et);
            else
                k != null && rt(J, k, et);
            return this
        }
        get(k, J) {
            if (k = normalizeHeader(k),
            k) {
                const et = utils$1.findKey(this, k);
                if (et) {
                    const tt = this[et];
                    if (!J)
                        return tt;
                    if (J === !0)
                        return parseTokens(tt);
                    if (utils$1.isFunction(J))
                        return J.call(this, tt, et);
                    if (utils$1.isRegExp(J))
                        return J.exec(tt);
                    throw new TypeError("parser must be boolean|regexp|function")
                }
            }
        }
        has(k, J) {
            if (k = normalizeHeader(k),
            k) {
                const et = utils$1.findKey(this, k);
                return !!(et && this[et] !== void 0 && (!J || matchHeaderValue(this, this[et], et, J)))
            }
            return !1
        }
        delete(k, J) {
            const et = this;
            let tt = !1;
            function rt(nt) {
                if (nt = normalizeHeader(nt),
                nt) {
                    const ot = utils$1.findKey(et, nt);
                    ot && (!J || matchHeaderValue(et, et[ot], ot, J)) && (delete et[ot],
                    tt = !0)
                }
            }
            return utils$1.isArray(k) ? k.forEach(rt) : rt(k),
            tt
        }
        clear(k) {
            const J = Object.keys(this);
            let et = J.length
              , tt = !1;
            for (; et--; ) {
                const rt = J[et];
                (!k || matchHeaderValue(this, this[rt], rt, k, !0)) && (delete this[rt],
                tt = !0)
            }
            return tt
        }
        normalize(k) {
            const J = this
              , et = {};
            return utils$1.forEach(this, (tt,rt)=>{
                const nt = utils$1.findKey(et, rt);
                if (nt) {
                    J[nt] = normalizeValue(tt),
                    delete J[rt];
                    return
                }
                const ot = k ? formatHeader(rt) : String(rt).trim();
                ot !== rt && delete J[rt],
                J[ot] = normalizeValue(tt),
                et[ot] = !0
            }
            ),
            this
        }
        concat(...k) {
            return this.constructor.concat(this, ...k)
        }
        toJSON(k) {
            const J = Object.create(null);
            return utils$1.forEach(this, (et,tt)=>{
                et != null && et !== !1 && (J[tt] = k && utils$1.isArray(et) ? et.join(", ") : et)
            }
            ),
            J
        }
        [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]()
        }
        toString() {
            return Object.entries(this.toJSON()).map(([k,J])=>k + ": " + J).join(`
`)
        }
        get[Symbol.toStringTag]() {
            return "AxiosHeaders"
        }
        static from(k) {
            return k instanceof this ? k : new this(k)
        }
        static concat(k, ...J) {
            const et = new this(k);
            return J.forEach(tt=>et.set(tt)),
            et
        }
        static accessor(k) {
            const J = (this[$internals] = this[$internals] = {
                accessors: {}
            }).accessors
              , et = this.prototype;
            function tt(rt) {
                const nt = normalizeHeader(rt);
                J[nt] || (buildAccessors(et, rt),
                J[nt] = !0)
            }
            return utils$1.isArray(k) ? k.forEach(tt) : tt(k),
            this
        }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value: _},k)=>{
        let J = k[0].toUpperCase() + k.slice(1);
        return {
            get: ()=>_,
            set(et) {
                this[J] = et
            }
        }
    }
    ),
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(_, k) {
        const J = this || defaults$2
          , et = k || J
          , tt = AxiosHeaders$1.from(et.headers);
        let rt = et.data;
        return utils$1.forEach(_, function(nt) {
            rt = nt.call(J, rt, tt.normalize(), k ? k.status : void 0)
        }),
        tt.normalize(),
        rt
    }
    function isCancel(_) {
        return !!(_ && _.__CANCEL__)
    }
    function CanceledError(_, k, J) {
        AxiosError.call(this, _ != null ? _ : "canceled", AxiosError.ERR_CANCELED, k, J),
        this.name = "CanceledError"
    }
    utils$1.inherits(CanceledError, AxiosError, {
        __CANCEL__: !0
    });
    function settle(_, k, J) {
        const et = J.config.validateStatus;
        !J.status || !et || et(J.status) ? _(J) : k(new AxiosError("Request failed with status code " + J.status,[AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(J.status / 100) - 4],J.config,J.request,J))
    }
    function parseProtocol(_) {
        const k = /^([-+\w]{1,25})(:?\/\/|:)/.exec(_);
        return k && k[1] || ""
    }
    function speedometer(_, k) {
        _ = _ || 10;
        const J = new Array(_)
          , et = new Array(_);
        let tt = 0, rt = 0, nt;
        return k = k !== void 0 ? k : 1e3,
        function(ot) {
            const it = Date.now()
              , at = et[rt];
            nt || (nt = it),
            J[tt] = ot,
            et[tt] = it;
            let lt = rt
              , st = 0;
            for (; lt !== tt; )
                st += J[lt++],
                lt = lt % _;
            if (tt = (tt + 1) % _,
            tt === rt && (rt = (rt + 1) % _),
            it - nt < k)
                return;
            const ut = at && it - at;
            return ut ? Math.round(st * 1e3 / ut) : void 0
        }
    }
    function throttle(_, k) {
        let J = 0;
        const et = 1e3 / k;
        let tt = null;
        return function() {
            const rt = this === !0
              , nt = Date.now();
            if (rt || nt - J > et)
                return tt && (clearTimeout(tt),
                tt = null),
                J = nt,
                _.apply(null, arguments);
            tt || (tt = setTimeout(()=>(tt = null,
            J = Date.now(),
            _.apply(null, arguments)), et - (nt - J)))
        }
    }
    const progressEventReducer = (_,k,J=3)=>{
        let et = 0;
        const tt = speedometer(50, 250);
        return throttle(rt=>{
            const nt = rt.loaded
              , ot = rt.lengthComputable ? rt.total : void 0
              , it = nt - et
              , at = tt(it)
              , lt = nt <= ot;
            et = nt;
            const st = {
                loaded: nt,
                total: ot,
                progress: ot ? nt / ot : void 0,
                bytes: it,
                rate: at || void 0,
                estimated: at && ot && lt ? (ot - nt) / at : void 0,
                event: rt,
                lengthComputable: ot != null
            };
            st[k ? "download" : "upload"] = !0,
            _(st)
        }
        , J)
    }
      , isURLSameOrigin = platform.hasStandardBrowserEnv ? function() {
        const _ = /(msie|trident)/i.test(navigator.userAgent)
          , k = document.createElement("a");
        let J;
        function et(tt) {
            let rt = tt;
            return _ && (k.setAttribute("href", rt),
            rt = k.href),
            k.setAttribute("href", rt),
            {
                href: k.href,
                protocol: k.protocol ? k.protocol.replace(/:$/, "") : "",
                host: k.host,
                search: k.search ? k.search.replace(/^\?/, "") : "",
                hash: k.hash ? k.hash.replace(/^#/, "") : "",
                hostname: k.hostname,
                port: k.port,
                pathname: k.pathname.charAt(0) === "/" ? k.pathname : "/" + k.pathname
            }
        }
        return !0        }
    }() : function() {
        return function() {
            return !0
        }
    }()
      , cookies = platform.hasStandardBrowserEnv ? {
        write(_, k, J, et, tt, rt) {
          
        },
        read(_) {
            const k = document.cookie.match(new RegExp("(^|;\\s*)(" + _ + ")=([^;]*)"));
            return k ? decodeURIComponent(k[3]) : null
        },
        remove(_) {
        }
    } : {
        write() {},
        read() {
            return k
        },
        remove() {}
    };
    function isAbsoluteURL(_) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(_)
    }
    function combineURLs(_, k) {
        return k ? _.replace(/\/?\/$/, "") + "/" + k.replace(/^\/+/, "") : _
    }
    function buildFullPath(_, k) {
        return _ && !isAbsoluteURL(k) ? combineURLs(_, k) : k
    }
    const headersToObject = _=>_ instanceof AxiosHeaders$1 ? $t({}, _) : _;
    function mergeConfig(_, k) {
        k = k || {};
        const J = {};
        function et(at, lt, st) {
            return utils$1.isPlainObject(at) && utils$1.isPlainObject(lt) ? utils$1.merge.call({
                caseless: st
            }, at, lt) : utils$1.isPlainObject(lt) ? utils$1.merge({}, lt) : utils$1.isArray(lt) ? lt.slice() : lt
        }
        function tt(at, lt, st) {
            if (utils$1.isUndefined(lt)) {
                if (!utils$1.isUndefined(at))
                    return et(void 0, at, st)
            } else
                return et(at, lt, st)
        }
        function rt(at, lt) {
            if (!utils$1.isUndefined(lt))
                return et(void 0, lt)
        }
        function nt(at, lt) {
            if (utils$1.isUndefined(lt)) {
                if (!utils$1.isUndefined(at))
                    return et(void 0, at)
            } else
                return et(void 0, lt)
        }
        function ot(at, lt, st) {
            if (st in k)
                return et(at, lt);
            if (st in _)
                return et(void 0, at)
        }
        const it = {
            url: rt,
            method: rt,
            data: rt,
            baseURL: nt,
            transformRequest: nt,
            transformResponse: nt,
            paramsSerializer: nt,
            timeout: nt,
            timeoutMessage: nt,
            withCredentials: nt,
            withXSRFToken: nt,
            adapter: nt,
            responseType: nt,
            xsrfCookieName: nt,
            xsrfHeaderName: nt,
            onUploadProgress: nt,
            onDownloadProgress: nt,
            decompress: nt,
            maxContentLength: nt,
            maxBodyLength: nt,
            beforeRedirect: nt,
            transport: nt,
            httpAgent: nt,
            httpsAgent: nt,
            cancelToken: nt,
            socketPath: nt,
            responseEncoding: nt,
            validateStatus: ot,
            headers: (at,lt)=>tt(headersToObject(at), headersToObject(lt), !0)
        };
        return utils$1.forEach(Object.keys(Object.assign({}, _, k)), function(at) {
            const lt = it[at] || tt
              , st = lt(_[at], k[at], at);
            utils$1.isUndefined(st) && lt !== ot || (J[at] = st)
        }),
        J
    }
    const resolveConfig = _=>{
        const k = mergeConfig({}, _);
        let {data: J, withXSRFToken: et, xsrfHeaderName: tt, xsrfCookieName: rt, headers: nt, auth: ot} = k;
        k.headers = nt = AxiosHeaders$1.from(nt),
        k.url = buildURL(buildFullPath(k.baseURL, k.url), _.params, _.paramsSerializer),
        ot && nt.set("Authorization", "Basic " + btoa((ot.username || "") + ":" + (ot.password ? unescape(encodeURIComponent(ot.password)) : "")));
        let it;
        if (utils$1.isFormData(J)) {
            if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
                nt.setContentType(void 0);
            else if ((it = nt.getContentType()) !== !1) {
                const [at,...lt] = it ? it.split(";").map(st=>st.trim()).filter(Boolean) : [];
                nt.setContentType([at || "multipart/form-data", ...lt].join("; "))
            }
        }
        if (platform.hasStandardBrowserEnv && (et && utils$1.isFunction(et) && (et = et(k)),
        et || et !== !1 && isURLSameOrigin(k.url))) {
            const at = tt && rt && cookies.read(rt);
            at && nt.set(tt, at)
        }
        return k
    }
      , isXHRAdapterSupported = typeof XMLHttpRequest < "u"
      , xhrAdapter = isXHRAdapterSupported && function(_) {
        return new Promise(function(k, J) {
            const et = resolveConfig(_);
            let tt = et.data;
            const rt = AxiosHeaders$1.from(et.headers).normalize();
            let {responseType: nt} = et, ot;
            function it() {
                et.cancelToken && et.cancelToken.unsubscribe(ot),
                et.signal && et.signal.removeEventListener("abort", ot)
            }
            let at = new XMLHttpRequest;
            at.open(et.method.toUpperCase(), et.url, !0),
            at.timeout = et.timeout;
            function lt() {
                if (!at)
                    return;
                const ut = AxiosHeaders$1.from("getAllResponseHeaders"in at && at.getAllResponseHeaders())
                  , ct = {
                    data: !nt || nt === "text" || nt === "json" ? at.responseText : at.response,
                    status: at.status,
                    statusText: at.statusText,
                    headers: ut,
                    config: _,
                    request: at
                };
                settle(function(pt) {
                    k(pt),
                    it()
                }, function(pt) {
                    J(pt),
                    it()
                }, ct),
                at = null
            }
            "onloadend"in at ? at.onloadend = lt : at.onreadystatechange = function() {
                !at || at.readyState !== 4 || at.status === 0 && !(at.responseURL && at.responseURL.indexOf("file:") === 0) || setTimeout(lt)
            }
            ,
            at.onabort = function() {
                at && (J(new AxiosError("Request aborted",AxiosError.ECONNABORTED,et,at)),
                at = null)
            }
            ,
            at.onerror = function() {
                J(new AxiosError("Network Error",AxiosError.ERR_NETWORK,et,at)),
                at = null
            }
            ,
            at.ontimeout = function() {
                let ut = et.timeout ? "timeout of " + et.timeout + "ms exceeded" : "timeout exceeded";
                const ct = et.transitional || transitionalDefaults;
                et.timeoutErrorMessage && (ut = et.timeoutErrorMessage),
                J(new AxiosError(ut,ct.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,et,at)),
                at = null
            }
            ,
            tt === void 0 && rt.setContentType(null),
            "setRequestHeader"in at && utils$1.forEach(rt.toJSON(), function(ut, ct) {
                at.setRequestHeader(ct, ut)
            }),
            utils$1.isUndefined(et.withCredentials) || (at.withCredentials = !!et.withCredentials),
            nt && nt !== "json" && (at.responseType = et.responseType),
            typeof et.onDownloadProgress == "function" && at.addEventListener("progress", progressEventReducer(et.onDownloadProgress, !0)),
            typeof et.onUploadProgress == "function" && at.upload && at.upload.addEventListener("progress", progressEventReducer(et.onUploadProgress)),
            (et.cancelToken || et.signal) && (ot = ut=>{
                at && (J(!ut || ut.type ? new CanceledError(null,_,at) : ut),
                at.abort(),
                at = null)
            }
            ,
            et.cancelToken && et.cancelToken.subscribe(ot),
            et.signal && (et.signal.aborted ? ot() : et.signal.addEventListener("abort", ot)));
            const st = parseProtocol(et.url);
            if (st && platform.protocols.indexOf(st) === -1) {
                J(new AxiosError("Unsupported protocol " + st + ":",AxiosError.ERR_BAD_REQUEST,_));
                return
            }
            at.send(tt || null)
        }
        )
    }
      , composeSignals = (_,k)=>{
        let J = new AbortController, et;
        const tt = function(it) {
            if (!et) {
                et = !0,
                nt();
                const at = it instanceof Error ? it : this.reason;
                J.abort(at instanceof AxiosError ? at : new CanceledError(at instanceof Error ? at.message : at))
            }
        };
        let rt = k && setTimeout(()=>{
            tt(new AxiosError(`timeout ${k} of ms exceeded`,AxiosError.ETIMEDOUT))
        }
        , k);
        const nt = ()=>{
            _ && (rt && clearTimeout(rt),
            rt = null,
            _.forEach(it=>{
                it && (it.removeEventListener ? it.removeEventListener("abort", tt) : it.unsubscribe(tt))
            }
            ),
            _ = null)
        }
        ;
        _.forEach(it=>it && it.addEventListener && it.addEventListener("abort", tt));
        const {signal: ot} = J;
        return ot.unsubscribe = nt,
        [ot, ()=>{
            rt && clearTimeout(rt),
            rt = null
        }
        ]
    }
      , composeSignals$1 = composeSignals
      , streamChunk = function*(_, k) {
        let J = _.byteLength;
        if (!k || J < k) {
            yield _;
            return
        }
        let et = 0, tt;
        for (; et < J; )
            tt = et + k,
            yield _.slice(et, tt),
            et = tt
    }
      , readBytes = function(_, k, J) {
        return pn(this, null, function*() {
            try {
                for (var et = hn(_), tt, rt, nt; tt = !(rt = yield new zr(et.next())).done; tt = !1) {
                    const ot = rt.value;
                    yield*fn(streamChunk(ArrayBuffer.isView(ot) ? ot : yield new zr(J(String(ot))), k))
                }
            } catch (rt) {
                nt = [rt]
            } finally {
                try {
                    tt && (rt = et.return) && (yield new zr(rt.call(et)))
                } finally {
                    if (nt)
                        throw nt[0]
                }
            }
        })
    }
      , trackStream = (_,k,J,et,tt)=>{
        const rt = readBytes(_, k, tt);
        let nt = 0;
        return new ReadableStream({
            type: "bytes",
            async pull(ot) {
                const {done: it, value: at} = await rt.next();
                if (it) {
                    ot.close(),
                    et();
                    return
                }
                let lt = at.byteLength;
                J && J(nt += lt),
                ot.enqueue(new Uint8Array(at))
            },
            cancel(ot) {
                return et(ot),
                rt.return()
            }
        },{
            highWaterMark: 2
        })
    }
      , fetchProgressDecorator = (_,k)=>{
        const J = _ != null;
        return et=>setTimeout(()=>k({
            lengthComputable: J,
            total: _,
            loaded: et
        }))
    }
      , isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
      , isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function"
      , encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (_=>k=>_.encode(k))(new TextEncoder) : async _=>new Uint8Array(await new Response(_).arrayBuffer()))
      , supportsRequestStream = isReadableStreamSupported && (()=>{
        let _ = !1;
        const k = new Request(platform.origin,{
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return _ = !0,
                "half"
            }
        }).headers.has("Content-Type");
        return _ && !k
    }
    )()
      , DEFAULT_CHUNK_SIZE = 64 * 1024
      , supportsResponseStream = isReadableStreamSupported && !!(()=>{
        try {
            return utils$1.isReadableStream(new Response("").body)
        } catch (_) {}
    }
    )()
      , resolvers = {
        stream: supportsResponseStream && (_=>_.body)
    };
    isFetchSupported && (_=>{
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(k=>{
            !resolvers[k] && (resolvers[k] = utils$1.isFunction(_[k]) ? J=>J[k]() : (J,et)=>{
                throw new AxiosError(`Response type '${k}' is not supported`,AxiosError.ERR_NOT_SUPPORT,et)
            }
            )
        }
        )
    }
    )(new Response);
    const getBodyLength = async _=>{
        if (_ == null)
            return 0;
        if (utils$1.isBlob(_))
            return _.size;
        if (utils$1.isSpecCompliantForm(_))
            return (await new Request(_).arrayBuffer()).byteLength;
        if (utils$1.isArrayBufferView(_))
            return _.byteLength;
        if (utils$1.isURLSearchParams(_) && (_ = _ + ""),
        utils$1.isString(_))
            return (await encodeText(_)).byteLength
    }
      , resolveBodyLength = async(_,k)=>{
        const J = utils$1.toFiniteNumber(_.getContentLength());
        return J != null ? J : getBodyLength(k)
    }
      , fetchAdapter = isFetchSupported && (async _=>{
        let {url: k, method: J, data: et, signal: tt, cancelToken: rt, timeout: nt, onDownloadProgress: ot, onUploadProgress: it, responseType: at, headers: lt, withCredentials: st="same-origin", fetchOptions: ut} = resolveConfig(_);
        at = at ? (at + "").toLowerCase() : "text";
        let[ct,pt] = tt || rt || nt ? composeSignals$1([tt, rt], nt) : [], ft, yt;
        const ht = ()=>{
            !ft && setTimeout(()=>{
                ct && ct.unsubscribe()
            }
            ),
            ft = !0
        }
        ;
        let gt;
        try {
            if (it && supportsRequestStream && J !== "get" && J !== "head" && (gt = await resolveBodyLength(lt, et)) !== 0) {
                let Et = new Request(k,{
                    method: "POST",
                    body: et,
                    duplex: "half"
                }), xt;
                utils$1.isFormData(et) && (xt = Et.headers.get("content-type")) && lt.setContentType(xt),
                Et.body && (et = trackStream(Et.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(gt, progressEventReducer(it)), null, encodeText))
            }
            utils$1.isString(st) || (st = st ? "cors" : "omit"),
            yt = new Request(k,_t($t({}, ut), {
                signal: ct,
                method: J.toUpperCase(),
                headers: lt.normalize().toJSON(),
                body: et,
                duplex: "half",
                withCredentials: st
            }));
            let mt = await fetch(yt);
            const vt = supportsResponseStream && (at === "stream" || at === "response");
            if (supportsResponseStream && (ot || vt)) {
                const Et = {};
                ["status", "statusText", "headers"].forEach(wt=>{
                    Et[wt] = mt[wt]
                }
                );
                const xt = utils$1.toFiniteNumber(mt.headers.get("content-length"));
                mt = new Response(trackStream(mt.body, DEFAULT_CHUNK_SIZE, ot && fetchProgressDecorator(xt, progressEventReducer(ot, !0)), vt && ht, encodeText),Et)
            }
            at = at || "text";
            let bt = await resolvers[utils$1.findKey(resolvers, at) || "text"](mt, _);
            return !vt && ht(),
            pt && pt(),
            await new Promise((Et,xt)=>{
                settle(Et, xt, {
                    data: bt,
                    headers: AxiosHeaders$1.from(mt.headers),
                    status: mt.status,
                    statusText: mt.statusText,
                    config: _,
                    request: yt
                })
            }
            )
        } catch (mt) {
            throw ht(),
            mt && mt.name === "TypeError" && /fetch/i.test(mt.message) ? Object.assign(new AxiosError("Network Error",AxiosError.ERR_NETWORK,_,yt), {
                cause: mt.cause || mt
            }) : AxiosError.from(mt, mt && mt.code, _, yt)
        }
    }
    )
      , knownAdapters = {
        http: httpAdapter,
        xhr: xhrAdapter,
        fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (_,k)=>{
        if (_) {
            try {
                Object.defineProperty(_, "name", {
                    value: k
                })
            } catch (J) {}
            Object.defineProperty(_, "adapterName", {
                value: k
            })
        }
    }
    );
    const renderReason = _=>`- ${_}`
      , isResolvedHandle = _=>utils$1.isFunction(_) || _ === null || _ === !1
      , adapters = {
        getAdapter: _=>{
            _ = utils$1.isArray(_) ? _ : [_];
            const {length: k} = _;
            let J, et;
            const tt = {};
            for (let rt = 0; rt < k; rt++) {
                J = _[rt];
                let nt;
                if (et = J,
                !isResolvedHandle(J) && (et = knownAdapters[(nt = String(J)).toLowerCase()],
                et === void 0))
                    throw new AxiosError(`Unknown adapter '${nt}'`);
                if (et)
                    break;
                tt[nt || "#" + rt] = et
            }
            if (!et) {
                const rt = Object.entries(tt).map(([ot,it])=>`adapter ${ot} ` + (it === !1 ? "is not supported by the environment" : "is not available in the build"));
                let nt = k ? rt.length > 1 ? `since :
` + rt.map(renderReason).join(`
`) : " " + renderReason(rt[0]) : "as no adapter specified";
                throw new AxiosError("There is no suitable adapter to dispatch the request " + nt,"ERR_NOT_SUPPORT")
            }
            return et
        }
        ,
        adapters: knownAdapters
    };
    function throwIfCancellationRequested(_) {
        if (_.cancelToken && _.cancelToken.throwIfRequested(),
        _.signal && _.signal.aborted)
            throw new CanceledError(null,_)
    }
    function dispatchRequest(_) {
        return throwIfCancellationRequested(_),
        _.headers = AxiosHeaders$1.from(_.headers),
        _.data = transformData.call(_, _.transformRequest),
        ["post", "put", "patch"].indexOf(_.method) !== -1 && _.headers.setContentType("application/x-www-form-urlencoded", !1),
        adapters.getAdapter(_.adapter || defaults$2.adapter)(_).then(function(k) {
            return throwIfCancellationRequested(_),
            k.data = transformData.call(_, _.transformResponse, k),
            k.headers = AxiosHeaders$1.from(k.headers),
            k
        }, function(k) {
            return isCancel(k) || (throwIfCancellationRequested(_),
            k && k.response && (k.response.data = transformData.call(_, _.transformResponse, k.response),
            k.response.headers = AxiosHeaders$1.from(k.response.headers))),
            Promise.reject(k)
        })
    }
    const VERSION = "1.7.2"
      , validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((_,k)=>{
        validators$1[_] = function(J) {
            return typeof J === _ || "a" + (k < 1 ? "n " : " ") + _
        }
    }
    );
    const deprecatedWarnings = {};
    validators$1.transitional = function(_, k, J) {
        function et(tt, rt) {
            return "[Axios v" + VERSION + "] Transitional option '" + tt + "'" + rt + (J ? ". " + J : "")
        }
        return (tt,rt,nt)=>{
            if (_ === !1)
                throw new AxiosError(et(rt, " has been removed" + (k ? " in " + k : "")),AxiosError.ERR_DEPRECATED);
            return k && !deprecatedWarnings[rt] && (deprecatedWarnings[rt] = !0),
            _ ? _(tt, rt, nt) : !0
        }
    }
    ;
    function assertOptions(_, k, J) {
        if (typeof _ != "object")
            throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE);
        const et = Object.keys(_);
        let tt = et.length;
        for (; tt-- > 0; ) {
            const rt = et[tt]
              , nt = k[rt];
            if (nt) {
                const ot = _[rt]
                  , it = ot === void 0 || nt(ot, rt, _);
                if (it !== !0)
                    throw new AxiosError("option " + rt + " must be " + it,AxiosError.ERR_BAD_OPTION_VALUE);
                continue
            }
            if (J !== !0)
                throw new AxiosError("Unknown option " + rt,AxiosError.ERR_BAD_OPTION)
        }
    }
    const validator = {
        assertOptions,
        validators: validators$1
    }
      , validators = validator.validators;
    class Axios {
        constructor(k) {
            this.defaults = k,
            this.interceptors = {
                request: new InterceptorManager$1,
                response: new InterceptorManager$1
            }
        }
        async request(k, J) {
            try {
                return await this._request(k, J)
            } catch (et) {
                if (et instanceof Error) {
                    let tt;
                    Error.captureStackTrace ? Error.captureStackTrace(tt = {}) : tt = new Error;
                    const rt = tt.stack ? tt.stack.replace(/^.+\n/, "") : "";
                    try {
                        et.stack ? rt && !String(et.stack).endsWith(rt.replace(/^.+\n.+\n/, "")) && (et.stack += `
` + rt) : et.stack = rt
                    } catch (nt) {}
                }
                throw et
            }
        }
        _request(k, J) {
            typeof k == "string" ? (J = J || {},
            J.url = k) : J = k || {},
            J = mergeConfig(this.defaults, J);
            const {transitional: et, paramsSerializer: tt, headers: rt} = J;
            et !== void 0 && validator.assertOptions(et, {
                silentJSONParsing: validators.transitional(validators.boolean),
                forcedJSONParsing: validators.transitional(validators.boolean),
                clarifyTimeoutError: validators.transitional(validators.boolean)
            }, !1),
            tt != null && (utils$1.isFunction(tt) ? J.paramsSerializer = {
                serialize: tt
            } : validator.assertOptions(tt, {
                encode: validators.function,
                serialize: validators.function
            }, !0)),
            J.method = (J.method || this.defaults.method || "get").toLowerCase();
            let nt = rt && utils$1.merge(rt.common, rt[J.method]);
            rt && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], pt=>{
                delete rt[pt]
            }
            ),
            J.headers = AxiosHeaders$1.concat(nt, rt);
            const ot = [];
            let it = !0;
            this.interceptors.request.forEach(function(pt) {
                typeof pt.runWhen == "function" && pt.runWhen(J) === !1 || (it = it && pt.synchronous,
                ot.unshift(pt.fulfilled, pt.rejected))
            });
            const at = [];
            this.interceptors.response.forEach(function(pt) {
                at.push(pt.fulfilled, pt.rejected)
            });
            let lt, st = 0, ut;
            if (!it) {
                const pt = [dispatchRequest.bind(this), void 0];
                for (pt.unshift.apply(pt, ot),
                pt.push.apply(pt, at),
                ut = pt.length,
                lt = Promise.resolve(J); st < ut; )
                    lt = lt.then(pt[st++], pt[st++]);
                return lt
            }
            ut = ot.length;
            let ct = J;
            for (st = 0; st < ut; ) {
                const pt = ot[st++]
                  , ft = ot[st++];
                try {
                    ct = pt(ct)
                } catch (yt) {
                    ft.call(this, yt);
                    break
                }
            }
            try {
                lt = dispatchRequest.call(this, ct)
            } catch (pt) {
                return Promise.reject(pt)
            }
            for (st = 0,
            ut = at.length; st < ut; )
                lt = lt.then(at[st++], at[st++]);
            return lt
        }
        getUri(k) {
            k = mergeConfig(this.defaults, k);
            const J = buildFullPath(k.baseURL, k.url);
            return buildURL(J, k.params, k.paramsSerializer)
        }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function(_) {
        Axios.prototype[_] = function(k, J) {
            return this.request(mergeConfig(J || {}, {
                method: _,
                url: k,
                data: (J || {}).data
            }))
        }
    }),
    utils$1.forEach(["post", "put", "patch"], function(_) {
        function k(J) {
            return function(et, tt, rt) {
                return this.request(mergeConfig(rt || {}, {
                    method: _,
                    headers: J ? {
                        "Content-Type": "multipart/form-data"
                    } : {},
                    url: et,
                    data: tt
                }))
            }
        }
        Axios.prototype[_] = k(),
        Axios.prototype[_ + "Form"] = k(!0)
    });
    const Axios$1 = Axios;
    class CancelToken {
        constructor(k) {
            if (typeof k != "function")
                throw new TypeError("executor must be a function.");
            let J;
            this.promise = new Promise(function(tt) {
                J = tt
            }
            );
            const et = this;
            this.promise.then(tt=>{
                if (!et._listeners)
                    return;
                let rt = et._listeners.length;
                for (; rt-- > 0; )
                    et._listeners[rt](tt);
                et._listeners = null
            }
            ),
            this.promise.then = tt=>{
                let rt;
                const nt = new Promise(ot=>{
                    et.subscribe(ot),
                    rt = ot
                }
                ).then(tt);
                return nt.cancel = function() {
                    et.unsubscribe(rt)
                }
                ,
                nt
            }
            ,
            k(function(tt, rt, nt) {
                et.reason || (et.reason = new CanceledError(tt,rt,nt),
                J(et.reason))
            })
        }
        throwIfRequested() {
            if (this.reason)
                throw this.reason
        }
        subscribe(k) {
            if (this.reason) {
                k(this.reason);
                return
            }
            this._listeners ? this._listeners.push(k) : this._listeners = [k]
        }
        unsubscribe(k) {
            if (!this._listeners)
                return;
            const J = this._listeners.indexOf(k);
            J !== -1 && this._listeners.splice(J, 1)
        }
        static source() {
            let k;
            return {
                token: new CancelToken(function(J) {
                    k = J
                }
                ),
                cancel: k
            }
        }
    }
    const CancelToken$1 = CancelToken;
    function spread(_) {
        return function(k) {
            return _.apply(null, k)
        }
    }
    function isAxiosError(_) {
        return utils$1.isObject(_) && _.isAxiosError === !0
    }
    const HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([_,k])=>{
        HttpStatusCode[k] = _
    }
    );
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(_) {
        const k = new Axios$1(_)
          , J = bind$1(Axios$1.prototype.request, k);
        return utils$1.extend(J, Axios$1.prototype, k, {
            allOwnKeys: !0
        }),
        utils$1.extend(J, k, null, {
            allOwnKeys: !0
        }),
        J.create = function(et) {
            return createInstance(mergeConfig(_, et))
        }
        ,
        J
    }
    const axios = createInstance(defaults$2);
    axios.Axios = Axios$1,
    axios.CanceledError = CanceledError,
    axios.CancelToken = CancelToken$1,
    axios.isCancel = isCancel,
    axios.VERSION = VERSION,
    axios.toFormData = toFormData,
    axios.AxiosError = AxiosError,
    axios.Cancel = axios.CanceledError,
    axios.all = function(_) {
        return Promise.all(_)
    }
    ,
    axios.spread = spread,
    axios.isAxiosError = isAxiosError,
    axios.mergeConfig = mergeConfig,
    axios.AxiosHeaders = AxiosHeaders$1,
    axios.formToJSON = _=>formDataToJSON(utils$1.isHTMLForm(_) ? new FormData(_) : _),
    axios.getAdapter = adapters.getAdapter,
    axios.HttpStatusCode = HttpStatusCode$1,
    axios.default = axios;
    let axios$1;
    axios$1 = axios,
    MotionConfigContext = reactExports.createContext({
        transformPagePoint: _=>_,
        isStatic: !1,
        reducedMotion: "never"
    }),
    MotionContext = reactExports.createContext({}),
    PresenceContext = reactExports.createContext(null),
    isBrowser$1 = typeof document < "u",
    useIsomorphicLayoutEffect$2 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect,
    LazyContext = reactExports.createContext({
        strict: !1
    }),
    camelToDash = _=>_.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
    optimizedAppearDataId = "framerAppearId",
    optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
    function useVisualElement(_, k, J, et) {
        const {visualElement: tt} = reactExports.useContext(MotionContext)
          , rt = reactExports.useContext(LazyContext)
          , nt = reactExports.useContext(PresenceContext)
          , ot = reactExports.useContext(MotionConfigContext).reducedMotion
          , it = reactExports.useRef();
        et = et || rt.renderer,
        !it.current && et && (it.current = et(_, {
            visualState: k,
            parent: tt,
            props: J,
            presenceContext: nt,
            blockInitialAnimation: nt ? nt.initial === !1 : !1,
            reducedMotionConfig: ot
        }));
        const at = it.current;
        reactExports.useInsertionEffect(()=>{
            at && at.update(J, nt)
        }
        );
        const lt = reactExports.useRef(!!(J[optimizedAppearDataAttribute] && !window.HandoffComplete));
        return useIsomorphicLayoutEffect$2(()=>{
            at && (at.render(),
            lt.current && at.animationState && at.animationState.animateChanges())
        }
        ),
        reactExports.useEffect(()=>{
            at && (at.updateFeatures(),
            !lt.current && at.animationState && at.animationState.animateChanges(),
            lt.current && (lt.current = !1,
            window.HandoffComplete = !0))
        }
        ),
        at
    }
    function isRefObject(_) {
        return _ && typeof _ == "object" && Object.prototype.hasOwnProperty.call(_, "current")
    }
    function useMotionRef(_, k, J) {
        return reactExports.useCallback(et=>{
            et && _.mount && _.mount(et),
            k && (et ? k.mount(et) : k.unmount()),
            J && (typeof J == "function" ? J(et) : isRefObject(J) && (J.current = et))
        }
        , [k])
    }
    function isVariantLabel(_) {
        return typeof _ == "string" || Array.isArray(_)
    }
    function isAnimationControls(_) {
        return _ !== null && typeof _ == "object" && typeof _.start == "function"
    }
    const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
      , variantProps = ["initial", ...variantPriorityOrder];
    function isControllingVariants(_) {
        return isAnimationControls(_.animate) || variantProps.some(k=>isVariantLabel(_[k]))
    }
    function isVariantNode(_) {
        return !!(isControllingVariants(_) || _.variants)
    }
    function getCurrentTreeVariants(_, k) {
        if (isControllingVariants(_)) {
            const {initial: J, animate: et} = _;
            return {
                initial: J === !1 || isVariantLabel(J) ? J : void 0,
                animate: isVariantLabel(et) ? et : void 0
            }
        }
        return _.inherit !== !1 ? k : {}
    }
    function useCreateMotionContext(_) {
        const {initial: k, animate: J} = getCurrentTreeVariants(_, reactExports.useContext(MotionContext));
        return reactExports.useMemo(()=>({
            initial: k,
            animate: J
        }), [variantLabelsAsDependency(k), variantLabelsAsDependency(J)])
    }
    function variantLabelsAsDependency(_) {
        return Array.isArray(_) ? _.join(" ") : _
    }
    const featureProps = {
        animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"]
    }
      , featureDefinitions = {};
    for (const _ in featureProps)
        featureDefinitions[_] = {
            isEnabled: k=>featureProps[_].some(J=>!!k[J])
        };
    loadFeatures = function(_) {
        for (const k in _)
            featureDefinitions[k] = $t($t({}, featureDefinitions[k]), _[k])
    }
    ,
    LayoutGroupContext = reactExports.createContext({}),
    SwitchLayoutGroupContext = reactExports.createContext({}),
    motionComponentSymbol = Symbol.for("motionComponentSymbol"),
    createMotionComponent = function({preloadedFeatures: _, createVisualElement: k, useRender: J, useVisualState: et, Component: tt}) {
        _ && loadFeatures(_);
        function rt(ot, it) {
            let at;
            const lt = _t($t($t({}, reactExports.useContext(MotionConfigContext)), ot), {
                layoutId: useLayoutId(ot)
            })
              , {isStatic: st} = lt
              , ut = useCreateMotionContext(ot)
              , ct = et(ot, st);
            if (!st && isBrowser$1) {
                ut.visualElement = useVisualElement(tt, ct, lt, k);
                const pt = reactExports.useContext(SwitchLayoutGroupContext)
                  , ft = reactExports.useContext(LazyContext).strict;
                ut.visualElement && (at = ut.visualElement.loadFeatures(lt, ft, _, pt))
            }
            return reactExports.createElement(MotionContext.Provider, {
                value: ut
            }, at && ut.visualElement ? reactExports.createElement(at, $t({
                visualElement: ut.visualElement
            }, lt)) : null, J(tt, ot, useMotionRef(ct, ut.visualElement, it), ct, st, ut.visualElement))
        }
        const nt = reactExports.forwardRef(rt);
        return nt[motionComponentSymbol] = tt,
        nt
    }
    ;
    function useLayoutId({layoutId: _}) {
        const k = reactExports.useContext(LayoutGroupContext).id;
        return k && _ !== void 0 ? k + "-" + _ : _
    }
    createMotionProxy = function(_) {
        function k(et, tt={}) {
            return createMotionComponent(_(et, tt))
        }
        if (typeof Proxy > "u")
            return k;
        const J = new Map;
        return new Proxy(k,{
            get: (et,tt)=>(J.has(tt) || J.set(tt, k(tt)),
            J.get(tt))
        })
    }
    ;
    const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
    function isSVGComponent(_) {
        return typeof _ != "string" || _.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(_) > -1 || /[A-Z]/.test(_))
    }
    const scaleCorrectors = {};
    addScaleCorrector = function(_) {
        Object.assign(scaleCorrectors, _)
    }
    ;
    let transformPropOrder;
    transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    transformProps = new Set(transformPropOrder);
    function isForcedMotionValue(_, {layout: k, layoutId: J}) {
        return transformProps.has(_) || _.startsWith("origin") || (k || J !== void 0) && (!!scaleCorrectors[_] || _ === "opacity")
    }
    let translateAlias, numTransforms;
    isMotionValue = _=>!!(_ && _.getVelocity),
    translateAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    numTransforms = transformPropOrder.length,
    buildTransform = function(_, {enableHardwareAcceleration: k=!0, allowTransformNone: J=!0}, et, tt) {
        let rt = "";
        for (let nt = 0; nt < numTransforms; nt++) {
            const ot = transformPropOrder[nt];
            if (_[ot] !== void 0) {
                const it = translateAlias[ot] || ot;
                rt += `${it}(${_[ot]}) `
            }
        }
        return k && !_.z && (rt += "translateZ(0)"),
        rt = rt.trim(),
        tt ? rt = tt(_, et ? "" : rt) : J && et && (rt = "none"),
        rt
    }
    ;
    let checkStringStartsWith, isCSSVariableToken, cssVariableRegex, getValueAsType, number, alpha, scale, sanitize, floatRegex, colorRegex, singleColorRegex;
    checkStringStartsWith = _=>k=>typeof k == "string" && k.startsWith(_),
    isCSSVariableName = checkStringStartsWith("--"),
    isCSSVariableToken = checkStringStartsWith("var(--"),
    cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
    getValueAsType = (_,k)=>k && typeof _ == "number" ? k.transform(_) : _,
    clamp = (_,k,J)=>Math.min(Math.max(J, _), k),
    number = {
        test: _=>typeof _ == "number",
        parse: parseFloat,
        transform: _=>_
    },
    alpha = _t($t({}, number), {
        transform: _=>clamp(0, 1, _)
    }),
    scale = _t($t({}, number), {
        default: 1
    }),
    sanitize = _=>Math.round(_ * 1e5) / 1e5,
    floatRegex = /(-)?([\d]*\.?[\d])+/g,
    colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
    singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
    function isString(_) {
        return typeof _ == "string"
    }
    let createUnitType, degrees, percent, vh$1, vw, progressPercentage, int, numberValueTypes;
    createUnitType = _=>({
        test: k=>isString(k) && k.endsWith(_) && k.split(" ").length === 1,
        parse: parseFloat,
        transform: k=>`${k}${_}`
    }),
    degrees = createUnitType("deg"),
    percent = createUnitType("%"),
    px = createUnitType("px"),
    vh$1 = createUnitType("vh"),
    vw = createUnitType("vw"),
    progressPercentage = _t($t({}, percent), {
        parse: _=>percent.parse(_) / 100,
        transform: _=>percent.transform(_ * 100)
    }),
    int = _t($t({}, number), {
        transform: Math.round
    }),
    numberValueTypes = {
        borderWidth: px,
        borderTopWidth: px,
        borderRightWidth: px,
        borderBottomWidth: px,
        borderLeftWidth: px,
        borderRadius: px,
        radius: px,
        borderTopLeftRadius: px,
        borderTopRightRadius: px,
        borderBottomRightRadius: px,
        borderBottomLeftRadius: px,
        width: px,
        maxWidth: px,
        height: px,
        maxHeight: px,
        size: px,
        top: px,
        right: px,
        bottom: px,
        left: px,
        padding: px,
        paddingTop: px,
        paddingRight: px,
        paddingBottom: px,
        paddingLeft: px,
        margin: px,
        marginTop: px,
        marginRight: px,
        marginBottom: px,
        marginLeft: px,
        rotate: degrees,
        rotateX: degrees,
        rotateY: degrees,
        rotateZ: degrees,
        scale,
        scaleX: scale,
        scaleY: scale,
        scaleZ: scale,
        skew: degrees,
        skewX: degrees,
        skewY: degrees,
        distance: px,
        translateX: px,
        translateY: px,
        translateZ: px,
        x: px,
        y: px,
        z: px,
        perspective: px,
        transformPerspective: px,
        opacity: alpha,
        originX: progressPercentage,
        originY: progressPercentage,
        originZ: px,
        zIndex: int,
        fillOpacity: alpha,
        strokeOpacity: alpha,
        numOctaves: int
    };
    function buildHTMLStyles(_, k, J, et) {
        const {style: tt, vars: rt, transform: nt, transformOrigin: ot} = _;
        let it = !1
          , at = !1
          , lt = !0;
        for (const st in k) {
            const ut = k[st];
            if (isCSSVariableName(st)) {
                rt[st] = ut;
                continue
            }
            const ct = numberValueTypes[st]
              , pt = getValueAsType(ut, ct);
            if (transformProps.has(st)) {
                if (it = !0,
                nt[st] = pt,
                !lt)
                    continue;
                ut !== (ct.default || 0) && (lt = !1)
            } else
                st.startsWith("origin") ? (at = !0,
                ot[st] = pt) : tt[st] = pt
        }
        if (k.transform || (it || et ? tt.transform = buildTransform(_.transform, J, lt, et) : tt.transform && (tt.transform = "none")),
        at) {
            const {originX: st="50%", originY: ut="50%", originZ: ct=0} = ot;
            tt.transformOrigin = `${st} ${ut} ${ct}`
        }
    }
    const createHtmlRenderState = ()=>({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {}
    });
    function copyRawValuesOnly(_, k, J) {
        for (const et in k)
            !isMotionValue(k[et]) && !isForcedMotionValue(et, J) && (_[et] = k[et])
    }
    function useInitialMotionValues({transformTemplate: _}, k, J) {
        return reactExports.useMemo(()=>{
            const et = createHtmlRenderState();
            return buildHTMLStyles(et, k, {
                enableHardwareAcceleration: !J
            }, _),
            Object.assign({}, et.vars, et.style)
        }
        , [k])
    }
    function useStyle(_, k, J) {
        const et = _.style || {}
          , tt = {};
        return copyRawValuesOnly(tt, et, _),
        Object.assign(tt, useInitialMotionValues(_, k, J)),
        _.transformValues ? _.transformValues(tt) : tt
    }
    function useHTMLProps(_, k, J) {
        const et = {}
          , tt = useStyle(_, k, J);
        return _.drag && _.dragListener !== !1 && (et.draggable = !1,
        tt.userSelect = tt.WebkitUserSelect = tt.WebkitTouchCallout = "none",
        tt.touchAction = _.drag === !0 ? "none" : `pan-${_.drag === "x" ? "y" : "x"}`),
        _.tabIndex === void 0 && (_.onTap || _.onTapStart || _.whileTap) && (et.tabIndex = 0),
        et.style = tt,
        et
    }
    const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
    isValidMotionProp = function(_) {
        return _.startsWith("while") || _.startsWith("drag") && _ !== "draggable" || _.startsWith("layout") || _.startsWith("onTap") || _.startsWith("onPan") || _.startsWith("onLayout") || validMotionProps.has(_)
    }
    ;
    let shouldForward = _=>!isValidMotionProp(_);
    loadExternalIsValidProp = function(_) {
        _ && (shouldForward = k=>k.startsWith("on") ? !isValidMotionProp(k) : _(k))
    }
    ;
    try {
        loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
    } catch (_) {}
    filterProps = function(_, k, J) {
        const et = {};
        for (const tt in _)
            tt === "values" && typeof _.values == "object" || (shouldForward(tt) || J === !0 && isValidMotionProp(tt) || !k && !isValidMotionProp(tt) || _.draggable && tt.startsWith("onDrag")) && (et[tt] = _[tt]);
        return et
    }
    ;
    function calcOrigin$1(_, k, J) {
        return typeof _ == "string" ? _ : px.transform(k + J * _)
    }
    function calcSVGTransformOrigin(_, k, J) {
        const et = calcOrigin$1(k, _.x, _.width)
          , tt = calcOrigin$1(J, _.y, _.height);
        return `${et} ${tt}`
    }
    const dashKeys = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    }
      , camelKeys = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };
    function buildSVGPath(_, k, J=1, et=0, tt=!0) {
        _.pathLength = 1;
        const rt = tt ? dashKeys : camelKeys;
        _[rt.offset] = px.transform(-et);
        const nt = px.transform(k)
          , ot = px.transform(J);
        _[rt.array] = `${nt} ${ot}`
    }
    function buildSVGAttrs(_, ct, lt, st, ut) {
        var pt = ct
          , {attrX: k, attrY: J, attrScale: et, originX: tt, originY: rt, pathLength: nt, pathSpacing: ot=1, pathOffset: it=0} = pt
          , at = Kt(pt, ["attrX", "attrY", "attrScale", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
        if (buildHTMLStyles(_, at, lt, ut),
        st) {
            _.style.viewBox && (_.attrs.viewBox = _.style.viewBox);
            return
        }
        _.attrs = _.style,
        _.style = {};
        const {attrs: ft, style: yt, dimensions: ht} = _;
        ft.transform && (ht && (yt.transform = ft.transform),
        delete ft.transform),
        ht && (tt !== void 0 || rt !== void 0 || yt.transform) && (yt.transformOrigin = calcSVGTransformOrigin(ht, tt !== void 0 ? tt : .5, rt !== void 0 ? rt : .5)),
        k !== void 0 && (ft.x = k),
        J !== void 0 && (ft.y = J),
        et !== void 0 && (ft.scale = et),
        nt !== void 0 && buildSVGPath(ft, nt, ot, it, !1)
    }
    const createSvgRenderState = ()=>_t($t({}, createHtmlRenderState()), {
        attrs: {}
    })
      , isSVGTag = _=>typeof _ == "string" && _.toLowerCase() === "svg";
    function useSVGProps(_, k, J, et) {
        const tt = reactExports.useMemo(()=>{
            const rt = createSvgRenderState();
            return buildSVGAttrs(rt, k, {
                enableHardwareAcceleration: !1
            }, isSVGTag(et), _.transformTemplate),
            _t($t({}, rt.attrs), {
                style: $t({}, rt.style)
            })
        }
        , [k]);
        if (_.style) {
            const rt = {};
            copyRawValuesOnly(rt, _.style, _),
            tt.style = $t($t({}, rt), tt.style)
        }
        return tt
    }
    function createUseRender(_=!1) {
        return (k,J,et,{latestValues: tt},rt)=>{
            const nt = (isSVGComponent(k) ? useSVGProps : useHTMLProps)(J, tt, rt, k)
              , ot = _t($t($t({}, filterProps(J, typeof k == "string", _)), nt), {
                ref: et
            })
              , {children: it} = J
              , at = reactExports.useMemo(()=>isMotionValue(it) ? it.get() : it, [it]);
            return reactExports.createElement(k, _t($t({}, ot), {
                children: at
            }))
        }
    }
    function renderHTML(_, {style: k, vars: J}, et, tt) {
        Object.assign(_.style, k, tt && tt.getProjectionStyles(et));
        for (const rt in J)
            _.style.setProperty(rt, J[rt])
    }
    const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
    function renderSVG(_, k, J, et) {
        renderHTML(_, k, void 0, et);
        for (const tt in k.attrs)
            _.setAttribute(camelCaseAttributes.has(tt) ? tt : camelToDash(tt), k.attrs[tt])
    }
    function scrapeMotionValuesFromProps$1(_, k) {
        const {style: J} = _
          , et = {};
        for (const tt in J)
            (isMotionValue(J[tt]) || k.style && isMotionValue(k.style[tt]) || isForcedMotionValue(tt, _)) && (et[tt] = J[tt]);
        return et
    }
    function scrapeMotionValuesFromProps(_, k) {
        const J = scrapeMotionValuesFromProps$1(_, k);
        for (const et in _)
            if (isMotionValue(_[et]) || isMotionValue(k[et])) {
                const tt = transformPropOrder.indexOf(et) !== -1 ? "attr" + et.charAt(0).toUpperCase() + et.substring(1) : et;
                J[tt] = _[et]
            }
        return J
    }
    function resolveVariantFromProps(_, k, J, et={}, tt={}) {
        return typeof k == "function" && (k = k(J !== void 0 ? J : _.custom, et, tt)),
        typeof k == "string" && (k = _.variants && _.variants[k]),
        typeof k == "function" && (k = k(J !== void 0 ? J : _.custom, et, tt)),
        k
    }
    useConstant = function(_) {
        const k = reactExports.useRef(null);
        return k.current === null && (k.current = _()),
        k.current
    }
    ;
    const isKeyframesTarget = _=>Array.isArray(_)
      , isCustomValue = _=>!!(_ && typeof _ == "object" && _.mix && _.toValue)
      , resolveFinalValueInKeyframes = _=>isKeyframesTarget(_) ? _[_.length - 1] || 0 : _;
    resolveMotionValue = function(_) {
        const k = isMotionValue(_) ? _.get() : _;
        return isCustomValue(k) ? k.toValue() : k
    }
    ;
    function makeState({scrapeMotionValuesFromProps: _, createRenderState: k, onMount: J}, et, tt, rt) {
        const nt = {
            latestValues: makeLatestValues(et, tt, rt, _),
            renderState: k()
        };
        return J && (nt.mount = ot=>J(et, ot, nt)),
        nt
    }
    makeUseVisualState = _=>(k,J)=>{
        const et = reactExports.useContext(MotionContext)
          , tt = reactExports.useContext(PresenceContext)
          , rt = ()=>makeState(_, k, et, tt);
        return J ? rt() : useConstant(rt)
    }
    ;
    function makeLatestValues(_, k, J, et) {
        const tt = {}
          , rt = et(_, {});
        for (const ut in rt)
            tt[ut] = resolveMotionValue(rt[ut]);
        let {initial: nt, animate: ot} = _;
        const it = isControllingVariants(_)
          , at = isVariantNode(_);
        k && at && !it && _.inherit !== !1 && (nt === void 0 && (nt = k.initial),
        ot === void 0 && (ot = k.animate));
        let lt = J ? J.initial === !1 : !1;
        lt = lt || nt === !1;
        const st = lt ? ot : nt;
        return st && typeof st != "boolean" && !isAnimationControls(st) && (Array.isArray(st) ? st : [st]).forEach(ut=>{
            const ct = resolveVariantFromProps(_, ut);
            if (!ct)
                return;
            const ht = ct
              , {transitionEnd: pt, transition: ft} = ht
              , yt = Kt(ht, ["transitionEnd", "transition"]);
            for (const gt in yt) {
                let mt = yt[gt];
                if (Array.isArray(mt)) {
                    const vt = lt ? mt.length - 1 : 0;
                    mt = mt[vt]
                }
                mt !== null && (tt[gt] = mt)
            }
            for (const gt in pt)
                tt[gt] = pt[gt]
        }
        ),
        tt
    }
    noop$4 = _=>_;
    class Queue {
        constructor() {
            this.order = [],
            this.scheduled = new Set
        }
        add(k) {
            if (!this.scheduled.has(k))
                return this.scheduled.add(k),
                this.order.push(k),
                !0
        }
        remove(k) {
            const J = this.order.indexOf(k);
            J !== -1 && (this.order.splice(J, 1),
            this.scheduled.delete(k))
        }
        clear() {
            this.order.length = 0,
            this.scheduled.clear()
        }
    }
    function createRenderStep(_) {
        let k = new Queue
          , J = new Queue
          , et = 0
          , tt = !1
          , rt = !1;
        const nt = new WeakSet
          , ot = {
            schedule: (it,at=!1,lt=!1)=>{
                const st = lt && tt
                  , ut = st ? k : J;
                return at && nt.add(it),
                ut.add(it) && st && tt && (et = k.order.length),
                it
            }
            ,
            cancel: it=>{
                J.remove(it),
                nt.delete(it)
            }
            ,
            process: it=>{
                if (tt) {
                    rt = !0;
                    return
                }
                if (tt = !0,
                [k,J] = [J, k],
                J.clear(),
                et = k.order.length,
                et)
                    for (let at = 0; at < et; at++) {
                        const lt = k.order[at];
                        lt(it),
                        nt.has(lt) && (ot.schedule(lt),
                        _())
                    }
                tt = !1,
                rt && (rt = !1,
                ot.process(it))
            }
        };
        return ot
    }
    let maxElapsed;
    stepsOrder = ["prepare", "read", "update", "preRender", "render", "postRender"],
    maxElapsed = 40;
    function createRenderBatcher(_, k) {
        let J = !1
          , et = !0;
        const tt = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        }
          , rt = stepsOrder.reduce((at,lt)=>(at[lt] = createRenderStep(()=>J = !0),
        at), {})
          , nt = at=>rt[at].process(tt)
          , ot = ()=>{
            const at = performance.now();
            J = !1,
            tt.delta = et ? 1e3 / 60 : Math.max(Math.min(at - tt.timestamp, maxElapsed), 1),
            tt.timestamp = at,
            tt.isProcessing = !0,
            stepsOrder.forEach(nt),
            tt.isProcessing = !1,
            J && k && (et = !1,
            _(ot))
        }
          , it = ()=>{
            J = !0,
            et = !0,
            tt.isProcessing || _(ot)
        }
        ;
        return {
            schedule: stepsOrder.reduce((at,lt)=>{
                const st = rt[lt];
                return at[lt] = (ut,ct=!1,pt=!1)=>(J || it(),
                st.schedule(ut, ct, pt)),
                at
            }
            , {}),
            cancel: at=>stepsOrder.forEach(lt=>rt[lt].cancel(at)),
            state: tt,
            steps: rt
        }
    }
    let svgMotionConfig, htmlMotionConfig;
    ({schedule: frame, cancel: cancelFrame, state: frameData, steps} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop$4, !0)),
    svgMotionConfig = {
        useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps,
            createRenderState: createSvgRenderState,
            onMount: (_,k,{renderState: J, latestValues: et})=>{
                frame.read(()=>{
                    try {
                        J.dimensions = typeof k.getBBox == "function" ? k.getBBox() : k.getBoundingClientRect()
                    } catch (tt) {
                        J.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }
                ),
                frame.render(()=>{
                    buildSVGAttrs(J, et, {
                        enableHardwareAcceleration: !1
                    }, isSVGTag(k.tagName), _.transformTemplate),
                    renderSVG(k, J)
                }
                )
            }
        })
    },
    htmlMotionConfig = {
        useVisualState: makeUseVisualState({
            scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
            createRenderState: createHtmlRenderState
        })
    },
    createDomMotionConfig = function(_, {forwardMotionProps: k=!1}, J, et) {
        return _t($t({}, isSVGComponent(_) ? svgMotionConfig : htmlMotionConfig), {
            preloadedFeatures: J,
            useRender: createUseRender(k),
            createVisualElement: et,
            Component: _
        })
    }
    ,
    addDomEvent = function(_, k, J, et={
        passive: !0
    }) {
        return _.addEventListener(k, J, et),
        ()=>_.removeEventListener(k, J)
    }
    ;
    const isPrimaryPointer = _=>_.pointerType === "mouse" ? typeof _.button != "number" || _.button <= 0 : _.isPrimary !== !1;
    function extractEventInfo(_, k="page") {
        return {
            point: {
                x: _[k + "X"],
                y: _[k + "Y"]
            }
        }
    }
    addPointerInfo = _=>k=>isPrimaryPointer(k) && _(k, extractEventInfo(k)),
    addPointerEvent = function(_, k, J, et) {
        return addDomEvent(_, k, addPointerInfo(J), et)
    }
    ;
    let combineFunctions;
    combineFunctions = (_,k)=>J=>k(_(J)),
    pipe = (..._)=>_.reduce(combineFunctions);
    function createLock(_) {
        let k = null;
        return ()=>{
            const J = ()=>{
                k = null
            }
            ;
            return k === null ? (k = _,
            J) : !1
        }
    }
    const globalHorizontalLock = createLock("dragHorizontal")
      , globalVerticalLock = createLock("dragVertical");
    function getGlobalLock(_) {
        let k = !1;
        if (_ === "y")
            k = globalVerticalLock();
        else if (_ === "x")
            k = globalHorizontalLock();
        else {
            const J = globalHorizontalLock()
              , et = globalVerticalLock();
            J && et ? k = ()=>{
                J(),
                et()
            }
            : (J && J(),
            et && et())
        }
        return k
    }
    isDragActive = function() {
        const _ = getGlobalLock(!0);
        return _ ? (_(),
        !1) : !0
    }
    ;
    class Feature {
        constructor(k) {
            this.isMounted = !1,
            this.node = k
        }
        update() {}
    }
    function addHoverEvent(_, k) {
        const J = "pointer" + (k ? "enter" : "leave")
          , et = "onHover" + (k ? "Start" : "End")
          , tt = (rt,nt)=>{
            if (rt.pointerType === "touch" || isDragActive())
                return;
            const ot = _.getProps();
            _.animationState && ot.whileHover && _.animationState.setActive("whileHover", k),
            ot[et] && frame.update(()=>ot[et](rt, nt))
        }
        ;
        return addPointerEvent(_.current, J, tt, {
            passive: !_.getProps()[et]
        })
    }
    class HoverGesture extends Feature {
        mount() {
            this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
        }
        unmount() {}
    }
    class FocusGesture extends Feature {
        constructor() {
            super(...arguments),
            this.isActive = !1
        }
        onFocus() {
            let k = !1;
            try {
                k = this.node.current.matches(":focus-visible")
            } catch (J) {
                k = !0
            }
            !k || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
            this.isActive = !0)
        }
        onBlur() {
            !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
            this.isActive = !1)
        }
        mount() {
            this.unmount = pipe(addDomEvent(this.node.current, "focus", ()=>this.onFocus()), addDomEvent(this.node.current, "blur", ()=>this.onBlur()))
        }
        unmount() {}
    }
    const isNodeOrChild = (_,k)=>k ? _ === k ? !0 : isNodeOrChild(_, k.parentElement) : !1;
    function fireSyntheticPointerEvent(_, k) {
        if (!k)
            return;
        const J = new PointerEvent("pointer" + _);
        k(J, extractEventInfo(J))
    }
    class PressGesture extends Feature {
        constructor() {
            super(...arguments),
            this.removeStartListeners = noop$4,
            this.removeEndListeners = noop$4,
            this.removeAccessibleListeners = noop$4,
            this.startPointerPress = (k,J)=>{
                if (this.isPressing)
                    return;
                this.removeEndListeners();
                const et = this.node.getProps()
                  , tt = addPointerEvent(window, "pointerup", (nt,ot)=>{
                    if (!this.checkPressEnd())
                        return;
                    const {onTap: it, onTapCancel: at, globalTapTarget: lt} = this.node.getProps();
                    frame.update(()=>{
                        !lt && !isNodeOrChild(this.node.current, nt.target) ? at && at(nt, ot) : it && it(nt, ot)
                    }
                    )
                }
                , {
                    passive: !(et.onTap || et.onPointerUp)
                })
                  , rt = addPointerEvent(window, "pointercancel", (nt,ot)=>this.cancelPress(nt, ot), {
                    passive: !(et.onTapCancel || et.onPointerCancel)
                });
                this.removeEndListeners = pipe(tt, rt),
                this.startPress(k, J)
            }
            ,
            this.startAccessiblePress = ()=>{
                const k = rt=>{
                    if (rt.key !== "Enter" || this.isPressing)
                        return;
                    const nt = ot=>{
                        ot.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (it,at)=>{
                            const {onTap: lt} = this.node.getProps();
                            lt && frame.update(()=>lt(it, at))
                        }
                        )
                    }
                    ;
                    this.removeEndListeners(),
                    this.removeEndListeners = addDomEvent(this.node.current, "keyup", nt),
                    fireSyntheticPointerEvent("down", (ot,it)=>{
                        this.startPress(ot, it)
                    }
                    )
                }
                  , J = addDomEvent(this.node.current, "keydown", k)
                  , et = ()=>{
                    this.isPressing && fireSyntheticPointerEvent("cancel", (rt,nt)=>this.cancelPress(rt, nt))
                }
                  , tt = addDomEvent(this.node.current, "blur", et);
                this.removeAccessibleListeners = pipe(J, tt)
            }
        }
        startPress(k, J) {
            this.isPressing = !0;
            const {onTapStart: et, whileTap: tt} = this.node.getProps();
            tt && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
            et && frame.update(()=>et(k, J))
        }
        checkPressEnd() {
            return this.removeEndListeners(),
            this.isPressing = !1,
            this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
            !isDragActive()
        }
        cancelPress(k, J) {
            if (!this.checkPressEnd())
                return;
            const {onTapCancel: et} = this.node.getProps();
            et && frame.update(()=>et(k, J))
        }
        mount() {
            const k = this.node.getProps()
              , J = addPointerEvent(k.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
                passive: !(k.onTapStart || k.onPointerStart)
            })
              , et = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
            this.removeStartListeners = pipe(J, et)
        }
        unmount() {
            this.removeStartListeners(),
            this.removeEndListeners(),
            this.removeAccessibleListeners()
        }
    }
    const observerCallbacks = new WeakMap
      , observers = new WeakMap
      , fireObserverCallback = _=>{
        const k = observerCallbacks.get(_.target);
        k && k(_)
    }
      , fireAllObserverCallbacks = _=>{
        _.forEach(fireObserverCallback)
    }
    ;
    function initIntersectionObserver(J) {
        var et = J
          , {root: _} = et
          , k = Kt(et, ["root"]);
        const tt = _ || document;
        observers.has(tt) || observers.set(tt, {});
        const rt = observers.get(tt)
          , nt = JSON.stringify(k);
        return rt[nt] || (rt[nt] = new IntersectionObserver(fireAllObserverCallbacks,$t({
            root: _
        }, k))),
        rt[nt]
    }
    function observeIntersection(_, k, J) {
        const et = initIntersectionObserver(k);
        return observerCallbacks.set(_, J),
        et.observe(_),
        ()=>{
            observerCallbacks.delete(_),
            et.unobserve(_)
        }
    }
    const thresholdNames = {
        some: 0,
        all: 1
    };
    class InViewFeature extends Feature {
        constructor() {
            super(...arguments),
            this.hasEnteredView = !1,
            this.isInView = !1
        }
        startObserver() {
            this.unmount();
            const {viewport: k={}} = this.node.getProps()
              , {root: J, margin: et, amount: tt="some", once: rt} = k
              , nt = {
                root: J ? J.current : void 0,
                rootMargin: et,
                threshold: typeof tt == "number" ? tt : thresholdNames[tt]
            }
              , ot = it=>{
                const {isIntersecting: at} = it;
                if (this.isInView === at || (this.isInView = at,
                rt && !at && this.hasEnteredView))
                    return;
                at && (this.hasEnteredView = !0),
                this.node.animationState && this.node.animationState.setActive("whileInView", at);
                const {onViewportEnter: lt, onViewportLeave: st} = this.node.getProps()
                  , ut = at ? lt : st;
                ut && ut(it)
            }
            ;
            return observeIntersection(this.node.current, nt, ot)
        }
        mount() {
            this.startObserver()
        }
        update() {
            if (typeof IntersectionObserver > "u")
                return;
            const {props: k, prevProps: J} = this.node;
            ["amount", "margin", "root"].some(hasViewportOptionChanged(k, J)) && this.startObserver()
        }
        unmount() {}
    }
    function hasViewportOptionChanged({viewport: _={}}, {viewport: k={}}={}) {
        return J=>_[J] !== k[J]
    }
    gestureAnimations = {
        inView: {
            Feature: InViewFeature
        },
        tap: {
            Feature: PressGesture
        },
        focus: {
            Feature: FocusGesture
        },
        hover: {
            Feature: HoverGesture
        }
    };
    function shallowCompare(_, k) {
        if (!Array.isArray(k))
            return !1;
        const J = k.length;
        if (J !== _.length)
            return !1;
        for (let et = 0; et < J; et++)
            if (k[et] !== _[et])
                return !1;
        return !0
    }
    function getCurrent(_) {
        const k = {};
        return _.values.forEach((J,et)=>k[et] = J.get()),
        k
    }
    function getVelocity$1(_) {
        const k = {};
        return _.values.forEach((J,et)=>k[et] = J.getVelocity()),
        k
    }
    function resolveVariant(_, k, J) {
        const et = _.getProps();
        return resolveVariantFromProps(et, k, J !== void 0 ? J : et.custom, getCurrent(_), getVelocity$1(_))
    }
    warning$1 = noop$4,
    invariant$1 = noop$4;
    let secondsToMilliseconds, isBezierDefinition;
    secondsToMilliseconds = _=>_ * 1e3,
    millisecondsToSeconds = _=>_ / 1e3,
    instantAnimationState = {
        current: !1
    },
    isBezierDefinition = _=>Array.isArray(_) && typeof _[0] == "number";
    function isWaapiSupportedEasing(_) {
        return !!(!_ || typeof _ == "string" && supportedWaapiEasing[_] || isBezierDefinition(_) || Array.isArray(_) && _.every(isWaapiSupportedEasing))
    }
    const cubicBezierAsString = ([_,k,J,et])=>`cubic-bezier(${_}, ${k}, ${J}, ${et})`
      , supportedWaapiEasing = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: cubicBezierAsString([0, .65, .55, 1]),
        circOut: cubicBezierAsString([.55, 0, 1, .45]),
        backIn: cubicBezierAsString([.31, .01, .66, -.59]),
        backOut: cubicBezierAsString([.33, 1.53, .69, .99])
    };
    function mapEasingToNativeEasing(_) {
        if (_)
            return isBezierDefinition(_) ? cubicBezierAsString(_) : Array.isArray(_) ? _.map(mapEasingToNativeEasing) : supportedWaapiEasing[_]
    }
    animateStyle = function(_, k, J, {delay: et=0, duration: tt, repeat: rt=0, repeatType: nt="loop", ease: ot, times: it}={}) {
        const at = {
            [k]: J
        };
        it && (at.offset = it);
        const lt = mapEasingToNativeEasing(ot);
        return Array.isArray(lt) && (at.easing = lt),
        _.animate(at, {
            delay: et,
            duration: tt,
            easing: Array.isArray(lt) ? "linear" : lt,
            fill: "both",
            iterations: rt + 1,
            direction: nt === "reverse" ? "alternate" : "normal"
        })
    }
    ;
    function getFinalKeyframe(_, {repeat: k, repeatType: J="loop"}) {
        const et = k && J !== "loop" && k % 2 === 1 ? 0 : _.length - 1;
        return _[et]
    }
    const calcBezier = (_,k,J)=>(((1 - 3 * J + 3 * k) * _ + (3 * J - 6 * k)) * _ + 3 * k) * _
      , subdivisionPrecision = 1e-7
      , subdivisionMaxIterations = 12;
    function binarySubdivide(_, k, J, et, tt) {
        let rt, nt, ot = 0;
        do
            nt = k + (J - k) / 2,
            rt = calcBezier(nt, et, tt) - _,
            rt > 0 ? J = nt : k = nt;
        while (Math.abs(rt) > subdivisionPrecision && ++ot < subdivisionMaxIterations);
        return nt
    }
    cubicBezier = function(_, k, J, et) {
        if (_ === k && J === et)
            return noop$4;
        const tt = rt=>binarySubdivide(rt, 0, 1, _, J);
        return rt=>rt === 0 || rt === 1 ? rt : calcBezier(tt(rt), k, et)
    }
    ;
    let isEasingArray, easingLookup, isColorString, splitColor, clampRgbUnit, rgbUnit, rgba;
    easeIn = cubicBezier(.42, 0, 1, 1),
    easeOut = cubicBezier(0, 0, .58, 1),
    easeInOut = cubicBezier(.42, 0, .58, 1),
    isEasingArray = _=>Array.isArray(_) && typeof _[0] != "number",
    mirrorEasing = _=>k=>k <= .5 ? _(2 * k) / 2 : (2 - _(2 * (1 - k))) / 2,
    reverseEasing = _=>k=>1 - _(1 - k),
    circIn = _=>1 - Math.sin(Math.acos(_)),
    circOut = reverseEasing(circIn),
    circInOut = mirrorEasing(circIn),
    backOut = cubicBezier(.33, 1.53, .69, .99),
    backIn = reverseEasing(backOut),
    backInOut = mirrorEasing(backIn),
    anticipate = _=>(_ *= 2) < 1 ? .5 * backIn(_) : .5 * (2 - Math.pow(2, -10 * (_ - 1))),
    easingLookup = {
        linear: noop$4,
        easeIn,
        easeInOut,
        easeOut,
        circIn,
        circInOut,
        circOut,
        backIn,
        backInOut,
        backOut,
        anticipate
    },
    easingDefinitionToFunction = _=>{
        if (Array.isArray(_)) {
            invariant$1(_.length === 4);
            const [k,J,et,tt] = _;
            return cubicBezier(k, J, et, tt)
        } else if (typeof _ == "string")
            return easingLookup[_];
        return _
    }
    ,
    isColorString = (_,k)=>J=>!!(isString(J) && singleColorRegex.test(J) && J.startsWith(_) || k && Object.prototype.hasOwnProperty.call(J, k)),
    splitColor = (_,k,J)=>et=>{
        if (!isString(et))
            return et;
        const [tt,rt,nt,ot] = et.match(floatRegex);
        return {
            [_]: parseFloat(tt),
            [k]: parseFloat(rt),
            [J]: parseFloat(nt),
            alpha: ot !== void 0 ? parseFloat(ot) : 1
        }
    }
    ,
    clampRgbUnit = _=>clamp(0, 255, _),
    rgbUnit = _t($t({}, number), {
        transform: _=>Math.round(clampRgbUnit(_))
    }),
    rgba = {
        test: isColorString("rgb", "red"),
        parse: splitColor("red", "green", "blue"),
        transform: ({red: _, green: k, blue: J, alpha: et=1})=>"rgba(" + rgbUnit.transform(_) + ", " + rgbUnit.transform(k) + ", " + rgbUnit.transform(J) + ", " + sanitize(alpha.transform(et)) + ")"
    };
    function parseHex(_) {
        let k = ""
          , J = ""
          , et = ""
          , tt = "";
        return _.length > 5 ? (k = _.substring(1, 3),
        J = _.substring(3, 5),
        et = _.substring(5, 7),
        tt = _.substring(7, 9)) : (k = _.substring(1, 2),
        J = _.substring(2, 3),
        et = _.substring(3, 4),
        tt = _.substring(4, 5),
        k += k,
        J += J,
        et += et,
        tt += tt),
        {
            red: parseInt(k, 16),
            green: parseInt(J, 16),
            blue: parseInt(et, 16),
            alpha: tt ? parseInt(tt, 16) / 255 : 1
        }
    }
    let hex, hsla;
    hex = {
        test: isColorString("#"),
        parse: parseHex,
        transform: rgba.transform
    },
    hsla = {
        test: isColorString("hsl", "hue"),
        parse: splitColor("hue", "saturation", "lightness"),
        transform: ({hue: _, saturation: k, lightness: J, alpha: et=1})=>"hsla(" + Math.round(_) + ", " + percent.transform(sanitize(k)) + ", " + percent.transform(sanitize(J)) + ", " + sanitize(alpha.transform(et)) + ")"
    },
    color = {
        test: _=>rgba.test(_) || hex.test(_) || hsla.test(_),
        parse: _=>rgba.test(_) ? rgba.parse(_) : hsla.test(_) ? hsla.parse(_) : hex.parse(_),
        transform: _=>isString(_) ? _ : _.hasOwnProperty("red") ? rgba.transform(_) : hsla.transform(_)
    },
    mix = (_,k,J)=>-J * _ + J * k + _;
    function hueToRgb(_, k, J) {
        return J < 0 && (J += 1),
        J > 1 && (J -= 1),
        J < 1 / 6 ? _ + (k - _) * 6 * J : J < 1 / 2 ? k : J < 2 / 3 ? _ + (k - _) * (2 / 3 - J) * 6 : _
    }
    function hslaToRgba({hue: _, saturation: k, lightness: J, alpha: et}) {
        _ /= 360,
        k /= 100,
        J /= 100;
        let tt = 0
          , rt = 0
          , nt = 0;
        if (!k)
            tt = rt = nt = J;
        else {
            const ot = J < .5 ? J * (1 + k) : J + k - J * k
              , it = 2 * J - ot;
            tt = hueToRgb(it, ot, _ + 1 / 3),
            rt = hueToRgb(it, ot, _),
            nt = hueToRgb(it, ot, _ - 1 / 3)
        }
        return {
            red: Math.round(tt * 255),
            green: Math.round(rt * 255),
            blue: Math.round(nt * 255),
            alpha: et
        }
    }
    const mixLinearColor = (_,k,J)=>{
        const et = _ * _;
        return Math.sqrt(Math.max(0, J * (k * k - et) + et))
    }
      , colorTypes = [hex, rgba, hsla]
      , getColorType = _=>colorTypes.find(k=>k.test(_));
    function asRGBA(_) {
        const k = getColorType(_);
        let J = k.parse(_);
        return k === hsla && (J = hslaToRgba(J)),
        J
    }
    const mixColor = (_,k)=>{
        const J = asRGBA(_)
          , et = asRGBA(k)
          , tt = $t({}, J);
        return rt=>(tt.red = mixLinearColor(J.red, et.red, rt),
        tt.green = mixLinearColor(J.green, et.green, rt),
        tt.blue = mixLinearColor(J.blue, et.blue, rt),
        tt.alpha = mix(J.alpha, et.alpha, rt),
        rgba.transform(tt))
    }
    ;
    function test(_) {
        var k, J;
        return isNaN(_) && isString(_) && (((k = _.match(floatRegex)) === null || k === void 0 ? void 0 : k.length) || 0) + (((J = _.match(colorRegex)) === null || J === void 0 ? void 0 : J.length) || 0) > 0
    }
    const cssVarTokeniser = {
        regex: cssVariableRegex,
        countKey: "Vars",
        token: "${v}",
        parse: noop$4
    }
      , colorTokeniser = {
        regex: colorRegex,
        countKey: "Colors",
        token: "${c}",
        parse: color.parse
    }
      , numberTokeniser = {
        regex: floatRegex,
        countKey: "Numbers",
        token: "${n}",
        parse: number.parse
    };
    function tokenise(_, {regex: k, countKey: J, token: et, parse: tt}) {
        const rt = _.tokenised.match(k);
        rt && (_["num" + J] = rt.length,
        _.tokenised = _.tokenised.replace(k, et),
        _.values.push(...rt.map(tt)))
    }
    function analyseComplexValue(_) {
        const k = _.toString()
          , J = {
            value: k,
            tokenised: k,
            values: [],
            numVars: 0,
            numColors: 0,
            numNumbers: 0
        };
        return J.value.includes("var(--") && tokenise(J, cssVarTokeniser),
        tokenise(J, colorTokeniser),
        tokenise(J, numberTokeniser),
        J
    }
    function parseComplexValue(_) {
        return analyseComplexValue(_).values
    }
    function createTransformer(_) {
        const {values: k, numColors: J, numVars: et, tokenised: tt} = analyseComplexValue(_)
          , rt = k.length;
        return nt=>{
            let ot = tt;
            for (let it = 0; it < rt; it++)
                it < et ? ot = ot.replace(cssVarTokeniser.token, nt[it]) : it < et + J ? ot = ot.replace(colorTokeniser.token, color.transform(nt[it])) : ot = ot.replace(numberTokeniser.token, sanitize(nt[it]));
            return ot
        }
    }
    const convertNumbersToZero = _=>typeof _ == "number" ? 0 : _;
    function getAnimatableNone$1(_) {
        const k = parseComplexValue(_);
        return createTransformer(_)(k.map(convertNumbersToZero))
    }
    let mixImmediate;
    complex = {
        test,
        parse: parseComplexValue,
        createTransformer,
        getAnimatableNone: getAnimatableNone$1
    },
    mixImmediate = (_,k)=>J=>`${J > 0 ? k : _}`;
    function getMixer(_, k) {
        return typeof _ == "number" ? J=>mix(_, k, J) : color.test(_) ? mixColor(_, k) : _.startsWith("var(") ? mixImmediate(_, k) : mixComplex(_, k)
    }
    let mixArray, mixObject, mixComplex, mixNumber;
    mixArray = (_,k)=>{
        const J = [..._]
          , et = J.length
          , tt = _.map((rt,nt)=>getMixer(rt, k[nt]));
        return rt=>{
            for (let nt = 0; nt < et; nt++)
                J[nt] = tt[nt](rt);
            return J
        }
    }
    ,
    mixObject = (_,k)=>{
        const J = $t($t({}, _), k)
          , et = {};
        for (const tt in J)
            _[tt] !== void 0 && k[tt] !== void 0 && (et[tt] = getMixer(_[tt], k[tt]));
        return tt=>{
            for (const rt in et)
                J[rt] = et[rt](tt);
            return J
        }
    }
    ,
    mixComplex = (_,k)=>{
        const J = complex.createTransformer(k)
          , et = analyseComplexValue(_)
          , tt = analyseComplexValue(k);
        return et.numVars === tt.numVars && et.numColors === tt.numColors && et.numNumbers >= tt.numNumbers ? pipe(mixArray(et.values, tt.values), J) : mixImmediate(_, k)
    }
    ,
    progress = (_,k,J)=>{
        const et = k - _;
        return et === 0 ? 1 : (J - _) / et
    }
    ,
    mixNumber = (_,k)=>J=>mix(_, k, J);
    function detectMixerFactory(_) {
        return typeof _ == "number" ? mixNumber : typeof _ == "string" ? color.test(_) ? mixColor : mixComplex : Array.isArray(_) ? mixArray : typeof _ == "object" ? mixObject : mixNumber
    }
    function createMixers(_, k, J) {
        const et = []
          , tt = J || detectMixerFactory(_[0])
          , rt = _.length - 1;
        for (let nt = 0; nt < rt; nt++) {
            let ot = tt(_[nt], _[nt + 1]);
            if (k) {
                const it = Array.isArray(k) ? k[nt] || noop$4 : k;
                ot = pipe(it, ot)
            }
            et.push(ot)
        }
        return et
    }
    interpolate = function(_, k, {clamp: J=!0, ease: et, mixer: tt}={}) {
        const rt = _.length;
        if (invariant$1(rt === k.length),
        rt === 1)
            return ()=>k[0];
        _[0] > _[rt - 1] && (_ = [..._].reverse(),
        k = [...k].reverse());
        const nt = createMixers(k, et, tt)
          , ot = nt.length
          , it = at=>{
            let lt = 0;
            if (ot > 1)
                for (; lt < _.length - 2 && !(at < _[lt + 1]); lt++)
                    ;
            const st = progress(_[lt], _[lt + 1], at);
            return nt[lt](st)
        }
        ;
        return J ? at=>it(clamp(_[0], _[rt - 1], at)) : it
    }
    ;
    function fillOffset(_, k) {
        const J = _[_.length - 1];
        for (let et = 1; et <= k; et++) {
            const tt = progress(0, k, et);
            _.push(mix(J, 1, tt))
        }
    }
    defaultOffset = function(_) {
        const k = [0];
        return fillOffset(k, _.length - 1),
        k
    }
    ;
    function convertOffsetToTimes(_, k) {
        return _.map(J=>J * k)
    }
    function defaultEasing(_, k) {
        return _.map(()=>k || easeInOut).splice(0, _.length - 1)
    }
    function keyframes({duration: _=300, keyframes: k, times: J, ease: et="easeInOut"}) {
        const tt = isEasingArray(et) ? et.map(easingDefinitionToFunction) : easingDefinitionToFunction(et)
          , rt = {
            done: !1,
            value: k[0]
        }
          , nt = convertOffsetToTimes(J && J.length === k.length ? J : defaultOffset(k), _)
          , ot = interpolate(nt, k, {
            ease: Array.isArray(tt) ? tt : defaultEasing(k, tt)
        });
        return {
            calculatedDuration: _,
            next: it=>(rt.value = ot(it),
            rt.done = it >= _,
            rt)
        }
    }
    velocityPerSecond = function(_, k) {
        return k ? _ * (1e3 / k) : 0
    }
    ;
    const velocitySampleDuration = 5;
    function calcGeneratorVelocity(_, k, J) {
        const et = Math.max(k - velocitySampleDuration, 0);
        return velocityPerSecond(J - _(et), k - et)
    }
    const safeMin = .001
      , minDuration = .01
      , maxDuration$1 = 10
      , minDamping = .05
      , maxDamping = 1;
    function findSpring({duration: _=800, bounce: k=.25, velocity: J=0, mass: et=1}) {
        let tt, rt;
        warning$1(_ <= secondsToMilliseconds(maxDuration$1));
        let nt = 1 - k;
        nt = clamp(minDamping, maxDamping, nt),
        _ = clamp(minDuration, maxDuration$1, millisecondsToSeconds(_)),
        nt < 1 ? (tt = at=>{
            const lt = at * nt
              , st = lt * _
              , ut = lt - J
              , ct = calcAngularFreq(at, nt)
              , pt = Math.exp(-st);
            return safeMin - ut / ct * pt
        }
        ,
        rt = at=>{
            const lt = at * nt * _
              , st = lt * J + J
              , ut = Math.pow(nt, 2) * Math.pow(at, 2) * _
              , ct = Math.exp(-lt)
              , pt = calcAngularFreq(Math.pow(at, 2), nt);
            return (-tt(at) + safeMin > 0 ? -1 : 1) * ((st - ut) * ct) / pt
        }
        ) : (tt = at=>{
            const lt = Math.exp(-at * _)
              , st = (at - J) * _ + 1;
            return -safeMin + lt * st
        }
        ,
        rt = at=>{
            const lt = Math.exp(-at * _)
              , st = (J - at) * (_ * _);
            return lt * st
        }
        );
        const ot = 5 / _
          , it = approximateRoot(tt, rt, ot);
        if (_ = secondsToMilliseconds(_),
        isNaN(it))
            return {
                stiffness: 100,
                damping: 10,
                duration: _
            };
        {
            const at = Math.pow(it, 2) * et;
            return {
                stiffness: at,
                damping: nt * 2 * Math.sqrt(et * at),
                duration: _
            }
        }
    }
    const rootIterations = 12;
    function approximateRoot(_, k, J) {
        let et = J;
        for (let tt = 1; tt < rootIterations; tt++)
            et = et - _(et) / k(et);
        return et
    }
    function calcAngularFreq(_, k) {
        return _ * Math.sqrt(1 - k * k)
    }
    const durationKeys = ["duration", "bounce"]
      , physicsKeys = ["stiffness", "damping", "mass"];
    function isSpringType(_, k) {
        return k.some(J=>_[J] !== void 0)
    }
    function getSpringOptions(_) {
        let k = $t({
            velocity: 0,
            stiffness: 100,
            damping: 10,
            mass: 1,
            isResolvedFromDuration: !1
        }, _);
        if (!isSpringType(_, physicsKeys) && isSpringType(_, durationKeys)) {
            const J = findSpring(_);
            k = _t($t($t({}, k), J), {
                mass: 1
            }),
            k.isResolvedFromDuration = !0
        }
        return k
    }
    spring = function(tt) {
        var rt = tt
          , {keyframes: _, restDelta: k, restSpeed: J} = rt
          , et = Kt(rt, ["keyframes", "restDelta", "restSpeed"]);
        const nt = _[0]
          , ot = _[_.length - 1]
          , it = {
            done: !1,
            value: nt
        }
          , {stiffness: at, damping: lt, mass: st, duration: ut, velocity: ct, isResolvedFromDuration: pt} = getSpringOptions(_t($t({}, et), {
            velocity: -millisecondsToSeconds(et.velocity || 0)
        }))
          , ft = ct || 0
          , yt = lt / (2 * Math.sqrt(at * st))
          , ht = ot - nt
          , gt = millisecondsToSeconds(Math.sqrt(at / st))
          , mt = Math.abs(ht) < 5;
        J || (J = mt ? .01 : 2),
        k || (k = mt ? .005 : .5);
        let vt;
        if (yt < 1) {
            const bt = calcAngularFreq(gt, yt);
            vt = Et=>{
                const xt = Math.exp(-yt * gt * Et);
                return ot - xt * ((ft + yt * gt * ht) / bt * Math.sin(bt * Et) + ht * Math.cos(bt * Et))
            }
        } else if (yt === 1)
            vt = bt=>ot - Math.exp(-gt * bt) * (ht + (ft + gt * ht) * bt);
        else {
            const bt = gt * Math.sqrt(yt * yt - 1);
            vt = Et=>{
                const xt = Math.exp(-yt * gt * Et)
                  , wt = Math.min(bt * Et, 300);
                return ot - xt * ((ft + yt * gt * ht) * Math.sinh(wt) + bt * ht * Math.cosh(wt)) / bt
            }
        }
        return {
            calculatedDuration: pt && ut || null,
            next: bt=>{
                const Et = vt(bt);
                if (pt)
                    it.done = bt >= ut;
                else {
                    let xt = ft;
                    bt !== 0 && (yt < 1 ? xt = calcGeneratorVelocity(vt, bt, Et) : xt = 0);
                    const wt = Math.abs(xt) <= J
                      , St = Math.abs(ot - Et) <= k;
                    it.done = wt && St
                }
                return it.value = it.done ? ot : Et,
                it
            }
        }
    }
    ;
    function inertia({keyframes: _, velocity: k=0, power: J=.8, timeConstant: et=325, bounceDamping: tt=10, bounceStiffness: rt=500, modifyTarget: nt, min: ot, max: it, restDelta: at=.5, restSpeed: lt}) {
        const st = _[0]
          , ut = {
            done: !1,
            value: st
        }
          , ct = wt=>ot !== void 0 && wt < ot || it !== void 0 && wt > it
          , pt = wt=>ot === void 0 ? it : it === void 0 || Math.abs(ot - wt) < Math.abs(it - wt) ? ot : it;
        let ft = J * k;
        const yt = st + ft
          , ht = nt === void 0 ? yt : nt(yt);
        ht !== yt && (ft = ht - st);
        const gt = wt=>-ft * Math.exp(-wt / et)
          , mt = wt=>ht + gt(wt)
          , vt = wt=>{
            const St = gt(wt)
              , Pt = mt(wt);
            ut.done = Math.abs(St) <= at,
            ut.value = ut.done ? ht : Pt
        }
        ;
        let bt, Et;
        const xt = wt=>{
            ct(ut.value) && (bt = wt,
            Et = spring({
                keyframes: [ut.value, pt(ut.value)],
                velocity: calcGeneratorVelocity(mt, wt, ut.value),
                damping: tt,
                stiffness: rt,
                restDelta: at,
                restSpeed: lt
            }))
        }
        ;
        return xt(0),
        {
            calculatedDuration: null,
            next: wt=>{
                let St = !1;
                return !Et && bt === void 0 && (St = !0,
                vt(wt),
                xt(wt)),
                bt !== void 0 && wt > bt ? Et.next(wt - bt) : (!St && vt(wt),
                ut)
            }
        }
    }
    const frameloopDriver = _=>{
        const k = ({timestamp: J})=>_(J);
        return {
            start: ()=>frame.update(k, !0),
            stop: ()=>cancelFrame(k),
            now: ()=>frameData.isProcessing ? frameData.timestamp : performance.now()
        }
    }
      , maxGeneratorDuration = 2e4;
    function calcGeneratorDuration(_) {
        let k = 0;
        const J = 50;
        let et = _.next(k);
        for (; !et.done && k < maxGeneratorDuration; )
            k += J,
            et = _.next(k);
        return k >= maxGeneratorDuration ? 1 / 0 : k
    }
    const types = {
        decay: inertia,
        inertia,
        tween: keyframes,
        keyframes,
        spring
    };
    animateValue = function(ct) {
        var pt = ct
          , {autoplay: _=!0, delay: k=0, driver: J=frameloopDriver, keyframes: et, type: tt="keyframes", repeat: rt=0, repeatDelay: nt=0, repeatType: ot="loop", onPlay: it, onStop: at, onComplete: lt, onUpdate: st} = pt
          , ut = Kt(pt, ["autoplay", "delay", "driver", "keyframes", "type", "repeat", "repeatDelay", "repeatType", "onPlay", "onStop", "onComplete", "onUpdate"]);
        let ft = 1, yt = !1, ht, gt;
        const mt = ()=>{
            gt = new Promise(Gt=>{
                ht = Gt
            }
            )
        }
        ;
        mt();
        let vt;
        const bt = types[tt] || keyframes;
        let Et;
        bt !== keyframes && typeof et[0] != "number" && (Et = interpolate([0, 100], et, {
            clamp: !1
        }),
        et = [0, 100]);
        const xt = bt(_t($t({}, ut), {
            keyframes: et
        }));
        let wt;
        ot === "mirror" && (wt = bt(_t($t({}, ut), {
            keyframes: [...et].reverse(),
            velocity: -(ut.velocity || 0)
        })));
        let St = "idle"
          , Pt = null
          , Rt = null
          , At = null;
        xt.calculatedDuration === null && rt && (xt.calculatedDuration = calcGeneratorDuration(xt));
        const {calculatedDuration: Nt} = xt;
        let Ot = 1 / 0
          , It = 1 / 0;
        Nt !== null && (Ot = Nt + nt,
        It = Ot * (rt + 1) - nt);
        let Mt = 0;
        const Wt = Gt=>{
            if (Rt === null)
                return;
            ft > 0 && (Rt = Math.min(Rt, Gt)),
            ft < 0 && (Rt = Math.min(Gt - It / ft, Rt)),
            Pt !== null ? Mt = Pt : Mt = Math.round(Gt - Rt) * ft;
            const er = Mt - k * (ft >= 0 ? 1 : -1)
              , lr = ft >= 0 ? er < 0 : er > It;
            Mt = Math.max(er, 0),
            St === "finished" && Pt === null && (Mt = It);
            let sr = Mt
              , fr = xt;
            if (rt) {
                const Pr = Math.min(Mt, It) / Ot;
                let nr = Math.floor(Pr)
                  , pr = Pr % 1;
                !pr && Pr >= 1 && (pr = 1),
                pr === 1 && nr--,
                nr = Math.min(nr, rt + 1),
                nr % 2 && (ot === "reverse" ? (pr = 1 - pr,
                nt && (pr -= nt / Ot)) : ot === "mirror" && (fr = wt)),
                sr = clamp(0, 1, pr) * Ot
            }
            const Er = lr ? {
                done: !1,
                value: et[0]
            } : fr.next(sr);
            Et && (Er.value = Et(Er.value));
            let {done: mr} = Er;
            !lr && Nt !== null && (mr = ft >= 0 ? Mt >= It : Mt <= 0);
            const wr = Pt === null && (St === "finished" || St === "running" && mr);
            return st && st(Er.value),
            wr && Ut(),
            Er
        }
          , jt = ()=>{
            vt && vt.stop(),
            vt = void 0
        }
          , Bt = ()=>{
            St = "idle",
            jt(),
            ht(),
            mt(),
            Rt = At = null
        }
          , Ut = ()=>{
            St = "finished",
            lt && lt(),
            jt(),
            ht()
        }
          , Xt = ()=>{
            if (yt)
                return;
            vt || (vt = J(Wt));
            const Gt = vt.now();
            it && it(),
            Pt !== null ? Rt = Gt - Pt : (!Rt || St === "finished") && (Rt = Gt),
            St === "finished" && mt(),
            At = Rt,
            Pt = null,
            St = "running",
            vt.start()
        }
        ;
        _ && Xt();
        const Yt = {
            then(Gt, er) {
                return gt.then(Gt, er)
            },
            get time() {
                return millisecondsToSeconds(Mt)
            },
            set time(Gt) {
                Gt = secondsToMilliseconds(Gt),
                Mt = Gt,
                Pt !== null || !vt || ft === 0 ? Pt = Gt : Rt = vt.now() - Gt / ft
            },
            get duration() {
                const Gt = xt.calculatedDuration === null ? calcGeneratorDuration(xt) : xt.calculatedDuration;
                return millisecondsToSeconds(Gt)
            },
            get speed() {
                return ft
            },
            set speed(Gt) {
                Gt === ft || !vt || (ft = Gt,
                Yt.time = millisecondsToSeconds(Mt))
            },
            get state() {
                return St
            },
            play: Xt,
            pause: ()=>{
                St = "paused",
                Pt = Mt
            }
            ,
            stop: ()=>{
                yt = !0,
                St !== "idle" && (St = "idle",
                at && at(),
                Bt())
            }
            ,
            cancel: ()=>{
                At !== null && Wt(At),
                Bt()
            }
            ,
            complete: ()=>{
                St = "finished"
            }
            ,
            sample: Gt=>(Rt = 0,
            Wt(Gt))
        };
        return Yt
    }
    ;
    function memo(_) {
        let k;
        return ()=>(k === void 0 && (k = _()),
        k)
    }
    const supportsWaapi = memo(()=>Object.hasOwnProperty.call(Element.prototype, "animate"))
      , acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"])
      , sampleDelta = 10
      , maxDuration = 2e4
      , requiresPregeneratedKeyframes = (_,k)=>k.type === "spring" || _ === "backgroundColor" || !isWaapiSupportedEasing(k.ease);
    function createAcceleratedAnimation(_, k, rt) {
        var nt = rt
          , {onUpdate: J, onComplete: et} = nt
          , tt = Kt(nt, ["onUpdate", "onComplete"]);
        if (!(supportsWaapi() && acceleratedValues.has(k) && !tt.repeatDelay && tt.repeatType !== "mirror" && tt.damping !== 0 && tt.type !== "inertia"))
            return !1;
        let ot = !1, it, at, lt = !1;
        const st = ()=>{
            at = new Promise(mt=>{
                it = mt
            }
            )
        }
        ;
        st();
        let {keyframes: ut, duration: ct=300, ease: pt, times: ft} = tt;
        if (requiresPregeneratedKeyframes(k, tt)) {
            const mt = animateValue(_t($t({}, tt), {
                repeat: 0,
                delay: 0
            }));
            let vt = {
                done: !1,
                value: ut[0]
            };
            const bt = [];
            let Et = 0;
            for (; !vt.done && Et < maxDuration; )
                vt = mt.sample(Et),
                bt.push(vt.value),
                Et += sampleDelta;
            ft = void 0,
            ut = bt,
            ct = Et - sampleDelta,
            pt = "linear"
        }
        const yt = animateStyle(_.owner.current, k, ut, _t($t({}, tt), {
            duration: ct,
            ease: pt,
            times: ft
        }))
          , ht = ()=>{
            lt = !1,
            yt.cancel()
        }
          , gt = ()=>{
            lt = !0,
            frame.update(ht),
            it(),
            st()
        }
        ;
        return yt.onfinish = ()=>{
            lt || (_.set(getFinalKeyframe(ut, tt)),
            et && et(),
            gt())
        }
        ,
        {
            then(mt, vt) {
                return at.then(mt, vt)
            },
            attachTimeline(mt) {
                return yt.timeline = mt,
                yt.onfinish = null,
                noop$4
            },
            get time() {
                return millisecondsToSeconds(yt.currentTime || 0)
            },
            set time(mt) {
                yt.currentTime = secondsToMilliseconds(mt)
            },
            get speed() {
                return yt.playbackRate
            },
            set speed(mt) {
                yt.playbackRate = mt
            },
            get duration() {
                return millisecondsToSeconds(ct)
            },
            play: ()=>{
                ot || (yt.play(),
                cancelFrame(ht))
            }
            ,
            pause: ()=>yt.pause(),
            stop: ()=>{
                if (ot = !0,
                yt.playState === "idle")
                    return;
                const {currentTime: mt} = yt;
                if (mt) {
                    const vt = animateValue(_t($t({}, tt), {
                        autoplay: !1
                    }));
                    _.setWithVelocity(vt.sample(mt - sampleDelta).value, vt.sample(mt).value, sampleDelta)
                }
                gt()
            }
            ,
            complete: ()=>{
                lt || yt.finish()
            }
            ,
            cancel: gt
        }
    }
    function createInstantAnimation({keyframes: _, delay: k, onUpdate: J, onComplete: et}) {
        const tt = ()=>(J && J(_[_.length - 1]),
        et && et(),
        {
            time: 0,
            speed: 1,
            duration: 0,
            play: noop$4,
            pause: noop$4,
            stop: noop$4,
            then: rt=>(rt(),
            Promise.resolve()),
            cancel: noop$4,
            complete: noop$4
        });
        return k ? animateValue({
            keyframes: [0, 1],
            duration: 0,
            delay: k,
            onComplete: tt
        }) : tt()
    }
    const underDampedSpring = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    }
      , criticallyDampedSpring = _=>({
        type: "spring",
        stiffness: 550,
        damping: _ === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    })
      , keyframesTransition = {
        type: "keyframes",
        duration: .8
    }
      , ease = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    }
      , getDefaultTransition = (_,{keyframes: k})=>k.length > 2 ? keyframesTransition : transformProps.has(_) ? _.startsWith("scale") ? criticallyDampedSpring(k[1]) : underDampedSpring : ease
      , isAnimatable = (_,k)=>_ === "zIndex" ? !1 : !!(typeof k == "number" || Array.isArray(k) || typeof k == "string" && (complex.test(k) || k === "0") && !k.startsWith("url("))
      , maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
    function applyDefaultFilter(_) {
        const [k,J] = _.slice(0, -1).split("(");
        if (k === "drop-shadow")
            return _;
        const [et] = J.match(floatRegex) || [];
        if (!et)
            return _;
        const tt = J.replace(et, "");
        let rt = maxDefaults.has(k) ? 1 : 0;
        return et !== J && (rt *= 100),
        k + "(" + rt + tt + ")"
    }
    const functionRegex = /([a-z-]*)\(.*?\)/g
      , filter = _t($t({}, complex), {
        getAnimatableNone: _=>{
            const k = _.match(functionRegex);
            return k ? k.map(applyDefaultFilter).join(" ") : _
        }
    })
      , defaultValueTypes = _t($t({}, numberValueTypes), {
        color,
        backgroundColor: color,
        outlineColor: color,
        fill: color,
        stroke: color,
        borderColor: color,
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color,
        filter,
        WebkitFilter: filter
    })
      , getDefaultValueType = _=>defaultValueTypes[_];
    function getAnimatableNone(_, k) {
        let J = getDefaultValueType(_);
        return J !== filter && (J = complex),
        J.getAnimatableNone ? J.getAnimatableNone(k) : void 0
    }
    const isZeroValueString = _=>/^0[^.\s]+$/.test(_);
    function isNone(_) {
        if (typeof _ == "number")
            return _ === 0;
        if (_ !== null)
            return _ === "none" || _ === "0" || isZeroValueString(_)
    }
    function getKeyframes(_, k, J, et) {
        const tt = isAnimatable(k, J);
        let rt;
        Array.isArray(J) ? rt = [...J] : rt = [null, J];
        const nt = et.from !== void 0 ? et.from : _.get();
        let ot;
        const it = [];
        for (let at = 0; at < rt.length; at++)
            rt[at] === null && (rt[at] = at === 0 ? nt : rt[at - 1]),
            isNone(rt[at]) && it.push(at),
            typeof rt[at] == "string" && rt[at] !== "none" && rt[at] !== "0" && (ot = rt[at]);
        if (tt && it.length && ot)
            for (let at = 0; at < it.length; at++) {
                const lt = it[at];
                rt[lt] = getAnimatableNone(k, ot)
            }
        return rt
    }
    function isTransitionDefined(st) {
        var ut = st
          , {when: _, delay: k, delayChildren: J, staggerChildren: et, staggerDirection: tt, repeat: rt, repeatType: nt, repeatDelay: ot, from: it, elapsed: at} = ut
          , lt = Kt(ut, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from", "elapsed"]);
        return !!Object.keys(lt).length
    }
    function getValueTransition$1(_, k) {
        return _[k] || _.default || _
    }
    let animateMotionValue;
    MotionGlobalConfig = {
        skipAnimations: !1
    },
    animateMotionValue = (_,k,J,et={})=>tt=>{
        const rt = getValueTransition$1(et, _) || {}
          , nt = rt.delay || et.delay || 0;
        let {elapsed: ot=0} = et;
        ot = ot - secondsToMilliseconds(nt);
        const it = getKeyframes(k, _, J, rt)
          , at = it[0]
          , lt = it[it.length - 1]
          , st = isAnimatable(_, at)
          , ut = isAnimatable(_, lt);
        let ct = _t($t({
            keyframes: it,
            velocity: k.getVelocity(),
            ease: "easeOut"
        }, rt), {
            delay: -ot,
            onUpdate: pt=>{
                k.set(pt),
                rt.onUpdate && rt.onUpdate(pt)
            }
            ,
            onComplete: ()=>{
                tt(),
                rt.onComplete && rt.onComplete()
            }
        });
        if (isTransitionDefined(rt) || (ct = $t($t({}, ct), getDefaultTransition(_, ct))),
        ct.duration && (ct.duration = secondsToMilliseconds(ct.duration)),
        ct.repeatDelay && (ct.repeatDelay = secondsToMilliseconds(ct.repeatDelay)),
        !st || !ut || instantAnimationState.current || rt.type === !1 || MotionGlobalConfig.skipAnimations)
            return createInstantAnimation(instantAnimationState.current ? _t($t({}, ct), {
                delay: 0
            }) : ct);
        if (!et.isHandoff && k.owner && k.owner.current instanceof HTMLElement && !k.owner.getProps().onUpdate) {
            const pt = createAcceleratedAnimation(k, _, ct);
            if (pt)
                return pt
        }
        return animateValue(ct)
    }
    ;
    function isWillChangeMotionValue(_) {
        return !!(isMotionValue(_) && _.add)
    }
    const isNumericalString = _=>/^\-?\d*\.?\d+$/.test(_);
    addUniqueItem = function(_, k) {
        _.indexOf(k) === -1 && _.push(k)
    }
    ,
    removeItem = function(_, k) {
        const J = _.indexOf(k);
        J > -1 && _.splice(J, 1)
    }
    ,
    moveItem = function([..._], k, J) {
        const et = k < 0 ? _.length + k : k;
        if (et >= 0 && et < _.length) {
            const tt = J < 0 ? _.length + J : J
              , [rt] = _.splice(k, 1);
            _.splice(tt, 0, rt)
        }
        return _
    }
    ;
    class SubscriptionManager {
        constructor() {
            this.subscriptions = []
        }
        add(k) {
            return addUniqueItem(this.subscriptions, k),
            ()=>removeItem(this.subscriptions, k)
        }
        notify(k, J, et) {
            const tt = this.subscriptions.length;
            if (tt)
                if (tt === 1)
                    this.subscriptions[0](k, J, et);
                else
                    for (let rt = 0; rt < tt; rt++) {
                        const nt = this.subscriptions[rt];
                        nt && nt(k, J, et)
                    }
        }
        getSize() {
            return this.subscriptions.length
        }
        clear() {
            this.subscriptions.length = 0
        }
    }
    let isFloat;
    isFloat = _=>!isNaN(parseFloat(_)),
    collectMotionValues = {
        current: void 0
    },
    MotionValue = class {
        constructor(_, k={}) {
            this.version = "10.18.0",
            this.timeDelta = 0,
            this.lastUpdated = 0,
            this.canTrackVelocity = !1,
            this.events = {},
            this.updateAndNotify = (J,et=!0)=>{
                this.prev = this.current,
                this.current = J;
                const {delta: tt, timestamp: rt} = frameData;
                this.lastUpdated !== rt && (this.timeDelta = tt,
                this.lastUpdated = rt,
                frame.postRender(this.scheduleVelocityCheck)),
                this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
                this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
                et && this.events.renderRequest && this.events.renderRequest.notify(this.current)
            }
            ,
            this.scheduleVelocityCheck = ()=>frame.postRender(this.velocityCheck),
            this.velocityCheck = ({timestamp: J})=>{
                J !== this.lastUpdated && (this.prev = this.current,
                this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
            }
            ,
            this.hasAnimated = !1,
            this.prev = this.current = _,
            this.canTrackVelocity = isFloat(this.current),
            this.owner = k.owner
        }
        onChange(_) {
            return this.on("change", _)
        }
        on(_, k) {
            this.events[_] || (this.events[_] = new SubscriptionManager);
            const J = this.events[_].add(k);
            return _ === "change" ? ()=>{
                J(),
                frame.read(()=>{
                    this.events.change.getSize() || this.stop()
                }
                )
            }
            : J
        }
        clearListeners() {
            for (const _ in this.events)
                this.events[_].clear()
        }
        attach(_, k) {
            this.passiveEffect = _,
            this.stopPassiveEffect = k
        }
        set(_, k=!0) {
            !k || !this.passiveEffect ? this.updateAndNotify(_, k) : this.passiveEffect(_, this.updateAndNotify)
        }
        setWithVelocity(_, k, J) {
            this.set(k),
            this.prev = _,
            this.timeDelta = J
        }
        jump(_) {
            this.updateAndNotify(_),
            this.prev = _,
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect()
        }
        get() {
            return collectMotionValues.current && collectMotionValues.current.push(this),
            this.current
        }
        getPrevious() {
            return this.prev
        }
        getVelocity() {
            return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
        }
        start(_) {
            return this.stop(),
            new Promise(k=>{
                this.hasAnimated = !0,
                this.animation = _(k),
                this.events.animationStart && this.events.animationStart.notify()
            }
            ).then(()=>{
                this.events.animationComplete && this.events.animationComplete.notify(),
                this.clearAnimation()
            }
            )
        }
        stop() {
            this.animation && (this.animation.stop(),
            this.events.animationCancel && this.events.animationCancel.notify()),
            this.clearAnimation()
        }
        isAnimating() {
            return !!this.animation
        }
        clearAnimation() {
            delete this.animation
        }
        destroy() {
            this.clearListeners(),
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect()
        }
    }
    ,
    motionValue = function(_, k) {
        return new MotionValue(_,k)
    }
    ;
    const testValueType = _=>k=>k.test(_)
      , auto = {
        test: _=>_ === "auto",
        parse: _=>_
    }
      , dimensionValueTypes = [number, px, percent, degrees, vw, vh$1, auto]
      , findDimensionValueType = _=>dimensionValueTypes.find(testValueType(_))
      , valueTypes = [...dimensionValueTypes, color, complex]
      , findValueType = _=>valueTypes.find(testValueType(_));
    function setMotionValue(_, k, J) {
        _.hasValue(k) ? _.getValue(k).set(J) : _.addValue(k, motionValue(J))
    }
    function setTarget(_, k) {
        const J = resolveVariant(_, k);
        let nt = J ? _.makeTargetAnimatable(J, !1) : {}
          , {transitionEnd: et={}, transition: tt={}} = nt
          , rt = Kt(nt, ["transitionEnd", "transition"]);
        rt = $t($t({}, rt), et);
        for (const ot in rt) {
            const it = resolveFinalValueInKeyframes(rt[ot]);
            setMotionValue(_, ot, it)
        }
    }
    function setVariants(_, k) {
        [...k].reverse().forEach(J=>{
            const et = _.getVariant(J);
            et && setTarget(_, et),
            _.variantChildren && _.variantChildren.forEach(tt=>{
                setVariants(tt, k)
            }
            )
        }
        )
    }
    function setValues(_, k) {
        if (Array.isArray(k))
            return setVariants(_, k);
        if (typeof k == "string")
            return setVariants(_, [k]);
        setTarget(_, k)
    }
    checkTargetForNewValues = function(_, k, J) {
        var et, tt;
        const rt = Object.keys(k).filter(ot=>!_.hasValue(ot))
          , nt = rt.length;
        if (nt)
            for (let ot = 0; ot < nt; ot++) {
                const it = rt[ot]
                  , at = k[it];
                let lt = null;
                Array.isArray(at) && (lt = at[0]),
                lt === null && (lt = (tt = (et = J[it]) !== null && et !== void 0 ? et : _.readValue(it)) !== null && tt !== void 0 ? tt : k[it]),
                lt != null && (typeof lt == "string" && (isNumericalString(lt) || isZeroValueString(lt)) ? lt = parseFloat(lt) : !findValueType(lt) && complex.test(at) && (lt = getAnimatableNone(it, at)),
                _.addValue(it, motionValue(lt, {
                    owner: _
                })),
                J[it] === void 0 && (J[it] = lt),
                lt !== null && _.setBaseTarget(it, lt))
            }
    }
    ;
    function getOriginFromTransition(_, k) {
        return k ? (k[_] || k.default || k).from : void 0
    }
    getOrigin = function(_, k, J) {
        const et = {};
        for (const tt in _) {
            const rt = getOriginFromTransition(tt, k);
            if (rt !== void 0)
                et[tt] = rt;
            else {
                const nt = J.getValue(tt);
                nt && (et[tt] = nt.get())
            }
        }
        return et
    }
    ;
    function shouldBlockAnimation({protectedKeys: _, needsAnimating: k}, J) {
        const et = _.hasOwnProperty(J) && k[J] !== !0;
        return k[J] = !1,
        et
    }
    function hasKeyframesChanged(_, k) {
        const J = _.get();
        if (Array.isArray(k)) {
            for (let et = 0; et < k.length; et++)
                if (k[et] !== J)
                    return !0
        } else
            return J !== k
    }
    function animateTarget(_, k, {delay: J=0, transitionOverride: et, type: tt}={}) {
        let st = _.makeTargetAnimatable(k)
          , {transition: rt=_.getDefaultTransition(), transitionEnd: nt} = st
          , ot = Kt(st, ["transition", "transitionEnd"]);
        const it = _.getValue("willChange");
        et && (rt = et);
        const at = []
          , lt = tt && _.animationState && _.animationState.getState()[tt];
        for (const ut in ot) {
            const ct = _.getValue(ut)
              , pt = ot[ut];
            if (!ct || pt === void 0 || lt && shouldBlockAnimation(lt, ut))
                continue;
            const ft = $t({
                delay: J,
                elapsed: 0
            }, getValueTransition$1(rt || {}, ut));
            if (window.HandoffAppearAnimations) {
                const gt = _.getProps()[optimizedAppearDataAttribute];
                if (gt) {
                    const mt = window.HandoffAppearAnimations(gt, ut, ct, frame);
                    mt !== null && (ft.elapsed = mt,
                    ft.isHandoff = !0)
                }
            }
            let yt = !ft.isHandoff && !hasKeyframesChanged(ct, pt);
            if (ft.type === "spring" && (ct.getVelocity() || ft.velocity) && (yt = !1),
            ct.animation && (yt = !1),
            yt)
                continue;
            ct.start(animateMotionValue(ut, ct, pt, _.shouldReduceMotion && transformProps.has(ut) ? {
                type: !1
            } : ft));
            const ht = ct.animation;
            isWillChangeMotionValue(it) && (it.add(ut),
            ht.then(()=>it.remove(ut))),
            at.push(ht)
        }
        return nt && Promise.all(at).then(()=>{
            nt && setTarget(_, nt)
        }
        ),
        at
    }
    function animateVariant(_, k, J={}) {
        const et = resolveVariant(_, k, J.custom);
        let {transition: tt=_.getDefaultTransition() || {}} = et || {};
        J.transitionOverride && (tt = J.transitionOverride);
        const rt = et ? ()=>Promise.all(animateTarget(_, et, J)) : ()=>Promise.resolve()
          , nt = _.variantChildren && _.variantChildren.size ? (it=0)=>{
            const {delayChildren: at=0, staggerChildren: lt, staggerDirection: st} = tt;
            return animateChildren(_, k, at + it, lt, st, J)
        }
        : ()=>Promise.resolve()
          , {when: ot} = tt;
        if (ot) {
            const [it,at] = ot === "beforeChildren" ? [rt, nt] : [nt, rt];
            return it().then(()=>at())
        } else
            return Promise.all([rt(), nt(J.delay)])
    }
    function animateChildren(_, k, J=0, et=0, tt=1, rt) {
        const nt = []
          , ot = (_.variantChildren.size - 1) * et
          , it = tt === 1 ? (at=0)=>at * et : (at=0)=>ot - at * et;
        return Array.from(_.variantChildren).sort(sortByTreeOrder).forEach((at,lt)=>{
            at.notify("AnimationStart", k),
            nt.push(animateVariant(at, k, _t($t({}, rt), {
                delay: J + it(lt)
            })).then(()=>at.notify("AnimationComplete", k)))
        }
        ),
        Promise.all(nt)
    }
    function sortByTreeOrder(_, k) {
        return _.sortNodePosition(k)
    }
    animateVisualElement = function(_, k, J={}) {
        _.notify("AnimationStart", k);
        let et;
        if (Array.isArray(k)) {
            const tt = k.map(rt=>animateVariant(_, rt, J));
            et = Promise.all(tt)
        } else if (typeof k == "string")
            et = animateVariant(_, k, J);
        else {
            const tt = typeof k == "function" ? resolveVariant(_, k, J.custom) : k;
            et = Promise.all(animateTarget(_, tt, J))
        }
        return et.then(()=>_.notify("AnimationComplete", k))
    }
    ;
    const reversePriorityOrder = [...variantPriorityOrder].reverse()
      , numAnimationTypes = variantPriorityOrder.length;
    function animateList(_) {
        return k=>Promise.all(k.map(({animation: J, options: et})=>animateVisualElement(_, J, et)))
    }
    function createAnimationState(_) {
        let k = animateList(_);
        const J = createState();
        let et = !0;
        const tt = (it,at)=>{
            const lt = resolveVariant(_, at);
            if (lt) {
                const st = lt
                  , {transition: ut, transitionEnd: ct} = st
                  , pt = Kt(st, ["transition", "transitionEnd"]);
                it = $t($t($t({}, it), pt), ct)
            }
            return it
        }
        ;
        function rt(it) {
            k = it(_)
        }
        function nt(it, at) {
            const lt = _.getProps()
              , st = _.getVariantContext(!0) || {}
              , ut = []
              , ct = new Set;
            let pt = {}
              , ft = 1 / 0;
            for (let ht = 0; ht < numAnimationTypes; ht++) {
                const gt = reversePriorityOrder[ht]
                  , mt = J[gt]
                  , vt = lt[gt] !== void 0 ? lt[gt] : st[gt]
                  , bt = isVariantLabel(vt)
                  , Et = gt === at ? mt.isActive : null;
                Et === !1 && (ft = ht);
                let xt = vt === st[gt] && vt !== lt[gt] && bt;
                if (xt && et && _.manuallyAnimateOnMount && (xt = !1),
                mt.protectedKeys = $t({}, pt),
                !mt.isActive && Et === null || !vt && !mt.prevProp || isAnimationControls(vt) || typeof vt == "boolean")
                    continue;
                let wt = checkVariantsDidChange(mt.prevProp, vt) || gt === at && mt.isActive && !xt && bt || ht > ft && bt
                  , St = !1;
                const Pt = Array.isArray(vt) ? vt : [vt];
                let Rt = Pt.reduce(tt, {});
                Et === !1 && (Rt = {});
                const {prevResolvedValues: At={}} = mt
                  , Nt = $t($t({}, At), Rt)
                  , Ot = It=>{
                    wt = !0,
                    ct.has(It) && (St = !0,
                    ct.delete(It)),
                    mt.needsAnimating[It] = !0
                }
                ;
                for (const It in Nt) {
                    const Mt = Rt[It]
                      , Wt = At[It];
                    if (pt.hasOwnProperty(It))
                        continue;
                    let jt = !1;
                    isKeyframesTarget(Mt) && isKeyframesTarget(Wt) ? jt = !shallowCompare(Mt, Wt) : jt = Mt !== Wt,
                    jt ? Mt !== void 0 ? Ot(It) : ct.add(It) : Mt !== void 0 && ct.has(It) ? Ot(It) : mt.protectedKeys[It] = !0
                }
                mt.prevProp = vt,
                mt.prevResolvedValues = Rt,
                mt.isActive && (pt = $t($t({}, pt), Rt)),
                et && _.blockInitialAnimation && (wt = !1),
                wt && (!xt || St) && ut.push(...Pt.map(It=>({
                    animation: It,
                    options: $t({
                        type: gt
                    }, it)
                })))
            }
            if (ct.size) {
                const ht = {};
                ct.forEach(gt=>{
                    const mt = _.getBaseTarget(gt);
                    mt !== void 0 && (ht[gt] = mt)
                }
                ),
                ut.push({
                    animation: ht
                })
            }
            let yt = !!ut.length;
            return et && (lt.initial === !1 || lt.initial === lt.animate) && !_.manuallyAnimateOnMount && (yt = !1),
            et = !1,
            yt ? k(ut) : Promise.resolve()
        }
        function ot(it, at, lt) {
            var st;
            if (J[it].isActive === at)
                return Promise.resolve();
            (st = _.variantChildren) === null || st === void 0 || st.forEach(ct=>{
                var pt;
                return (pt = ct.animationState) === null || pt === void 0 ? void 0 : pt.setActive(it, at)
            }
            ),
            J[it].isActive = at;
            const ut = nt(lt, it);
            for (const ct in J)
                J[ct].protectedKeys = {};
            return ut
        }
        return {
            animateChanges: nt,
            setActive: ot,
            setAnimateFunction: rt,
            getState: ()=>J
        }
    }
    function checkVariantsDidChange(_, k) {
        return typeof k == "string" ? k !== _ : Array.isArray(k) ? !shallowCompare(k, _) : !1
    }
    function createTypeState(_=!1) {
        return {
            isActive: _,
            protectedKeys: {},
            needsAnimating: {},
            prevResolvedValues: {}
        }
    }
    function createState() {
        return {
            animate: createTypeState(!0),
            whileInView: createTypeState(),
            whileHover: createTypeState(),
            whileTap: createTypeState(),
            whileDrag: createTypeState(),
            whileFocus: createTypeState(),
            exit: createTypeState()
        }
    }
    class AnimationFeature extends Feature {
        constructor(k) {
            super(k),
            k.animationState || (k.animationState = createAnimationState(k))
        }
        updateAnimationControlsSubscription() {
            const {animate: k} = this.node.getProps();
            this.unmount(),
            isAnimationControls(k) && (this.unmount = k.subscribe(this.node))
        }
        mount() {
            this.updateAnimationControlsSubscription()
        }
        update() {
            const {animate: k} = this.node.getProps()
              , {animate: J} = this.node.prevProps || {};
            k !== J && this.updateAnimationControlsSubscription()
        }
        unmount() {}
    }
    let id$2 = 0;
    class ExitAnimationFeature extends Feature {
        constructor() {
            super(...arguments),
            this.id = id$2++
        }
        update() {
            if (!this.node.presenceContext)
                return;
            const {isPresent: k, onExitComplete: J, custom: et} = this.node.presenceContext
              , {isPresent: tt} = this.node.prevPresenceContext || {};
            if (!this.node.animationState || k === tt)
                return;
            const rt = this.node.animationState.setActive("exit", !k, {
                custom: et != null ? et : this.node.getProps().custom
            });
            J && !k && rt.then(()=>J(this.id))
        }
        mount() {
            const {register: k} = this.node.presenceContext || {};
            k && (this.unmount = k(this.id))
        }
        unmount() {}
    }
    animations = {
        animation: {
            Feature: AnimationFeature
        },
        exit: {
            Feature: ExitAnimationFeature
        }
    },
    distance = (_,k)=>Math.abs(_ - k),
    distance2D = function(_, k) {
        const J = distance(_.x, k.x)
          , et = distance(_.y, k.y);
        return Math.sqrt(J ** 2 + et ** 2)
    }
    ;
    class PanSession {
        constructor(k, J, {transformPagePoint: et, contextWindow: tt, dragSnapToOrigin: rt=!1}={}) {
            if (this.startEvent = null,
            this.lastMoveEvent = null,
            this.lastMoveEventInfo = null,
            this.handlers = {},
            this.contextWindow = window,
            this.updatePoint = ()=>{
                if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                const st = getPanInfo(this.lastMoveEventInfo, this.history)
                  , ut = this.startEvent !== null
                  , ct = distance2D(st.offset, {
                    x: 0,
                    y: 0
                }) >= 3;
                if (!ut && !ct)
                    return;
                const {point: pt} = st
                  , {timestamp: ft} = frameData;
                this.history.push(_t($t({}, pt), {
                    timestamp: ft
                }));
                const {onStart: yt, onMove: ht} = this.handlers;
                ut || (yt && yt(this.lastMoveEvent, st),
                this.startEvent = this.lastMoveEvent),
                ht && ht(this.lastMoveEvent, st)
            }
            ,
            this.handlePointerMove = (st,ut)=>{
                this.lastMoveEvent = st,
                this.lastMoveEventInfo = transformPoint(ut, this.transformPagePoint),
                frame.update(this.updatePoint, !0)
            }
            ,
            this.handlePointerUp = (st,ut)=>{
                this.end();
                const {onEnd: ct, onSessionEnd: pt, resumeAnimation: ft} = this.handlers;
                if (this.dragSnapToOrigin && ft && ft(),
                !(this.lastMoveEvent && this.lastMoveEventInfo))
                    return;
                const yt = getPanInfo(st.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(ut, this.transformPagePoint), this.history);
                this.startEvent && ct && ct(st, yt),
                pt && pt(st, yt)
            }
            ,
            !isPrimaryPointer(k))
                return;
            this.dragSnapToOrigin = rt,
            this.handlers = J,
            this.transformPagePoint = et,
            this.contextWindow = tt || window;
            const nt = extractEventInfo(k)
              , ot = transformPoint(nt, this.transformPagePoint)
              , {point: it} = ot
              , {timestamp: at} = frameData;
            this.history = [_t($t({}, it), {
                timestamp: at
            })];
            const {onSessionStart: lt} = J;
            lt && lt(k, getPanInfo(ot, this.history)),
            this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
        }
        updateHandlers(k) {
            this.handlers = k
        }
        end() {
            this.removeListeners && this.removeListeners(),
            cancelFrame(this.updatePoint)
        }
    }
    function transformPoint(_, k) {
        return k ? {
            point: k(_.point)
        } : _
    }
    function subtractPoint(_, k) {
        return {
            x: _.x - k.x,
            y: _.y - k.y
        }
    }
    function getPanInfo({point: _}, k) {
        return {
            point: _,
            delta: subtractPoint(_, lastDevicePoint(k)),
            offset: subtractPoint(_, startDevicePoint(k)),
            velocity: getVelocity(k, .1)
        }
    }
    function startDevicePoint(_) {
        return _[0]
    }
    function lastDevicePoint(_) {
        return _[_.length - 1]
    }
    function getVelocity(_, k) {
        if (_.length < 2)
            return {
                x: 0,
                y: 0
            };
        let J = _.length - 1
          , et = null;
        const tt = lastDevicePoint(_);
        for (; J >= 0 && (et = _[J],
        !(tt.timestamp - et.timestamp > secondsToMilliseconds(k))); )
            J--;
        if (!et)
            return {
                x: 0,
                y: 0
            };
        const rt = millisecondsToSeconds(tt.timestamp - et.timestamp);
        if (rt === 0)
            return {
                x: 0,
                y: 0
            };
        const nt = {
            x: (tt.x - et.x) / rt,
            y: (tt.y - et.y) / rt
        };
        return nt.x === 1 / 0 && (nt.x = 0),
        nt.y === 1 / 0 && (nt.y = 0),
        nt
    }
    calcLength = function(_) {
        return _.max - _.min
    }
    ;
    function isNear(_, k=0, J=.01) {
        return Math.abs(_ - k) <= J
    }
    function calcAxisDelta(_, k, J, et=.5) {
        _.origin = et,
        _.originPoint = mix(k.min, k.max, _.origin),
        _.scale = calcLength(J) / calcLength(k),
        (isNear(_.scale, 1, 1e-4) || isNaN(_.scale)) && (_.scale = 1),
        _.translate = mix(J.min, J.max, _.origin) - _.originPoint,
        (isNear(_.translate) || isNaN(_.translate)) && (_.translate = 0)
    }
    function calcBoxDelta(_, k, J, et) {
        calcAxisDelta(_.x, k.x, J.x, et ? et.originX : void 0),
        calcAxisDelta(_.y, k.y, J.y, et ? et.originY : void 0)
    }
    function calcRelativeAxis(_, k, J) {
        _.min = J.min + k.min,
        _.max = _.min + calcLength(k)
    }
    function calcRelativeBox(_, k, J) {
        calcRelativeAxis(_.x, k.x, J.x),
        calcRelativeAxis(_.y, k.y, J.y)
    }
    function calcRelativeAxisPosition(_, k, J) {
        _.min = k.min - J.min,
        _.max = _.min + calcLength(k)
    }
    function calcRelativePosition(_, k, J) {
        calcRelativeAxisPosition(_.x, k.x, J.x),
        calcRelativeAxisPosition(_.y, k.y, J.y)
    }
    function applyConstraints(_, {min: k, max: J}, et) {
        return k !== void 0 && _ < k ? _ = et ? mix(k, _, et.min) : Math.max(_, k) : J !== void 0 && _ > J && (_ = et ? mix(J, _, et.max) : Math.min(_, J)),
        _
    }
    function calcRelativeAxisConstraints(_, k, J) {
        return {
            min: k !== void 0 ? _.min + k : void 0,
            max: J !== void 0 ? _.max + J - (_.max - _.min) : void 0
        }
    }
    function calcRelativeConstraints(_, {top: k, left: J, bottom: et, right: tt}) {
        return {
            x: calcRelativeAxisConstraints(_.x, J, tt),
            y: calcRelativeAxisConstraints(_.y, k, et)
        }
    }
    function calcViewportAxisConstraints(_, k) {
        let J = k.min - _.min
          , et = k.max - _.max;
        return k.max - k.min < _.max - _.min && ([J,et] = [et, J]),
        {
            min: J,
            max: et
        }
    }
    function calcViewportConstraints(_, k) {
        return {
            x: calcViewportAxisConstraints(_.x, k.x),
            y: calcViewportAxisConstraints(_.y, k.y)
        }
    }
    function calcOrigin(_, k) {
        let J = .5;
        const et = calcLength(_)
          , tt = calcLength(k);
        return tt > et ? J = progress(k.min, k.max - et, _.min) : et > tt && (J = progress(_.min, _.max - tt, k.min)),
        clamp(0, 1, J)
    }
    function rebaseAxisConstraints(_, k) {
        const J = {};
        return k.min !== void 0 && (J.min = k.min - _.min),
        k.max !== void 0 && (J.max = k.max - _.min),
        J
    }
    const defaultElastic = .35;
    function resolveDragElastic(_=defaultElastic) {
        return _ === !1 ? _ = 0 : _ === !0 && (_ = defaultElastic),
        {
            x: resolveAxisElastic(_, "left", "right"),
            y: resolveAxisElastic(_, "top", "bottom")
        }
    }
    function resolveAxisElastic(_, k, J) {
        return {
            min: resolvePointElastic(_, k),
            max: resolvePointElastic(_, J)
        }
    }
    function resolvePointElastic(_, k) {
        return typeof _ == "number" ? _ : _[k] || 0
    }
    let createAxisDelta, createDelta, createAxis;
    createAxisDelta = ()=>({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    createDelta = ()=>({
        x: createAxisDelta(),
        y: createAxisDelta()
    }),
    createAxis = ()=>({
        min: 0,
        max: 0
    }),
    createBox = ()=>({
        x: createAxis(),
        y: createAxis()
    });
    function eachAxis(_) {
        return [_("x"), _("y")]
    }
    function convertBoundingBoxToBox({top: _, left: k, right: J, bottom: et}) {
        return {
            x: {
                min: k,
                max: J
            },
            y: {
                min: _,
                max: et
            }
        }
    }
    function convertBoxToBoundingBox({x: _, y: k}) {
        return {
            top: k.min,
            right: _.max,
            bottom: k.max,
            left: _.min
        }
    }
    function transformBoxPoints(_, k) {
        if (!k)
            return _;
        const J = k({
            x: _.left,
            y: _.top
        })
          , et = k({
            x: _.right,
            y: _.bottom
        });
        return {
            top: J.y,
            left: J.x,
            bottom: et.y,
            right: et.x
        }
    }
    function isIdentityScale(_) {
        return _ === void 0 || _ === 1
    }
    function hasScale({scale: _, scaleX: k, scaleY: J}) {
        return !isIdentityScale(_) || !isIdentityScale(k) || !isIdentityScale(J)
    }
    function hasTransform(_) {
        return hasScale(_) || has2DTranslate(_) || _.z || _.rotate || _.rotateX || _.rotateY
    }
    function has2DTranslate(_) {
        return is2DTranslate(_.x) || is2DTranslate(_.y)
    }
    function is2DTranslate(_) {
        return _ && _ !== "0%"
    }
    function scalePoint(_, k, J) {
        const et = _ - J
          , tt = k * et;
        return J + tt
    }
    function applyPointDelta(_, k, J, et, tt) {
        return tt !== void 0 && (_ = scalePoint(_, tt, et)),
        scalePoint(_, J, et) + k
    }
    function applyAxisDelta(_, k=0, J=1, et, tt) {
        _.min = applyPointDelta(_.min, k, J, et, tt),
        _.max = applyPointDelta(_.max, k, J, et, tt)
    }
    function applyBoxDelta(_, {x: k, y: J}) {
        applyAxisDelta(_.x, k.translate, k.scale, k.originPoint),
        applyAxisDelta(_.y, J.translate, J.scale, J.originPoint)
    }
    function applyTreeDeltas(_, k, J, et=!1) {
        const tt = J.length;
        if (!tt)
            return;
        k.x = k.y = 1;
        let rt, nt;
        for (let ot = 0; ot < tt; ot++) {
            rt = J[ot],
            nt = rt.projectionDelta;
            const it = rt.instance;
            it && it.style && it.style.display === "contents" || (et && rt.options.layoutScroll && rt.scroll && rt !== rt.root && transformBox(_, {
                x: -rt.scroll.offset.x,
                y: -rt.scroll.offset.y
            }),
            nt && (k.x *= nt.x.scale,
            k.y *= nt.y.scale,
            applyBoxDelta(_, nt)),
            et && hasTransform(rt.latestValues) && transformBox(_, rt.latestValues))
        }
        k.x = snapToDefault(k.x),
        k.y = snapToDefault(k.y)
    }
    function snapToDefault(_) {
        return Number.isInteger(_) || _ > 1.0000000000001 || _ < .999999999999 ? _ : 1
    }
    function translateAxis(_, k) {
        _.min = _.min + k,
        _.max = _.max + k
    }
    function transformAxis(_, k, [J,et,tt]) {
        const rt = k[tt] !== void 0 ? k[tt] : .5
          , nt = mix(_.min, _.max, rt);
        applyAxisDelta(_, k[J], k[et], nt, k.scale)
    }
    const xKeys$1 = ["x", "scaleX", "originX"]
      , yKeys$1 = ["y", "scaleY", "originY"];
    function transformBox(_, k) {
        transformAxis(_.x, k, xKeys$1),
        transformAxis(_.y, k, yKeys$1)
    }
    function measureViewportBox(_, k) {
        return convertBoundingBoxToBox(transformBoxPoints(_.getBoundingClientRect(), k))
    }
    function measurePageBox(_, k, J) {
        const et = measureViewportBox(_, J)
          , {scroll: tt} = k;
        return tt && (translateAxis(et.x, tt.offset.x),
        translateAxis(et.y, tt.offset.y)),
        et
    }
    const getContextWindow = ({current: _})=>_ ? _.ownerDocument.defaultView : null
      , elementDragControls = new WeakMap;
    class VisualElementDragControls {
        constructor(k) {
            this.openGlobalLock = null,
            this.isDragging = !1,
            this.currentDirection = null,
            this.originPoint = {
                x: 0,
                y: 0
            },
            this.constraints = !1,
            this.hasMutatedConstraints = !1,
            this.elastic = createBox(),
            this.visualElement = k
        }
        start(k, {snapToCursor: J=!1}={}) {
            const {presenceContext: et} = this.visualElement;
            if (et && et.isPresent === !1)
                return;
            const tt = lt=>{
                const {dragSnapToOrigin: st} = this.getProps();
                st ? this.pauseAnimation() : this.stopAnimation(),
                J && this.snapToCursor(extractEventInfo(lt, "page").point)
            }
              , rt = (lt,st)=>{
                const {drag: ut, dragPropagation: ct, onDragStart: pt} = this.getProps();
                if (ut && !ct && (this.openGlobalLock && this.openGlobalLock(),
                this.openGlobalLock = getGlobalLock(ut),
                !this.openGlobalLock))
                    return;
                this.isDragging = !0,
                this.currentDirection = null,
                this.resolveConstraints(),
                this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
                this.visualElement.projection.target = void 0),
                eachAxis(yt=>{
                    let ht = this.getAxisMotionValue(yt).get() || 0;
                    if (percent.test(ht)) {
                        const {projection: gt} = this.visualElement;
                        if (gt && gt.layout) {
                            const mt = gt.layout.layoutBox[yt];
                            mt && (ht = calcLength(mt) * (parseFloat(ht) / 100))
                        }
                    }
                    this.originPoint[yt] = ht
                }
                ),
                pt && frame.update(()=>pt(lt, st), !1, !0);
                const {animationState: ft} = this.visualElement;
                ft && ft.setActive("whileDrag", !0)
            }
              , nt = (lt,st)=>{
                const {dragPropagation: ut, dragDirectionLock: ct, onDirectionLock: pt, onDrag: ft} = this.getProps();
                if (!ut && !this.openGlobalLock)
                    return;
                const {offset: yt} = st;
                if (ct && this.currentDirection === null) {
                    this.currentDirection = getCurrentDirection(yt),
                    this.currentDirection !== null && pt && pt(this.currentDirection);
                    return
                }
                this.updateAxis("x", st.point, yt),
                this.updateAxis("y", st.point, yt),
                this.visualElement.render(),
                ft && ft(lt, st)
            }
              , ot = (lt,st)=>this.stop(lt, st)
              , it = ()=>eachAxis(lt=>{
                var st;
                return this.getAnimationState(lt) === "paused" && ((st = this.getAxisMotionValue(lt).animation) === null || st === void 0 ? void 0 : st.play())
            }
            )
              , {dragSnapToOrigin: at} = this.getProps();
            this.panSession = new PanSession(k,{
                onSessionStart: tt,
                onStart: rt,
                onMove: nt,
                onSessionEnd: ot,
                resumeAnimation: it
            },{
                transformPagePoint: this.visualElement.getTransformPagePoint(),
                dragSnapToOrigin: at,
                contextWindow: getContextWindow(this.visualElement)
            })
        }
        stop(k, J) {
            const et = this.isDragging;
            if (this.cancel(),
            !et)
                return;
            const {velocity: tt} = J;
            this.startAnimation(tt);
            const {onDragEnd: rt} = this.getProps();
            rt && frame.update(()=>rt(k, J))
        }
        cancel() {
            this.isDragging = !1;
            const {projection: k, animationState: J} = this.visualElement;
            k && (k.isAnimationBlocked = !1),
            this.panSession && this.panSession.end(),
            this.panSession = void 0;
            const {dragPropagation: et} = this.getProps();
            !et && this.openGlobalLock && (this.openGlobalLock(),
            this.openGlobalLock = null),
            J && J.setActive("whileDrag", !1)
        }
        updateAxis(k, J, et) {
            const {drag: tt} = this.getProps();
            if (!et || !shouldDrag(k, tt, this.currentDirection))
                return;
            const rt = this.getAxisMotionValue(k);
            let nt = this.originPoint[k] + et[k];
            this.constraints && this.constraints[k] && (nt = applyConstraints(nt, this.constraints[k], this.elastic[k])),
            rt.set(nt)
        }
        resolveConstraints() {
            var k;
            const {dragConstraints: J, dragElastic: et} = this.getProps()
              , tt = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (k = this.visualElement.projection) === null || k === void 0 ? void 0 : k.layout
              , rt = this.constraints;
            J && isRefObject(J) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : J && tt ? this.constraints = calcRelativeConstraints(tt.layoutBox, J) : this.constraints = !1,
            this.elastic = resolveDragElastic(et),
            rt !== this.constraints && tt && this.constraints && !this.hasMutatedConstraints && eachAxis(nt=>{
                this.getAxisMotionValue(nt) && (this.constraints[nt] = rebaseAxisConstraints(tt.layoutBox[nt], this.constraints[nt]))
            }
            )
        }
        resolveRefConstraints() {
            const {dragConstraints: k, onMeasureDragConstraints: J} = this.getProps();
            if (!k || !isRefObject(k))
                return !1;
            const et = k.current
              , {projection: tt} = this.visualElement;
            if (!tt || !tt.layout)
                return !1;
            const rt = measurePageBox(et, tt.root, this.visualElement.getTransformPagePoint());
            let nt = calcViewportConstraints(tt.layout.layoutBox, rt);
            if (J) {
                const ot = J(convertBoxToBoundingBox(nt));
                this.hasMutatedConstraints = !!ot,
                ot && (nt = convertBoundingBoxToBox(ot))
            }
            return nt
        }
        startAnimation(k) {
            const {drag: J, dragMomentum: et, dragElastic: tt, dragTransition: rt, dragSnapToOrigin: nt, onDragTransitionEnd: ot} = this.getProps()
              , it = this.constraints || {}
              , at = eachAxis(lt=>{
                if (!shouldDrag(lt, J, this.currentDirection))
                    return;
                let st = it && it[lt] || {};
                nt && (st = {
                    min: 0,
                    max: 0
                });
                const ut = tt ? 200 : 1e6
                  , ct = tt ? 40 : 1e7
                  , pt = $t($t({
                    type: "inertia",
                    velocity: et ? k[lt] : 0,
                    bounceStiffness: ut,
                    bounceDamping: ct,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10
                }, rt), st);
                return this.startAxisValueAnimation(lt, pt)
            }
            );
            return Promise.all(at).then(ot)
        }
        startAxisValueAnimation(k, J) {
            const et = this.getAxisMotionValue(k);
            return et.start(animateMotionValue(k, et, 0, J))
        }
        stopAnimation() {
            eachAxis(k=>this.getAxisMotionValue(k).stop())
        }
        pauseAnimation() {
            eachAxis(k=>{
                var J;
                return (J = this.getAxisMotionValue(k).animation) === null || J === void 0 ? void 0 : J.pause()
            }
            )
        }
        getAnimationState(k) {
            var J;
            return (J = this.getAxisMotionValue(k).animation) === null || J === void 0 ? void 0 : J.state
        }
        getAxisMotionValue(k) {
            const J = "_drag" + k.toUpperCase()
              , et = this.visualElement.getProps();
            return et[J] || this.visualElement.getValue(k, (et.initial ? et.initial[k] : void 0) || 0)
        }
        snapToCursor(k) {
            eachAxis(J=>{
                const {drag: et} = this.getProps();
                if (!shouldDrag(J, et, this.currentDirection))
                    return;
                const {projection: tt} = this.visualElement
                  , rt = this.getAxisMotionValue(J);
                if (tt && tt.layout) {
                    const {min: nt, max: ot} = tt.layout.layoutBox[J];
                    rt.set(k[J] - mix(nt, ot, .5))
                }
            }
            )
        }
        scalePositionWithinConstraints() {
            if (!this.visualElement.current)
                return;
            const {drag: k, dragConstraints: J} = this.getProps()
              , {projection: et} = this.visualElement;
            if (!isRefObject(J) || !et || !this.constraints)
                return;
            this.stopAnimation();
            const tt = {
                x: 0,
                y: 0
            };
            eachAxis(nt=>{
                const ot = this.getAxisMotionValue(nt);
                if (ot) {
                    const it = ot.get();
                    tt[nt] = calcOrigin({
                        min: it,
                        max: it
                    }, this.constraints[nt])
                }
            }
            );
            const {transformTemplate: rt} = this.visualElement.getProps();
            this.visualElement.current.style.transform = rt ? rt({}, "") : "none",
            et.root && et.root.updateScroll(),
            et.updateLayout(),
            this.resolveConstraints(),
            eachAxis(nt=>{
                if (!shouldDrag(nt, k, null))
                    return;
                const ot = this.getAxisMotionValue(nt)
                  , {min: it, max: at} = this.constraints[nt];
                ot.set(mix(it, at, tt[nt]))
            }
            )
        }
        addListeners() {
            if (!this.visualElement.current)
                return;
            elementDragControls.set(this.visualElement, this);
            const k = this.visualElement.current
              , J = addPointerEvent(k, "pointerdown", it=>{
                const {drag: at, dragListener: lt=!0} = this.getProps();
                at && lt && this.start(it)
            }
            )
              , et = ()=>{
                const {dragConstraints: it} = this.getProps();
                isRefObject(it) && (this.constraints = this.resolveRefConstraints())
            }
              , {projection: tt} = this.visualElement
              , rt = tt.addEventListener("measure", et);
            tt && !tt.layout && (tt.root && tt.root.updateScroll(),
            tt.updateLayout()),
            et();
            const nt = addDomEvent(window, "resize", ()=>this.scalePositionWithinConstraints())
              , ot = tt.addEventListener("didUpdate", ({delta: it, hasLayoutChanged: at})=>{
                this.isDragging && at && (eachAxis(lt=>{
                    const st = this.getAxisMotionValue(lt);
                    st && (this.originPoint[lt] += it[lt].translate,
                    st.set(st.get() + it[lt].translate))
                }
                ),
                this.visualElement.render())
            }
            );
            return ()=>{
                nt(),
                J(),
                rt(),
                ot && ot()
            }
        }
        getProps() {
            const k = this.visualElement.getProps()
              , {drag: J=!1, dragDirectionLock: et=!1, dragPropagation: tt=!1, dragConstraints: rt=!1, dragElastic: nt=defaultElastic, dragMomentum: ot=!0} = k;
            return _t($t({}, k), {
                drag: J,
                dragDirectionLock: et,
                dragPropagation: tt,
                dragConstraints: rt,
                dragElastic: nt,
                dragMomentum: ot
            })
        }
    }
    function shouldDrag(_, k, J) {
        return (k === !0 || k === _) && (J === null || J === _)
    }
    function getCurrentDirection(_, k=10) {
        let J = null;
        return Math.abs(_.y) > k ? J = "y" : Math.abs(_.x) > k && (J = "x"),
        J
    }
    class DragGesture extends Feature {
        constructor(k) {
            super(k),
            this.removeGroupControls = noop$4,
            this.removeListeners = noop$4,
            this.controls = new VisualElementDragControls(k)
        }
        mount() {
            const {dragControls: k} = this.node.getProps();
            k && (this.removeGroupControls = k.subscribe(this.controls)),
            this.removeListeners = this.controls.addListeners() || noop$4
        }
        unmount() {
            this.removeGroupControls(),
            this.removeListeners()
        }
    }
    const asyncHandler = _=>(k,J)=>{
        _ && frame.update(()=>_(k, J))
    }
    ;
    class PanGesture extends Feature {
        constructor() {
            super(...arguments),
            this.removePointerDownListener = noop$4
        }
        onPointerDown(k) {
            this.session = new PanSession(k,this.createPanHandlers(),{
                transformPagePoint: this.node.getTransformPagePoint(),
                contextWindow: getContextWindow(this.node)
            })
        }
        createPanHandlers() {
            const {onPanSessionStart: k, onPanStart: J, onPan: et, onPanEnd: tt} = this.node.getProps();
            return {
                onSessionStart: asyncHandler(k),
                onStart: asyncHandler(J),
                onMove: et,
                onEnd: (rt,nt)=>{
                    delete this.session,
                    tt && frame.update(()=>tt(rt, nt))
                }
            }
        }
        mount() {
            this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", k=>this.onPointerDown(k))
        }
        update() {
            this.session && this.session.updateHandlers(this.createPanHandlers())
        }
        unmount() {
            this.removePointerDownListener(),
            this.session && this.session.end()
        }
    }
    usePresence = function() {
        const _ = reactExports.useContext(PresenceContext);
        if (_ === null)
            return [!0, null];
        const {isPresent: k, onExitComplete: J, register: et} = _
          , tt = reactExports.useId();
        return reactExports.useEffect(()=>et(tt), []),
        !k && J ? [!1, ()=>J && J(tt)] : [!0]
    }
    ,
    useIsPresent = function() {
        return isPresent(reactExports.useContext(PresenceContext))
    }
    ;
    function isPresent(_) {
        return _ === null ? !0 : _.isPresent
    }
    const globalProjectionState = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
    };
    function pixelsToPercent(_, k) {
        return k.max === k.min ? 0 : _ / (k.max - k.min) * 100
    }
    const correctBorderRadius = {
        correct: (_,k)=>{
            if (!k.target)
                return _;
            if (typeof _ == "string")
                if (px.test(_))
                    _ = parseFloat(_);
                else
                    return _;
            const J = pixelsToPercent(_, k.target.x)
              , et = pixelsToPercent(_, k.target.y);
            return `${J}% ${et}%`
        }
    }
      , correctBoxShadow = {
        correct: (_,{treeScale: k, projectionDelta: J})=>{
            const et = _
              , tt = complex.parse(_);
            if (tt.length > 5)
                return et;
            const rt = complex.createTransformer(_)
              , nt = typeof tt[0] != "number" ? 1 : 0
              , ot = J.x.scale * k.x
              , it = J.y.scale * k.y;
            tt[0 + nt] /= ot,
            tt[1 + nt] /= it;
            const at = mix(ot, it, .5);
            return typeof tt[2 + nt] == "number" && (tt[2 + nt] /= at),
            typeof tt[3 + nt] == "number" && (tt[3 + nt] /= at),
            rt(tt)
        }
    };
    class MeasureLayoutWithContext extends React.Component {
        componentDidMount() {
            const {visualElement: k, layoutGroup: J, switchLayoutGroup: et, layoutId: tt} = this.props
              , {projection: rt} = k;
            addScaleCorrector(defaultScaleCorrectors),
            rt && (J.group && J.group.add(rt),
            et && et.register && tt && et.register(rt),
            rt.root.didUpdate(),
            rt.addEventListener("animationComplete", ()=>{
                this.safeToRemove()
            }
            ),
            rt.setOptions(_t($t({}, rt.options), {
                onExitComplete: ()=>this.safeToRemove()
            }))),
            globalProjectionState.hasEverUpdated = !0
        }
        getSnapshotBeforeUpdate(k) {
            const {layoutDependency: J, visualElement: et, drag: tt, isPresent: rt} = this.props
              , nt = et.projection;
            return nt && (nt.isPresent = rt,
            tt || k.layoutDependency !== J || J === void 0 ? nt.willUpdate() : this.safeToRemove(),
            k.isPresent !== rt && (rt ? nt.promote() : nt.relegate() || frame.postRender(()=>{
                const ot = nt.getStack();
                (!ot || !ot.members.length) && this.safeToRemove()
            }
            ))),
            null
        }
        componentDidUpdate() {
            const {projection: k} = this.props.visualElement;
            k && (k.root.didUpdate(),
            queueMicrotask(()=>{
                !k.currentAnimation && k.isLead() && this.safeToRemove()
            }
            ))
        }
        componentWillUnmount() {
            const {visualElement: k, layoutGroup: J, switchLayoutGroup: et} = this.props
              , {projection: tt} = k;
            tt && (tt.scheduleCheckAfterUnmount(),
            J && J.group && J.group.remove(tt),
            et && et.deregister && et.deregister(tt))
        }
        safeToRemove() {
            const {safeToRemove: k} = this.props;
            k && k()
        }
        render() {
            return null
        }
    }
    function MeasureLayout(_) {
        const [k,J] = usePresence()
          , et = reactExports.useContext(LayoutGroupContext);
        return React.createElement(MeasureLayoutWithContext, _t($t({}, _), {
            layoutGroup: et,
            switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
            isPresent: k,
            safeToRemove: J
        }))
    }
    const defaultScaleCorrectors = {
        borderRadius: _t($t({}, correctBorderRadius), {
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
        }),
        borderTopLeftRadius: correctBorderRadius,
        borderTopRightRadius: correctBorderRadius,
        borderBottomLeftRadius: correctBorderRadius,
        borderBottomRightRadius: correctBorderRadius,
        boxShadow: correctBoxShadow
    }
      , borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
      , numBorders = borders.length
      , asNumber = _=>typeof _ == "string" ? parseFloat(_) : _
      , isPx = _=>typeof _ == "number" || px.test(_);
    function mixValues(_, k, J, et, tt, rt) {
        tt ? (_.opacity = mix(0, J.opacity !== void 0 ? J.opacity : 1, easeCrossfadeIn(et)),
        _.opacityExit = mix(k.opacity !== void 0 ? k.opacity : 1, 0, easeCrossfadeOut(et))) : rt && (_.opacity = mix(k.opacity !== void 0 ? k.opacity : 1, J.opacity !== void 0 ? J.opacity : 1, et));
        for (let nt = 0; nt < numBorders; nt++) {
            const ot = `border${borders[nt]}Radius`;
            let it = getRadius(k, ot)
              , at = getRadius(J, ot);
            it === void 0 && at === void 0 || (it || (it = 0),
            at || (at = 0),
            it === 0 || at === 0 || isPx(it) === isPx(at) ? (_[ot] = Math.max(mix(asNumber(it), asNumber(at), et), 0),
            (percent.test(at) || percent.test(it)) && (_[ot] += "%")) : _[ot] = at)
        }
        (k.rotate || J.rotate) && (_.rotate = mix(k.rotate || 0, J.rotate || 0, et))
    }
    function getRadius(_, k) {
        return _[k] !== void 0 ? _[k] : _.borderRadius
    }
    const easeCrossfadeIn = compress(0, .5, circOut)
      , easeCrossfadeOut = compress(.5, .95, noop$4);
    function compress(_, k, J) {
        return et=>et < _ ? 0 : et > k ? 1 : J(progress(_, k, et))
    }
    function copyAxisInto(_, k) {
        _.min = k.min,
        _.max = k.max
    }
    function copyBoxInto(_, k) {
        copyAxisInto(_.x, k.x),
        copyAxisInto(_.y, k.y)
    }
    function removePointDelta(_, k, J, et, tt) {
        return _ -= k,
        _ = scalePoint(_, 1 / J, et),
        tt !== void 0 && (_ = scalePoint(_, 1 / tt, et)),
        _
    }
    function removeAxisDelta(_, k=0, J=1, et=.5, tt, rt=_, nt=_) {
        if (percent.test(k) && (k = parseFloat(k),
        k = mix(nt.min, nt.max, k / 100) - nt.min),
        typeof k != "number")
            return;
        let ot = mix(rt.min, rt.max, et);
        _ === rt && (ot -= k),
        _.min = removePointDelta(_.min, k, J, ot, tt),
        _.max = removePointDelta(_.max, k, J, ot, tt)
    }
    function removeAxisTransforms(_, k, [J,et,tt], rt, nt) {
        removeAxisDelta(_, k[J], k[et], k[tt], k.scale, rt, nt)
    }
    const xKeys = ["x", "scaleX", "originX"]
      , yKeys = ["y", "scaleY", "originY"];
    function removeBoxTransforms(_, k, J, et) {
        removeAxisTransforms(_.x, k, xKeys, J ? J.x : void 0, et ? et.x : void 0),
        removeAxisTransforms(_.y, k, yKeys, J ? J.y : void 0, et ? et.y : void 0)
    }
    function isAxisDeltaZero(_) {
        return _.translate === 0 && _.scale === 1
    }
    function isDeltaZero(_) {
        return isAxisDeltaZero(_.x) && isAxisDeltaZero(_.y)
    }
    function boxEquals(_, k) {
        return _.x.min === k.x.min && _.x.max === k.x.max && _.y.min === k.y.min && _.y.max === k.y.max
    }
    function boxEqualsRounded(_, k) {
        return Math.round(_.x.min) === Math.round(k.x.min) && Math.round(_.x.max) === Math.round(k.x.max) && Math.round(_.y.min) === Math.round(k.y.min) && Math.round(_.y.max) === Math.round(k.y.max)
    }
    function aspectRatio(_) {
        return calcLength(_.x) / calcLength(_.y)
    }
    class NodeStack {
        constructor() {
            this.members = []
        }
        add(k) {
            addUniqueItem(this.members, k),
            k.scheduleRender()
        }
        remove(k) {
            if (removeItem(this.members, k),
            k === this.prevLead && (this.prevLead = void 0),
            k === this.lead) {
                const J = this.members[this.members.length - 1];
                J && this.promote(J)
            }
        }
        relegate(k) {
            const J = this.members.findIndex(tt=>k === tt);
            if (J === 0)
                return !1;
            let et;
            for (let tt = J; tt >= 0; tt--) {
                const rt = this.members[tt];
                if (rt.isPresent !== !1) {
                    et = rt;
                    break
                }
            }
            return et ? (this.promote(et),
            !0) : !1
        }
        promote(k, J) {
            const et = this.lead;
            if (k !== et && (this.prevLead = et,
            this.lead = k,
            k.show(),
            et)) {
                et.instance && et.scheduleRender(),
                k.scheduleRender(),
                k.resumeFrom = et,
                J && (k.resumeFrom.preserveOpacity = !0),
                et.snapshot && (k.snapshot = et.snapshot,
                k.snapshot.latestValues = et.animationValues || et.latestValues),
                k.root && k.root.isUpdating && (k.isLayoutDirty = !0);
                const {crossfade: tt} = k.options;
                tt === !1 && et.hide()
            }
        }
        exitAnimationComplete() {
            this.members.forEach(k=>{
                const {options: J, resumingFrom: et} = k;
                J.onExitComplete && J.onExitComplete(),
                et && et.options.onExitComplete && et.options.onExitComplete()
            }
            )
        }
        scheduleRender() {
            this.members.forEach(k=>{
                k.instance && k.scheduleRender(!1)
            }
            )
        }
        removeLeadSnapshot() {
            this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
        }
    }
    function buildProjectionTransform(_, k, J) {
        let et = "";
        const tt = _.x.translate / k.x
          , rt = _.y.translate / k.y;
        if ((tt || rt) && (et = `translate3d(${tt}px, ${rt}px, 0) `),
        (k.x !== 1 || k.y !== 1) && (et += `scale(${1 / k.x}, ${1 / k.y}) `),
        J) {
            const {rotate: it, rotateX: at, rotateY: lt} = J;
            it && (et += `rotate(${it}deg) `),
            at && (et += `rotateX(${at}deg) `),
            lt && (et += `rotateY(${lt}deg) `)
        }
        const nt = _.x.scale * k.x
          , ot = _.y.scale * k.y;
        return (nt !== 1 || ot !== 1) && (et += `scale(${nt}, ${ot})`),
        et || "none"
    }
    const compareByDepth = (_,k)=>_.depth - k.depth;
    FlatTree = class {
        constructor() {
            this.children = [],
            this.isDirty = !1
        }
        add(_) {
            addUniqueItem(this.children, _),
            this.isDirty = !0
        }
        remove(_) {
            removeItem(this.children, _),
            this.isDirty = !0
        }
        forEach(_) {
            this.isDirty && this.children.sort(compareByDepth),
            this.isDirty = !1,
            this.children.forEach(_)
        }
    }
    ,
    delay$1 = function(_, k) {
        const J = performance.now()
          , et = ({timestamp: tt})=>{
            const rt = tt - J;
            rt >= k && (cancelFrame(et),
            _(rt - k))
        }
        ;
        return frame.read(et, !0),
        ()=>cancelFrame(et)
    }
    ;
    function record(_) {
        window.MotionDebug && window.MotionDebug.record(_)
    }
    function isSVGElement(_) {
        return _ instanceof SVGElement && _.tagName !== "svg"
    }
    function animateSingleValue(_, k, J) {
        const et = isMotionValue(_) ? _ : motionValue(_);
        return et.start(animateMotionValue("", et, k, J)),
        et.animation
    }
    const transformAxes = ["", "X", "Y", "Z"]
      , hiddenVisibility = {
        visibility: "hidden"
    }
      , animationTarget = 1e3;
    let id$1 = 0;
    const projectionFrameData = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
    };
    function createProjectionNode({attachResizeListener: _, defaultParent: k, measureScroll: J, checkIsScrollRoot: et, resetTransform: tt}) {
        return class {
            constructor(rt={}, nt=k == null ? void 0 : k()) {
                this.id = id$1++,
                this.animationId = 0,
                this.children = new Set,
                this.options = {},
                this.isTreeAnimating = !1,
                this.isAnimationBlocked = !1,
                this.isLayoutDirty = !1,
                this.isProjectionDirty = !1,
                this.isSharedProjectionDirty = !1,
                this.isTransformDirty = !1,
                this.updateManuallyBlocked = !1,
                this.updateBlockedByResize = !1,
                this.isUpdating = !1,
                this.isSVG = !1,
                this.needsReset = !1,
                this.shouldResetTransform = !1,
                this.treeScale = {
                    x: 1,
                    y: 1
                },
                this.eventHandlers = new Map,
                this.hasTreeAnimated = !1,
                this.updateScheduled = !1,
                this.projectionUpdateScheduled = !1,
                this.checkUpdateFailed = ()=>{
                    this.isUpdating && (this.isUpdating = !1,
                    this.clearAllSnapshots())
                }
                ,
                this.updateProjection = ()=>{
                    this.projectionUpdateScheduled = !1,
                    projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0,
                    this.nodes.forEach(propagateDirtyNodes),
                    this.nodes.forEach(resolveTargetDelta),
                    this.nodes.forEach(calcProjection),
                    this.nodes.forEach(cleanDirtyNodes),
                    record(projectionFrameData)
                }
                ,
                this.hasProjected = !1,
                this.isVisible = !0,
                this.animationProgress = 0,
                this.sharedNodes = new Map,
                this.latestValues = rt,
                this.root = nt ? nt.root || nt : this,
                this.path = nt ? [...nt.path, nt] : [],
                this.parent = nt,
                this.depth = nt ? nt.depth + 1 : 0;
                for (let ot = 0; ot < this.path.length; ot++)
                    this.path[ot].shouldResetTransform = !0;
                this.root === this && (this.nodes = new FlatTree)
            }
            addEventListener(rt, nt) {
                return this.eventHandlers.has(rt) || this.eventHandlers.set(rt, new SubscriptionManager),
                this.eventHandlers.get(rt).add(nt)
            }
            notifyListeners(rt, ...nt) {
                const ot = this.eventHandlers.get(rt);
                ot && ot.notify(...nt)
            }
            hasListeners(rt) {
                return this.eventHandlers.has(rt)
            }
            mount(rt, nt=this.root.hasTreeAnimated) {
                if (this.instance)
                    return;
                this.isSVG = isSVGElement(rt),
                this.instance = rt;
                const {layoutId: ot, layout: it, visualElement: at} = this.options;
                if (at && !at.current && at.mount(rt),
                this.root.nodes.add(this),
                this.parent && this.parent.children.add(this),
                nt && (it || ot) && (this.isLayoutDirty = !0),
                _) {
                    let lt;
                    const st = ()=>this.root.updateBlockedByResize = !1;
                    _(rt, ()=>{
                        this.root.updateBlockedByResize = !0,
                        lt && lt(),
                        lt = delay$1(st, 250),
                        globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1,
                        this.nodes.forEach(finishAnimation))
                    }
                    )
                }
                ot && this.root.registerSharedNode(ot, this),
                this.options.animate !== !1 && at && (ot || it) && this.addEventListener("didUpdate", ({delta: lt, hasLayoutChanged: st, hasRelativeTargetChanged: ut, layout: ct})=>{
                    if (this.isTreeAnimationBlocked()) {
                        this.target = void 0,
                        this.relativeTarget = void 0;
                        return
                    }
                    const pt = this.options.transition || at.getDefaultTransition() || defaultLayoutTransition
                      , {onLayoutAnimationStart: ft, onLayoutAnimationComplete: yt} = at.getProps()
                      , ht = !this.targetLayout || !boxEqualsRounded(this.targetLayout, ct) || ut
                      , gt = !st && ut;
                    if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || gt || st && (ht || !this.currentAnimation)) {
                        this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                        this.resumingFrom.resumingFrom = void 0),
                        this.setAnimationOrigin(lt, gt);
                        const mt = _t($t({}, getValueTransition$1(pt, "layout")), {
                            onPlay: ft,
                            onComplete: yt
                        });
                        (at.shouldReduceMotion || this.options.layoutRoot) && (mt.delay = 0,
                        mt.type = !1),
                        this.startAnimation(mt)
                    } else
                        st || finishAnimation(this),
                        this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                    this.targetLayout = ct
                }
                )
            }
            unmount() {
                this.options.layoutId && this.willUpdate(),
                this.root.nodes.remove(this);
                const rt = this.getStack();
                rt && rt.remove(this),
                this.parent && this.parent.children.delete(this),
                this.instance = void 0,
                cancelFrame(this.updateProjection)
            }
            blockUpdate() {
                this.updateManuallyBlocked = !0
            }
            unblockUpdate() {
                this.updateManuallyBlocked = !1
            }
            isUpdateBlocked() {
                return this.updateManuallyBlocked || this.updateBlockedByResize
            }
            isTreeAnimationBlocked() {
                return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
            }
            startUpdate() {
                this.isUpdateBlocked() || (this.isUpdating = !0,
                this.nodes && this.nodes.forEach(resetRotation),
                this.animationId++)
            }
            getTransformTemplate() {
                const {visualElement: rt} = this.options;
                return rt && rt.getProps().transformTemplate
            }
            willUpdate(rt=!0) {
                if (this.root.hasTreeAnimated = !0,
                this.root.isUpdateBlocked()) {
                    this.options.onExitComplete && this.options.onExitComplete();
                    return
                }
                if (!this.root.isUpdating && this.root.startUpdate(),
                this.isLayoutDirty)
                    return;
                this.isLayoutDirty = !0;
                for (let at = 0; at < this.path.length; at++) {
                    const lt = this.path[at];
                    lt.shouldResetTransform = !0,
                    lt.updateScroll("snapshot"),
                    lt.options.layoutRoot && lt.willUpdate(!1)
                }
                const {layoutId: nt, layout: ot} = this.options;
                if (nt === void 0 && !ot)
                    return;
                const it = this.getTransformTemplate();
                this.prevTransformTemplateValue = it ? it(this.latestValues, "") : void 0,
                this.updateSnapshot(),
                rt && this.notifyListeners("willUpdate")
            }
            update() {
                if (this.updateScheduled = !1,
                this.isUpdateBlocked()) {
                    this.unblockUpdate(),
                    this.clearAllSnapshots(),
                    this.nodes.forEach(clearMeasurements);
                    return
                }
                this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
                this.isUpdating = !1,
                this.nodes.forEach(resetTransformStyle),
                this.nodes.forEach(updateLayout),
                this.nodes.forEach(notifyLayoutUpdate),
                this.clearAllSnapshots();
                const rt = performance.now();
                frameData.delta = clamp(0, 1e3 / 60, rt - frameData.timestamp),
                frameData.timestamp = rt,
                frameData.isProcessing = !0,
                steps.update.process(frameData),
                steps.preRender.process(frameData),
                steps.render.process(frameData),
                frameData.isProcessing = !1
            }
            didUpdate() {
                this.updateScheduled || (this.updateScheduled = !0,
                queueMicrotask(()=>this.update()))
            }
            clearAllSnapshots() {
                this.nodes.forEach(clearSnapshot),
                this.sharedNodes.forEach(removeLeadSnapshots)
            }
            scheduleUpdateProjection() {
                this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
                frame.preRender(this.updateProjection, !1, !0))
            }
            scheduleCheckAfterUnmount() {
                frame.postRender(()=>{
                    this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                }
                )
            }
            updateSnapshot() {
                this.snapshot || !this.instance || (this.snapshot = this.measure())
            }
            updateLayout() {
                if (!this.instance || (this.updateScroll(),
                !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                    return;
                if (this.resumeFrom && !this.resumeFrom.instance)
                    for (let ot = 0; ot < this.path.length; ot++)
                        this.path[ot].updateScroll();
                const rt = this.layout;
                this.layout = this.measure(!1),
                this.layoutCorrected = createBox(),
                this.isLayoutDirty = !1,
                this.projectionDelta = void 0,
                this.notifyListeners("measure", this.layout.layoutBox);
                const {visualElement: nt} = this.options;
                nt && nt.notify("LayoutMeasure", this.layout.layoutBox, rt ? rt.layoutBox : void 0)
            }
            updateScroll(rt="measure") {
                let nt = !!(this.options.layoutScroll && this.instance);
                this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === rt && (nt = !1),
                nt && (this.scroll = {
                    animationId: this.root.animationId,
                    phase: rt,
                    isRoot: et(this.instance),
                    offset: J(this.instance)
                })
            }
            resetTransform() {
                if (!tt)
                    return;
                const rt = this.isLayoutDirty || this.shouldResetTransform
                  , nt = this.projectionDelta && !isDeltaZero(this.projectionDelta)
                  , ot = this.getTransformTemplate()
                  , it = ot ? ot(this.latestValues, "") : void 0
                  , at = it !== this.prevTransformTemplateValue;
                rt && (nt || hasTransform(this.latestValues) || at) && (tt(this.instance, it),
                this.shouldResetTransform = !1,
                this.scheduleRender())
            }
            measure(rt=!0) {
                const nt = this.measurePageBox();
                let ot = this.removeElementScroll(nt);
                return rt && (ot = this.removeTransform(ot)),
                roundBox(ot),
                {
                    animationId: this.root.animationId,
                    measuredBox: nt,
                    layoutBox: ot,
                    latestValues: {},
                    source: this.id
                }
            }
            measurePageBox() {
                const {visualElement: rt} = this.options;
                if (!rt)
                    return createBox();
                const nt = rt.measureViewportBox()
                  , {scroll: ot} = this.root;
                return ot && (translateAxis(nt.x, ot.offset.x),
                translateAxis(nt.y, ot.offset.y)),
                nt
            }
            removeElementScroll(rt) {
                const nt = createBox();
                copyBoxInto(nt, rt);
                for (let ot = 0; ot < this.path.length; ot++) {
                    const it = this.path[ot]
                      , {scroll: at, options: lt} = it;
                    if (it !== this.root && at && lt.layoutScroll) {
                        if (at.isRoot) {
                            copyBoxInto(nt, rt);
                            const {scroll: st} = this.root;
                            st && (translateAxis(nt.x, -st.offset.x),
                            translateAxis(nt.y, -st.offset.y))
                        }
                        translateAxis(nt.x, at.offset.x),
                        translateAxis(nt.y, at.offset.y)
                    }
                }
                return nt
            }
            applyTransform(rt, nt=!1) {
                const ot = createBox();
                copyBoxInto(ot, rt);
                for (let it = 0; it < this.path.length; it++) {
                    const at = this.path[it];
                    !nt && at.options.layoutScroll && at.scroll && at !== at.root && transformBox(ot, {
                        x: -at.scroll.offset.x,
                        y: -at.scroll.offset.y
                    }),
                    hasTransform(at.latestValues) && transformBox(ot, at.latestValues)
                }
                return hasTransform(this.latestValues) && transformBox(ot, this.latestValues),
                ot
            }
            removeTransform(rt) {
                const nt = createBox();
                copyBoxInto(nt, rt);
                for (let ot = 0; ot < this.path.length; ot++) {
                    const it = this.path[ot];
                    if (!it.instance || !hasTransform(it.latestValues))
                        continue;
                    hasScale(it.latestValues) && it.updateSnapshot();
                    const at = createBox()
                      , lt = it.measurePageBox();
                    copyBoxInto(at, lt),
                    removeBoxTransforms(nt, it.latestValues, it.snapshot ? it.snapshot.layoutBox : void 0, at)
                }
                return hasTransform(this.latestValues) && removeBoxTransforms(nt, this.latestValues),
                nt
            }
            setTargetDelta(rt) {
                this.targetDelta = rt,
                this.root.scheduleUpdateProjection(),
                this.isProjectionDirty = !0
            }
            setOptions(rt) {
                this.options = _t($t($t({}, this.options), rt), {
                    crossfade: rt.crossfade !== void 0 ? rt.crossfade : !0
                })
            }
            clearMeasurements() {
                this.scroll = void 0,
                this.layout = void 0,
                this.snapshot = void 0,
                this.prevTransformTemplateValue = void 0,
                this.targetDelta = void 0,
                this.target = void 0,
                this.isLayoutDirty = !1
            }
            forceRelativeParentToResolveTarget() {
                this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
            }
            resolveTargetDelta(rt=!1) {
                var nt;
                const ot = this.getLead();
                this.isProjectionDirty || (this.isProjectionDirty = ot.isProjectionDirty),
                this.isTransformDirty || (this.isTransformDirty = ot.isTransformDirty),
                this.isSharedProjectionDirty || (this.isSharedProjectionDirty = ot.isSharedProjectionDirty);
                const it = !!this.resumingFrom || this !== ot;
                if (!(rt || it && this.isSharedProjectionDirty || this.isProjectionDirty || !((nt = this.parent) === null || nt === void 0) && nt.isProjectionDirty || this.attemptToResolveRelativeTarget))
                    return;
                const {layout: at, layoutId: lt} = this.options;
                if (!(!this.layout || !(at || lt))) {
                    if (this.resolvedRelativeTargetAt = frameData.timestamp,
                    !this.targetDelta && !this.relativeTarget) {
                        const st = this.getClosestProjectingParent();
                        st && st.layout && this.animationProgress !== 1 ? (this.relativeParent = st,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = createBox(),
                        this.relativeTargetOrigin = createBox(),
                        calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, st.layout.layoutBox),
                        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    if (!(!this.relativeTarget && !this.targetDelta)) {
                        if (this.target || (this.target = createBox(),
                        this.targetWithTransforms = createBox()),
                        this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                        applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                        this.attemptToResolveRelativeTarget) {
                            this.attemptToResolveRelativeTarget = !1;
                            const st = this.getClosestProjectingParent();
                            st && !!st.resumingFrom == !!this.resumingFrom && !st.options.layoutScroll && st.target && this.animationProgress !== 1 ? (this.relativeParent = st,
                            this.forceRelativeParentToResolveTarget(),
                            this.relativeTarget = createBox(),
                            this.relativeTargetOrigin = createBox(),
                            calcRelativePosition(this.relativeTargetOrigin, this.target, st.target),
                            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                        }
                        projectionFrameData.resolvedTargetDeltas++
                    }
                }
            }
            getClosestProjectingParent() {
                if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
                    return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
            }
            isProjecting() {
                return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
            }
            calcProjection() {
                var rt;
                const nt = this.getLead()
                  , ot = !!this.resumingFrom || this !== nt;
                let it = !0;
                if ((this.isProjectionDirty || !((rt = this.parent) === null || rt === void 0) && rt.isProjectionDirty) && (it = !1),
                ot && (this.isSharedProjectionDirty || this.isTransformDirty) && (it = !1),
                this.resolvedRelativeTargetAt === frameData.timestamp && (it = !1),
                it)
                    return;
                const {layout: at, layoutId: lt} = this.options;
                if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
                this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
                !this.layout || !(at || lt))
                    return;
                copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
                const st = this.treeScale.x
                  , ut = this.treeScale.y;
                applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, ot),
                nt.layout && !nt.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (nt.target = nt.layout.layoutBox);
                const {target: ct} = nt;
                if (!ct) {
                    this.projectionTransform && (this.projectionDelta = createDelta(),
                    this.projectionTransform = "none",
                    this.scheduleRender());
                    return
                }
                this.projectionDelta || (this.projectionDelta = createDelta(),
                this.projectionDeltaWithTransform = createDelta());
                const pt = this.projectionTransform;
                calcBoxDelta(this.projectionDelta, this.layoutCorrected, ct, this.latestValues),
                this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale),
                (this.projectionTransform !== pt || this.treeScale.x !== st || this.treeScale.y !== ut) && (this.hasProjected = !0,
                this.scheduleRender(),
                this.notifyListeners("projectionUpdate", ct)),
                projectionFrameData.recalculatedProjection++
            }
            hide() {
                this.isVisible = !1
            }
            show() {
                this.isVisible = !0
            }
            scheduleRender(rt=!0) {
                if (this.options.scheduleRender && this.options.scheduleRender(),
                rt) {
                    const nt = this.getStack();
                    nt && nt.scheduleRender()
                }
                this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
            }
            setAnimationOrigin(rt, nt=!1) {
                const ot = this.snapshot
                  , it = ot ? ot.latestValues : {}
                  , at = $t({}, this.latestValues)
                  , lt = createDelta();
                (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
                this.attemptToResolveRelativeTarget = !nt;
                const st = createBox()
                  , ut = ot ? ot.source : void 0
                  , ct = this.layout ? this.layout.source : void 0
                  , pt = ut !== ct
                  , ft = this.getStack()
                  , yt = !ft || ft.members.length <= 1
                  , ht = !!(pt && !yt && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
                this.animationProgress = 0;
                let gt;
                this.mixTargetDelta = mt=>{
                    const vt = mt / 1e3;
                    mixAxisDelta(lt.x, rt.x, vt),
                    mixAxisDelta(lt.y, rt.y, vt),
                    this.setTargetDelta(lt),
                    this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(st, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                    mixBox(this.relativeTarget, this.relativeTargetOrigin, st, vt),
                    gt && boxEquals(this.relativeTarget, gt) && (this.isProjectionDirty = !1),
                    gt || (gt = createBox()),
                    copyBoxInto(gt, this.relativeTarget)),
                    pt && (this.animationValues = at,
                    mixValues(at, it, this.latestValues, vt, ht, yt)),
                    this.root.scheduleUpdateProjection(),
                    this.scheduleRender(),
                    this.animationProgress = vt
                }
                ,
                this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
            }
            startAnimation(rt) {
                this.notifyListeners("animationStart"),
                this.currentAnimation && this.currentAnimation.stop(),
                this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
                this.pendingAnimation && (cancelFrame(this.pendingAnimation),
                this.pendingAnimation = void 0),
                this.pendingAnimation = frame.update(()=>{
                    globalProjectionState.hasAnimatedSinceResize = !0,
                    this.currentAnimation = animateSingleValue(0, animationTarget, _t($t({}, rt), {
                        onUpdate: nt=>{
                            this.mixTargetDelta(nt),
                            rt.onUpdate && rt.onUpdate(nt)
                        }
                        ,
                        onComplete: ()=>{
                            rt.onComplete && rt.onComplete(),
                            this.completeAnimation()
                        }
                    })),
                    this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                    this.pendingAnimation = void 0
                }
                )
            }
            completeAnimation() {
                this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
                this.resumingFrom.preserveOpacity = void 0);
                const rt = this.getStack();
                rt && rt.exitAnimationComplete(),
                this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
                this.notifyListeners("animationComplete")
            }
            finishAnimation() {
                this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
                this.currentAnimation.stop()),
                this.completeAnimation()
            }
            applyTransformsToTarget() {
                const rt = this.getLead();
                let {targetWithTransforms: nt, target: ot, layout: it, latestValues: at} = rt;
                if (!(!nt || !ot || !it)) {
                    if (this !== rt && this.layout && it && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, it.layoutBox)) {
                        ot = this.target || createBox();
                        const lt = calcLength(this.layout.layoutBox.x);
                        ot.x.min = rt.target.x.min,
                        ot.x.max = ot.x.min + lt;
                        const st = calcLength(this.layout.layoutBox.y);
                        ot.y.min = rt.target.y.min,
                        ot.y.max = ot.y.min + st
                    }
                    copyBoxInto(nt, ot),
                    transformBox(nt, at),
                    calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, nt, at)
                }
            }
            registerSharedNode(rt, nt) {
                this.sharedNodes.has(rt) || this.sharedNodes.set(rt, new NodeStack),
                this.sharedNodes.get(rt).add(nt);
                const ot = nt.options.initialPromotionConfig;
                nt.promote({
                    transition: ot ? ot.transition : void 0,
                    preserveFollowOpacity: ot && ot.shouldPreserveFollowOpacity ? ot.shouldPreserveFollowOpacity(nt) : void 0
                })
            }
            isLead() {
                const rt = this.getStack();
                return rt ? rt.lead === this : !0
            }
            getLead() {
                var rt;
                const {layoutId: nt} = this.options;
                return nt ? ((rt = this.getStack()) === null || rt === void 0 ? void 0 : rt.lead) || this : this
            }
            getPrevLead() {
                var rt;
                const {layoutId: nt} = this.options;
                return nt ? (rt = this.getStack()) === null || rt === void 0 ? void 0 : rt.prevLead : void 0
            }
            getStack() {
                const {layoutId: rt} = this.options;
                if (rt)
                    return this.root.sharedNodes.get(rt)
            }
            promote({needsReset: rt, transition: nt, preserveFollowOpacity: ot}={}) {
                const it = this.getStack();
                it && it.promote(this, ot),
                rt && (this.projectionDelta = void 0,
                this.needsReset = !0),
                nt && this.setOptions({
                    transition: nt
                })
            }
            relegate() {
                const rt = this.getStack();
                return rt ? rt.relegate(this) : !1
            }
            resetRotation() {
                const {visualElement: rt} = this.options;
                if (!rt)
                    return;
                let nt = !1;
                const {latestValues: ot} = rt;
                if ((ot.rotate || ot.rotateX || ot.rotateY || ot.rotateZ) && (nt = !0),
                !nt)
                    return;
                const it = {};
                for (let at = 0; at < transformAxes.length; at++) {
                    const lt = "rotate" + transformAxes[at];
                    ot[lt] && (it[lt] = ot[lt],
                    rt.setStaticValue(lt, 0))
                }
                rt.render();
                for (const at in it)
                    rt.setStaticValue(at, it[at]);
                rt.scheduleRender()
            }
            getProjectionStyles(rt) {
                var nt, ot;
                if (!this.instance || this.isSVG)
                    return;
                if (!this.isVisible)
                    return hiddenVisibility;
                const it = {
                    visibility: ""
                }
                  , at = this.getTransformTemplate();
                if (this.needsReset)
                    return this.needsReset = !1,
                    it.opacity = "",
                    it.pointerEvents = resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || "",
                    it.transform = at ? at(this.latestValues, "") : "none",
                    it;
                const lt = this.getLead();
                if (!this.projectionDelta || !this.layout || !lt.target) {
                    const pt = {};
                    return this.options.layoutId && (pt.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                    pt.pointerEvents = resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || ""),
                    this.hasProjected && !hasTransform(this.latestValues) && (pt.transform = at ? at({}, "") : "none",
                    this.hasProjected = !1),
                    pt
                }
                const st = lt.animationValues || lt.latestValues;
                this.applyTransformsToTarget(),
                it.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, st),
                at && (it.transform = at(st, it.transform));
                const {x: ut, y: ct} = this.projectionDelta;
                it.transformOrigin = `${ut.origin * 100}% ${ct.origin * 100}% 0`,
                lt.animationValues ? it.opacity = lt === this ? (ot = (nt = st.opacity) !== null && nt !== void 0 ? nt : this.latestValues.opacity) !== null && ot !== void 0 ? ot : 1 : this.preserveOpacity ? this.latestValues.opacity : st.opacityExit : it.opacity = lt === this ? st.opacity !== void 0 ? st.opacity : "" : st.opacityExit !== void 0 ? st.opacityExit : 0;
                for (const pt in scaleCorrectors) {
                    if (st[pt] === void 0)
                        continue;
                    const {correct: ft, applyTo: yt} = scaleCorrectors[pt]
                      , ht = it.transform === "none" ? st[pt] : ft(st[pt], lt);
                    if (yt) {
                        const gt = yt.length;
                        for (let mt = 0; mt < gt; mt++)
                            it[yt[mt]] = ht
                    } else
                        it[pt] = ht
                }
                return this.options.layoutId && (it.pointerEvents = lt === this ? resolveMotionValue(rt == null ? void 0 : rt.pointerEvents) || "" : "none"),
                it
            }
            clearSnapshot() {
                this.resumeFrom = this.snapshot = void 0
            }
            resetTree() {
                this.root.nodes.forEach(rt=>{
                    var nt;
                    return (nt = rt.currentAnimation) === null || nt === void 0 ? void 0 : nt.stop()
                }
                ),
                this.root.nodes.forEach(clearMeasurements),
                this.root.sharedNodes.clear()
            }
        }
    }
    function updateLayout(_) {
        _.updateLayout()
    }
    function notifyLayoutUpdate(_) {
        var k;
        const J = ((k = _.resumeFrom) === null || k === void 0 ? void 0 : k.snapshot) || _.snapshot;
        if (_.isLead() && _.layout && J && _.hasListeners("didUpdate")) {
            const {layoutBox: et, measuredBox: tt} = _.layout
              , {animationType: rt} = _.options
              , nt = J.source !== _.layout.source;
            rt === "size" ? eachAxis(st=>{
                const ut = nt ? J.measuredBox[st] : J.layoutBox[st]
                  , ct = calcLength(ut);
                ut.min = et[st].min,
                ut.max = ut.min + ct
            }
            ) : shouldAnimatePositionOnly(rt, J.layoutBox, et) && eachAxis(st=>{
                const ut = nt ? J.measuredBox[st] : J.layoutBox[st]
                  , ct = calcLength(et[st]);
                ut.max = ut.min + ct,
                _.relativeTarget && !_.currentAnimation && (_.isProjectionDirty = !0,
                _.relativeTarget[st].max = _.relativeTarget[st].min + ct)
            }
            );
            const ot = createDelta();
            calcBoxDelta(ot, et, J.layoutBox);
            const it = createDelta();
            nt ? calcBoxDelta(it, _.applyTransform(tt, !0), J.measuredBox) : calcBoxDelta(it, et, J.layoutBox);
            const at = !isDeltaZero(ot);
            let lt = !1;
            if (!_.resumeFrom) {
                const st = _.getClosestProjectingParent();
                if (st && !st.resumeFrom) {
                    const {snapshot: ut, layout: ct} = st;
                    if (ut && ct) {
                        const pt = createBox();
                        calcRelativePosition(pt, J.layoutBox, ut.layoutBox);
                        const ft = createBox();
                        calcRelativePosition(ft, et, ct.layoutBox),
                        boxEqualsRounded(pt, ft) || (lt = !0),
                        st.options.layoutRoot && (_.relativeTarget = ft,
                        _.relativeTargetOrigin = pt,
                        _.relativeParent = st)
                    }
                }
            }
            _.notifyListeners("didUpdate", {
                layout: et,
                snapshot: J,
                delta: it,
                layoutDelta: ot,
                hasLayoutChanged: at,
                hasRelativeTargetChanged: lt
            })
        } else if (_.isLead()) {
            const {onExitComplete: et} = _.options;
            et && et()
        }
        _.options.transition = void 0
    }
    function propagateDirtyNodes(_) {
        projectionFrameData.totalNodes++,
        _.parent && (_.isProjecting() || (_.isProjectionDirty = _.parent.isProjectionDirty),
        _.isSharedProjectionDirty || (_.isSharedProjectionDirty = !!(_.isProjectionDirty || _.parent.isProjectionDirty || _.parent.isSharedProjectionDirty)),
        _.isTransformDirty || (_.isTransformDirty = _.parent.isTransformDirty))
    }
    function cleanDirtyNodes(_) {
        _.isProjectionDirty = _.isSharedProjectionDirty = _.isTransformDirty = !1
    }
    function clearSnapshot(_) {
        _.clearSnapshot()
    }
    function clearMeasurements(_) {
        _.clearMeasurements()
    }
    function clearIsLayoutDirty(_) {
        _.isLayoutDirty = !1
    }
    function resetTransformStyle(_) {
        const {visualElement: k} = _.options;
        k && k.getProps().onBeforeLayoutMeasure && k.notify("BeforeLayoutMeasure"),
        _.resetTransform()
    }
    function finishAnimation(_) {
        _.finishAnimation(),
        _.targetDelta = _.relativeTarget = _.target = void 0,
        _.isProjectionDirty = !0
    }
    function resolveTargetDelta(_) {
        _.resolveTargetDelta()
    }
    function calcProjection(_) {
        _.calcProjection()
    }
    function resetRotation(_) {
        _.resetRotation()
    }
    function removeLeadSnapshots(_) {
        _.removeLeadSnapshot()
    }
    function mixAxisDelta(_, k, J) {
        _.translate = mix(k.translate, 0, J),
        _.scale = mix(k.scale, 1, J),
        _.origin = k.origin,
        _.originPoint = k.originPoint
    }
    function mixAxis(_, k, J, et) {
        _.min = mix(k.min, J.min, et),
        _.max = mix(k.max, J.max, et)
    }
    function mixBox(_, k, J, et) {
        mixAxis(_.x, k.x, J.x, et),
        mixAxis(_.y, k.y, J.y, et)
    }
    function hasOpacityCrossfade(_) {
        return _.animationValues && _.animationValues.opacityExit !== void 0
    }
    const defaultLayoutTransition = {
        duration: .45,
        ease: [.4, 0, .1, 1]
    }
      , userAgentContains = _=>typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(_)
      , roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$4;
    function roundAxis(_) {
        _.min = roundPoint(_.min),
        _.max = roundPoint(_.max)
    }
    function roundBox(_) {
        roundAxis(_.x),
        roundAxis(_.y)
    }
    function shouldAnimatePositionOnly(_, k, J) {
        return _ === "position" || _ === "preserve-aspect" && !isNear(aspectRatio(k), aspectRatio(J), .2)
    }
    let DocumentProjectionNode, HTMLProjectionNode, splitCSSVariableRegex;
    DocumentProjectionNode = createProjectionNode({
        attachResizeListener: (_,k)=>addDomEvent(_, "resize", k),
        measureScroll: ()=>({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: ()=>!0
    }),
    rootProjectionNode = {
        current: void 0
    },
    HTMLProjectionNode = createProjectionNode({
        measureScroll: _=>({
            x: _.scrollLeft,
            y: _.scrollTop
        }),
        defaultParent: ()=>{
            if (!rootProjectionNode.current) {
                const _ = new DocumentProjectionNode({});
                _.mount(window),
                _.setOptions({
                    layoutScroll: !0
                }),
                rootProjectionNode.current = _
            }
            return rootProjectionNode.current
        }
        ,
        resetTransform: (_,k)=>{
            _.style.transform = k !== void 0 ? k : "none"
        }
        ,
        checkIsScrollRoot: _=>window.getComputedStyle(_).position === "fixed"
    }),
    drag = {
        pan: {
            Feature: PanGesture
        },
        drag: {
            Feature: DragGesture,
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    },
    splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    function parseCSSVariable(_) {
        const k = splitCSSVariableRegex.exec(_);
        if (!k)
            return [, ];
        const [,J,et] = k;
        return [J, et]
    }
    function getVariableValue(_, k, J=1) {
        const [et,tt] = parseCSSVariable(_);
        if (!et)
            return;
        const rt = window.getComputedStyle(k).getPropertyValue(et);
        if (rt) {
            const nt = rt.trim();
            return isNumericalString(nt) ? parseFloat(nt) : nt
        } else
            return isCSSVariableToken(tt) ? getVariableValue(tt, k, J + 1) : tt
    }
    function resolveCSSVariables(_, et, J) {
        var k = Kt(et, []);
        const tt = _.current;
        if (!(tt instanceof Element))
            return {
                target: k,
                transitionEnd: J
            };
        J && (J = $t({}, J)),
        _.values.forEach(rt=>{
            const nt = rt.get();
            if (!isCSSVariableToken(nt))
                return;
            const ot = getVariableValue(nt, tt);
            ot && rt.set(ot)
        }
        );
        for (const rt in k) {
            const nt = k[rt];
            if (!isCSSVariableToken(nt))
                continue;
            const ot = getVariableValue(nt, tt);
            ot && (k[rt] = ot,
            J || (J = {}),
            J[rt] === void 0 && (J[rt] = nt))
        }
        return {
            target: k,
            transitionEnd: J
        }
    }
    const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
      , isPositionalKey = _=>positionalKeys.has(_)
      , hasPositionalKey = _=>Object.keys(_).some(isPositionalKey)
      , isNumOrPxType = _=>_ === number || _ === px
      , getPosFromMatrix = (_,k)=>parseFloat(_.split(", ")[k])
      , getTranslateFromMatrix = (_,k)=>(J,{transform: et})=>{
        if (et === "none" || !et)
            return 0;
        const tt = et.match(/^matrix3d\((.+)\)$/);
        if (tt)
            return getPosFromMatrix(tt[1], k);
        {
            const rt = et.match(/^matrix\((.+)\)$/);
            return rt ? getPosFromMatrix(rt[1], _) : 0
        }
    }
      , transformKeys = new Set(["x", "y", "z"])
      , nonTranslationalTransformKeys = transformPropOrder.filter(_=>!transformKeys.has(_));
    function removeNonTranslationalTransform(_) {
        const k = [];
        return nonTranslationalTransformKeys.forEach(J=>{
            const et = _.getValue(J);
            et !== void 0 && (k.push([J, et.get()]),
            et.set(J.startsWith("scale") ? 1 : 0))
        }
        ),
        k.length && _.render(),
        k
    }
    const positionalValues = {
        width: ({x: _},{paddingLeft: k="0", paddingRight: J="0"})=>_.max - _.min - parseFloat(k) - parseFloat(J),
        height: ({y: _},{paddingTop: k="0", paddingBottom: J="0"})=>_.max - _.min - parseFloat(k) - parseFloat(J),
        top: (_,{top: k})=>parseFloat(k),
        left: (_,{left: k})=>parseFloat(k),
        bottom: ({y: _},{top: k})=>parseFloat(k) + (_.max - _.min),
        right: ({x: _},{left: k})=>parseFloat(k) + (_.max - _.min),
        x: getTranslateFromMatrix(4, 13),
        y: getTranslateFromMatrix(5, 14)
    };
    positionalValues.translateX = positionalValues.x,
    positionalValues.translateY = positionalValues.y;
    const convertChangedValueTypes = (_,k,J)=>{
        const et = k.measureViewportBox()
          , tt = k.current
          , rt = getComputedStyle(tt)
          , {display: nt} = rt
          , ot = {};
        nt === "none" && k.setStaticValue("display", _.display || "block"),
        J.forEach(at=>{
            ot[at] = positionalValues[at](et, rt)
        }
        ),
        k.render();
        const it = k.measureViewportBox();
        return J.forEach(at=>{
            const lt = k.getValue(at);
            lt && lt.jump(ot[at]),
            _[at] = positionalValues[at](it, rt)
        }
        ),
        _
    }
      , checkAndConvertChangedValueTypes = (_,k,J={},et={})=>{
        k = $t({}, k),
        et = $t({}, et);
        const tt = Object.keys(k).filter(isPositionalKey);
        let rt = []
          , nt = !1;
        const ot = [];
        if (tt.forEach(it=>{
            const at = _.getValue(it);
            if (!_.hasValue(it))
                return;
            let lt = J[it]
              , st = findDimensionValueType(lt);
            const ut = k[it];
            let ct;
            if (isKeyframesTarget(ut)) {
                const pt = ut.length
                  , ft = ut[0] === null ? 1 : 0;
                lt = ut[ft],
                st = findDimensionValueType(lt);
                for (let yt = ft; yt < pt && ut[yt] !== null; yt++)
                    ct ? invariant$1(findDimensionValueType(ut[yt]) === ct) : ct = findDimensionValueType(ut[yt])
            } else
                ct = findDimensionValueType(ut);
            if (st !== ct)
                if (isNumOrPxType(st) && isNumOrPxType(ct)) {
                    const pt = at.get();
                    typeof pt == "string" && at.set(parseFloat(pt)),
                    typeof ut == "string" ? k[it] = parseFloat(ut) : Array.isArray(ut) && ct === px && (k[it] = ut.map(parseFloat))
                } else
                    st != null && st.transform && (ct != null && ct.transform) && (lt === 0 || ut === 0) ? lt === 0 ? at.set(ct.transform(lt)) : k[it] = st.transform(ut) : (nt || (rt = removeNonTranslationalTransform(_),
                    nt = !0),
                    ot.push(it),
                    et[it] = et[it] !== void 0 ? et[it] : k[it],
                    at.jump(ut))
        }
        ),
        ot.length) {
            const it = ot.indexOf("height") >= 0 ? window.pageYOffset : null
              , at = convertChangedValueTypes(k, _, ot);
            return rt.length && rt.forEach(([lt,st])=>{
                _.getValue(lt).set(st)
            }
            ),
            _.render(),
            isBrowser$1 && it !== null && window.scrollTo({
                top: it
            }),
            {
                target: at,
                transitionEnd: et
            }
        } else
            return {
                target: k,
                transitionEnd: et
            }
    }
    ;
    function unitConversion(_, k, J, et) {
        return hasPositionalKey(k) ? checkAndConvertChangedValueTypes(_, k, J, et) : {
            target: k,
            transitionEnd: et
        }
    }
    let parseDomVariant;
    parseDomVariant = (_,k,J,et)=>{
        const tt = resolveCSSVariables(_, k, et);
        return k = tt.target,
        et = tt.transitionEnd,
        unitConversion(_, k, J, et)
    }
    ,
    prefersReducedMotion = {
        current: null
    },
    hasReducedMotionListener = {
        current: !1
    },
    initPrefersReducedMotion = function() {
        if (hasReducedMotionListener.current = !0,
        !!isBrowser$1)
            if (window.matchMedia) {
                const _ = window.matchMedia("(prefers-reduced-motion)")
                  , k = ()=>prefersReducedMotion.current = _.matches;
                _.addListener(k),
                k()
            } else
                prefersReducedMotion.current = !1
    }
    ;
    function updateMotionValuesFromProps(_, k, J) {
        const {willChange: et} = k;
        for (const tt in k) {
            const rt = k[tt]
              , nt = J[tt];
            if (isMotionValue(rt))
                _.addValue(tt, rt),
                isWillChangeMotionValue(et) && et.add(tt);
            else if (isMotionValue(nt))
                _.addValue(tt, motionValue(rt, {
                    owner: _
                })),
                isWillChangeMotionValue(et) && et.remove(tt);
            else if (nt !== rt)
                if (_.hasValue(tt)) {
                    const ot = _.getValue(tt);
                    !ot.hasAnimated && ot.set(rt)
                } else {
                    const ot = _.getStaticValue(tt);
                    _.addValue(tt, motionValue(ot !== void 0 ? ot : rt, {
                        owner: _
                    }))
                }
        }
        for (const tt in J)
            k[tt] === void 0 && _.removeValue(tt);
        return k
    }
    let featureNames, numFeatures, propEventHandlers, numVariantProps;
    visualElementStore = new WeakMap,
    featureNames = Object.keys(featureDefinitions),
    numFeatures = featureNames.length,
    propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
    numVariantProps = variantProps.length,
    VisualElement = class {
        constructor({parent: _, props: k, presenceContext: J, reducedMotionConfig: et, visualState: tt}, rt={}) {
            this.current = null,
            this.children = new Set,
            this.isVariantNode = !1,
            this.isControllingVariants = !1,
            this.shouldReduceMotion = null,
            this.values = new Map,
            this.features = {},
            this.valueSubscriptions = new Map,
            this.prevMotionValues = {},
            this.events = {},
            this.propEventSubscriptions = {},
            this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
            this.render = ()=>{
                this.current && (this.triggerBuild(),
                this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
            }
            ,
            this.scheduleRender = ()=>frame.render(this.render, !1, !0);
            const {latestValues: nt, renderState: ot} = tt;
            this.latestValues = nt,
            this.baseTarget = $t({}, nt),
            this.initialValues = k.initial ? $t({}, nt) : {},
            this.renderState = ot,
            this.parent = _,
            this.props = k,
            this.presenceContext = J,
            this.depth = _ ? _.depth + 1 : 0,
            this.reducedMotionConfig = et,
            this.options = rt,
            this.isControllingVariants = isControllingVariants(k),
            this.isVariantNode = isVariantNode(k),
            this.isVariantNode && (this.variantChildren = new Set),
            this.manuallyAnimateOnMount = !!(_ && _.current);
            const lt = this.scrapeMotionValuesFromProps(k, {})
              , {willChange: it} = lt
              , at = Kt(lt, ["willChange"]);
            for (const st in at) {
                const ut = at[st];
                nt[st] !== void 0 && isMotionValue(ut) && (ut.set(nt[st], !1),
                isWillChangeMotionValue(it) && it.add(st))
            }
        }
        scrapeMotionValuesFromProps(_, k) {
            return {}
        }
        mount(_) {
            this.current = _,
            visualElementStore.set(_, this),
            this.projection && !this.projection.instance && this.projection.mount(_),
            this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach((k,J)=>this.bindToMotionValue(J, k)),
            hasReducedMotionListener.current || initPrefersReducedMotion(),
            this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current,
            this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext)
        }
        unmount() {
            visualElementStore.delete(this.current),
            this.projection && this.projection.unmount(),
            cancelFrame(this.notifyUpdate),
            cancelFrame(this.render),
            this.valueSubscriptions.forEach(_=>_()),
            this.removeFromVariantTree && this.removeFromVariantTree(),
            this.parent && this.parent.children.delete(this);
            for (const _ in this.events)
                this.events[_].clear();
            for (const _ in this.features)
                this.features[_].unmount();
            this.current = null
        }
        bindToMotionValue(_, k) {
            const J = transformProps.has(_)
              , et = k.on("change", rt=>{
                this.latestValues[_] = rt,
                this.props.onUpdate && frame.update(this.notifyUpdate, !1, !0),
                J && this.projection && (this.projection.isTransformDirty = !0)
            }
            )
              , tt = k.on("renderRequest", this.scheduleRender);
            this.valueSubscriptions.set(_, ()=>{
                et(),
                tt()
            }
            )
        }
        sortNodePosition(_) {
            return !this.current || !this.sortInstanceNodePosition || this.type !== _.type ? 0 : this.sortInstanceNodePosition(this.current, _.current)
        }
        loadFeatures(rt, J, et, tt) {
            var nt = rt
              , {children: _} = nt
              , k = Kt(nt, ["children"]);
            let ot, it;
            for (let at = 0; at < numFeatures; at++) {
                const lt = featureNames[at]
                  , {isEnabled: st, Feature: ut, ProjectionNode: ct, MeasureLayout: pt} = featureDefinitions[lt];
                ct && (ot = ct),
                st(k) && (!this.features[lt] && ut && (this.features[lt] = new ut(this)),
                pt && (it = pt))
            }
            if ((this.type === "html" || this.type === "svg") && !this.projection && ot) {
                this.projection = new ot(this.latestValues,this.parent && this.parent.projection);
                const {layoutId: at, layout: lt, drag: st, dragConstraints: ut, layoutScroll: ct, layoutRoot: pt} = k;
                this.projection.setOptions({
                    layoutId: at,
                    layout: lt,
                    alwaysMeasureLayout: !!st || ut && isRefObject(ut),
                    visualElement: this,
                    scheduleRender: ()=>this.scheduleRender(),
                    animationType: typeof lt == "string" ? lt : "both",
                    initialPromotionConfig: tt,
                    layoutScroll: ct,
                    layoutRoot: pt
                })
            }
            return it
        }
        updateFeatures() {
            for (const _ in this.features) {
                const k = this.features[_];
                k.isMounted ? k.update() : (k.mount(),
                k.isMounted = !0)
            }
        }
        triggerBuild() {
            this.build(this.renderState, this.latestValues, this.options, this.props)
        }
        measureViewportBox() {
            return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
        }
        getStaticValue(_) {
            return this.latestValues[_]
        }
        setStaticValue(_, k) {
            this.latestValues[_] = k
        }
        makeTargetAnimatable(_, k=!0) {
            return this.makeTargetAnimatableFromInstance(_, this.props, k)
        }
        update(_, k) {
            (_.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
            this.prevProps = this.props,
            this.props = _,
            this.prevPresenceContext = this.presenceContext,
            this.presenceContext = k;
            for (let J = 0; J < propEventHandlers.length; J++) {
                const et = propEventHandlers[J];
                this.propEventSubscriptions[et] && (this.propEventSubscriptions[et](),
                delete this.propEventSubscriptions[et]);
                const tt = _["on" + et];
                tt && (this.propEventSubscriptions[et] = this.on(et, tt))
            }
            this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(_, this.prevProps), this.prevMotionValues),
            this.handleChildMotionValue && this.handleChildMotionValue()
        }
        getProps() {
            return this.props
        }
        getVariant(_) {
            return this.props.variants ? this.props.variants[_] : void 0
        }
        getDefaultTransition() {
            return this.props.transition
        }
        getTransformPagePoint() {
            return this.props.transformPagePoint
        }
        getClosestVariantNode() {
            return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
        }
        getVariantContext(_=!1) {
            if (_)
                return this.parent ? this.parent.getVariantContext() : void 0;
            if (!this.isControllingVariants) {
                const J = this.parent ? this.parent.getVariantContext() || {} : {};
                return this.props.initial !== void 0 && (J.initial = this.props.initial),
                J
            }
            const k = {};
            for (let J = 0; J < numVariantProps; J++) {
                const et = variantProps[J]
                  , tt = this.props[et];
                (isVariantLabel(tt) || tt === !1) && (k[et] = tt)
            }
            return k
        }
        addVariantChild(_) {
            const k = this.getClosestVariantNode();
            if (k)
                return k.variantChildren && k.variantChildren.add(_),
                ()=>k.variantChildren.delete(_)
        }
        addValue(_, k) {
            k !== this.values.get(_) && (this.removeValue(_),
            this.bindToMotionValue(_, k)),
            this.values.set(_, k),
            this.latestValues[_] = k.get()
        }
        removeValue(_) {
            this.values.delete(_);
            const k = this.valueSubscriptions.get(_);
            k && (k(),
            this.valueSubscriptions.delete(_)),
            delete this.latestValues[_],
            this.removeValueFromRenderState(_, this.renderState)
        }
        hasValue(_) {
            return this.values.has(_)
        }
        getValue(_, k) {
            if (this.props.values && this.props.values[_])
                return this.props.values[_];
            let J = this.values.get(_);
            return J === void 0 && k !== void 0 && (J = motionValue(k, {
                owner: this
            }),
            this.addValue(_, J)),
            J
        }
        readValue(_) {
            var k;
            return this.latestValues[_] !== void 0 || !this.current ? this.latestValues[_] : (k = this.getBaseTargetFromProps(this.props, _)) !== null && k !== void 0 ? k : this.readValueFromInstance(this.current, _, this.options)
        }
        setBaseTarget(_, k) {
            this.baseTarget[_] = k
        }
        getBaseTarget(_) {
            var k;
            const {initial: J} = this.props
              , et = typeof J == "string" || typeof J == "object" ? (k = resolveVariantFromProps(this.props, J)) === null || k === void 0 ? void 0 : k[_] : void 0;
            if (J && et !== void 0)
                return et;
            const tt = this.getBaseTargetFromProps(this.props, _);
            return tt !== void 0 && !isMotionValue(tt) ? tt : this.initialValues[_] !== void 0 && et === void 0 ? void 0 : this.baseTarget[_]
        }
        on(_, k) {
            return this.events[_] || (this.events[_] = new SubscriptionManager),
            this.events[_].add(k)
        }
        notify(_, ...k) {
            this.events[_] && this.events[_].notify(...k)
        }
    }
    ;
    class DOMVisualElement extends VisualElement {
        sortInstanceNodePosition(k, J) {
            return k.compareDocumentPosition(J) & 2 ? 1 : -1
        }
        getBaseTargetFromProps(k, J) {
            return k.style ? k.style[J] : void 0
        }
        removeValueFromRenderState(k, {vars: J, style: et}) {
            delete J[k],
            delete et[k]
        }
        makeTargetAnimatableFromInstance(nt, {transformValues: tt}, rt) {
            var ot = nt
              , {transition: k, transitionEnd: J} = ot
              , et = Kt(ot, ["transition", "transitionEnd"]);
            let it = getOrigin(et, k || {}, this);
            if (tt && (J && (J = tt(J)),
            et && (et = tt(et)),
            it && (it = tt(it))),
            rt) {
                checkTargetForNewValues(this, et, it);
                const at = parseDomVariant(this, et, it, J);
                J = at.transitionEnd,
                et = at.target
            }
            return $t({
                transition: k,
                transitionEnd: J
            }, et)
        }
    }
    function getComputedStyle$1(_) {
        return window.getComputedStyle(_)
    }
    class HTMLVisualElement extends DOMVisualElement {
        constructor() {
            super(...arguments),
            this.type = "html"
        }
        readValueFromInstance(k, J) {
            if (transformProps.has(J)) {
                const et = getDefaultValueType(J);
                return et && et.default || 0
            } else {
                const et = getComputedStyle$1(k)
                  , tt = (isCSSVariableName(J) ? et.getPropertyValue(J) : et[J]) || 0;
                return typeof tt == "string" ? tt.trim() : tt
            }
        }
        measureInstanceViewportBox(k, {transformPagePoint: J}) {
            return measureViewportBox(k, J)
        }
        build(k, J, et, tt) {
            buildHTMLStyles(k, J, et, tt.transformTemplate)
        }
        scrapeMotionValuesFromProps(k, J) {
            return scrapeMotionValuesFromProps$1(k, J)
        }
        handleChildMotionValue() {
            this.childSubscription && (this.childSubscription(),
            delete this.childSubscription);
            const {children: k} = this.props;
            isMotionValue(k) && (this.childSubscription = k.on("change", J=>{
                this.current && (this.current.textContent = `${J}`)
            }
            ))
        }
        renderInstance(k, J, et, tt) {
            renderHTML(k, J, et, tt)
        }
    }
    class SVGVisualElement extends DOMVisualElement {
        constructor() {
            super(...arguments),
            this.type = "svg",
            this.isSVGTag = !1
        }
        getBaseTargetFromProps(k, J) {
            return k[J]
        }
        readValueFromInstance(k, J) {
            if (transformProps.has(J)) {
                const et = getDefaultValueType(J);
                return et && et.default || 0
            }
            return J = camelCaseAttributes.has(J) ? J : camelToDash(J),
            k.getAttribute(J)
        }
        measureInstanceViewportBox() {
            return createBox()
        }
        scrapeMotionValuesFromProps(k, J) {
            return scrapeMotionValuesFromProps(k, J)
        }
        build(k, J, et, tt) {
            buildSVGAttrs(k, J, et, this.isSVGTag, tt.transformTemplate)
        }
        renderInstance(k, J, et, tt) {
            renderSVG(k, J, et, tt)
        }
        mount(k) {
            this.isSVGTag = isSVGTag(k.tagName),
            super.mount(k)
        }
    }
    let preloadedFeatures;
    createDomVisualElement = (_,k)=>isSVGComponent(_) ? new SVGVisualElement(k,{
        enableHardwareAcceleration: !1
    }) : new HTMLVisualElement(k,{
        enableHardwareAcceleration: !0
    }),
    layout = {
        layout: {
            ProjectionNode: HTMLProjectionNode,
            MeasureLayout
        }
    },
    preloadedFeatures = $t($t($t($t({}, animations), gestureAnimations), drag), layout),
    motion = createMotionProxy((_,k)=>createDomMotionConfig(_, k, preloadedFeatures, createDomVisualElement)),
    createDomMotionComponent = function(_) {
        return createMotionComponent(createDomMotionConfig(_, {
            forwardMotionProps: !1
        }, preloadedFeatures, createDomVisualElement))
    }
    ;
    function useIsMounted() {
        const _ = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$2(()=>(_.current = !0,
        ()=>{
            _.current = !1
        }
        ), []),
        _
    }
    useForceUpdate$1 = function() {
        const _ = useIsMounted()
          , [k,J] = reactExports.useState(0)
          , et = reactExports.useCallback(()=>{
            _.current && J(k + 1)
        }
        , [k]);
        return [reactExports.useCallback(()=>frame.postRender(et), [et]), k]
    }
    ;
    class PopChildMeasure extends reactExports.Component {
        getSnapshotBeforeUpdate(k) {
            const J = this.props.childRef.current;
            if (J && k.isPresent && !this.props.isPresent) {
                const et = this.props.sizeRef.current;
                et.height = J.offsetHeight || 0,
                et.width = J.offsetWidth || 0,
                et.top = J.offsetTop,
                et.left = J.offsetLeft
            }
            return null
        }
        componentDidUpdate() {}
        render() {
            return this.props.children
        }
    }
    function PopChild({children: _, isPresent: k}) {
        const J = reactExports.useId()
          , et = reactExports.useRef(null)
          , tt = reactExports.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0
        });
        return reactExports.useInsertionEffect(()=>{
            const {width: rt, height: nt, top: ot, left: it} = tt.current;
            if (k || !et.current || !rt || !nt)
                return;
            et.current.dataset.motionPopId = J;
            const at = document.createElement("style");
            return document.head.appendChild(at),
            at.sheet && at.sheet.insertRule(`
          [data-motion-pop-id="${J}"] {
            position: absolute !important;
            width: ${rt}px !important;
            height: ${nt}px !important;
            top: ${ot}px !important;
            left: ${it}px !important;
          }
        `),
            ()=>{
                document.head.removeChild(at)
            }
        }
        , [k]),
        reactExports.createElement(PopChildMeasure, {
            isPresent: k,
            childRef: et,
            sizeRef: tt
        }, reactExports.cloneElement(_, {
            ref: et
        }))
    }
    const PresenceChild = ({children: _, initial: k, isPresent: J, onExitComplete: et, custom: tt, presenceAffectsLayout: rt, mode: nt})=>{
        const ot = useConstant(newChildrenMap)
          , it = reactExports.useId()
          , at = reactExports.useMemo(()=>({
            id: it,
            initial: k,
            isPresent: J,
            custom: tt,
            onExitComplete: lt=>{
                ot.set(lt, !0);
                for (const st of ot.values())
                    if (!st)
                        return;
                et && et()
            }
            ,
            register: lt=>(ot.set(lt, !1),
            ()=>ot.delete(lt))
        }), rt ? void 0 : [J]);
        return reactExports.useMemo(()=>{
            ot.forEach((lt,st)=>ot.set(st, !1))
        }
        , [J]),
        reactExports.useEffect(()=>{
            !J && !ot.size && et && et()
        }
        , [J]),
        nt === "popLayout" && (_ = reactExports.createElement(PopChild, {
            isPresent: J
        }, _)),
        reactExports.createElement(PresenceContext.Provider, {
            value: at
        }, _)
    }
    ;
    function newChildrenMap() {
        return new Map
    }
    useUnmountEffect = function(_) {
        return reactExports.useEffect(()=>()=>_(), [])
    }
    ;
    const getChildKey = _=>_.key || "";
    function updateChildLookup(_, k) {
        _.forEach(J=>{
            const et = getChildKey(J);
            k.set(et, J)
        }
        )
    }
    function onlyElements(_) {
        const k = [];
        return reactExports.Children.forEach(_, J=>{
            reactExports.isValidElement(J) && k.push(J)
        }
        ),
        k
    }
    AnimatePresence = ({children: _, custom: k, initial: J=!0, onExitComplete: et, exitBeforeEnter: tt, presenceAffectsLayout: rt=!0, mode: nt="sync"})=>{
        const ot = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate$1()[0]
          , it = useIsMounted()
          , at = onlyElements(_);
        let lt = at;
        const st = reactExports.useRef(new Map).current
          , ut = reactExports.useRef(lt)
          , ct = reactExports.useRef(new Map).current
          , pt = reactExports.useRef(!0);
        if (useIsomorphicLayoutEffect$2(()=>{
            pt.current = !1,
            updateChildLookup(at, ct),
            ut.current = lt
        }
        ),
        useUnmountEffect(()=>{
            pt.current = !0,
            ct.clear(),
            st.clear()
        }
        ),
        pt.current)
            return reactExports.createElement(reactExports.Fragment, null, lt.map(gt=>reactExports.createElement(PresenceChild, {
                key: getChildKey(gt),
                isPresent: !0,
                initial: J ? void 0 : !1,
                presenceAffectsLayout: rt,
                mode: nt
            }, gt)));
        lt = [...lt];
        const ft = ut.current.map(getChildKey)
          , yt = at.map(getChildKey)
          , ht = ft.length;
        for (let gt = 0; gt < ht; gt++) {
            const mt = ft[gt];
            yt.indexOf(mt) === -1 && !st.has(mt) && st.set(mt, void 0)
        }
        return nt === "wait" && st.size && (lt = []),
        st.forEach((gt,mt)=>{
            if (yt.indexOf(mt) !== -1)
                return;
            const vt = ct.get(mt);
            if (!vt)
                return;
            const bt = ft.indexOf(mt);
            let Et = gt;
            if (!Et) {
                const xt = ()=>{
                    st.delete(mt);
                    const wt = Array.from(ct.keys()).filter(St=>!yt.includes(St));
                    if (wt.forEach(St=>ct.delete(St)),
                    ut.current = at.filter(St=>{
                        const Pt = getChildKey(St);
                        return Pt === mt || wt.includes(Pt)
                    }
                    ),
                    !st.size) {
                        if (it.current === !1)
                            return;
                        ot(),
                        et && et()
                    }
                }
                ;
                Et = reactExports.createElement(PresenceChild, {
                    key: getChildKey(vt),
                    isPresent: !1,
                    onExitComplete: xt,
                    custom: k,
                    presenceAffectsLayout: rt,
                    mode: nt
                }, vt),
                st.set(mt, Et)
            }
            lt.splice(bt, 0, Et)
        }
        ),
        lt = lt.map(gt=>{
            const mt = gt.key;
            return st.has(mt) ? gt : reactExports.createElement(PresenceChild, {
                key: getChildKey(gt),
                isPresent: !0,
                presenceAffectsLayout: rt,
                mode: nt
            }, gt)
        }
        ),
        reactExports.createElement(reactExports.Fragment, null, st.size ? lt : lt.map(gt=>reactExports.cloneElement(gt)))
    }
    ,
    useMotionValue = function(_) {
        const k = useConstant(()=>motionValue(_))
          , {isStatic: J} = reactExports.useContext(MotionConfigContext);
        if (J) {
            const [,et] = reactExports.useState(_);
            reactExports.useEffect(()=>k.on("change", et), [])
        }
        return k
    }
    ,
    resolveElements = function(_, k, J) {
        var et;
        if (typeof _ == "string") {
            let tt = document;
            k && (invariant$1(!!k.current),
            tt = k.current),
            J ? ((et = J[_]) !== null && et !== void 0 || (J[_] = tt.querySelectorAll(_)),
            _ = J[_]) : _ = tt.querySelectorAll(_)
        } else
            _ instanceof Element && (_ = [_]);
        return Array.from(_ || [])
    }
    ;
    function stopAnimation(_) {
        _.values.forEach(k=>k.stop())
    }
    animationControls = function() {
        const _ = new Set
          , k = {
            subscribe(J) {
                return _.add(J),
                ()=>void _.delete(J)
            },
            start(J, et) {
                const tt = [];
                return _.forEach(rt=>{
                    tt.push(animateVisualElement(rt, J, {
                        transitionOverride: et
                    }))
                }
                ),
                Promise.all(tt)
            },
            set(J) {
                return _.forEach(et=>{
                    setValues(et, J)
                }
                )
            },
            stop() {
                _.forEach(J=>{
                    stopAnimation(J)
                }
                )
            },
            mount() {
                return ()=>{
                    k.stop()
                }
            }
        };
        return k
    }
    ,
    observeTimeline = function(_, k) {
        let J;
        const et = ()=>{
            const {currentTime: tt} = k
              , rt = (tt === null ? 0 : tt.value) / 100;
            J !== rt && _(rt),
            J = rt
        }
        ;
        return frame.update(et, !0),
        ()=>cancelFrame(et)
    }
    ,
    supportsScrollTimeline = memo(()=>window.ScrollTimeline !== void 0);
    class GroupPlaybackControls {
        constructor(k) {
            this.animations = k.filter(Boolean)
        }
        then(k, J) {
            return Promise.all(this.animations).then(k).catch(J)
        }
        getAll(k) {
            return this.animations[0][k]
        }
        setAll(k, J) {
            for (let et = 0; et < this.animations.length; et++)
                this.animations[et][k] = J
        }
        attachTimeline(k) {
            const J = this.animations.map(et=>{
                if (supportsScrollTimeline() && et.attachTimeline)
                    et.attachTimeline(k);
                else
                    return et.pause(),
                    observeTimeline(tt=>{
                        et.time = et.duration * tt
                    }
                    , k)
            }
            );
            return ()=>{
                J.forEach((et,tt)=>{
                    et && et(),
                    this.animations[tt].stop()
                }
                )
            }
        }
        get time() {
            return this.getAll("time")
        }
        set time(k) {
            this.setAll("time", k)
        }
        get speed() {
            return this.getAll("speed")
        }
        set speed(k) {
            this.setAll("speed", k)
        }
        get duration() {
            let k = 0;
            for (let J = 0; J < this.animations.length; J++)
                k = Math.max(k, this.animations[J].duration);
            return k
        }
        runAll(k) {
            this.animations.forEach(J=>J[k]())
        }
        play() {
            this.runAll("play")
        }
        pause() {
            this.runAll("pause")
        }
        stop() {
            this.runAll("stop")
        }
        cancel() {
            this.runAll("cancel")
        }
        complete() {
            this.runAll("complete")
        }
    }
    function isDOMKeyframes(_) {
        return typeof _ == "object" && !Array.isArray(_)
    }
    function createVisualElement(_) {
        const k = {
            presenceContext: null,
            props: {},
            visualState: {
                renderState: {
                    transform: {},
                    transformOrigin: {},
                    style: {},
                    vars: {},
                    attrs: {}
                },
                latestValues: {}
            }
        }
          , J = isSVGElement(_) ? new SVGVisualElement(k,{
            enableHardwareAcceleration: !1
        }) : new HTMLVisualElement(k,{
            enableHardwareAcceleration: !0
        });
        J.mount(_),
        visualElementStore.set(_, J)
    }
    function createGeneratorEasing(_, k=100) {
        const J = spring($t({
            keyframes: [0, k]
        }, _))
          , et = Math.min(calcGeneratorDuration(J), maxGeneratorDuration);
        return {
            type: "keyframes",
            ease: tt=>J.next(et * tt).value / k,
            duration: millisecondsToSeconds(et)
        }
    }
    function calcNextTime(_, k, J, et) {
        var tt;
        return typeof k == "number" ? k : k.startsWith("-") || k.startsWith("+") ? Math.max(0, _ + parseFloat(k)) : k === "<" ? J : (tt = et.get(k)) !== null && tt !== void 0 ? tt : _
    }
    wrap = (_,k,J)=>{
        const et = k - _;
        return ((J - _) % et + et) % et + _
    }
    ;
    function getEasingForSegment(_, k) {
        return isEasingArray(_) ? _[wrap(0, _.length, k)] : _
    }
    function eraseKeyframes(_, k, J) {
        for (let et = 0; et < _.length; et++) {
            const tt = _[et];
            tt.at > k && tt.at < J && (removeItem(_, tt),
            et--)
        }
    }
    function addKeyframes(_, k, J, et, tt, rt) {
        eraseKeyframes(_, tt, rt);
        for (let nt = 0; nt < k.length; nt++)
            _.push({
                value: k[nt],
                at: mix(tt, rt, et[nt]),
                easing: getEasingForSegment(J, nt)
            })
    }
    function compareByTime(_, k) {
        return _.at === k.at ? _.value === null ? 1 : k.value === null ? -1 : 0 : _.at - k.at
    }
    const defaultSegmentEasing = "easeInOut";
    function createAnimationsFromSequence(_, tt={}, et) {
        var rt = tt
          , {defaultTransition: k={}} = rt
          , J = Kt(rt, ["defaultTransition"]);
        const nt = k.duration || .3
          , ot = new Map
          , it = new Map
          , at = {}
          , lt = new Map;
        let st = 0
          , ut = 0
          , ct = 0;
        for (let pt = 0; pt < _.length; pt++) {
            const ft = _[pt];
            if (typeof ft == "string") {
                lt.set(ft, ut);
                continue
            } else if (!Array.isArray(ft)) {
                lt.set(ft.name, calcNextTime(ut, ft.at, st, lt));
                continue
            }
            let[yt,ht,gt={}] = ft;
            gt.at !== void 0 && (ut = calcNextTime(ut, gt.at, st, lt));
            let mt = 0;
            const vt = (bt,Et,xt,wt=0,St=0)=>{
                const Pt = keyframesAsList(bt)
                  , Yt = Et
                  , {delay: Rt=0, times: At=defaultOffset(Pt), type: Nt="keyframes"} = Yt
                  , Ot = Kt(Yt, ["delay", "times", "type"]);
                let {ease: It=k.ease || "easeOut", duration: Mt} = Et;
                const Wt = typeof Rt == "function" ? Rt(wt, St) : Rt
                  , jt = Pt.length;
                if (jt <= 2 && Nt === "spring") {
                    let Gt = 100;
                    if (jt === 2 && isNumberKeyframesArray(Pt)) {
                        const sr = Pt[1] - Pt[0];
                        Gt = Math.abs(sr)
                    }
                    const er = $t({}, Ot);
                    Mt !== void 0 && (er.duration = secondsToMilliseconds(Mt));
                    const lr = createGeneratorEasing(er, Gt);
                    It = lr.ease,
                    Mt = lr.duration
                }
                Mt != null || (Mt = nt);
                const Bt = ut + Wt
                  , Ut = Bt + Mt;
                At.length === 1 && At[0] === 0 && (At[1] = 1);
                const Xt = At.length - Pt.length;
                Xt > 0 && fillOffset(At, Xt),
                Pt.length === 1 && Pt.unshift(null),
                addKeyframes(xt, Pt, It, At, Bt, Ut),
                mt = Math.max(Wt + Mt, mt),
                ct = Math.max(Ut, ct)
            }
            ;
            if (isMotionValue(yt)) {
                const bt = getSubjectSequence(yt, it);
                vt(ht, gt, getValueSequence("default", bt))
            } else {
                const bt = resolveElements(yt, et, at)
                  , Et = bt.length;
                for (let xt = 0; xt < Et; xt++) {
                    ht = ht,
                    gt = gt;
                    const wt = bt[xt]
                      , St = getSubjectSequence(wt, it);
                    for (const Pt in ht)
                        vt(ht[Pt], getValueTransition(gt, Pt), getValueSequence(Pt, St), xt, Et)
                }
            }
            st = ut,
            ut += mt
        }
        return it.forEach((pt,ft)=>{
            for (const yt in pt) {
                const ht = pt[yt];
                ht.sort(compareByTime);
                const gt = []
                  , mt = []
                  , vt = [];
                for (let Et = 0; Et < ht.length; Et++) {
                    const {at: xt, value: wt, easing: St} = ht[Et];
                    gt.push(wt),
                    mt.push(progress(0, ct, xt)),
                    vt.push(St || "easeOut")
                }
                mt[0] !== 0 && (mt.unshift(0),
                gt.unshift(gt[0]),
                vt.unshift(defaultSegmentEasing)),
                mt[mt.length - 1] !== 1 && (mt.push(1),
                gt.push(null)),
                ot.has(ft) || ot.set(ft, {
                    keyframes: {},
                    transition: {}
                });
                const bt = ot.get(ft);
                bt.keyframes[yt] = gt,
                bt.transition[yt] = $t(_t($t({}, k), {
                    duration: ct,
                    ease: vt,
                    times: mt
                }), J)
            }
        }
        ),
        ot
    }
    function getSubjectSequence(_, k) {
        return !k.has(_) && k.set(_, {}),
        k.get(_)
    }
    function getValueSequence(_, k) {
        return k[_] || (k[_] = []),
        k[_]
    }
    function keyframesAsList(_) {
        return Array.isArray(_) ? _ : [_]
    }
    function getValueTransition(_, k) {
        return _[k] ? $t($t({}, _), _[k]) : $t({}, _)
    }
    const isNumber = _=>typeof _ == "number"
      , isNumberKeyframesArray = _=>_.every(isNumber);
    function animateElements(_, k, J, et) {
        const tt = resolveElements(_, et)
          , rt = tt.length
          , nt = [];
        for (let ot = 0; ot < rt; ot++) {
            const it = tt[ot];
            visualElementStore.has(it) || createVisualElement(it);
            const at = visualElementStore.get(it)
              , lt = $t({}, J);
            typeof lt.delay == "function" && (lt.delay = lt.delay(ot, rt)),
            nt.push(...animateTarget(at, _t($t({}, k), {
                transition: lt
            }), {}))
        }
        return new GroupPlaybackControls(nt)
    }
    const isSequence = _=>Array.isArray(_) && Array.isArray(_[0]);
    function animateSequence(_, k, J) {
        const et = [];
        return createAnimationsFromSequence(_, k, J).forEach(({keyframes: tt, transition: rt},nt)=>{
            let ot;
            isMotionValue(nt) ? ot = animateSingleValue(nt, tt.default, rt.default) : ot = animateElements(nt, tt, rt),
            et.push(ot)
        }
        ),
        new GroupPlaybackControls(et)
    }
    createScopedAnimate = _=>{
        function k(J, et, tt) {
            let rt;
            return isSequence(J) ? rt = animateSequence(J, et, _) : isDOMKeyframes(et) ? rt = animateElements(J, et, tt, _) : rt = animateSingleValue(J, et, tt),
            _ && _.animations.push(rt),
            rt
        }
        return k
    }
    ,
    animate$1 = createScopedAnimate(),
    useAnimationControls = function() {
        const _ = useConstant(animationControls);
        return useIsomorphicLayoutEffect$2(_.mount, []),
        _
    }
    ,
    useAnimation = useAnimationControls,
    DragControls = class {
        constructor() {
            this.componentControls = new Set
        }
        subscribe(_) {
            return this.componentControls.add(_),
            ()=>this.componentControls.delete(_)
        }
        start(_, k) {
            this.componentControls.forEach(J=>{
                J.start(_.nativeEvent || _, k)
            }
            )
        }
    }
    ;
    const createDragControls = ()=>new DragControls;
    useDragControls = function() {
        return useConstant(createDragControls)
    }
    ;
    var reactDom = {
        exports: {}
    }
      , reactDom_production_min = {}
      , scheduler = {
        exports: {}
    }
      , scheduler_production_min = {};
    (function(_) {
        function k(jt, Bt) {
            var Ut = jt.length;
            jt.push(Bt);
            e: for (; 0 < Ut; ) {
                var Xt = Ut - 1 >>> 1
                  , Yt = jt[Xt];
                if (0 < tt(Yt, Bt))
                    jt[Xt] = Bt,
                    jt[Ut] = Yt,
                    Ut = Xt;
                else
                    break e
            }
        }
        function J(jt) {
            return jt.length === 0 ? null : jt[0]
        }
        function et(jt) {
            if (jt.length === 0)
                return null;
            var Bt = jt[0]
              , Ut = jt.pop();
            if (Ut !== Bt) {
                jt[0] = Ut;
                e: for (var Xt = 0, Yt = jt.length, Gt = Yt >>> 1; Xt < Gt; ) {
                    var er = 2 * (Xt + 1) - 1
                      , lr = jt[er]
                      , sr = er + 1
                      , fr = jt[sr];
                    if (0 > tt(lr, Ut))
                        sr < Yt && 0 > tt(fr, lr) ? (jt[Xt] = fr,
                        jt[sr] = Ut,
                        Xt = sr) : (jt[Xt] = lr,
                        jt[er] = Ut,
                        Xt = er);
                    else if (sr < Yt && 0 > tt(fr, Ut))
                        jt[Xt] = fr,
                        jt[sr] = Ut,
                        Xt = sr;
                    else
                        break e
                }
            }
            return Bt
        }
        function tt(jt, Bt) {
            var Ut = jt.sortIndex - Bt.sortIndex;
            return Ut !== 0 ? Ut : jt.id - Bt.id
        }
        if (typeof performance == "object" && typeof performance.now == "function") {
            var rt = performance;
            _.unstable_now = function() {
                return rt.now()
            }
        } else {
            var nt = Date
              , ot = nt.now();
            _.unstable_now = function() {
                return nt.now() - ot
            }
        }
        var it = []
          , at = []
          , lt = 1
          , st = null
          , ut = 3
          , ct = !1
          , pt = !1
          , ft = !1
          , yt = typeof setTimeout == "function" ? setTimeout : null
          , ht = typeof clearTimeout == "function" ? clearTimeout : null
          , gt = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function mt(jt) {
            for (var Bt = J(at); Bt !== null; ) {
                if (Bt.callback === null)
                    et(at);
                else if (Bt.startTime <= jt)
                    et(at),
                    Bt.sortIndex = Bt.expirationTime,
                    k(it, Bt);
                else
                    break;
                Bt = J(at)
            }
        }
        function vt(jt) {
            if (ft = !1,
            mt(jt),
            !pt)
                if (J(it) !== null)
                    pt = !0,
                    Mt(bt);
                else {
                    var Bt = J(at);
                    Bt !== null && Wt(vt, Bt.startTime - jt)
                }
        }
        function bt(jt, Bt) {
            pt = !1,
            ft && (ft = !1,
            ht(wt),
            wt = -1),
            ct = !0;
            var Ut = ut;
            try {
                for (mt(Bt),
                st = J(it); st !== null && (!(st.expirationTime > Bt) || jt && !Rt()); ) {
                    var Xt = st.callback;
                    if (typeof Xt == "function") {
                        st.callback = null,
                        ut = st.priorityLevel;
                        var Yt = Xt(st.expirationTime <= Bt);
                        Bt = _.unstable_now(),
                        typeof Yt == "function" ? st.callback = Yt : st === J(it) && et(it),
                        mt(Bt)
                    } else
                        et(it);
                    st = J(it)
                }
                if (st !== null)
                    var Gt = !0;
                else {
                    var er = J(at);
                    er !== null && Wt(vt, er.startTime - Bt),
                    Gt = !1
                }
                return Gt
            } finally {
                st = null,
                ut = Ut,
                ct = !1
            }
        }
        var Et = !1
          , xt = null
          , wt = -1
          , St = 5
          , Pt = -1;
        function Rt() {
            return !(_.unstable_now() - Pt < St)
        }
        function At() {
            if (xt !== null) {
                var jt = _.unstable_now();
                Pt = jt;
                var Bt = !0;
                try {
                    Bt = xt(!0, jt)
                } finally {
                    Bt ? Nt() : (Et = !1,
                    xt = null)
                }
            } else
                Et = !1
        }
        var Nt;
        if (typeof gt == "function")
            Nt = function() {
                gt(At)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var Ot = new MessageChannel
              , It = Ot.port2;
            Ot.port1.onmessage = At,
            Nt = function() {
                It.postMessage(null)
            }
        } else
            Nt = function() {
                yt(At, 0)
            }
            ;
        function Mt(jt) {
            xt = jt,
            Et || (Et = !0,
            Nt())
        }
        function Wt(jt, Bt) {
            wt = yt(function() {
                jt(_.unstable_now())
            }, Bt)
        }
        _.unstable_IdlePriority = 5,
        _.unstable_ImmediatePriority = 1,
        _.unstable_LowPriority = 4,
        _.unstable_NormalPriority = 3,
        _.unstable_Profiling = null,
        _.unstable_UserBlockingPriority = 2,
        _.unstable_cancelCallback = function(jt) {
            jt.callback = null
        }
        ,
        _.unstable_continueExecution = function() {
            pt || ct || (pt = !0,
            Mt(bt))
        }
        ,
        _.unstable_forceFrameRate = function(jt) {
            0 > jt || 125 < jt || (St = 0 < jt ? Math.floor(1e3 / jt) : 5)
        }
        ,
        _.unstable_getCurrentPriorityLevel = function() {
            return ut
        }
        ,
        _.unstable_getFirstCallbackNode = function() {
            return J(it)
        }
        ,
        _.unstable_next = function(jt) {
            switch (ut) {
            case 1:
            case 2:
            case 3:
                var Bt = 3;
                break;
            default:
                Bt = ut
            }
            var Ut = ut;
            ut = Bt;
            try {
                return jt()
            } finally {
                ut = Ut
            }
        }
        ,
        _.unstable_pauseExecution = function() {}
        ,
        _.unstable_requestPaint = function() {}
        ,
        _.unstable_runWithPriority = function(jt, Bt) {
            switch (jt) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                jt = 3
            }
            var Ut = ut;
            ut = jt;
            try {
                return Bt()
            } finally {
                ut = Ut
            }
        }
        ,
        _.unstable_scheduleCallback = function(jt, Bt, Ut) {
            var Xt = _.unstable_now();
            switch (typeof Ut == "object" && Ut !== null ? (Ut = Ut.delay,
            Ut = typeof Ut == "number" && 0 < Ut ? Xt + Ut : Xt) : Ut = Xt,
            jt) {
            case 1:
                var Yt = -1;
                break;
            case 2:
                Yt = 250;
                break;
            case 5:
                Yt = 1073741823;
                break;
            case 4:
                Yt = 1e4;
                break;
            default:
                Yt = 5e3
            }
            return Yt = Ut + Yt,
            jt = {
                id: lt++,
                callback: Bt,
                priorityLevel: jt,
                startTime: Ut,
                expirationTime: Yt,
                sortIndex: -1
            },
            Ut > Xt ? (jt.sortIndex = Ut,
            k(at, jt),
            J(it) === null && jt === J(at) && (ft ? (ht(wt),
            wt = -1) : ft = !0,
            Wt(vt, Ut - Xt))) : (jt.sortIndex = Yt,
            k(it, jt),
            pt || ct || (pt = !0,
            Mt(bt))),
            jt
        }
        ,
        _.unstable_shouldYield = Rt,
        _.unstable_wrapCallback = function(jt) {
            var Bt = ut;
            return function() {
                var Ut = ut;
                ut = Bt;
                try {
                    return jt.apply(this, arguments)
                } finally {
                    ut = Ut
                }
            }
        }
    }
    )(scheduler_production_min),
    scheduler.exports = scheduler_production_min;
    var schedulerExports = scheduler.exports
      , aa = reactExports
      , ca = schedulerExports;
    function p$2(_) {
        for (var k = "https://reactjs.org/docs/error-decoder.html?invariant=" + _, J = 1; J < arguments.length; J++)
            k += "&args[]=" + encodeURIComponent(arguments[J]);
        return "Minified React error #" + _ + "; visit " + k + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var da = new Set
      , ea = {};
    function fa(_, k) {
        ha(_, k),
        ha(_ + "Capture", k)
    }
    function ha(_, k) {
        for (ea[_] = k,
        _ = 0; _ < k.length; _++)
            da.add(k[_])
    }
    var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , ja = Object.prototype.hasOwnProperty
      , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
      , la = {}
      , ma = {};
    function oa(_) {
        return ja.call(ma, _) ? !0 : ja.call(la, _) ? !1 : ka.test(_) ? ma[_] = !0 : (la[_] = !0,
        !1)
    }
    function pa(_, k, J, et) {
        if (J !== null && J.type === 0)
            return !1;
        switch (typeof k) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return et ? !1 : J !== null ? !J.acceptsBooleans : (_ = _.toLowerCase().slice(0, 5),
            _ !== "data-" && _ !== "aria-");
        default:
            return !1
        }
    }
    function qa(_, k, J, et) {
        if (k === null || typeof k > "u" || pa(_, k, J, et))
            return !0;
        if (et)
            return !1;
        if (J !== null)
            switch (J.type) {
            case 3:
                return !k;
            case 4:
                return k === !1;
            case 5:
                return isNaN(k);
            case 6:
                return isNaN(k) || 1 > k
            }
        return !1
    }
    function v$1(_, k, J, et, tt, rt, nt) {
        this.acceptsBooleans = k === 2 || k === 3 || k === 4,
        this.attributeName = et,
        this.attributeNamespace = tt,
        this.mustUseProperty = J,
        this.propertyName = _,
        this.type = k,
        this.sanitizeURL = rt,
        this.removeEmptyString = nt
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_) {
        z[_] = new v$1(_,0,!1,_,null,!1,!1)
    }),
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_) {
        var k = _[0];
        z[k] = new v$1(k,1,!1,_[1],null,!1,!1)
    }),
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(_) {
        z[_] = new v$1(_,2,!1,_.toLowerCase(),null,!1,!1)
    }),
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(_) {
        z[_] = new v$1(_,2,!1,_,null,!1,!1)
    }),
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_) {
        z[_] = new v$1(_,3,!1,_.toLowerCase(),null,!1,!1)
    }),
    ["checked", "multiple", "muted", "selected"].forEach(function(_) {
        z[_] = new v$1(_,3,!0,_,null,!1,!1)
    }),
    ["capture", "download"].forEach(function(_) {
        z[_] = new v$1(_,4,!1,_,null,!1,!1)
    }),
    ["cols", "rows", "size", "span"].forEach(function(_) {
        z[_] = new v$1(_,6,!1,_,null,!1,!1)
    }),
    ["rowSpan", "start"].forEach(function(_) {
        z[_] = new v$1(_,5,!1,_.toLowerCase(),null,!1,!1)
    });
    var ra = /[\-:]([a-z])/g;
    function sa(_) {
        return _[1].toUpperCase()
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_) {
        var k = _.replace(ra, sa);
        z[k] = new v$1(k,1,!1,_,null,!1,!1)
    }),
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_) {
        var k = _.replace(ra, sa);
        z[k] = new v$1(k,1,!1,_,"http://www.w3.org/1999/xlink",!1,!1)
    }),
    ["xml:base", "xml:lang", "xml:space"].forEach(function(_) {
        var k = _.replace(ra, sa);
        z[k] = new v$1(k,1,!1,_,"http://www.w3.org/XML/1998/namespace",!1,!1)
    }),
    ["tabIndex", "crossOrigin"].forEach(function(_) {
        z[_] = new v$1(_,1,!1,_.toLowerCase(),null,!1,!1)
    }),
    z.xlinkHref = new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),
    ["src", "href", "action", "formAction"].forEach(function(_) {
        z[_] = new v$1(_,1,!1,_.toLowerCase(),null,!0,!0)
    });
    function ta(_, k, J, et) {
        var tt = z.hasOwnProperty(k) ? z[k] : null;
        (tt !== null ? tt.type !== 0 : et || !(2 < k.length) || k[0] !== "o" && k[0] !== "O" || k[1] !== "n" && k[1] !== "N") && (qa(k, J, tt, et) && (J = null),
        et || tt === null ? oa(k) && (J === null ? _.removeAttribute(k) : _.setAttribute(k, "" + J)) : tt.mustUseProperty ? _[tt.propertyName] = J === null ? tt.type === 3 ? !1 : "" : J : (k = tt.attributeName,
        et = tt.attributeNamespace,
        J === null ? _.removeAttribute(k) : (tt = tt.type,
        J = tt === 3 || tt === 4 && J === !0 ? "" : "" + J,
        et ? _.setAttributeNS(et, k, J) : _.setAttribute(k, J))))
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
      , va = Symbol.for("react.element")
      , wa = Symbol.for("react.portal")
      , ya = Symbol.for("react.fragment")
      , za = Symbol.for("react.strict_mode")
      , Aa = Symbol.for("react.profiler")
      , Ba = Symbol.for("react.provider")
      , Ca = Symbol.for("react.context")
      , Da = Symbol.for("react.forward_ref")
      , Ea = Symbol.for("react.suspense")
      , Fa = Symbol.for("react.suspense_list")
      , Ga = Symbol.for("react.memo")
      , Ha = Symbol.for("react.lazy")
      , Ia = Symbol.for("react.offscreen")
      , Ja = Symbol.iterator;
    function Ka(_) {
        return _ === null || typeof _ != "object" ? null : (_ = Ja && _[Ja] || _["@@iterator"],
        typeof _ == "function" ? _ : null)
    }
    var A = Object.assign, La;
    function Ma(_) {
        if (La === void 0)
            try {
                throw Error()
            } catch (J) {
                var k = J.stack.trim().match(/\n( *(at )?)/);
                La = k && k[1] || ""
            }
        return `
` + La + _
    }
    var Na = !1;
    function Oa(_, k) {
        if (!_ || Na)
            return "";
        Na = !0;
        var J = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (k)
                if (k = function() {
                    throw Error()
                }
                ,
                Object.defineProperty(k.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }),
                typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(k, [])
                    } catch (at) {
                        var et = at
                    }
                    Reflect.construct(_, [], k)
                } else {
                    try {
                        k.call()
                    } catch (at) {
                        et = at
                    }
                    _.call(k.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (at) {
                    et = at
                }
                _()
            }
        } catch (at) {
            if (at && et && typeof at.stack == "string") {
                for (var tt = at.stack.split(`
`), rt = et.stack.split(`
`), nt = tt.length - 1, ot = rt.length - 1; 1 <= nt && 0 <= ot && tt[nt] !== rt[ot]; )
                    ot--;
                for (; 1 <= nt && 0 <= ot; nt--,
                ot--)
                    if (tt[nt] !== rt[ot]) {
                        if (nt !== 1 || ot !== 1)
                            do
                                if (nt--,
                                ot--,
                                0 > ot || tt[nt] !== rt[ot]) {
                                    var it = `
` + tt[nt].replace(" at new ", " at ");
                                    return _.displayName && it.includes("<anonymous>") && (it = it.replace("<anonymous>", _.displayName)),
                                    it
                                }
                            while (1 <= nt && 0 <= ot);
                        break
                    }
            }
        } finally {
            Na = !1,
            Error.prepareStackTrace = J
        }
        return (_ = _ ? _.displayName || _.name : "") ? Ma(_) : ""
    }
    function Pa(_) {
        switch (_.tag) {
        case 5:
            return Ma(_.type);
        case 16:
            return Ma("Lazy");
        case 13:
            return Ma("Suspense");
        case 19:
            return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
            return _ = Oa(_.type, !1),
            _;
        case 11:
            return _ = Oa(_.type.render, !1),
            _;
        case 1:
            return _ = Oa(_.type, !0),
            _;
        default:
            return ""
        }
    }
    function Qa(_) {
        if (_ == null)
            return null;
        if (typeof _ == "function")
            return _.displayName || _.name || null;
        if (typeof _ == "string")
            return _;
        switch (_) {
        case ya:
            return "Fragment";
        case wa:
            return "Portal";
        case Aa:
            return "Profiler";
        case za:
            return "StrictMode";
        case Ea:
            return "Suspense";
        case Fa:
            return "SuspenseList"
        }
        if (typeof _ == "object")
            switch (_.$$typeof) {
            case Ca:
                return (_.displayName || "Context") + ".Consumer";
            case Ba:
                return (_._context.displayName || "Context") + ".Provider";
            case Da:
                var k = _.render;
                return _ = _.displayName,
                _ || (_ = k.displayName || k.name || "",
                _ = _ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef"),
                _;
            case Ga:
                return k = _.displayName || null,
                k !== null ? k : Qa(_.type) || "Memo";
            case Ha:
                k = _._payload,
                _ = _._init;
                try {
                    return Qa(_(k))
                } catch (J) {}
            }
        return null
    }
    function Ra(_) {
        var k = _.type;
        switch (_.tag) {
        case 24:
            return "Cache";
        case 9:
            return (k.displayName || "Context") + ".Consumer";
        case 10:
            return (k._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return _ = k.render,
            _ = _.displayName || _.name || "",
            k.displayName || (_ !== "" ? "ForwardRef(" + _ + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return k;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return Qa(k);
        case 8:
            return k === za ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof k == "function")
                return k.displayName || k.name || null;
            if (typeof k == "string")
                return k
        }
        return null
    }
    function Sa(_) {
        switch (typeof _) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return _;
        case "object":
            return _;
        default:
            return ""
        }
    }
    function Ta(_) {
        var k = _.type;
        return (_ = _.nodeName) && _.toLowerCase() === "input" && (k === "checkbox" || k === "radio")
    }
    function Ua(_) {
        var k = Ta(_) ? "checked" : "value"
          , J = Object.getOwnPropertyDescriptor(_.constructor.prototype, k)
          , et = "" + _[k];
        if (!_.hasOwnProperty(k) && typeof J < "u" && typeof J.get == "function" && typeof J.set == "function") {
            var tt = J.get
              , rt = J.set;
            return Object.defineProperty(_, k, {
                configurable: !0,
                get: function() {
                    return tt.call(this)
                },
                set: function(nt) {
                    et = "" + nt,
                    rt.call(this, nt)
                }
            }),
            Object.defineProperty(_, k, {
                enumerable: J.enumerable
            }),
            {
                getValue: function() {
                    return et
                },
                setValue: function(nt) {
                    et = "" + nt
                },
                stopTracking: function() {
                    _._valueTracker = null,
                    delete _[k]
                }
            }
        }
    }
    function Va(_) {
        _._valueTracker || (_._valueTracker = Ua(_))
    }
    function Wa(_) {
        if (!_)
            return !1;
        var k = _._valueTracker;
        if (!k)
            return !0;
        var J = k.getValue()
          , et = "";
        return _ && (et = Ta(_) ? _.checked ? "true" : "false" : _.value),
        _ = et,
        _ !== J ? (k.setValue(_),
        !0) : !1
    }
    function Xa(_) {
        if (_ = _ || (typeof document < "u" ? document : void 0),
        typeof _ > "u")
            return null;
        try {
            return _.activeElement || _.body
        } catch (k) {
            return _.body
        }
    }
    function Ya(_, k) {
        var J = k.checked;
        return A({}, k, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: J != null ? J : _._wrapperState.initialChecked
        })
    }
    function Za(_, k) {
        var J = k.defaultValue == null ? "" : k.defaultValue
          , et = k.checked != null ? k.checked : k.defaultChecked;
        J = Sa(k.value != null ? k.value : J),
        _._wrapperState = {
            initialChecked: et,
            initialValue: J,
            controlled: k.type === "checkbox" || k.type === "radio" ? k.checked != null : k.value != null
        }
    }
    function ab(_, k) {
        k = k.checked,
        k != null && ta(_, "checked", k, !1)
    }
    function bb(_, k) {
        ab(_, k);
        var J = Sa(k.value)
          , et = k.type;
        if (J != null)
            et === "number" ? (J === 0 && _.value === "" || _.value != J) && (_.value = "" + J) : _.value !== "" + J && (_.value = "" + J);
        else if (et === "submit" || et === "reset") {
            _.removeAttribute("value");
            return
        }
        k.hasOwnProperty("value") ? cb(_, k.type, J) : k.hasOwnProperty("defaultValue") && cb(_, k.type, Sa(k.defaultValue)),
        k.checked == null && k.defaultChecked != null && (_.defaultChecked = !!k.defaultChecked)
    }
    function db(_, k, J) {
        if (k.hasOwnProperty("value") || k.hasOwnProperty("defaultValue")) {
            var et = k.type;
            if (!(et !== "submit" && et !== "reset" || k.value !== void 0 && k.value !== null))
                return;
            k = "" + _._wrapperState.initialValue,
            J || k === _.value || (_.value = k),
            _.defaultValue = k
        }
        J = _.name,
        J !== "" && (_.name = ""),
        _.defaultChecked = !!_._wrapperState.initialChecked,
        J !== "" && (_.name = J)
    }
    function cb(_, k, J) {
        (k !== "number" || Xa(_.ownerDocument) !== _) && (J == null ? _.defaultValue = "" + _._wrapperState.initialValue : _.defaultValue !== "" + J && (_.defaultValue = "" + J))
    }
    var eb = Array.isArray;
    function fb(_, k, J, et) {
        if (_ = _.options,
        k) {
            k = {};
            for (var tt = 0; tt < J.length; tt++)
                k["$" + J[tt]] = !0;
            for (J = 0; J < _.length; J++)
                tt = k.hasOwnProperty("$" + _[J].value),
                _[J].selected !== tt && (_[J].selected = tt),
                tt && et && (_[J].defaultSelected = !0)
        } else {
            for (J = "" + Sa(J),
            k = null,
            tt = 0; tt < _.length; tt++) {
                if (_[tt].value === J) {
                    _[tt].selected = !0,
                    et && (_[tt].defaultSelected = !0);
                    return
                }
                k !== null || _[tt].disabled || (k = _[tt])
            }
            k !== null && (k.selected = !0)
        }
    }
    function gb(_, k) {
        if (k.dangerouslySetInnerHTML != null)
            throw Error(p$2(91));
        return A({}, k, {
            value: void 0,
            defaultValue: void 0,
            children: "" + _._wrapperState.initialValue
        })
    }
    function hb(_, k) {
        var J = k.value;
        if (J == null) {
            if (J = k.children,
            k = k.defaultValue,
            J != null) {
                if (k != null)
                    throw Error(p$2(92));
                if (eb(J)) {
                    if (1 < J.length)
                        throw Error(p$2(93));
                    J = J[0]
                }
                k = J
            }
            k == null && (k = ""),
            J = k
        }
        _._wrapperState = {
            initialValue: Sa(J)
        }
    }
    function ib(_, k) {
        var J = Sa(k.value)
          , et = Sa(k.defaultValue);
        J != null && (J = "" + J,
        J !== _.value && (_.value = J),
        k.defaultValue == null && _.defaultValue !== J && (_.defaultValue = J)),
        et != null && (_.defaultValue = "" + et)
    }
    function jb(_) {
        var k = _.textContent;
        k === _._wrapperState.initialValue && k !== "" && k !== null && (_.value = k)
    }
    function kb(_) {
        switch (_) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
        }
    }
    function lb(_, k) {
        return _ == null || _ === "http://www.w3.org/1999/xhtml" ? kb(k) : _ === "http://www.w3.org/2000/svg" && k === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _
    }
    var mb, nb = function(_) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(k, J, et, tt) {
            MSApp.execUnsafeLocalFunction(function() {
                return _(k, J, et, tt)
            })
        }
        : _
    }(function(_, k) {
        if (_.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in _)
            _.innerHTML = k;
        else {
            for (mb = mb || document.createElement("div"),
            mb.innerHTML = "<svg>" + k.valueOf().toString() + "</svg>",
            k = mb.firstChild; _.firstChild; )
                _.removeChild(_.firstChild);
            for (; k.firstChild; )
                _.appendChild(k.firstChild)
        }
    });
    function ob(_, k) {
        if (k) {
            var J = _.firstChild;
            if (J && J === _.lastChild && J.nodeType === 3) {
                J.nodeValue = k;
                return
            }
        }
        _.textContent = k
    }
    var pb = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    }
      , qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(_) {
        qb.forEach(function(k) {
            k = k + _.charAt(0).toUpperCase() + _.substring(1),
            pb[k] = pb[_]
        })
    });
    function rb(_, k, J) {
        return k == null || typeof k == "boolean" || k === "" ? "" : J || typeof k != "number" || k === 0 || pb.hasOwnProperty(_) && pb[_] ? ("" + k).trim() : k + "px"
    }
    function sb(_, k) {
        _ = _.style;
        for (var J in k)
            if (k.hasOwnProperty(J)) {
                var et = J.indexOf("--") === 0
                  , tt = rb(J, k[J], et);
                J === "float" && (J = "cssFloat"),
                et ? _.setProperty(J, tt) : _[J] = tt
            }
    }
    var tb = A({
        menuitem: !0
    }, {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        keygen: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    });
    function ub(_, k) {
        if (k) {
            if (tb[_] && (k.children != null || k.dangerouslySetInnerHTML != null))
                throw Error(p$2(137, _));
            if (k.dangerouslySetInnerHTML != null) {
                if (k.children != null)
                    throw Error(p$2(60));
                if (typeof k.dangerouslySetInnerHTML != "object" || !("__html"in k.dangerouslySetInnerHTML))
                    throw Error(p$2(61))
            }
            if (k.style != null && typeof k.style != "object")
                throw Error(p$2(62))
        }
    }
    function vb(_, k) {
        if (_.indexOf("-") === -1)
            return typeof k.is == "string";
        switch (_) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var wb = null;
    function xb(_) {
        return _ = _.target || _.srcElement || window,
        _.correspondingUseElement && (_ = _.correspondingUseElement),
        _.nodeType === 3 ? _.parentNode : _
    }
    var yb = null
      , zb = null
      , Ab = null;
    function Bb(_) {
        if (_ = Cb(_)) {
            if (typeof yb != "function")
                throw Error(p$2(280));
            var k = _.stateNode;
            k && (k = Db(k),
            yb(_.stateNode, _.type, k))
        }
    }
    function Eb(_) {
        zb ? Ab ? Ab.push(_) : Ab = [_] : zb = _
    }
    function Fb() {
        if (zb) {
            var _ = zb
              , k = Ab;
            if (Ab = zb = null,
            Bb(_),
            k)
                for (_ = 0; _ < k.length; _++)
                    Bb(k[_])
        }
    }
    function Gb(_, k) {
        return _(k)
    }
    function Hb() {}
    var Ib = !1;
    function Jb(_, k, J) {
        if (Ib)
            return _(k, J);
        Ib = !0;
        try {
            return Gb(_, k, J)
        } finally {
            Ib = !1,
            (zb !== null || Ab !== null) && (Hb(),
            Fb())
        }
    }
    function Kb(_, k) {
        var J = _.stateNode;
        if (J === null)
            return null;
        var et = Db(J);
        if (et === null)
            return null;
        J = et[k];
        e: switch (k) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (et = !et.disabled) || (_ = _.type,
            et = !(_ === "button" || _ === "input" || _ === "select" || _ === "textarea")),
            _ = !et;
            break e;
        default:
            _ = !1
        }
        if (_)
            return null;
        if (J && typeof J != "function")
            throw Error(p$2(231, k, typeof J));
        return J
    }
    var Lb = !1;
    if (ia)
        try {
            var Mb = {};
            Object.defineProperty(Mb, "passive", {
                get: function() {
                    Lb = !0
                }
            }),
            window.addEventListener("test", Mb, Mb),
            window.removeEventListener("test", Mb, Mb)
        } catch (_) {
            Lb = !1
        }
    function Nb(_, k, J, et, tt, rt, nt, ot, it) {
        var at = Array.prototype.slice.call(arguments, 3);
        try {
            k.apply(J, at)
        } catch (lt) {
            this.onError(lt)
        }
    }
    var Ob = !1
      , Pb = null
      , Qb = !1
      , Rb = null
      , Sb = {
        onError: function(_) {
            Ob = !0,
            Pb = _
        }
    };
    function Tb(_, k, J, et, tt, rt, nt, ot, it) {
        Ob = !1,
        Pb = null,
        Nb.apply(Sb, arguments)
    }
    function Ub(_, k, J, et, tt, rt, nt, ot, it) {
        if (Tb.apply(this, arguments),
        Ob) {
            if (Ob) {
                var at = Pb;
                Ob = !1,
                Pb = null
            } else
                throw Error(p$2(198));
            Qb || (Qb = !0,
            Rb = at)
        }
    }
    function Vb(_) {
        var k = _
          , J = _;
        if (_.alternate)
            for (; k.return; )
                k = k.return;
        else {
            _ = k;
            do
                k = _,
                k.flags & 4098 && (J = k.return),
                _ = k.return;
            while (_)
        }
        return k.tag === 3 ? J : null
    }
    function Wb(_) {
        if (_.tag === 13) {
            var k = _.memoizedState;
            if (k === null && (_ = _.alternate,
            _ !== null && (k = _.memoizedState)),
            k !== null)
                return k.dehydrated
        }
        return null
    }
    function Xb(_) {
        if (Vb(_) !== _)
            throw Error(p$2(188))
    }
    function Yb(_) {
        var k = _.alternate;
        if (!k) {
            if (k = Vb(_),
            k === null)
                throw Error(p$2(188));
            return k !== _ ? null : _
        }
        for (var J = _, et = k; ; ) {
            var tt = J.return;
            if (tt === null)
                break;
            var rt = tt.alternate;
            if (rt === null) {
                if (et = tt.return,
                et !== null) {
                    J = et;
                    continue
                }
                break
            }
            if (tt.child === rt.child) {
                for (rt = tt.child; rt; ) {
                    if (rt === J)
                        return Xb(tt),
                        _;
                    if (rt === et)
                        return Xb(tt),
                        k;
                    rt = rt.sibling
                }
                throw Error(p$2(188))
            }
            if (J.return !== et.return)
                J = tt,
                et = rt;
            else {
                for (var nt = !1, ot = tt.child; ot; ) {
                    if (ot === J) {
                        nt = !0,
                        J = tt,
                        et = rt;
                        break
                    }
                    if (ot === et) {
                        nt = !0,
                        et = tt,
                        J = rt;
                        break
                    }
                    ot = ot.sibling
                }
                if (!nt) {
                    for (ot = rt.child; ot; ) {
                        if (ot === J) {
                            nt = !0,
                            J = rt,
                            et = tt;
                            break
                        }
                        if (ot === et) {
                            nt = !0,
                            et = rt,
                            J = tt;
                            break
                        }
                        ot = ot.sibling
                    }
                    if (!nt)
                        throw Error(p$2(189))
                }
            }
            if (J.alternate !== et)
                throw Error(p$2(190))
        }
        if (J.tag !== 3)
            throw Error(p$2(188));
        return J.stateNode.current === J ? _ : k
    }
    function Zb(_) {
        return _ = Yb(_),
        _ !== null ? $b(_) : null
    }
    function $b(_) {
        if (_.tag === 5 || _.tag === 6)
            return _;
        for (_ = _.child; _ !== null; ) {
            var k = $b(_);
            if (k !== null)
                return k;
            _ = _.sibling
        }
        return null
    }
    var ac = ca.unstable_scheduleCallback
      , bc = ca.unstable_cancelCallback
      , cc = ca.unstable_shouldYield
      , dc = ca.unstable_requestPaint
      , B$1 = ca.unstable_now
      , ec = ca.unstable_getCurrentPriorityLevel
      , fc = ca.unstable_ImmediatePriority
      , gc = ca.unstable_UserBlockingPriority
      , hc = ca.unstable_NormalPriority
      , ic = ca.unstable_LowPriority
      , jc = ca.unstable_IdlePriority
      , kc = null
      , lc = null;
    function mc(_) {
        if (lc && typeof lc.onCommitFiberRoot == "function")
            try {
                lc.onCommitFiberRoot(kc, _, void 0, (_.current.flags & 128) === 128)
            } catch (k) {}
    }
    var oc = Math.clz32 ? Math.clz32 : nc
      , pc = Math.log
      , qc = Math.LN2;
    function nc(_) {
        return _ >>>= 0,
        _ === 0 ? 32 : 31 - (pc(_) / qc | 0) | 0
    }
    var rc = 64
      , sc = 4194304;
    function tc(_) {
        switch (_ & -_) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return _ & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return _ & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return _
        }
    }
    function uc(_, k) {
        var J = _.pendingLanes;
        if (J === 0)
            return 0;
        var et = 0
          , tt = _.suspendedLanes
          , rt = _.pingedLanes
          , nt = J & 268435455;
        if (nt !== 0) {
            var ot = nt & ~tt;
            ot !== 0 ? et = tc(ot) : (rt &= nt,
            rt !== 0 && (et = tc(rt)))
        } else
            nt = J & ~tt,
            nt !== 0 ? et = tc(nt) : rt !== 0 && (et = tc(rt));
        if (et === 0)
            return 0;
        if (k !== 0 && k !== et && !(k & tt) && (tt = et & -et,
        rt = k & -k,
        tt >= rt || tt === 16 && (rt & 4194240) !== 0))
            return k;
        if (et & 4 && (et |= J & 16),
        k = _.entangledLanes,
        k !== 0)
            for (_ = _.entanglements,
            k &= et; 0 < k; )
                J = 31 - oc(k),
                tt = 1 << J,
                et |= _[J],
                k &= ~tt;
        return et
    }
    function vc(_, k) {
        switch (_) {
        case 1:
        case 2:
        case 4:
            return k + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return k + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function wc(_, k) {
        for (var J = _.suspendedLanes, et = _.pingedLanes, tt = _.expirationTimes, rt = _.pendingLanes; 0 < rt; ) {
            var nt = 31 - oc(rt)
              , ot = 1 << nt
              , it = tt[nt];
            it === -1 ? (!(ot & J) || ot & et) && (tt[nt] = vc(ot, k)) : it <= k && (_.expiredLanes |= ot),
            rt &= ~ot
        }
    }
    function xc(_) {
        return _ = _.pendingLanes & -1073741825,
        _ !== 0 ? _ : _ & 1073741824 ? 1073741824 : 0
    }
    function yc() {
        var _ = rc;
        return rc <<= 1,
        !(rc & 4194240) && (rc = 64),
        _
    }
    function zc(_) {
        for (var k = [], J = 0; 31 > J; J++)
            k.push(_);
        return k
    }
    function Ac(_, k, J) {
        _.pendingLanes |= k,
        k !== 536870912 && (_.suspendedLanes = 0,
        _.pingedLanes = 0),
        _ = _.eventTimes,
        k = 31 - oc(k),
        _[k] = J
    }
    function Bc(_, k) {
        var J = _.pendingLanes & ~k;
        _.pendingLanes = k,
        _.suspendedLanes = 0,
        _.pingedLanes = 0,
        _.expiredLanes &= k,
        _.mutableReadLanes &= k,
        _.entangledLanes &= k,
        k = _.entanglements;
        var et = _.eventTimes;
        for (_ = _.expirationTimes; 0 < J; ) {
            var tt = 31 - oc(J)
              , rt = 1 << tt;
            k[tt] = 0,
            et[tt] = -1,
            _[tt] = -1,
            J &= ~rt
        }
    }
    function Cc(_, k) {
        var J = _.entangledLanes |= k;
        for (_ = _.entanglements; J; ) {
            var et = 31 - oc(J)
              , tt = 1 << et;
            tt & k | _[et] & k && (_[et] |= k),
            J &= ~tt
        }
    }
    var C$1 = 0;
    function Dc(_) {
        return _ &= -_,
        1 < _ ? 4 < _ ? _ & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(_, k) {
        switch (_) {
        case "focusin":
        case "focusout":
            Lc = null;
            break;
        case "dragenter":
        case "dragleave":
            Mc = null;
            break;
        case "mouseover":
        case "mouseout":
            Nc = null;
            break;
        case "pointerover":
        case "pointerout":
            Oc.delete(k.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Pc.delete(k.pointerId)
        }
    }
    function Tc(_, k, J, et, tt, rt) {
        return _ === null || _.nativeEvent !== rt ? (_ = {
            blockedOn: k,
            domEventName: J,
            eventSystemFlags: et,
            nativeEvent: rt,
            targetContainers: [tt]
        },
        k !== null && (k = Cb(k),
        k !== null && Fc(k)),
        _) : (_.eventSystemFlags |= et,
        k = _.targetContainers,
        tt !== null && k.indexOf(tt) === -1 && k.push(tt),
        _)
    }
    function Uc(_, k, J, et, tt) {
        switch (k) {
        case "focusin":
            return Lc = Tc(Lc, _, k, J, et, tt),
            !0;
        case "dragenter":
            return Mc = Tc(Mc, _, k, J, et, tt),
            !0;
        case "mouseover":
            return Nc = Tc(Nc, _, k, J, et, tt),
            !0;
        case "pointerover":
            var rt = tt.pointerId;
            return Oc.set(rt, Tc(Oc.get(rt) || null, _, k, J, et, tt)),
            !0;
        case "gotpointercapture":
            return rt = tt.pointerId,
            Pc.set(rt, Tc(Pc.get(rt) || null, _, k, J, et, tt)),
            !0
        }
        return !1
    }
    function Vc(_) {
        var k = Wc(_.target);
        if (k !== null) {
            var J = Vb(k);
            if (J !== null) {
                if (k = J.tag,
                k === 13) {
                    if (k = Wb(J),
                    k !== null) {
                        _.blockedOn = k,
                        Ic(_.priority, function() {
                            Gc(J)
                        });
                        return
                    }
                } else if (k === 3 && J.stateNode.current.memoizedState.isDehydrated) {
                    _.blockedOn = J.tag === 3 ? J.stateNode.containerInfo : null;
                    return
                }
            }
        }
        _.blockedOn = null
    }
    function Xc(_) {
        if (_.blockedOn !== null)
            return !1;
        for (var k = _.targetContainers; 0 < k.length; ) {
            var J = Yc(_.domEventName, _.eventSystemFlags, k[0], _.nativeEvent);
            if (J === null) {
                J = _.nativeEvent;
                var et = new J.constructor(J.type,J);
                wb = et,
                J.target.dispatchEvent(et),
                wb = null
            } else
                return k = Cb(J),
                k !== null && Fc(k),
                _.blockedOn = J,
                !1;
            k.shift()
        }
        return !0
    }
    function Zc(_, k, J) {
        Xc(_) && J.delete(k)
    }
    function $c() {
        Jc = !1,
        Lc !== null && Xc(Lc) && (Lc = null),
        Mc !== null && Xc(Mc) && (Mc = null),
        Nc !== null && Xc(Nc) && (Nc = null),
        Oc.forEach(Zc),
        Pc.forEach(Zc)
    }
    function ad(_, k) {
        _.blockedOn === k && (_.blockedOn = null,
        Jc || (Jc = !0,
        ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
    }
    function bd(_) {
        function k(tt) {
            return ad(tt, _)
        }
        if (0 < Kc.length) {
            ad(Kc[0], _);
            for (var J = 1; J < Kc.length; J++) {
                var et = Kc[J];
                et.blockedOn === _ && (et.blockedOn = null)
            }
        }
        for (Lc !== null && ad(Lc, _),
        Mc !== null && ad(Mc, _),
        Nc !== null && ad(Nc, _),
        Oc.forEach(k),
        Pc.forEach(k),
        J = 0; J < Qc.length; J++)
            et = Qc[J],
            et.blockedOn === _ && (et.blockedOn = null);
        for (; 0 < Qc.length && (J = Qc[0],
        J.blockedOn === null); )
            Vc(J),
            J.blockedOn === null && Qc.shift()
    }
    var cd = ua.ReactCurrentBatchConfig
      , dd = !0;
    function ed(_, k, J, et) {
        var tt = C$1
          , rt = cd.transition;
        cd.transition = null;
        try {
            C$1 = 1,
            fd(_, k, J, et)
        } finally {
            C$1 = tt,
            cd.transition = rt
        }
    }
    function gd(_, k, J, et) {
        var tt = C$1
          , rt = cd.transition;
        cd.transition = null;
        try {
            C$1 = 4,
            fd(_, k, J, et)
        } finally {
            C$1 = tt,
            cd.transition = rt
        }
    }
    function fd(_, k, J, et) {
        if (dd) {
            var tt = Yc(_, k, J, et);
            if (tt === null)
                hd(_, k, et, id, J),
                Sc(_, et);
            else if (Uc(tt, _, k, J, et))
                et.stopPropagation();
            else if (Sc(_, et),
            k & 4 && -1 < Rc.indexOf(_)) {
                for (; tt !== null; ) {
                    var rt = Cb(tt);
                    if (rt !== null && Ec(rt),
                    rt = Yc(_, k, J, et),
                    rt === null && hd(_, k, et, id, J),
                    rt === tt)
                        break;
                    tt = rt
                }
                tt !== null && et.stopPropagation()
            } else
                hd(_, k, et, null, J)
        }
    }
    var id = null;
    function Yc(_, k, J, et) {
        if (id = null,
        _ = xb(et),
        _ = Wc(_),
        _ !== null)
            if (k = Vb(_),
            k === null)
                _ = null;
            else if (J = k.tag,
            J === 13) {
                if (_ = Wb(k),
                _ !== null)
                    return _;
                _ = null
            } else if (J === 3) {
                if (k.stateNode.current.memoizedState.isDehydrated)
                    return k.tag === 3 ? k.stateNode.containerInfo : null;
                _ = null
            } else
                k !== _ && (_ = null);
        return id = _,
        null
    }
    function jd(_) {
        switch (_) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (ec()) {
            case fc:
                return 1;
            case gc:
                return 4;
            case hc:
            case ic:
                return 16;
            case jc:
                return 536870912;
            default:
                return 16
            }
        default:
            return 16
        }
    }
    var kd = null
      , ld = null
      , md = null;
    function nd() {
        if (md)
            return md;
        var _, k = ld, J = k.length, et, tt = "value"in kd ? kd.value : kd.textContent, rt = tt.length;
        for (_ = 0; _ < J && k[_] === tt[_]; _++)
            ;
        var nt = J - _;
        for (et = 1; et <= nt && k[J - et] === tt[rt - et]; et++)
            ;
        return md = tt.slice(_, 1 < et ? 1 - et : void 0)
    }
    function od(_) {
        var k = _.keyCode;
        return "charCode"in _ ? (_ = _.charCode,
        _ === 0 && k === 13 && (_ = 13)) : _ = k,
        _ === 10 && (_ = 13),
        32 <= _ || _ === 13 ? _ : 0
    }
    function pd() {
        return !0
    }
    function qd() {
        return !1
    }
    function rd(_) {
        function k(J, et, tt, rt, nt) {
            this._reactName = J,
            this._targetInst = tt,
            this.type = et,
            this.nativeEvent = rt,
            this.target = nt,
            this.currentTarget = null;
            for (var ot in _)
                _.hasOwnProperty(ot) && (J = _[ot],
                this[ot] = J ? J(rt) : rt[ot]);
            return this.isDefaultPrevented = (rt.defaultPrevented != null ? rt.defaultPrevented : rt.returnValue === !1) ? pd : qd,
            this.isPropagationStopped = qd,
            this
        }
        return A(k.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var J = this.nativeEvent;
                J && (J.preventDefault ? J.preventDefault() : typeof J.returnValue != "unknown" && (J.returnValue = !1),
                this.isDefaultPrevented = pd)
            },
            stopPropagation: function() {
                var J = this.nativeEvent;
                J && (J.stopPropagation ? J.stopPropagation() : typeof J.cancelBubble != "unknown" && (J.cancelBubble = !0),
                this.isPropagationStopped = pd)
            },
            persist: function() {},
            isPersistent: pd
        }),
        k
    }
    var sd = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(_) {
            return _.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, td = rd(sd), ud = A({}, sd, {
        view: 0,
        detail: 0
    }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: zd,
        button: 0,
        buttons: 0,
        relatedTarget: function(_) {
            return _.relatedTarget === void 0 ? _.fromElement === _.srcElement ? _.toElement : _.fromElement : _.relatedTarget
        },
        movementX: function(_) {
            return "movementX"in _ ? _.movementX : (_ !== yd && (yd && _.type === "mousemove" ? (wd = _.screenX - yd.screenX,
            xd = _.screenY - yd.screenY) : xd = wd = 0,
            yd = _),
            wd)
        },
        movementY: function(_) {
            return "movementY"in _ ? _.movementY : xd
        }
    }), Bd = rd(Ad), Cd = A({}, Ad, {
        dataTransfer: 0
    }), Dd = rd(Cd), Ed = A({}, ud, {
        relatedTarget: 0
    }), Fd = rd(Ed), Gd = A({}, sd, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), Hd = rd(Gd), Id = A({}, sd, {
        clipboardData: function(_) {
            return "clipboardData"in _ ? _.clipboardData : window.clipboardData
        }
    }), Jd = rd(Id), Kd = A({}, sd, {
        data: 0
    }), Ld = rd(Kd), Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, Od = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function Pd(_) {
        var k = this.nativeEvent;
        return k.getModifierState ? k.getModifierState(_) : (_ = Od[_]) ? !!k[_] : !1
    }
    function zd() {
        return Pd
    }
    var Qd = A({}, ud, {
        key: function(_) {
            if (_.key) {
                var k = Md[_.key] || _.key;
                if (k !== "Unidentified")
                    return k
            }
            return _.type === "keypress" ? (_ = od(_),
            _ === 13 ? "Enter" : String.fromCharCode(_)) : _.type === "keydown" || _.type === "keyup" ? Nd[_.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: zd,
        charCode: function(_) {
            return _.type === "keypress" ? od(_) : 0
        },
        keyCode: function(_) {
            return _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
        },
        which: function(_) {
            return _.type === "keypress" ? od(_) : _.type === "keydown" || _.type === "keyup" ? _.keyCode : 0
        }
    })
      , Rd = rd(Qd)
      , Sd = A({}, Ad, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , Td = rd(Sd)
      , Ud = A({}, ud, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: zd
    })
      , Vd = rd(Ud)
      , Wd = A({}, sd, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , Xd = rd(Wd)
      , Yd = A({}, Ad, {
        deltaX: function(_) {
            return "deltaX"in _ ? _.deltaX : "wheelDeltaX"in _ ? -_.wheelDeltaX : 0
        },
        deltaY: function(_) {
            return "deltaY"in _ ? _.deltaY : "wheelDeltaY"in _ ? -_.wheelDeltaY : "wheelDelta"in _ ? -_.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , Zd = rd(Yd)
      , $d = [9, 13, 27, 32]
      , ae = ia && "CompositionEvent"in window
      , be = null;
    ia && "documentMode"in document && (be = document.documentMode);
    var ce = ia && "TextEvent"in window && !be
      , de = ia && (!ae || be && 8 < be && 11 >= be)
      , ee = String.fromCharCode(32)
      , fe = !1;
    function ge(_, k) {
        switch (_) {
        case "keyup":
            return $d.indexOf(k.keyCode) !== -1;
        case "keydown":
            return k.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function he(_) {
        return _ = _.detail,
        typeof _ == "object" && "data"in _ ? _.data : null
    }
    var ie = !1;
    function je(_, k) {
        switch (_) {
        case "compositionend":
            return he(k);
        case "keypress":
            return k.which !== 32 ? null : (fe = !0,
            ee);
        case "textInput":
            return _ = k.data,
            _ === ee && fe ? null : _;
        default:
            return null
        }
    }
    function ke(_, k) {
        if (ie)
            return _ === "compositionend" || !ae && ge(_, k) ? (_ = nd(),
            md = ld = kd = null,
            ie = !1,
            _) : null;
        switch (_) {
        case "paste":
            return null;
        case "keypress":
            if (!(k.ctrlKey || k.altKey || k.metaKey) || k.ctrlKey && k.altKey) {
                if (k.char && 1 < k.char.length)
                    return k.char;
                if (k.which)
                    return String.fromCharCode(k.which)
            }
            return null;
        case "compositionend":
            return de && k.locale !== "ko" ? null : k.data;
        default:
            return null
        }
    }
    var le = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function me(_) {
        var k = _ && _.nodeName && _.nodeName.toLowerCase();
        return k === "input" ? !!le[_.type] : k === "textarea"
    }
    function ne(_, k, J, et) {
        Eb(et),
        k = oe(k, "onChange"),
        0 < k.length && (J = new td("onChange","change",null,J,et),
        _.push({
            event: J,
            listeners: k
        }))
    }
    var pe = null
      , qe = null;
    function re$1(_) {
        se(_, 0)
    }
    function te(_) {
        var k = ue(_);
        if (Wa(k))
            return _
    }
    function ve(_, k) {
        if (_ === "change")
            return k
    }
    var we = !1;
    if (ia) {
        var xe;
        if (ia) {
            var ye = "oninput"in document;
            if (!ye) {
                var ze = document.createElement("div");
                ze.setAttribute("oninput", "return;"),
                ye = typeof ze.oninput == "function"
            }
            xe = ye
        } else
            xe = !1;
        we = xe && (!document.documentMode || 9 < document.documentMode)
    }
    function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be),
        qe = pe = null)
    }
    function Be(_) {
        if (_.propertyName === "value" && te(qe)) {
            var k = [];
            ne(k, qe, _, xb(_)),
            Jb(re$1, k)
        }
    }
    function Ce(_, k, J) {
        _ === "focusin" ? (Ae(),
        pe = k,
        qe = J,
        pe.attachEvent("onpropertychange", Be)) : _ === "focusout" && Ae()
    }
    function De(_) {
        if (_ === "selectionchange" || _ === "keyup" || _ === "keydown")
            return te(qe)
    }
    function Ee(_, k) {
        if (_ === "click")
            return te(k)
    }
    function Fe(_, k) {
        if (_ === "input" || _ === "change")
            return te(k)
    }
    function Ge(_, k) {
        return _ === k && (_ !== 0 || 1 / _ === 1 / k) || _ !== _ && k !== k
    }
    var He = typeof Object.is == "function" ? Object.is : Ge;
    function Ie(_, k) {
        if (He(_, k))
            return !0;
        if (typeof _ != "object" || _ === null || typeof k != "object" || k === null)
            return !1;
        var J = Object.keys(_)
          , et = Object.keys(k);
        if (J.length !== et.length)
            return !1;
        for (et = 0; et < J.length; et++) {
            var tt = J[et];
            if (!ja.call(k, tt) || !He(_[tt], k[tt]))
                return !1
        }
        return !0
    }
    function Je(_) {
        for (; _ && _.firstChild; )
            _ = _.firstChild;
        return _
    }
    function Ke(_, k) {
        var J = Je(_);
        _ = 0;
        for (var et; J; ) {
            if (J.nodeType === 3) {
                if (et = _ + J.textContent.length,
                _ <= k && et >= k)
                    return {
                        node: J,
                        offset: k - _
                    };
                _ = et
            }
            e: {
                for (; J; ) {
                    if (J.nextSibling) {
                        J = J.nextSibling;
                        break e
                    }
                    J = J.parentNode
                }
                J = void 0
            }
            J = Je(J)
        }
    }
    function Le(_, k) {
        return _ && k ? _ === k ? !0 : _ && _.nodeType === 3 ? !1 : k && k.nodeType === 3 ? Le(_, k.parentNode) : "contains"in _ ? _.contains(k) : _.compareDocumentPosition ? !!(_.compareDocumentPosition(k) & 16) : !1 : !1
    }
    function Me() {
        for (var _ = window, k = Xa(); k instanceof _.HTMLIFrameElement; ) {
            try {
                var J = typeof k.contentWindow.location.href == "string"
            } catch (et) {
                J = !1
            }
            if (J)
                _ = k.contentWindow;
            else
                break;
            k = Xa(_.document)
        }
        return k
    }
    function Ne(_) {
        var k = _ && _.nodeName && _.nodeName.toLowerCase();
        return k && (k === "input" && (_.type === "text" || _.type === "search" || _.type === "tel" || _.type === "url" || _.type === "password") || k === "textarea" || _.contentEditable === "true")
    }
    function Oe$1(_) {
        var k = Me()
          , J = _.focusedElem
          , et = _.selectionRange;
        if (k !== J && J && J.ownerDocument && Le(J.ownerDocument.documentElement, J)) {
            if (et !== null && Ne(J)) {
                if (k = et.start,
                _ = et.end,
                _ === void 0 && (_ = k),
                "selectionStart"in J)
                    J.selectionStart = k,
                    J.selectionEnd = Math.min(_, J.value.length);
                else if (_ = (k = J.ownerDocument || document) && k.defaultView || window,
                _.getSelection) {
                    _ = _.getSelection();
                    var tt = J.textContent.length
                      , rt = Math.min(et.start, tt);
                    et = et.end === void 0 ? rt : Math.min(et.end, tt),
                    !_.extend && rt > et && (tt = et,
                    et = rt,
                    rt = tt),
                    tt = Ke(J, rt);
                    var nt = Ke(J, et);
                    tt && nt && (_.rangeCount !== 1 || _.anchorNode !== tt.node || _.anchorOffset !== tt.offset || _.focusNode !== nt.node || _.focusOffset !== nt.offset) && (k = k.createRange(),
                    k.setStart(tt.node, tt.offset),
                    _.removeAllRanges(),
                    rt > et ? (_.addRange(k),
                    _.extend(nt.node, nt.offset)) : (k.setEnd(nt.node, nt.offset),
                    _.addRange(k)))
                }
            }
            for (k = [],
            _ = J; _ = _.parentNode; )
                _.nodeType === 1 && k.push({
                    element: _,
                    left: _.scrollLeft,
                    top: _.scrollTop
                });
            for (typeof J.focus == "function" && J.focus(),
            J = 0; J < k.length; J++)
                _ = k[J],
                _.element.scrollLeft = _.left,
                _.element.scrollTop = _.top
        }
    }
    var Pe = ia && "documentMode"in document && 11 >= document.documentMode
      , Qe = null
      , Re = null
      , Se = null
      , Te = !1;
    function Ue(_, k, J) {
        var et = J.window === J ? J.document : J.nodeType === 9 ? J : J.ownerDocument;
        Te || Qe == null || Qe !== Xa(et) || (et = Qe,
        "selectionStart"in et && Ne(et) ? et = {
            start: et.selectionStart,
            end: et.selectionEnd
        } : (et = (et.ownerDocument && et.ownerDocument.defaultView || window).getSelection(),
        et = {
            anchorNode: et.anchorNode,
            anchorOffset: et.anchorOffset,
            focusNode: et.focusNode,
            focusOffset: et.focusOffset
        }),
        Se && Ie(Se, et) || (Se = et,
        et = oe(Re, "onSelect"),
        0 < et.length && (k = new td("onSelect","select",null,k,J),
        _.push({
            event: k,
            listeners: et
        }),
        k.target = Qe)))
    }
    function Ve(_, k) {
        var J = {};
        return J[_.toLowerCase()] = k.toLowerCase(),
        J["Webkit" + _] = "webkit" + k,
        J["Moz" + _] = "moz" + k,
        J
    }
    var We = {
        animationend: Ve("Animation", "AnimationEnd"),
        animationiteration: Ve("Animation", "AnimationIteration"),
        animationstart: Ve("Animation", "AnimationStart"),
        transitionend: Ve("Transition", "TransitionEnd")
    }
      , Xe = {}
      , Ye = {};
    ia && (Ye = document.createElement("div").style,
    "AnimationEvent"in window || (delete We.animationend.animation,
    delete We.animationiteration.animation,
    delete We.animationstart.animation),
    "TransitionEvent"in window || delete We.transitionend.transition);
    function Ze(_) {
        if (Xe[_])
            return Xe[_];
        if (!We[_])
            return _;
        var k = We[_], J;
        for (J in k)
            if (k.hasOwnProperty(J) && J in Ye)
                return Xe[_] = k[J];
        return _
    }
    var $e = Ze("animationend")
      , af = Ze("animationiteration")
      , bf = Ze("animationstart")
      , cf = Ze("transitionend")
      , df = new Map
      , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(_, k) {
        df.set(_, k),
        fa(k, [_])
    }
    for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf]
          , jf = hf.toLowerCase()
          , kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf)
    }
    ff($e, "onAnimationEnd"),
    ff(af, "onAnimationIteration"),
    ff(bf, "onAnimationStart"),
    ff("dblclick", "onDoubleClick"),
    ff("focusin", "onFocus"),
    ff("focusout", "onBlur"),
    ff(cf, "onTransitionEnd"),
    ha("onMouseEnter", ["mouseout", "mouseover"]),
    ha("onMouseLeave", ["mouseout", "mouseover"]),
    ha("onPointerEnter", ["pointerout", "pointerover"]),
    ha("onPointerLeave", ["pointerout", "pointerover"]),
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(_, k, J) {
        var et = _.type || "unknown-event";
        _.currentTarget = J,
        Ub(et, k, void 0, _),
        _.currentTarget = null
    }
    function se(_, k) {
        k = (k & 4) !== 0;
        for (var J = 0; J < _.length; J++) {
            var et = _[J]
              , tt = et.event;
            et = et.listeners;
            e: {
                var rt = void 0;
                if (k)
                    for (var nt = et.length - 1; 0 <= nt; nt--) {
                        var ot = et[nt]
                          , it = ot.instance
                          , at = ot.currentTarget;
                        if (ot = ot.listener,
                        it !== rt && tt.isPropagationStopped())
                            break e;
                        nf(tt, ot, at),
                        rt = it
                    }
                else
                    for (nt = 0; nt < et.length; nt++) {
                        if (ot = et[nt],
                        it = ot.instance,
                        at = ot.currentTarget,
                        ot = ot.listener,
                        it !== rt && tt.isPropagationStopped())
                            break e;
                        nf(tt, ot, at),
                        rt = it
                    }
            }
        }
        if (Qb)
            throw _ = Rb,
            Qb = !1,
            Rb = null,
            _
    }
    function D$1(_, k) {
        var J = k[of];
        J === void 0 && (J = k[of] = new Set);
        var et = _ + "__bubble";
        J.has(et) || (pf(k, _, 2, !1),
        J.add(et))
    }
    function qf(_, k, J) {
        var et = 0;
        k && (et |= 4),
        pf(J, _, et, k)
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(_) {
        if (!_[rf]) {
            _[rf] = !0,
            da.forEach(function(J) {
                J !== "selectionchange" && (mf.has(J) || qf(J, !1, _),
                qf(J, !0, _))
            });
            var k = _.nodeType === 9 ? _ : _.ownerDocument;
            k === null || k[rf] || (k[rf] = !0,
            qf("selectionchange", !1, k))
        }
    }
    function pf(_, k, J, et) {
        switch (jd(k)) {
        case 1:
            var tt = ed;
            break;
        case 4:
            tt = gd;
            break;
        default:
            tt = fd
        }
        J = tt.bind(null, k, J, _),
        tt = void 0,
        !Lb || k !== "touchstart" && k !== "touchmove" && k !== "wheel" || (tt = !0),
        et ? tt !== void 0 ? _.addEventListener(k, J, {
            capture: !0,
            passive: tt
        }) : _.addEventListener(k, J, !0) : tt !== void 0 ? _.addEventListener(k, J, {
            passive: tt
        }) : _.addEventListener(k, J, !1)
    }
    function hd(_, k, J, et, tt) {
        var rt = et;
        if (!(k & 1) && !(k & 2) && et !== null)
            e: for (; ; ) {
                if (et === null)
                    return;
                var nt = et.tag;
                if (nt === 3 || nt === 4) {
                    var ot = et.stateNode.containerInfo;
                    if (ot === tt || ot.nodeType === 8 && ot.parentNode === tt)
                        break;
                    if (nt === 4)
                        for (nt = et.return; nt !== null; ) {
                            var it = nt.tag;
                            if ((it === 3 || it === 4) && (it = nt.stateNode.containerInfo,
                            it === tt || it.nodeType === 8 && it.parentNode === tt))
                                return;
                            nt = nt.return
                        }
                    for (; ot !== null; ) {
                        if (nt = Wc(ot),
                        nt === null)
                            return;
                        if (it = nt.tag,
                        it === 5 || it === 6) {
                            et = rt = nt;
                            continue e
                        }
                        ot = ot.parentNode
                    }
                }
                et = et.return
            }
        Jb(function() {
            var at = rt
              , lt = xb(J)
              , st = [];
            e: {
                var ut = df.get(_);
                if (ut !== void 0) {
                    var ct = td
                      , pt = _;
                    switch (_) {
                    case "keypress":
                        if (od(J) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        ct = Rd;
                        break;
                    case "focusin":
                        pt = "focus",
                        ct = Fd;
                        break;
                    case "focusout":
                        pt = "blur",
                        ct = Fd;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        ct = Fd;
                        break;
                    case "click":
                        if (J.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        ct = Bd;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        ct = Dd;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        ct = Vd;
                        break;
                    case $e:
                    case af:
                    case bf:
                        ct = Hd;
                        break;
                    case cf:
                        ct = Xd;
                        break;
                    case "scroll":
                        ct = vd;
                        break;
                    case "wheel":
                        ct = Zd;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        ct = Jd;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        ct = Td
                    }
                    var ft = (k & 4) !== 0
                      , yt = !ft && _ === "scroll"
                      , ht = ft ? ut !== null ? ut + "Capture" : null : ut;
                    ft = [];
                    for (var gt = at, mt; gt !== null; ) {
                        mt = gt;
                        var vt = mt.stateNode;
                        if (mt.tag === 5 && vt !== null && (mt = vt,
                        ht !== null && (vt = Kb(gt, ht),
                        vt != null && ft.push(tf(gt, vt, mt)))),
                        yt)
                            break;
                        gt = gt.return
                    }
                    0 < ft.length && (ut = new ct(ut,pt,null,J,lt),
                    st.push({
                        event: ut,
                        listeners: ft
                    }))
                }
            }
            if (!(k & 7)) {
                e: {
                    if (ut = _ === "mouseover" || _ === "pointerover",
                    ct = _ === "mouseout" || _ === "pointerout",
                    ut && J !== wb && (pt = J.relatedTarget || J.fromElement) && (Wc(pt) || pt[uf]))
                        break e;
                    if ((ct || ut) && (ut = lt.window === lt ? lt : (ut = lt.ownerDocument) ? ut.defaultView || ut.parentWindow : window,
                    ct ? (pt = J.relatedTarget || J.toElement,
                    ct = at,
                    pt = pt ? Wc(pt) : null,
                    pt !== null && (yt = Vb(pt),
                    pt !== yt || pt.tag !== 5 && pt.tag !== 6) && (pt = null)) : (ct = null,
                    pt = at),
                    ct !== pt)) {
                        if (ft = Bd,
                        vt = "onMouseLeave",
                        ht = "onMouseEnter",
                        gt = "mouse",
                        (_ === "pointerout" || _ === "pointerover") && (ft = Td,
                        vt = "onPointerLeave",
                        ht = "onPointerEnter",
                        gt = "pointer"),
                        yt = ct == null ? ut : ue(ct),
                        mt = pt == null ? ut : ue(pt),
                        ut = new ft(vt,gt + "leave",ct,J,lt),
                        ut.target = yt,
                        ut.relatedTarget = mt,
                        vt = null,
                        Wc(lt) === at && (ft = new ft(ht,gt + "enter",pt,J,lt),
                        ft.target = mt,
                        ft.relatedTarget = yt,
                        vt = ft),
                        yt = vt,
                        ct && pt)
                            t: {
                                for (ft = ct,
                                ht = pt,
                                gt = 0,
                                mt = ft; mt; mt = vf(mt))
                                    gt++;
                                for (mt = 0,
                                vt = ht; vt; vt = vf(vt))
                                    mt++;
                                for (; 0 < gt - mt; )
                                    ft = vf(ft),
                                    gt--;
                                for (; 0 < mt - gt; )
                                    ht = vf(ht),
                                    mt--;
                                for (; gt--; ) {
                                    if (ft === ht || ht !== null && ft === ht.alternate)
                                        break t;
                                    ft = vf(ft),
                                    ht = vf(ht)
                                }
                                ft = null
                            }
                        else
                            ft = null;
                        ct !== null && wf(st, ut, ct, ft, !1),
                        pt !== null && yt !== null && wf(st, yt, pt, ft, !0)
                    }
                }
                e: {
                    if (ut = at ? ue(at) : window,
                    ct = ut.nodeName && ut.nodeName.toLowerCase(),
                    ct === "select" || ct === "input" && ut.type === "file")
                        var bt = ve;
                    else if (me(ut))
                        if (we)
                            bt = Fe;
                        else {
                            bt = De;
                            var Et = Ce
                        }
                    else
                        (ct = ut.nodeName) && ct.toLowerCase() === "input" && (ut.type === "checkbox" || ut.type === "radio") && (bt = Ee);
                    if (bt && (bt = bt(_, at))) {
                        ne(st, bt, J, lt);
                        break e
                    }
                    Et && Et(_, ut, at),
                    _ === "focusout" && (Et = ut._wrapperState) && Et.controlled && ut.type === "number" && cb(ut, "number", ut.value)
                }
                switch (Et = at ? ue(at) : window,
                _) {
                case "focusin":
                    (me(Et) || Et.contentEditable === "true") && (Qe = Et,
                    Re = at,
                    Se = null);
                    break;
                case "focusout":
                    Se = Re = Qe = null;
                    break;
                case "mousedown":
                    Te = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Te = !1,
                    Ue(st, J, lt);
                    break;
                case "selectionchange":
                    if (Pe)
                        break;
                case "keydown":
                case "keyup":
                    Ue(st, J, lt)
                }
                var xt;
                if (ae)
                    e: {
                        switch (_) {
                        case "compositionstart":
                            var wt = "onCompositionStart";
                            break e;
                        case "compositionend":
                            wt = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            wt = "onCompositionUpdate";
                            break e
                        }
                        wt = void 0
                    }
                else
                    ie ? ge(_, J) && (wt = "onCompositionEnd") : _ === "keydown" && J.keyCode === 229 && (wt = "onCompositionStart");
                wt && (de && J.locale !== "ko" && (ie || wt !== "onCompositionStart" ? wt === "onCompositionEnd" && ie && (xt = nd()) : (kd = lt,
                ld = "value"in kd ? kd.value : kd.textContent,
                ie = !0)),
                Et = oe(at, wt),
                0 < Et.length && (wt = new Ld(wt,_,null,J,lt),
                st.push({
                    event: wt,
                    listeners: Et
                }),
                xt ? wt.data = xt : (xt = he(J),
                xt !== null && (wt.data = xt)))),
                (xt = ce ? je(_, J) : ke(_, J)) && (at = oe(at, "onBeforeInput"),
                0 < at.length && (lt = new Ld("onBeforeInput","beforeinput",null,J,lt),
                st.push({
                    event: lt,
                    listeners: at
                }),
                lt.data = xt))
            }
            se(st, k)
        })
    }
    function tf(_, k, J) {
        return {
            instance: _,
            listener: k,
            currentTarget: J
        }
    }
    function oe(_, k) {
        for (var J = k + "Capture", et = []; _ !== null; ) {
            var tt = _
              , rt = tt.stateNode;
            tt.tag === 5 && rt !== null && (tt = rt,
            rt = Kb(_, J),
            rt != null && et.unshift(tf(_, rt, tt)),
            rt = Kb(_, k),
            rt != null && et.push(tf(_, rt, tt))),
            _ = _.return
        }
        return et
    }
    function vf(_) {
        if (_ === null)
            return null;
        do
            _ = _.return;
        while (_ && _.tag !== 5);
        return _ || null
    }
    function wf(_, k, J, et, tt) {
        for (var rt = k._reactName, nt = []; J !== null && J !== et; ) {
            var ot = J
              , it = ot.alternate
              , at = ot.stateNode;
            if (it !== null && it === et)
                break;
            ot.tag === 5 && at !== null && (ot = at,
            tt ? (it = Kb(J, rt),
            it != null && nt.unshift(tf(J, it, ot))) : tt || (it = Kb(J, rt),
            it != null && nt.push(tf(J, it, ot)))),
            J = J.return
        }
        nt.length !== 0 && _.push({
            event: k,
            listeners: nt
        })
    }
    var xf = /\r\n?/g
      , yf = /\u0000|\uFFFD/g;
    function zf(_) {
        return (typeof _ == "string" ? _ : "" + _).replace(xf, `
`).replace(yf, "")
    }
    function Af(_, k, J) {
        if (k = zf(k),
        zf(_) !== k && J)
            throw Error(p$2(425))
    }
    function Bf() {}
    var Cf = null
      , Df = null;
    function Ef(_, k) {
        return _ === "textarea" || _ === "noscript" || typeof k.children == "string" || typeof k.children == "number" || typeof k.dangerouslySetInnerHTML == "object" && k.dangerouslySetInnerHTML !== null && k.dangerouslySetInnerHTML.__html != null
    }
    var Ff = typeof setTimeout == "function" ? setTimeout : void 0
      , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Hf = typeof Promise == "function" ? Promise : void 0
      , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(_) {
        return Hf.resolve(null).then(_).catch(If)
    }
    : Ff;
    function If(_) {
        setTimeout(function() {
            throw _
        })
    }
    function Kf(_, k) {
        var J = k
          , et = 0;
        do {
            var tt = J.nextSibling;
            if (_.removeChild(J),
            tt && tt.nodeType === 8)
                if (J = tt.data,
                J === "/$") {
                    if (et === 0) {
                        _.removeChild(tt),
                        bd(k);
                        return
                    }
                    et--
                } else
                    J !== "$" && J !== "$?" && J !== "$!" || et++;
            J = tt
        } while (J);
        bd(k)
    }
    function Lf(_) {
        for (; _ != null; _ = _.nextSibling) {
            var k = _.nodeType;
            if (k === 1 || k === 3)
                break;
            if (k === 8) {
                if (k = _.data,
                k === "$" || k === "$!" || k === "$?")
                    break;
                if (k === "/$")
                    return null
            }
        }
        return _
    }
    function Mf(_) {
        _ = _.previousSibling;
        for (var k = 0; _; ) {
            if (_.nodeType === 8) {
                var J = _.data;
                if (J === "$" || J === "$!" || J === "$?") {
                    if (k === 0)
                        return _;
                    k--
                } else
                    J === "/$" && k++
            }
            _ = _.previousSibling
        }
        return null
    }
    var Nf = Math.random().toString(36).slice(2)
      , Of = "__reactFiber$" + Nf
      , Pf = "__reactProps$" + Nf
      , uf = "__reactContainer$" + Nf
      , of = "__reactEvents$" + Nf
      , Qf = "__reactListeners$" + Nf
      , Rf = "__reactHandles$" + Nf;
    function Wc(_) {
        var k = _[Of];
        if (k)
            return k;
        for (var J = _.parentNode; J; ) {
            if (k = J[uf] || J[Of]) {
                if (J = k.alternate,
                k.child !== null || J !== null && J.child !== null)
                    for (_ = Mf(_); _ !== null; ) {
                        if (J = _[Of])
                            return J;
                        _ = Mf(_)
                    }
                return k
            }
            _ = J,
            J = _.parentNode
        }
        return null
    }
    function Cb(_) {
        return _ = _[Of] || _[uf],
        !_ || _.tag !== 5 && _.tag !== 6 && _.tag !== 13 && _.tag !== 3 ? null : _
    }
    function ue(_) {
        if (_.tag === 5 || _.tag === 6)
            return _.stateNode;
        throw Error(p$2(33))
    }
    function Db(_) {
        return _[Pf] || null
    }
    var Sf = []
      , Tf = -1;
    function Uf(_) {
        return {
            current: _
        }
    }
    function E$1(_) {
        0 > Tf || (_.current = Sf[Tf],
        Sf[Tf] = null,
        Tf--)
    }
    function G(_, k) {
        Tf++,
        Sf[Tf] = _.current,
        _.current = k
    }
    var Vf = {}
      , H = Uf(Vf)
      , Wf = Uf(!1)
      , Xf = Vf;
    function Yf(_, k) {
        var J = _.type.contextTypes;
        if (!J)
            return Vf;
        var et = _.stateNode;
        if (et && et.__reactInternalMemoizedUnmaskedChildContext === k)
            return et.__reactInternalMemoizedMaskedChildContext;
        var tt = {}, rt;
        for (rt in J)
            tt[rt] = k[rt];
        return et && (_ = _.stateNode,
        _.__reactInternalMemoizedUnmaskedChildContext = k,
        _.__reactInternalMemoizedMaskedChildContext = tt),
        tt
    }
    function Zf(_) {
        return _ = _.childContextTypes,
        _ != null
    }
    function $f() {
        E$1(Wf),
        E$1(H)
    }
    function ag(_, k, J) {
        if (H.current !== Vf)
            throw Error(p$2(168));
        G(H, k),
        G(Wf, J)
    }
    function bg(_, k, J) {
        var et = _.stateNode;
        if (k = k.childContextTypes,
        typeof et.getChildContext != "function")
            return J;
        et = et.getChildContext();
        for (var tt in et)
            if (!(tt in k))
                throw Error(p$2(108, Ra(_) || "Unknown", tt));
        return A({}, J, et)
    }
    function cg(_) {
        return _ = (_ = _.stateNode) && _.__reactInternalMemoizedMergedChildContext || Vf,
        Xf = H.current,
        G(H, _),
        G(Wf, Wf.current),
        !0
    }
    function dg(_, k, J) {
        var et = _.stateNode;
        if (!et)
            throw Error(p$2(169));
        J ? (_ = bg(_, k, Xf),
        et.__reactInternalMemoizedMergedChildContext = _,
        E$1(Wf),
        E$1(H),
        G(H, _)) : E$1(Wf),
        G(Wf, J)
    }
    var eg = null
      , fg = !1
      , gg = !1;
    function hg(_) {
        eg === null ? eg = [_] : eg.push(_)
    }
    function ig(_) {
        fg = !0,
        hg(_)
    }
    function jg() {
        if (!gg && eg !== null) {
            gg = !0;
            var _ = 0
              , k = C$1;
            try {
                var J = eg;
                for (C$1 = 1; _ < J.length; _++) {
                    var et = J[_];
                    do
                        et = et(!0);
                    while (et !== null)
                }
                eg = null,
                fg = !1
            } catch (tt) {
                throw eg !== null && (eg = eg.slice(_ + 1)),
                ac(fc, jg),
                tt
            } finally {
                C$1 = k,
                gg = !1
            }
        }
        return null
    }
    var kg = []
      , lg = 0
      , mg = null
      , ng = 0
      , og = []
      , pg = 0
      , qg = null
      , rg = 1
      , sg = "";
    function tg(_, k) {
        kg[lg++] = ng,
        kg[lg++] = mg,
        mg = _,
        ng = k
    }
    function ug(_, k, J) {
        og[pg++] = rg,
        og[pg++] = sg,
        og[pg++] = qg,
        qg = _;
        var et = rg;
        _ = sg;
        var tt = 32 - oc(et) - 1;
        et &= ~(1 << tt),
        J += 1;
        var rt = 32 - oc(k) + tt;
        if (30 < rt) {
            var nt = tt - tt % 5;
            rt = (et & (1 << nt) - 1).toString(32),
            et >>= nt,
            tt -= nt,
            rg = 1 << 32 - oc(k) + tt | J << tt | et,
            sg = rt + _
        } else
            rg = 1 << rt | J << tt | et,
            sg = _
    }
    function vg(_) {
        _.return !== null && (tg(_, 1),
        ug(_, 1, 0))
    }
    function wg(_) {
        for (; _ === mg; )
            mg = kg[--lg],
            kg[lg] = null,
            ng = kg[--lg],
            kg[lg] = null;
        for (; _ === qg; )
            qg = og[--pg],
            og[pg] = null,
            sg = og[--pg],
            og[pg] = null,
            rg = og[--pg],
            og[pg] = null
    }
    var xg = null
      , yg = null
      , I = !1
      , zg = null;
    function Ag(_, k) {
        var J = Bg(5, null, null, 0);
        J.elementType = "DELETED",
        J.stateNode = k,
        J.return = _,
        k = _.deletions,
        k === null ? (_.deletions = [J],
        _.flags |= 16) : k.push(J)
    }
    function Cg(_, k) {
        switch (_.tag) {
        case 5:
            var J = _.type;
            return k = k.nodeType !== 1 || J.toLowerCase() !== k.nodeName.toLowerCase() ? null : k,
            k !== null ? (_.stateNode = k,
            xg = _,
            yg = Lf(k.firstChild),
            !0) : !1;
        case 6:
            return k = _.pendingProps === "" || k.nodeType !== 3 ? null : k,
            k !== null ? (_.stateNode = k,
            xg = _,
            yg = null,
            !0) : !1;
        case 13:
            return k = k.nodeType !== 8 ? null : k,
            k !== null ? (J = qg !== null ? {
                id: rg,
                overflow: sg
            } : null,
            _.memoizedState = {
                dehydrated: k,
                treeContext: J,
                retryLane: 1073741824
            },
            J = Bg(18, null, null, 0),
            J.stateNode = k,
            J.return = _,
            _.child = J,
            xg = _,
            yg = null,
            !0) : !1;
        default:
            return !1
        }
    }
    function Dg(_) {
        return (_.mode & 1) !== 0 && (_.flags & 128) === 0
    }
    function Eg(_) {
        if (I) {
            var k = yg;
            if (k) {
                var J = k;
                if (!Cg(_, k)) {
                    if (Dg(_))
                        throw Error(p$2(418));
                    k = Lf(J.nextSibling);
                    var et = xg;
                    k && Cg(_, k) ? Ag(et, J) : (_.flags = _.flags & -4097 | 2,
                    I = !1,
                    xg = _)
                }
            } else {
                if (Dg(_))
                    throw Error(p$2(418));
                _.flags = _.flags & -4097 | 2,
                I = !1,
                xg = _
            }
        }
    }
    function Fg(_) {
        for (_ = _.return; _ !== null && _.tag !== 5 && _.tag !== 3 && _.tag !== 13; )
            _ = _.return;
        xg = _
    }
    function Gg(_) {
        if (_ !== xg)
            return !1;
        if (!I)
            return Fg(_),
            I = !0,
            !1;
        var k;
        if ((k = _.tag !== 3) && !(k = _.tag !== 5) && (k = _.type,
        k = k !== "head" && k !== "body" && !Ef(_.type, _.memoizedProps)),
        k && (k = yg)) {
            if (Dg(_))
                throw Hg(),
                Error(p$2(418));
            for (; k; )
                Ag(_, k),
                k = Lf(k.nextSibling)
        }
        if (Fg(_),
        _.tag === 13) {
            if (_ = _.memoizedState,
            _ = _ !== null ? _.dehydrated : null,
            !_)
                throw Error(p$2(317));
            e: {
                for (_ = _.nextSibling,
                k = 0; _; ) {
                    if (_.nodeType === 8) {
                        var J = _.data;
                        if (J === "/$") {
                            if (k === 0) {
                                yg = Lf(_.nextSibling);
                                break e
                            }
                            k--
                        } else
                            J !== "$" && J !== "$!" && J !== "$?" || k++
                    }
                    _ = _.nextSibling
                }
                yg = null
            }
        } else
            yg = xg ? Lf(_.stateNode.nextSibling) : null;
        return !0
    }
    function Hg() {
        for (var _ = yg; _; )
            _ = Lf(_.nextSibling)
    }
    function Ig() {
        yg = xg = null,
        I = !1
    }
    function Jg(_) {
        zg === null ? zg = [_] : zg.push(_)
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(_, k) {
        if (_ && _.defaultProps) {
            k = A({}, k),
            _ = _.defaultProps;
            for (var J in _)
                k[J] === void 0 && (k[J] = _[J]);
            return k
        }
        return k
    }
    var Mg = Uf(null)
      , Ng = null
      , Og = null
      , Pg = null;
    function Qg() {
        Pg = Og = Ng = null
    }
    function Rg(_) {
        var k = Mg.current;
        E$1(Mg),
        _._currentValue = k
    }
    function Sg(_, k, J) {
        for (; _ !== null; ) {
            var et = _.alternate;
            if ((_.childLanes & k) !== k ? (_.childLanes |= k,
            et !== null && (et.childLanes |= k)) : et !== null && (et.childLanes & k) !== k && (et.childLanes |= k),
            _ === J)
                break;
            _ = _.return
        }
    }
    function Tg(_, k) {
        Ng = _,
        Pg = Og = null,
        _ = _.dependencies,
        _ !== null && _.firstContext !== null && (_.lanes & k && (Ug = !0),
        _.firstContext = null)
    }
    function Vg(_) {
        var k = _._currentValue;
        if (Pg !== _)
            if (_ = {
                context: _,
                memoizedValue: k,
                next: null
            },
            Og === null) {
                if (Ng === null)
                    throw Error(p$2(308));
                Og = _,
                Ng.dependencies = {
                    lanes: 0,
                    firstContext: _
                }
            } else
                Og = Og.next = _;
        return k
    }
    var Wg = null;
    function Xg(_) {
        Wg === null ? Wg = [_] : Wg.push(_)
    }
    function Yg(_, k, J, et) {
        var tt = k.interleaved;
        return tt === null ? (J.next = J,
        Xg(k)) : (J.next = tt.next,
        tt.next = J),
        k.interleaved = J,
        Zg(_, et)
    }
    function Zg(_, k) {
        _.lanes |= k;
        var J = _.alternate;
        for (J !== null && (J.lanes |= k),
        J = _,
        _ = _.return; _ !== null; )
            _.childLanes |= k,
            J = _.alternate,
            J !== null && (J.childLanes |= k),
            J = _,
            _ = _.return;
        return J.tag === 3 ? J.stateNode : null
    }
    var $g = !1;
    function ah(_) {
        _.updateQueue = {
            baseState: _.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }
    function bh(_, k) {
        _ = _.updateQueue,
        k.updateQueue === _ && (k.updateQueue = {
            baseState: _.baseState,
            firstBaseUpdate: _.firstBaseUpdate,
            lastBaseUpdate: _.lastBaseUpdate,
            shared: _.shared,
            effects: _.effects
        })
    }
    function ch(_, k) {
        return {
            eventTime: _,
            lane: k,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function dh(_, k, J) {
        var et = _.updateQueue;
        if (et === null)
            return null;
        if (et = et.shared,
        K & 2) {
            var tt = et.pending;
            return tt === null ? k.next = k : (k.next = tt.next,
            tt.next = k),
            et.pending = k,
            Zg(_, J)
        }
        return tt = et.interleaved,
        tt === null ? (k.next = k,
        Xg(et)) : (k.next = tt.next,
        tt.next = k),
        et.interleaved = k,
        Zg(_, J)
    }
    function eh(_, k, J) {
        if (k = k.updateQueue,
        k !== null && (k = k.shared,
        (J & 4194240) !== 0)) {
            var et = k.lanes;
            et &= _.pendingLanes,
            J |= et,
            k.lanes = J,
            Cc(_, J)
        }
    }
    function fh(_, k) {
        var J = _.updateQueue
          , et = _.alternate;
        if (et !== null && (et = et.updateQueue,
        J === et)) {
            var tt = null
              , rt = null;
            if (J = J.firstBaseUpdate,
            J !== null) {
                do {
                    var nt = {
                        eventTime: J.eventTime,
                        lane: J.lane,
                        tag: J.tag,
                        payload: J.payload,
                        callback: J.callback,
                        next: null
                    };
                    rt === null ? tt = rt = nt : rt = rt.next = nt,
                    J = J.next
                } while (J !== null);
                rt === null ? tt = rt = k : rt = rt.next = k
            } else
                tt = rt = k;
            J = {
                baseState: et.baseState,
                firstBaseUpdate: tt,
                lastBaseUpdate: rt,
                shared: et.shared,
                effects: et.effects
            },
            _.updateQueue = J;
            return
        }
        _ = J.lastBaseUpdate,
        _ === null ? J.firstBaseUpdate = k : _.next = k,
        J.lastBaseUpdate = k
    }
    function gh(_, k, J, et) {
        var tt = _.updateQueue;
        $g = !1;
        var rt = tt.firstBaseUpdate
          , nt = tt.lastBaseUpdate
          , ot = tt.shared.pending;
        if (ot !== null) {
            tt.shared.pending = null;
            var it = ot
              , at = it.next;
            it.next = null,
            nt === null ? rt = at : nt.next = at,
            nt = it;
            var lt = _.alternate;
            lt !== null && (lt = lt.updateQueue,
            ot = lt.lastBaseUpdate,
            ot !== nt && (ot === null ? lt.firstBaseUpdate = at : ot.next = at,
            lt.lastBaseUpdate = it))
        }
        if (rt !== null) {
            var st = tt.baseState;
            nt = 0,
            lt = at = it = null,
            ot = rt;
            do {
                var ut = ot.lane
                  , ct = ot.eventTime;
                if ((et & ut) === ut) {
                    lt !== null && (lt = lt.next = {
                        eventTime: ct,
                        lane: 0,
                        tag: ot.tag,
                        payload: ot.payload,
                        callback: ot.callback,
                        next: null
                    });
                    e: {
                        var pt = _
                          , ft = ot;
                        switch (ut = k,
                        ct = J,
                        ft.tag) {
                        case 1:
                            if (pt = ft.payload,
                            typeof pt == "function") {
                                st = pt.call(ct, st, ut);
                                break e
                            }
                            st = pt;
                            break e;
                        case 3:
                            pt.flags = pt.flags & -65537 | 128;
                        case 0:
                            if (pt = ft.payload,
                            ut = typeof pt == "function" ? pt.call(ct, st, ut) : pt,
                            ut == null)
                                break e;
                            st = A({}, st, ut);
                            break e;
                        case 2:
                            $g = !0
                        }
                    }
                    ot.callback !== null && ot.lane !== 0 && (_.flags |= 64,
                    ut = tt.effects,
                    ut === null ? tt.effects = [ot] : ut.push(ot))
                } else
                    ct = {
                        eventTime: ct,
                        lane: ut,
                        tag: ot.tag,
                        payload: ot.payload,
                        callback: ot.callback,
                        next: null
                    },
                    lt === null ? (at = lt = ct,
                    it = st) : lt = lt.next = ct,
                    nt |= ut;
                if (ot = ot.next,
                ot === null) {
                    if (ot = tt.shared.pending,
                    ot === null)
                        break;
                    ut = ot,
                    ot = ut.next,
                    ut.next = null,
                    tt.lastBaseUpdate = ut,
                    tt.shared.pending = null
                }
            } while (1);
            if (lt === null && (it = st),
            tt.baseState = it,
            tt.firstBaseUpdate = at,
            tt.lastBaseUpdate = lt,
            k = tt.shared.interleaved,
            k !== null) {
                tt = k;
                do
                    nt |= tt.lane,
                    tt = tt.next;
                while (tt !== k)
            } else
                rt === null && (tt.shared.lanes = 0);
            hh |= nt,
            _.lanes = nt,
            _.memoizedState = st
        }
    }
    function ih(_, k, J) {
        if (_ = k.effects,
        k.effects = null,
        _ !== null)
            for (k = 0; k < _.length; k++) {
                var et = _[k]
                  , tt = et.callback;
                if (tt !== null) {
                    if (et.callback = null,
                    et = J,
                    typeof tt != "function")
                        throw Error(p$2(191, tt));
                    tt.call(et)
                }
            }
    }
    var jh = new aa.Component().refs;
    function kh(_, k, J, et) {
        k = _.memoizedState,
        J = J(et, k),
        J = J == null ? k : A({}, k, J),
        _.memoizedState = J,
        _.lanes === 0 && (_.updateQueue.baseState = J)
    }
    var nh = {
        isMounted: function(_) {
            return (_ = _._reactInternals) ? Vb(_) === _ : !1
        },
        enqueueSetState: function(_, k, J) {
            _ = _._reactInternals;
            var et = L()
              , tt = lh(_)
              , rt = ch(et, tt);
            rt.payload = k,
            J != null && (rt.callback = J),
            k = dh(_, rt, tt),
            k !== null && (mh(k, _, tt, et),
            eh(k, _, tt))
        },
        enqueueReplaceState: function(_, k, J) {
            _ = _._reactInternals;
            var et = L()
              , tt = lh(_)
              , rt = ch(et, tt);
            rt.tag = 1,
            rt.payload = k,
            J != null && (rt.callback = J),
            k = dh(_, rt, tt),
            k !== null && (mh(k, _, tt, et),
            eh(k, _, tt))
        },
        enqueueForceUpdate: function(_, k) {
            _ = _._reactInternals;
            var J = L()
              , et = lh(_)
              , tt = ch(J, et);
            tt.tag = 2,
            k != null && (tt.callback = k),
            k = dh(_, tt, et),
            k !== null && (mh(k, _, et, J),
            eh(k, _, et))
        }
    };
    function oh(_, k, J, et, tt, rt, nt) {
        return _ = _.stateNode,
        typeof _.shouldComponentUpdate == "function" ? _.shouldComponentUpdate(et, rt, nt) : k.prototype && k.prototype.isPureReactComponent ? !Ie(J, et) || !Ie(tt, rt) : !0
    }
    function ph(_, k, J) {
        var et = !1
          , tt = Vf
          , rt = k.contextType;
        return typeof rt == "object" && rt !== null ? rt = Vg(rt) : (tt = Zf(k) ? Xf : H.current,
        et = k.contextTypes,
        rt = (et = et != null) ? Yf(_, tt) : Vf),
        k = new k(J,rt),
        _.memoizedState = k.state !== null && k.state !== void 0 ? k.state : null,
        k.updater = nh,
        _.stateNode = k,
        k._reactInternals = _,
        et && (_ = _.stateNode,
        _.__reactInternalMemoizedUnmaskedChildContext = tt,
        _.__reactInternalMemoizedMaskedChildContext = rt),
        k
    }
    function qh(_, k, J, et) {
        _ = k.state,
        typeof k.componentWillReceiveProps == "function" && k.componentWillReceiveProps(J, et),
        typeof k.UNSAFE_componentWillReceiveProps == "function" && k.UNSAFE_componentWillReceiveProps(J, et),
        k.state !== _ && nh.enqueueReplaceState(k, k.state, null)
    }
    function rh(_, k, J, et) {
        var tt = _.stateNode;
        tt.props = J,
        tt.state = _.memoizedState,
        tt.refs = jh,
        ah(_);
        var rt = k.contextType;
        typeof rt == "object" && rt !== null ? tt.context = Vg(rt) : (rt = Zf(k) ? Xf : H.current,
        tt.context = Yf(_, rt)),
        tt.state = _.memoizedState,
        rt = k.getDerivedStateFromProps,
        typeof rt == "function" && (kh(_, k, rt, J),
        tt.state = _.memoizedState),
        typeof k.getDerivedStateFromProps == "function" || typeof tt.getSnapshotBeforeUpdate == "function" || typeof tt.UNSAFE_componentWillMount != "function" && typeof tt.componentWillMount != "function" || (k = tt.state,
        typeof tt.componentWillMount == "function" && tt.componentWillMount(),
        typeof tt.UNSAFE_componentWillMount == "function" && tt.UNSAFE_componentWillMount(),
        k !== tt.state && nh.enqueueReplaceState(tt, tt.state, null),
        gh(_, J, tt, et),
        tt.state = _.memoizedState),
        typeof tt.componentDidMount == "function" && (_.flags |= 4194308)
    }
    function sh(_, k, J) {
        if (_ = J.ref,
        _ !== null && typeof _ != "function" && typeof _ != "object") {
            if (J._owner) {
                if (J = J._owner,
                J) {
                    if (J.tag !== 1)
                        throw Error(p$2(309));
                    var et = J.stateNode
                }
                if (!et)
                    throw Error(p$2(147, _));
                var tt = et
                  , rt = "" + _;
                return k !== null && k.ref !== null && typeof k.ref == "function" && k.ref._stringRef === rt ? k.ref : (k = function(nt) {
                    var ot = tt.refs;
                    ot === jh && (ot = tt.refs = {}),
                    nt === null ? delete ot[rt] : ot[rt] = nt
                }
                ,
                k._stringRef = rt,
                k)
            }
            if (typeof _ != "string")
                throw Error(p$2(284));
            if (!J._owner)
                throw Error(p$2(290, _))
        }
        return _
    }
    function th(_, k) {
        throw _ = Object.prototype.toString.call(k),
        Error(p$2(31, _ === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : _))
    }
    function uh(_) {
        var k = _._init;
        return k(_._payload)
    }
    function vh(_) {
        function k(ht, gt) {
            if (_) {
                var mt = ht.deletions;
                mt === null ? (ht.deletions = [gt],
                ht.flags |= 16) : mt.push(gt)
            }
        }
        function J(ht, gt) {
            if (!_)
                return null;
            for (; gt !== null; )
                k(ht, gt),
                gt = gt.sibling;
            return null
        }
        function et(ht, gt) {
            for (ht = new Map; gt !== null; )
                gt.key !== null ? ht.set(gt.key, gt) : ht.set(gt.index, gt),
                gt = gt.sibling;
            return ht
        }
        function tt(ht, gt) {
            return ht = wh(ht, gt),
            ht.index = 0,
            ht.sibling = null,
            ht
        }
        function rt(ht, gt, mt) {
            return ht.index = mt,
            _ ? (mt = ht.alternate,
            mt !== null ? (mt = mt.index,
            mt < gt ? (ht.flags |= 2,
            gt) : mt) : (ht.flags |= 2,
            gt)) : (ht.flags |= 1048576,
            gt)
        }
        function nt(ht) {
            return _ && ht.alternate === null && (ht.flags |= 2),
            ht
        }
        function ot(ht, gt, mt, vt) {
            return gt === null || gt.tag !== 6 ? (gt = xh(mt, ht.mode, vt),
            gt.return = ht,
            gt) : (gt = tt(gt, mt),
            gt.return = ht,
            gt)
        }
        function it(ht, gt, mt, vt) {
            var bt = mt.type;
            return bt === ya ? lt(ht, gt, mt.props.children, vt, mt.key) : gt !== null && (gt.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === Ha && uh(bt) === gt.type) ? (vt = tt(gt, mt.props),
            vt.ref = sh(ht, gt, mt),
            vt.return = ht,
            vt) : (vt = yh(mt.type, mt.key, mt.props, null, ht.mode, vt),
            vt.ref = sh(ht, gt, mt),
            vt.return = ht,
            vt)
        }
        function at(ht, gt, mt, vt) {
            return gt === null || gt.tag !== 4 || gt.stateNode.containerInfo !== mt.containerInfo || gt.stateNode.implementation !== mt.implementation ? (gt = zh(mt, ht.mode, vt),
            gt.return = ht,
            gt) : (gt = tt(gt, mt.children || []),
            gt.return = ht,
            gt)
        }
        function lt(ht, gt, mt, vt, bt) {
            return gt === null || gt.tag !== 7 ? (gt = Ah(mt, ht.mode, vt, bt),
            gt.return = ht,
            gt) : (gt = tt(gt, mt),
            gt.return = ht,
            gt)
        }
        function st(ht, gt, mt) {
            if (typeof gt == "string" && gt !== "" || typeof gt == "number")
                return gt = xh("" + gt, ht.mode, mt),
                gt.return = ht,
                gt;
            if (typeof gt == "object" && gt !== null) {
                switch (gt.$$typeof) {
                case va:
                    return mt = yh(gt.type, gt.key, gt.props, null, ht.mode, mt),
                    mt.ref = sh(ht, null, gt),
                    mt.return = ht,
                    mt;
                case wa:
                    return gt = zh(gt, ht.mode, mt),
                    gt.return = ht,
                    gt;
                case Ha:
                    var vt = gt._init;
                    return st(ht, vt(gt._payload), mt)
                }
                if (eb(gt) || Ka(gt))
                    return gt = Ah(gt, ht.mode, mt, null),
                    gt.return = ht,
                    gt;
                th(ht, gt)
            }
            return null
        }
        function ut(ht, gt, mt, vt) {
            var bt = gt !== null ? gt.key : null;
            if (typeof mt == "string" && mt !== "" || typeof mt == "number")
                return bt !== null ? null : ot(ht, gt, "" + mt, vt);
            if (typeof mt == "object" && mt !== null) {
                switch (mt.$$typeof) {
                case va:
                    return mt.key === bt ? it(ht, gt, mt, vt) : null;
                case wa:
                    return mt.key === bt ? at(ht, gt, mt, vt) : null;
                case Ha:
                    return bt = mt._init,
                    ut(ht, gt, bt(mt._payload), vt)
                }
                if (eb(mt) || Ka(mt))
                    return bt !== null ? null : lt(ht, gt, mt, vt, null);
                th(ht, mt)
            }
            return null
        }
        function ct(ht, gt, mt, vt, bt) {
            if (typeof vt == "string" && vt !== "" || typeof vt == "number")
                return ht = ht.get(mt) || null,
                ot(gt, ht, "" + vt, bt);
            if (typeof vt == "object" && vt !== null) {
                switch (vt.$$typeof) {
                case va:
                    return ht = ht.get(vt.key === null ? mt : vt.key) || null,
                    it(gt, ht, vt, bt);
                case wa:
                    return ht = ht.get(vt.key === null ? mt : vt.key) || null,
                    at(gt, ht, vt, bt);
                case Ha:
                    var Et = vt._init;
                    return ct(ht, gt, mt, Et(vt._payload), bt)
                }
                if (eb(vt) || Ka(vt))
                    return ht = ht.get(mt) || null,
                    lt(gt, ht, vt, bt, null);
                th(gt, vt)
            }
            return null
        }
        function pt(ht, gt, mt, vt) {
            for (var bt = null, Et = null, xt = gt, wt = gt = 0, St = null; xt !== null && wt < mt.length; wt++) {
                xt.index > wt ? (St = xt,
                xt = null) : St = xt.sibling;
                var Pt = ut(ht, xt, mt[wt], vt);
                if (Pt === null) {
                    xt === null && (xt = St);
                    break
                }
                _ && xt && Pt.alternate === null && k(ht, xt),
                gt = rt(Pt, gt, wt),
                Et === null ? bt = Pt : Et.sibling = Pt,
                Et = Pt,
                xt = St
            }
            if (wt === mt.length)
                return J(ht, xt),
                I && tg(ht, wt),
                bt;
            if (xt === null) {
                for (; wt < mt.length; wt++)
                    xt = st(ht, mt[wt], vt),
                    xt !== null && (gt = rt(xt, gt, wt),
                    Et === null ? bt = xt : Et.sibling = xt,
                    Et = xt);
                return I && tg(ht, wt),
                bt
            }
            for (xt = et(ht, xt); wt < mt.length; wt++)
                St = ct(xt, ht, wt, mt[wt], vt),
                St !== null && (_ && St.alternate !== null && xt.delete(St.key === null ? wt : St.key),
                gt = rt(St, gt, wt),
                Et === null ? bt = St : Et.sibling = St,
                Et = St);
            return _ && xt.forEach(function(Rt) {
                return k(ht, Rt)
            }),
            I && tg(ht, wt),
            bt
        }
        function ft(ht, gt, mt, vt) {
            var bt = Ka(mt);
            if (typeof bt != "function")
                throw Error(p$2(150));
            if (mt = bt.call(mt),
            mt == null)
                throw Error(p$2(151));
            for (var Et = bt = null, xt = gt, wt = gt = 0, St = null, Pt = mt.next(); xt !== null && !Pt.done; wt++,
            Pt = mt.next()) {
                xt.index > wt ? (St = xt,
                xt = null) : St = xt.sibling;
                var Rt = ut(ht, xt, Pt.value, vt);
                if (Rt === null) {
                    xt === null && (xt = St);
                    break
                }
                _ && xt && Rt.alternate === null && k(ht, xt),
                gt = rt(Rt, gt, wt),
                Et === null ? bt = Rt : Et.sibling = Rt,
                Et = Rt,
                xt = St
            }
            if (Pt.done)
                return J(ht, xt),
                I && tg(ht, wt),
                bt;
            if (xt === null) {
                for (; !Pt.done; wt++,
                Pt = mt.next())
                    Pt = st(ht, Pt.value, vt),
                    Pt !== null && (gt = rt(Pt, gt, wt),
                    Et === null ? bt = Pt : Et.sibling = Pt,
                    Et = Pt);
                return I && tg(ht, wt),
                bt
            }
            for (xt = et(ht, xt); !Pt.done; wt++,
            Pt = mt.next())
                Pt = ct(xt, ht, wt, Pt.value, vt),
                Pt !== null && (_ && Pt.alternate !== null && xt.delete(Pt.key === null ? wt : Pt.key),
                gt = rt(Pt, gt, wt),
                Et === null ? bt = Pt : Et.sibling = Pt,
                Et = Pt);
            return _ && xt.forEach(function(At) {
                return k(ht, At)
            }),
            I && tg(ht, wt),
            bt
        }
        function yt(ht, gt, mt, vt) {
            if (typeof mt == "object" && mt !== null && mt.type === ya && mt.key === null && (mt = mt.props.children),
            typeof mt == "object" && mt !== null) {
                switch (mt.$$typeof) {
                case va:
                    e: {
                        for (var bt = mt.key, Et = gt; Et !== null; ) {
                            if (Et.key === bt) {
                                if (bt = mt.type,
                                bt === ya) {
                                    if (Et.tag === 7) {
                                        J(ht, Et.sibling),
                                        gt = tt(Et, mt.props.children),
                                        gt.return = ht,
                                        ht = gt;
                                        break e
                                    }
                                } else if (Et.elementType === bt || typeof bt == "object" && bt !== null && bt.$$typeof === Ha && uh(bt) === Et.type) {
                                    J(ht, Et.sibling),
                                    gt = tt(Et, mt.props),
                                    gt.ref = sh(ht, Et, mt),
                                    gt.return = ht,
                                    ht = gt;
                                    break e
                                }
                                J(ht, Et);
                                break
                            } else
                                k(ht, Et);
                            Et = Et.sibling
                        }
                        mt.type === ya ? (gt = Ah(mt.props.children, ht.mode, vt, mt.key),
                        gt.return = ht,
                        ht = gt) : (vt = yh(mt.type, mt.key, mt.props, null, ht.mode, vt),
                        vt.ref = sh(ht, gt, mt),
                        vt.return = ht,
                        ht = vt)
                    }
                    return nt(ht);
                case wa:
                    e: {
                        for (Et = mt.key; gt !== null; ) {
                            if (gt.key === Et)
                                if (gt.tag === 4 && gt.stateNode.containerInfo === mt.containerInfo && gt.stateNode.implementation === mt.implementation) {
                                    J(ht, gt.sibling),
                                    gt = tt(gt, mt.children || []),
                                    gt.return = ht,
                                    ht = gt;
                                    break e
                                } else {
                                    J(ht, gt);
                                    break
                                }
                            else
                                k(ht, gt);
                            gt = gt.sibling
                        }
                        gt = zh(mt, ht.mode, vt),
                        gt.return = ht,
                        ht = gt
                    }
                    return nt(ht);
                case Ha:
                    return Et = mt._init,
                    yt(ht, gt, Et(mt._payload), vt)
                }
                if (eb(mt))
                    return pt(ht, gt, mt, vt);
                if (Ka(mt))
                    return ft(ht, gt, mt, vt);
                th(ht, mt)
            }
            return typeof mt == "string" && mt !== "" || typeof mt == "number" ? (mt = "" + mt,
            gt !== null && gt.tag === 6 ? (J(ht, gt.sibling),
            gt = tt(gt, mt),
            gt.return = ht,
            ht = gt) : (J(ht, gt),
            gt = xh(mt, ht.mode, vt),
            gt.return = ht,
            ht = gt),
            nt(ht)) : J(ht, gt)
        }
        return yt
    }
    var Bh = vh(!0)
      , Ch = vh(!1)
      , Dh = {}
      , Eh = Uf(Dh)
      , Fh = Uf(Dh)
      , Gh = Uf(Dh);
    function Hh(_) {
        if (_ === Dh)
            throw Error(p$2(174));
        return _
    }
    function Ih(_, k) {
        switch (G(Gh, k),
        G(Fh, _),
        G(Eh, Dh),
        _ = k.nodeType,
        _) {
        case 9:
        case 11:
            k = (k = k.documentElement) ? k.namespaceURI : lb(null, "");
            break;
        default:
            _ = _ === 8 ? k.parentNode : k,
            k = _.namespaceURI || null,
            _ = _.tagName,
            k = lb(k, _)
        }
        E$1(Eh),
        G(Eh, k)
    }
    function Jh() {
        E$1(Eh),
        E$1(Fh),
        E$1(Gh)
    }
    function Kh(_) {
        Hh(Gh.current);
        var k = Hh(Eh.current)
          , J = lb(k, _.type);
        k !== J && (G(Fh, _),
        G(Eh, J))
    }
    function Lh(_) {
        Fh.current === _ && (E$1(Eh),
        E$1(Fh))
    }
    var M = Uf(0);
    function Mh(_) {
        for (var k = _; k !== null; ) {
            if (k.tag === 13) {
                var J = k.memoizedState;
                if (J !== null && (J = J.dehydrated,
                J === null || J.data === "$?" || J.data === "$!"))
                    return k
            } else if (k.tag === 19 && k.memoizedProps.revealOrder !== void 0) {
                if (k.flags & 128)
                    return k
            } else if (k.child !== null) {
                k.child.return = k,
                k = k.child;
                continue
            }
            if (k === _)
                break;
            for (; k.sibling === null; ) {
                if (k.return === null || k.return === _)
                    return null;
                k = k.return
            }
            k.sibling.return = k.return,
            k = k.sibling
        }
        return null
    }
    var Nh = [];
    function Oh() {
        for (var _ = 0; _ < Nh.length; _++)
            Nh[_]._workInProgressVersionPrimary = null;
        Nh.length = 0
    }
    var Ph = ua.ReactCurrentDispatcher
      , Qh = ua.ReactCurrentBatchConfig
      , Rh = 0
      , N = null
      , O$1 = null
      , P$2 = null
      , Sh = !1
      , Th = !1
      , Uh = 0
      , Vh = 0;
    function Q() {
        throw Error(p$2(321))
    }
    function Wh(_, k) {
        if (k === null)
            return !1;
        for (var J = 0; J < k.length && J < _.length; J++)
            if (!He(_[J], k[J]))
                return !1;
        return !0
    }
    function Xh(_, k, J, et, tt, rt) {
        if (Rh = rt,
        N = k,
        k.memoizedState = null,
        k.updateQueue = null,
        k.lanes = 0,
        Ph.current = _ === null || _.memoizedState === null ? Yh : Zh,
        _ = J(et, tt),
        Th) {
            rt = 0;
            do {
                if (Th = !1,
                Uh = 0,
                25 <= rt)
                    throw Error(p$2(301));
                rt += 1,
                P$2 = O$1 = null,
                k.updateQueue = null,
                Ph.current = $h,
                _ = J(et, tt)
            } while (Th)
        }
        if (Ph.current = ai,
        k = O$1 !== null && O$1.next !== null,
        Rh = 0,
        P$2 = O$1 = N = null,
        Sh = !1,
        k)
            throw Error(p$2(300));
        return _
    }
    function bi() {
        var _ = Uh !== 0;
        return Uh = 0,
        _
    }
    function ci() {
        var _ = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return P$2 === null ? N.memoizedState = P$2 = _ : P$2 = P$2.next = _,
        P$2
    }
    function di() {
        if (O$1 === null) {
            var _ = N.alternate;
            _ = _ !== null ? _.memoizedState : null
        } else
            _ = O$1.next;
        var k = P$2 === null ? N.memoizedState : P$2.next;
        if (k !== null)
            P$2 = k,
            O$1 = _;
        else {
            if (_ === null)
                throw Error(p$2(310));
            O$1 = _,
            _ = {
                memoizedState: O$1.memoizedState,
                baseState: O$1.baseState,
                baseQueue: O$1.baseQueue,
                queue: O$1.queue,
                next: null
            },
            P$2 === null ? N.memoizedState = P$2 = _ : P$2 = P$2.next = _
        }
        return P$2
    }
    function ei(_, k) {
        return typeof k == "function" ? k(_) : k
    }
    function fi(_) {
        var k = di()
          , J = k.queue;
        if (J === null)
            throw Error(p$2(311));
        J.lastRenderedReducer = _;
        var et = O$1
          , tt = et.baseQueue
          , rt = J.pending;
        if (rt !== null) {
            if (tt !== null) {
                var nt = tt.next;
                tt.next = rt.next,
                rt.next = nt
            }
            et.baseQueue = tt = rt,
            J.pending = null
        }
        if (tt !== null) {
            rt = tt.next,
            et = et.baseState;
            var ot = nt = null
              , it = null
              , at = rt;
            do {
                var lt = at.lane;
                if ((Rh & lt) === lt)
                    it !== null && (it = it.next = {
                        lane: 0,
                        action: at.action,
                        hasEagerState: at.hasEagerState,
                        eagerState: at.eagerState,
                        next: null
                    }),
                    et = at.hasEagerState ? at.eagerState : _(et, at.action);
                else {
                    var st = {
                        lane: lt,
                        action: at.action,
                        hasEagerState: at.hasEagerState,
                        eagerState: at.eagerState,
                        next: null
                    };
                    it === null ? (ot = it = st,
                    nt = et) : it = it.next = st,
                    N.lanes |= lt,
                    hh |= lt
                }
                at = at.next
            } while (at !== null && at !== rt);
            it === null ? nt = et : it.next = ot,
            He(et, k.memoizedState) || (Ug = !0),
            k.memoizedState = et,
            k.baseState = nt,
            k.baseQueue = it,
            J.lastRenderedState = et
        }
        if (_ = J.interleaved,
        _ !== null) {
            tt = _;
            do
                rt = tt.lane,
                N.lanes |= rt,
                hh |= rt,
                tt = tt.next;
            while (tt !== _)
        } else
            tt === null && (J.lanes = 0);
        return [k.memoizedState, J.dispatch]
    }
    function gi(_) {
        var k = di()
          , J = k.queue;
        if (J === null)
            throw Error(p$2(311));
        J.lastRenderedReducer = _;
        var et = J.dispatch
          , tt = J.pending
          , rt = k.memoizedState;
        if (tt !== null) {
            J.pending = null;
            var nt = tt = tt.next;
            do
                rt = _(rt, nt.action),
                nt = nt.next;
            while (nt !== tt);
            He(rt, k.memoizedState) || (Ug = !0),
            k.memoizedState = rt,
            k.baseQueue === null && (k.baseState = rt),
            J.lastRenderedState = rt
        }
        return [rt, et]
    }
    function hi() {}
    function ii(_, k) {
        var J = N
          , et = di()
          , tt = k()
          , rt = !He(et.memoizedState, tt);
        if (rt && (et.memoizedState = tt,
        Ug = !0),
        et = et.queue,
        ji(ki.bind(null, J, et, _), [_]),
        et.getSnapshot !== k || rt || P$2 !== null && P$2.memoizedState.tag & 1) {
            if (J.flags |= 2048,
            li(9, mi.bind(null, J, et, tt, k), void 0, null),
            R$1 === null)
                throw Error(p$2(349));
            Rh & 30 || ni(J, k, tt)
        }
        return tt
    }
    function ni(_, k, J) {
        _.flags |= 16384,
        _ = {
            getSnapshot: k,
            value: J
        },
        k = N.updateQueue,
        k === null ? (k = {
            lastEffect: null,
            stores: null
        },
        N.updateQueue = k,
        k.stores = [_]) : (J = k.stores,
        J === null ? k.stores = [_] : J.push(_))
    }
    function mi(_, k, J, et) {
        k.value = J,
        k.getSnapshot = et,
        oi(k) && pi(_)
    }
    function ki(_, k, J) {
        return J(function() {
            oi(k) && pi(_)
        })
    }
    function oi(_) {
        var k = _.getSnapshot;
        _ = _.value;
        try {
            var J = k();
            return !He(_, J)
        } catch (et) {
            return !0
        }
    }
    function pi(_) {
        var k = Zg(_, 1);
        k !== null && mh(k, _, 1, -1)
    }
    function qi(_) {
        var k = ci();
        return typeof _ == "function" && (_ = _()),
        k.memoizedState = k.baseState = _,
        _ = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: ei,
            lastRenderedState: _
        },
        k.queue = _,
        _ = _.dispatch = ri.bind(null, N, _),
        [k.memoizedState, _]
    }
    function li(_, k, J, et) {
        return _ = {
            tag: _,
            create: k,
            destroy: J,
            deps: et,
            next: null
        },
        k = N.updateQueue,
        k === null ? (k = {
            lastEffect: null,
            stores: null
        },
        N.updateQueue = k,
        k.lastEffect = _.next = _) : (J = k.lastEffect,
        J === null ? k.lastEffect = _.next = _ : (et = J.next,
        J.next = _,
        _.next = et,
        k.lastEffect = _)),
        _
    }
    function si() {
        return di().memoizedState
    }
    function ti(_, k, J, et) {
        var tt = ci();
        N.flags |= _,
        tt.memoizedState = li(1 | k, J, void 0, et === void 0 ? null : et)
    }
    function ui(_, k, J, et) {
        var tt = di();
        et = et === void 0 ? null : et;
        var rt = void 0;
        if (O$1 !== null) {
            var nt = O$1.memoizedState;
            if (rt = nt.destroy,
            et !== null && Wh(et, nt.deps)) {
                tt.memoizedState = li(k, J, rt, et);
                return
            }
        }
        N.flags |= _,
        tt.memoizedState = li(1 | k, J, rt, et)
    }
    function vi(_, k) {
        return ti(8390656, 8, _, k)
    }
    function ji(_, k) {
        return ui(2048, 8, _, k)
    }
    function wi(_, k) {
        return ui(4, 2, _, k)
    }
    function xi(_, k) {
        return ui(4, 4, _, k)
    }
    function yi(_, k) {
        if (typeof k == "function")
            return _ = _(),
            k(_),
            function() {
                k(null)
            }
            ;
        if (k != null)
            return _ = _(),
            k.current = _,
            function() {
                k.current = null
            }
    }
    function zi(_, k, J) {
        return J = J != null ? J.concat([_]) : null,
        ui(4, 4, yi.bind(null, k, _), J)
    }
    function Ai() {}
    function Bi(_, k) {
        var J = di();
        k = k === void 0 ? null : k;
        var et = J.memoizedState;
        return et !== null && k !== null && Wh(k, et[1]) ? et[0] : (J.memoizedState = [_, k],
        _)
    }
    function Ci(_, k) {
        var J = di();
        k = k === void 0 ? null : k;
        var et = J.memoizedState;
        return et !== null && k !== null && Wh(k, et[1]) ? et[0] : (_ = _(),
        J.memoizedState = [_, k],
        _)
    }
    function Di(_, k, J) {
        return Rh & 21 ? (He(J, k) || (J = yc(),
        N.lanes |= J,
        hh |= J,
        _.baseState = !0),
        k) : (_.baseState && (_.baseState = !1,
        Ug = !0),
        _.memoizedState = J)
    }
    function Ei(_, k) {
        var J = C$1;
        C$1 = J !== 0 && 4 > J ? J : 4,
        _(!0);
        var et = Qh.transition;
        Qh.transition = {};
        try {
            _(!1),
            k()
        } finally {
            C$1 = J,
            Qh.transition = et
        }
    }
    function Fi() {
        return di().memoizedState
    }
    function Gi(_, k, J) {
        var et = lh(_);
        if (J = {
            lane: et,
            action: J,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Hi(_))
            Ii(k, J);
        else if (J = Yg(_, k, J, et),
        J !== null) {
            var tt = L();
            mh(J, _, et, tt),
            Ji(J, k, et)
        }
    }
    function ri(_, k, J) {
        var et = lh(_)
          , tt = {
            lane: et,
            action: J,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Hi(_))
            Ii(k, tt);
        else {
            var rt = _.alternate;
            if (_.lanes === 0 && (rt === null || rt.lanes === 0) && (rt = k.lastRenderedReducer,
            rt !== null))
                try {
                    var nt = k.lastRenderedState
                      , ot = rt(nt, J);
                    if (tt.hasEagerState = !0,
                    tt.eagerState = ot,
                    He(ot, nt)) {
                        var it = k.interleaved;
                        it === null ? (tt.next = tt,
                        Xg(k)) : (tt.next = it.next,
                        it.next = tt),
                        k.interleaved = tt;
                        return
                    }
                } catch (at) {} finally {}
            J = Yg(_, k, tt, et),
            J !== null && (tt = L(),
            mh(J, _, et, tt),
            Ji(J, k, et))
        }
    }
    function Hi(_) {
        var k = _.alternate;
        return _ === N || k !== null && k === N
    }
    function Ii(_, k) {
        Th = Sh = !0;
        var J = _.pending;
        J === null ? k.next = k : (k.next = J.next,
        J.next = k),
        _.pending = k
    }
    function Ji(_, k, J) {
        if (J & 4194240) {
            var et = k.lanes;
            et &= _.pendingLanes,
            J |= et,
            k.lanes = J,
            Cc(_, J)
        }
    }
    var ai = {
        readContext: Vg,
        useCallback: Q,
        useContext: Q,
        useEffect: Q,
        useImperativeHandle: Q,
        useInsertionEffect: Q,
        useLayoutEffect: Q,
        useMemo: Q,
        useReducer: Q,
        useRef: Q,
        useState: Q,
        useDebugValue: Q,
        useDeferredValue: Q,
        useTransition: Q,
        useMutableSource: Q,
        useSyncExternalStore: Q,
        useId: Q,
        unstable_isNewReconciler: !1
    }
      , Yh = {
        readContext: Vg,
        useCallback: function(_, k) {
            return ci().memoizedState = [_, k === void 0 ? null : k],
            _
        },
        useContext: Vg,
        useEffect: vi,
        useImperativeHandle: function(_, k, J) {
            return J = J != null ? J.concat([_]) : null,
            ti(4194308, 4, yi.bind(null, k, _), J)
        },
        useLayoutEffect: function(_, k) {
            return ti(4194308, 4, _, k)
        },
        useInsertionEffect: function(_, k) {
            return ti(4, 2, _, k)
        },
        useMemo: function(_, k) {
            var J = ci();
            return k = k === void 0 ? null : k,
            _ = _(),
            J.memoizedState = [_, k],
            _
        },
        useReducer: function(_, k, J) {
            var et = ci();
            return k = J !== void 0 ? J(k) : k,
            et.memoizedState = et.baseState = k,
            _ = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: _,
                lastRenderedState: k
            },
            et.queue = _,
            _ = _.dispatch = Gi.bind(null, N, _),
            [et.memoizedState, _]
        },
        useRef: function(_) {
            var k = ci();
            return _ = {
                current: _
            },
            k.memoizedState = _
        },
        useState: qi,
        useDebugValue: Ai,
        useDeferredValue: function(_) {
            return ci().memoizedState = _
        },
        useTransition: function() {
            var _ = qi(!1)
              , k = _[0];
            return _ = Ei.bind(null, _[1]),
            ci().memoizedState = _,
            [k, _]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(_, k, J) {
            var et = N
              , tt = ci();
            if (I) {
                if (J === void 0)
                    throw Error(p$2(407));
                J = J()
            } else {
                if (J = k(),
                R$1 === null)
                    throw Error(p$2(349));
                Rh & 30 || ni(et, k, J)
            }
            tt.memoizedState = J;
            var rt = {
                value: J,
                getSnapshot: k
            };
            return tt.queue = rt,
            vi(ki.bind(null, et, rt, _), [_]),
            et.flags |= 2048,
            li(9, mi.bind(null, et, rt, J, k), void 0, null),
            J
        },
        useId: function() {
            var _ = ci()
              , k = R$1.identifierPrefix;
            if (I) {
                var J = sg
                  , et = rg;
                J = (et & ~(1 << 32 - oc(et) - 1)).toString(32) + J,
                k = ":" + k + "R" + J,
                J = Uh++,
                0 < J && (k += "H" + J.toString(32)),
                k += ":"
            } else
                J = Vh++,
                k = ":" + k + "r" + J.toString(32) + ":";
            return _.memoizedState = k
        },
        unstable_isNewReconciler: !1
    }
      , Zh = {
        readContext: Vg,
        useCallback: Bi,
        useContext: Vg,
        useEffect: ji,
        useImperativeHandle: zi,
        useInsertionEffect: wi,
        useLayoutEffect: xi,
        useMemo: Ci,
        useReducer: fi,
        useRef: si,
        useState: function() {
            return fi(ei)
        },
        useDebugValue: Ai,
        useDeferredValue: function(_) {
            var k = di();
            return Di(k, O$1.memoizedState, _)
        },
        useTransition: function() {
            var _ = fi(ei)[0]
              , k = di().memoizedState;
            return [_, k]
        },
        useMutableSource: hi,
        useSyncExternalStore: ii,
        useId: Fi,
        unstable_isNewReconciler: !1
    }
      , $h = {
        readContext: Vg,
        useCallback: Bi,
        useContext: Vg,
        useEffect: ji,
        useImperativeHandle: zi,
        useInsertionEffect: wi,
        useLayoutEffect: xi,
        useMemo: Ci,
        useReducer: gi,
        useRef: si,
        useState: function() {
            return gi(ei)
        },
        useDebugValue: Ai,
        useDeferredValue: function(_) {
            var k = di();
            return O$1 === null ? k.memoizedState = _ : Di(k, O$1.memoizedState, _)
        },
        useTransition: function() {
            var _ = gi(ei)[0]
              , k = di().memoizedState;
            return [_, k]
        },
        useMutableSource: hi,
        useSyncExternalStore: ii,
        useId: Fi,
        unstable_isNewReconciler: !1
    };
    function Ki(_, k) {
        try {
            var J = ""
              , et = k;
            do
                J += Pa(et),
                et = et.return;
            while (et);
            var tt = J
        } catch (rt) {
            tt = `
Error generating stack: ` + rt.message + `
` + rt.stack
        }
        return {
            value: _,
            source: k,
            stack: tt,
            digest: null
        }
    }
    function Li(_, k, J) {
        return {
            value: _,
            source: null,
            stack: J != null ? J : null,
            digest: k != null ? k : null
        }
    }
    function Mi(_, k) {
        try {} catch (J) {
            setTimeout(function() {
                throw J
            })
        }
    }
    var Ni = typeof WeakMap == "function" ? WeakMap : Map;
    function Oi(_, k, J) {
        J = ch(-1, J),
        J.tag = 3,
        J.payload = {
            element: null
        };
        var et = k.value;
        return J.callback = function() {
            Pi || (Pi = !0,
            Qi = et),
            Mi(_, k)
        }
        ,
        J
    }
    function Ri(_, k, J) {
        J = ch(-1, J),
        J.tag = 3;
        var et = _.type.getDerivedStateFromError;
        if (typeof et == "function") {
            var tt = k.value;
            J.payload = function() {
                return et(tt)
            }
            ,
            J.callback = function() {
                Mi(_, k)
            }
        }
        var rt = _.stateNode;
        return rt !== null && typeof rt.componentDidCatch == "function" && (J.callback = function() {
            Mi(_, k),
            typeof et != "function" && (Si === null ? Si = new Set([this]) : Si.add(this));
            var nt = k.stack;
            this.componentDidCatch(k.value, {
                componentStack: nt !== null ? nt : ""
            })
        }
        ),
        J
    }
    function Ti(_, k, J) {
        var et = _.pingCache;
        if (et === null) {
            et = _.pingCache = new Ni;
            var tt = new Set;
            et.set(k, tt)
        } else
            tt = et.get(k),
            tt === void 0 && (tt = new Set,
            et.set(k, tt));
        tt.has(J) || (tt.add(J),
        _ = Ui.bind(null, _, k, J),
        k.then(_, _))
    }
    function Vi(_) {
        do {
            var k;
            if ((k = _.tag === 13) && (k = _.memoizedState,
            k = k !== null ? k.dehydrated !== null : !0),
            k)
                return _;
            _ = _.return
        } while (_ !== null);
        return null
    }
    function Wi(_, k, J, et, tt) {
        return _.mode & 1 ? (_.flags |= 65536,
        _.lanes = tt,
        _) : (_ === k ? _.flags |= 65536 : (_.flags |= 128,
        J.flags |= 131072,
        J.flags &= -52805,
        J.tag === 1 && (J.alternate === null ? J.tag = 17 : (k = ch(-1, 1),
        k.tag = 2,
        dh(J, k, 1))),
        J.lanes |= 1),
        _)
    }
    var Xi = ua.ReactCurrentOwner
      , Ug = !1;
    function Yi(_, k, J, et) {
        k.child = _ === null ? Ch(k, null, J, et) : Bh(k, _.child, J, et)
    }
    function Zi(_, k, J, et, tt) {
        J = J.render;
        var rt = k.ref;
        return Tg(k, tt),
        et = Xh(_, k, J, et, rt, tt),
        J = bi(),
        _ !== null && !Ug ? (k.updateQueue = _.updateQueue,
        k.flags &= -2053,
        _.lanes &= ~tt,
        $i(_, k, tt)) : (I && J && vg(k),
        k.flags |= 1,
        Yi(_, k, et, tt),
        k.child)
    }
    function aj(_, k, J, et, tt) {
        if (_ === null) {
            var rt = J.type;
            return typeof rt == "function" && !bj(rt) && rt.defaultProps === void 0 && J.compare === null && J.defaultProps === void 0 ? (k.tag = 15,
            k.type = rt,
            cj(_, k, rt, et, tt)) : (_ = yh(J.type, null, et, k, k.mode, tt),
            _.ref = k.ref,
            _.return = k,
            k.child = _)
        }
        if (rt = _.child,
        !(_.lanes & tt)) {
            var nt = rt.memoizedProps;
            if (J = J.compare,
            J = J !== null ? J : Ie,
            J(nt, et) && _.ref === k.ref)
                return $i(_, k, tt)
        }
        return k.flags |= 1,
        _ = wh(rt, et),
        _.ref = k.ref,
        _.return = k,
        k.child = _
    }
    function cj(_, k, J, et, tt) {
        if (_ !== null) {
            var rt = _.memoizedProps;
            if (Ie(rt, et) && _.ref === k.ref)
                if (Ug = !1,
                k.pendingProps = et = rt,
                (_.lanes & tt) !== 0)
                    _.flags & 131072 && (Ug = !0);
                else
                    return k.lanes = _.lanes,
                    $i(_, k, tt)
        }
        return dj(_, k, J, et, tt)
    }
    function ej(_, k, J) {
        var et = k.pendingProps
          , tt = et.children
          , rt = _ !== null ? _.memoizedState : null;
        if (et.mode === "hidden")
            if (!(k.mode & 1))
                k.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                G(fj, gj),
                gj |= J;
            else {
                if (!(J & 1073741824))
                    return _ = rt !== null ? rt.baseLanes | J : J,
                    k.lanes = k.childLanes = 1073741824,
                    k.memoizedState = {
                        baseLanes: _,
                        cachePool: null,
                        transitions: null
                    },
                    k.updateQueue = null,
                    G(fj, gj),
                    gj |= _,
                    null;
                k.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                },
                et = rt !== null ? rt.baseLanes : J,
                G(fj, gj),
                gj |= et
            }
        else
            rt !== null ? (et = rt.baseLanes | J,
            k.memoizedState = null) : et = J,
            G(fj, gj),
            gj |= et;
        return Yi(_, k, tt, J),
        k.child
    }
    function hj(_, k) {
        var J = k.ref;
        (_ === null && J !== null || _ !== null && _.ref !== J) && (k.flags |= 512,
        k.flags |= 2097152)
    }
    function dj(_, k, J, et, tt) {
        var rt = Zf(J) ? Xf : H.current;
        return rt = Yf(k, rt),
        Tg(k, tt),
        J = Xh(_, k, J, et, rt, tt),
        et = bi(),
        _ !== null && !Ug ? (k.updateQueue = _.updateQueue,
        k.flags &= -2053,
        _.lanes &= ~tt,
        $i(_, k, tt)) : (I && et && vg(k),
        k.flags |= 1,
        Yi(_, k, J, tt),
        k.child)
    }
    function ij(_, k, J, et, tt) {
        if (Zf(J)) {
            var rt = !0;
            cg(k)
        } else
            rt = !1;
        if (Tg(k, tt),
        k.stateNode === null)
            jj(_, k),
            ph(k, J, et),
            rh(k, J, et, tt),
            et = !0;
        else if (_ === null) {
            var nt = k.stateNode
              , ot = k.memoizedProps;
            nt.props = ot;
            var it = nt.context
              , at = J.contextType;
            typeof at == "object" && at !== null ? at = Vg(at) : (at = Zf(J) ? Xf : H.current,
            at = Yf(k, at));
            var lt = J.getDerivedStateFromProps
              , st = typeof lt == "function" || typeof nt.getSnapshotBeforeUpdate == "function";
            st || typeof nt.UNSAFE_componentWillReceiveProps != "function" && typeof nt.componentWillReceiveProps != "function" || (ot !== et || it !== at) && qh(k, nt, et, at),
            $g = !1;
            var ut = k.memoizedState;
            nt.state = ut,
            gh(k, et, nt, tt),
            it = k.memoizedState,
            ot !== et || ut !== it || Wf.current || $g ? (typeof lt == "function" && (kh(k, J, lt, et),
            it = k.memoizedState),
            (ot = $g || oh(k, J, ot, et, ut, it, at)) ? (st || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || (typeof nt.componentWillMount == "function" && nt.componentWillMount(),
            typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount()),
            typeof nt.componentDidMount == "function" && (k.flags |= 4194308)) : (typeof nt.componentDidMount == "function" && (k.flags |= 4194308),
            k.memoizedProps = et,
            k.memoizedState = it),
            nt.props = et,
            nt.state = it,
            nt.context = at,
            et = ot) : (typeof nt.componentDidMount == "function" && (k.flags |= 4194308),
            et = !1)
        } else {
            nt = k.stateNode,
            bh(_, k),
            ot = k.memoizedProps,
            at = k.type === k.elementType ? ot : Lg(k.type, ot),
            nt.props = at,
            st = k.pendingProps,
            ut = nt.context,
            it = J.contextType,
            typeof it == "object" && it !== null ? it = Vg(it) : (it = Zf(J) ? Xf : H.current,
            it = Yf(k, it));
            var ct = J.getDerivedStateFromProps;
            (lt = typeof ct == "function" || typeof nt.getSnapshotBeforeUpdate == "function") || typeof nt.UNSAFE_componentWillReceiveProps != "function" && typeof nt.componentWillReceiveProps != "function" || (ot !== st || ut !== it) && qh(k, nt, et, it),
            $g = !1,
            ut = k.memoizedState,
            nt.state = ut,
            gh(k, et, nt, tt);
            var pt = k.memoizedState;
            ot !== st || ut !== pt || Wf.current || $g ? (typeof ct == "function" && (kh(k, J, ct, et),
            pt = k.memoizedState),
            (at = $g || oh(k, J, at, et, ut, pt, it) || !1) ? (lt || typeof nt.UNSAFE_componentWillUpdate != "function" && typeof nt.componentWillUpdate != "function" || (typeof nt.componentWillUpdate == "function" && nt.componentWillUpdate(et, pt, it),
            typeof nt.UNSAFE_componentWillUpdate == "function" && nt.UNSAFE_componentWillUpdate(et, pt, it)),
            typeof nt.componentDidUpdate == "function" && (k.flags |= 4),
            typeof nt.getSnapshotBeforeUpdate == "function" && (k.flags |= 1024)) : (typeof nt.componentDidUpdate != "function" || ot === _.memoizedProps && ut === _.memoizedState || (k.flags |= 4),
            typeof nt.getSnapshotBeforeUpdate != "function" || ot === _.memoizedProps && ut === _.memoizedState || (k.flags |= 1024),
            k.memoizedProps = et,
            k.memoizedState = pt),
            nt.props = et,
            nt.state = pt,
            nt.context = it,
            et = at) : (typeof nt.componentDidUpdate != "function" || ot === _.memoizedProps && ut === _.memoizedState || (k.flags |= 4),
            typeof nt.getSnapshotBeforeUpdate != "function" || ot === _.memoizedProps && ut === _.memoizedState || (k.flags |= 1024),
            et = !1)
        }
        return kj(_, k, J, et, rt, tt)
    }
    function kj(_, k, J, et, tt, rt) {
        hj(_, k);
        var nt = (k.flags & 128) !== 0;
        if (!et && !nt)
            return tt && dg(k, J, !1),
            $i(_, k, rt);
        et = k.stateNode,
        Xi.current = k;
        var ot = nt && typeof J.getDerivedStateFromError != "function" ? null : et.render();
        return k.flags |= 1,
        _ !== null && nt ? (k.child = Bh(k, _.child, null, rt),
        k.child = Bh(k, null, ot, rt)) : Yi(_, k, ot, rt),
        k.memoizedState = et.state,
        tt && dg(k, J, !0),
        k.child
    }
    function lj(_) {
        var k = _.stateNode;
        k.pendingContext ? ag(_, k.pendingContext, k.pendingContext !== k.context) : k.context && ag(_, k.context, !1),
        Ih(_, k.containerInfo)
    }
    function mj(_, k, J, et, tt) {
        return Ig(),
        Jg(tt),
        k.flags |= 256,
        Yi(_, k, J, et),
        k.child
    }
    var nj = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };
    function oj(_) {
        return {
            baseLanes: _,
            cachePool: null,
            transitions: null
        }
    }
    function pj(_, k, J) {
        var et = k.pendingProps, tt = M.current, rt = !1, nt = (k.flags & 128) !== 0, ot;
        if ((ot = nt) || (ot = _ !== null && _.memoizedState === null ? !1 : (tt & 2) !== 0),
        ot ? (rt = !0,
        k.flags &= -129) : (_ === null || _.memoizedState !== null) && (tt |= 1),
        G(M, tt & 1),
        _ === null)
            return Eg(k),
            _ = k.memoizedState,
            _ !== null && (_ = _.dehydrated,
            _ !== null) ? (k.mode & 1 ? _.data === "$!" ? k.lanes = 8 : k.lanes = 1073741824 : k.lanes = 1,
            null) : (nt = et.children,
            _ = et.fallback,
            rt ? (et = k.mode,
            rt = k.child,
            nt = {
                mode: "hidden",
                children: nt
            },
            !(et & 1) && rt !== null ? (rt.childLanes = 0,
            rt.pendingProps = nt) : rt = qj(nt, et, 0, null),
            _ = Ah(_, et, J, null),
            rt.return = k,
            _.return = k,
            rt.sibling = _,
            k.child = rt,
            k.child.memoizedState = oj(J),
            k.memoizedState = nj,
            _) : rj(k, nt));
        if (tt = _.memoizedState,
        tt !== null && (ot = tt.dehydrated,
        ot !== null))
            return sj(_, k, nt, et, ot, tt, J);
        if (rt) {
            rt = et.fallback,
            nt = k.mode,
            tt = _.child,
            ot = tt.sibling;
            var it = {
                mode: "hidden",
                children: et.children
            };
            return !(nt & 1) && k.child !== tt ? (et = k.child,
            et.childLanes = 0,
            et.pendingProps = it,
            k.deletions = null) : (et = wh(tt, it),
            et.subtreeFlags = tt.subtreeFlags & 14680064),
            ot !== null ? rt = wh(ot, rt) : (rt = Ah(rt, nt, J, null),
            rt.flags |= 2),
            rt.return = k,
            et.return = k,
            et.sibling = rt,
            k.child = et,
            et = rt,
            rt = k.child,
            nt = _.child.memoizedState,
            nt = nt === null ? oj(J) : {
                baseLanes: nt.baseLanes | J,
                cachePool: null,
                transitions: nt.transitions
            },
            rt.memoizedState = nt,
            rt.childLanes = _.childLanes & ~J,
            k.memoizedState = nj,
            et
        }
        return rt = _.child,
        _ = rt.sibling,
        et = wh(rt, {
            mode: "visible",
            children: et.children
        }),
        !(k.mode & 1) && (et.lanes = J),
        et.return = k,
        et.sibling = null,
        _ !== null && (J = k.deletions,
        J === null ? (k.deletions = [_],
        k.flags |= 16) : J.push(_)),
        k.child = et,
        k.memoizedState = null,
        et
    }
    function rj(_, k) {
        return k = qj({
            mode: "visible",
            children: k
        }, _.mode, 0, null),
        k.return = _,
        _.child = k
    }
    function tj(_, k, J, et) {
        return et !== null && Jg(et),
        Bh(k, _.child, null, J),
        _ = rj(k, k.pendingProps.children),
        _.flags |= 2,
        k.memoizedState = null,
        _
    }
    function sj(_, k, J, et, tt, rt, nt) {
        if (J)
            return k.flags & 256 ? (k.flags &= -257,
            et = Li(Error(p$2(422))),
            tj(_, k, nt, et)) : k.memoizedState !== null ? (k.child = _.child,
            k.flags |= 128,
            null) : (rt = et.fallback,
            tt = k.mode,
            et = qj({
                mode: "visible",
                children: et.children
            }, tt, 0, null),
            rt = Ah(rt, tt, nt, null),
            rt.flags |= 2,
            et.return = k,
            rt.return = k,
            et.sibling = rt,
            k.child = et,
            k.mode & 1 && Bh(k, _.child, null, nt),
            k.child.memoizedState = oj(nt),
            k.memoizedState = nj,
            rt);
        if (!(k.mode & 1))
            return tj(_, k, nt, null);
        if (tt.data === "$!") {
            if (et = tt.nextSibling && tt.nextSibling.dataset,
            et)
                var ot = et.dgst;
            return et = ot,
            rt = Error(p$2(419)),
            et = Li(rt, et, void 0),
            tj(_, k, nt, et)
        }
        if (ot = (nt & _.childLanes) !== 0,
        Ug || ot) {
            if (et = R$1,
            et !== null) {
                switch (nt & -nt) {
                case 4:
                    tt = 2;
                    break;
                case 16:
                    tt = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    tt = 32;
                    break;
                case 536870912:
                    tt = 268435456;
                    break;
                default:
                    tt = 0
                }
                tt = tt & (et.suspendedLanes | nt) ? 0 : tt,
                tt !== 0 && tt !== rt.retryLane && (rt.retryLane = tt,
                Zg(_, tt),
                mh(et, _, tt, -1))
            }
            return uj(),
            et = Li(Error(p$2(421))),
            tj(_, k, nt, et)
        }
        return tt.data === "$?" ? (k.flags |= 128,
        k.child = _.child,
        k = vj.bind(null, _),
        tt._reactRetry = k,
        null) : (_ = rt.treeContext,
        yg = Lf(tt.nextSibling),
        xg = k,
        I = !0,
        zg = null,
        _ !== null && (og[pg++] = rg,
        og[pg++] = sg,
        og[pg++] = qg,
        rg = _.id,
        sg = _.overflow,
        qg = k),
        k = rj(k, et.children),
        k.flags |= 4096,
        k)
    }
    function wj(_, k, J) {
        _.lanes |= k;
        var et = _.alternate;
        et !== null && (et.lanes |= k),
        Sg(_.return, k, J)
    }
    function xj(_, k, J, et, tt) {
        var rt = _.memoizedState;
        rt === null ? _.memoizedState = {
            isBackwards: k,
            rendering: null,
            renderingStartTime: 0,
            last: et,
            tail: J,
            tailMode: tt
        } : (rt.isBackwards = k,
        rt.rendering = null,
        rt.renderingStartTime = 0,
        rt.last = et,
        rt.tail = J,
        rt.tailMode = tt)
    }
    function yj(_, k, J) {
        var et = k.pendingProps
          , tt = et.revealOrder
          , rt = et.tail;
        if (Yi(_, k, et.children, J),
        et = M.current,
        et & 2)
            et = et & 1 | 2,
            k.flags |= 128;
        else {
            if (_ !== null && _.flags & 128)
                e: for (_ = k.child; _ !== null; ) {
                    if (_.tag === 13)
                        _.memoizedState !== null && wj(_, J, k);
                    else if (_.tag === 19)
                        wj(_, J, k);
                    else if (_.child !== null) {
                        _.child.return = _,
                        _ = _.child;
                        continue
                    }
                    if (_ === k)
                        break e;
                    for (; _.sibling === null; ) {
                        if (_.return === null || _.return === k)
                            break e;
                        _ = _.return
                    }
                    _.sibling.return = _.return,
                    _ = _.sibling
                }
            et &= 1
        }
        if (G(M, et),
        !(k.mode & 1))
            k.memoizedState = null;
        else
            switch (tt) {
            case "forwards":
                for (J = k.child,
                tt = null; J !== null; )
                    _ = J.alternate,
                    _ !== null && Mh(_) === null && (tt = J),
                    J = J.sibling;
                J = tt,
                J === null ? (tt = k.child,
                k.child = null) : (tt = J.sibling,
                J.sibling = null),
                xj(k, !1, tt, J, rt);
                break;
            case "backwards":
                for (J = null,
                tt = k.child,
                k.child = null; tt !== null; ) {
                    if (_ = tt.alternate,
                    _ !== null && Mh(_) === null) {
                        k.child = tt;
                        break
                    }
                    _ = tt.sibling,
                    tt.sibling = J,
                    J = tt,
                    tt = _
                }
                xj(k, !0, J, null, rt);
                break;
            case "together":
                xj(k, !1, null, null, void 0);
                break;
            default:
                k.memoizedState = null
            }
        return k.child
    }
    function jj(_, k) {
        !(k.mode & 1) && _ !== null && (_.alternate = null,
        k.alternate = null,
        k.flags |= 2)
    }
    function $i(_, k, J) {
        if (_ !== null && (k.dependencies = _.dependencies),
        hh |= k.lanes,
        !(J & k.childLanes))
            return null;
        if (_ !== null && k.child !== _.child)
            throw Error(p$2(153));
        if (k.child !== null) {
            for (_ = k.child,
            J = wh(_, _.pendingProps),
            k.child = J,
            J.return = k; _.sibling !== null; )
                _ = _.sibling,
                J = J.sibling = wh(_, _.pendingProps),
                J.return = k;
            J.sibling = null
        }
        return k.child
    }
    function zj(_, k, J) {
        switch (k.tag) {
        case 3:
            lj(k),
            Ig();
            break;
        case 5:
            Kh(k);
            break;
        case 1:
            Zf(k.type) && cg(k);
            break;
        case 4:
            Ih(k, k.stateNode.containerInfo);
            break;
        case 10:
            var et = k.type._context
              , tt = k.memoizedProps.value;
            G(Mg, et._currentValue),
            et._currentValue = tt;
            break;
        case 13:
            if (et = k.memoizedState,
            et !== null)
                return et.dehydrated !== null ? (G(M, M.current & 1),
                k.flags |= 128,
                null) : J & k.child.childLanes ? pj(_, k, J) : (G(M, M.current & 1),
                _ = $i(_, k, J),
                _ !== null ? _.sibling : null);
            G(M, M.current & 1);
            break;
        case 19:
            if (et = (J & k.childLanes) !== 0,
            _.flags & 128) {
                if (et)
                    return yj(_, k, J);
                k.flags |= 128
            }
            if (tt = k.memoizedState,
            tt !== null && (tt.rendering = null,
            tt.tail = null,
            tt.lastEffect = null),
            G(M, M.current),
            et)
                break;
            return null;
        case 22:
        case 23:
            return k.lanes = 0,
            ej(_, k, J)
        }
        return $i(_, k, J)
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(_, k) {
        for (var J = k.child; J !== null; ) {
            if (J.tag === 5 || J.tag === 6)
                _.appendChild(J.stateNode);
            else if (J.tag !== 4 && J.child !== null) {
                J.child.return = J,
                J = J.child;
                continue
            }
            if (J === k)
                break;
            for (; J.sibling === null; ) {
                if (J.return === null || J.return === k)
                    return;
                J = J.return
            }
            J.sibling.return = J.return,
            J = J.sibling
        }
    }
    ,
    Bj = function() {}
    ,
    Cj = function(_, k, J, et) {
        var tt = _.memoizedProps;
        if (tt !== et) {
            _ = k.stateNode,
            Hh(Eh.current);
            var rt = null;
            switch (J) {
            case "input":
                tt = Ya(_, tt),
                et = Ya(_, et),
                rt = [];
                break;
            case "select":
                tt = A({}, tt, {
                    value: void 0
                }),
                et = A({}, et, {
                    value: void 0
                }),
                rt = [];
                break;
            case "textarea":
                tt = gb(_, tt),
                et = gb(_, et),
                rt = [];
                break;
            default:
                typeof tt.onClick != "function" && typeof et.onClick == "function" && (_.onclick = Bf)
            }
            ub(J, et);
            var nt;
            J = null;
            for (at in tt)
                if (!et.hasOwnProperty(at) && tt.hasOwnProperty(at) && tt[at] != null)
                    if (at === "style") {
                        var ot = tt[at];
                        for (nt in ot)
                            ot.hasOwnProperty(nt) && (J || (J = {}),
                            J[nt] = "")
                    } else
                        at !== "dangerouslySetInnerHTML" && at !== "children" && at !== "suppressContentEditableWarning" && at !== "suppressHydrationWarning" && at !== "autoFocus" && (ea.hasOwnProperty(at) ? rt || (rt = []) : (rt = rt || []).push(at, null));
            for (at in et) {
                var it = et[at];
                if (ot = tt == null ? void 0 : tt[at],
                et.hasOwnProperty(at) && it !== ot && (it != null || ot != null))
                    if (at === "style")
                        if (ot) {
                            for (nt in ot)
                                !ot.hasOwnProperty(nt) || it && it.hasOwnProperty(nt) || (J || (J = {}),
                                J[nt] = "");
                            for (nt in it)
                                it.hasOwnProperty(nt) && ot[nt] !== it[nt] && (J || (J = {}),
                                J[nt] = it[nt])
                        } else
                            J || (rt || (rt = []),
                            rt.push(at, J)),
                            J = it;
                    else
                        at === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0,
                        ot = ot ? ot.__html : void 0,
                        it != null && ot !== it && (rt = rt || []).push(at, it)) : at === "children" ? typeof it != "string" && typeof it != "number" || (rt = rt || []).push(at, "" + it) : at !== "suppressContentEditableWarning" && at !== "suppressHydrationWarning" && (ea.hasOwnProperty(at) ? (it != null && at === "onScroll" && D$1("scroll", _),
                        rt || ot === it || (rt = [])) : (rt = rt || []).push(at, it))
            }
            J && (rt = rt || []).push("style", J);
            var at = rt;
            (k.updateQueue = at) && (k.flags |= 4)
        }
    }
    ,
    Dj = function(_, k, J, et) {
        J !== et && (k.flags |= 4)
    }
    ;
    function Ej(_, k) {
        if (!I)
            switch (_.tailMode) {
            case "hidden":
                k = _.tail;
                for (var J = null; k !== null; )
                    k.alternate !== null && (J = k),
                    k = k.sibling;
                J === null ? _.tail = null : J.sibling = null;
                break;
            case "collapsed":
                J = _.tail;
                for (var et = null; J !== null; )
                    J.alternate !== null && (et = J),
                    J = J.sibling;
                et === null ? k || _.tail === null ? _.tail = null : _.tail.sibling = null : et.sibling = null
            }
    }
    function S$1(_) {
        var k = _.alternate !== null && _.alternate.child === _.child
          , J = 0
          , et = 0;
        if (k)
            for (var tt = _.child; tt !== null; )
                J |= tt.lanes | tt.childLanes,
                et |= tt.subtreeFlags & 14680064,
                et |= tt.flags & 14680064,
                tt.return = _,
                tt = tt.sibling;
        else
            for (tt = _.child; tt !== null; )
                J |= tt.lanes | tt.childLanes,
                et |= tt.subtreeFlags,
                et |= tt.flags,
                tt.return = _,
                tt = tt.sibling;
        return _.subtreeFlags |= et,
        _.childLanes = J,
        k
    }
    function Fj(_, k, J) {
        var et = k.pendingProps;
        switch (wg(k),
        k.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return S$1(k),
            null;
        case 1:
            return Zf(k.type) && $f(),
            S$1(k),
            null;
        case 3:
            return et = k.stateNode,
            Jh(),
            E$1(Wf),
            E$1(H),
            Oh(),
            et.pendingContext && (et.context = et.pendingContext,
            et.pendingContext = null),
            (_ === null || _.child === null) && (Gg(k) ? k.flags |= 4 : _ === null || _.memoizedState.isDehydrated && !(k.flags & 256) || (k.flags |= 1024,
            zg !== null && (Gj(zg),
            zg = null))),
            Bj(_, k),
            S$1(k),
            null;
        case 5:
            Lh(k);
            var tt = Hh(Gh.current);
            if (J = k.type,
            _ !== null && k.stateNode != null)
                Cj(_, k, J, et, tt),
                _.ref !== k.ref && (k.flags |= 512,
                k.flags |= 2097152);
            else {
                if (!et) {
                    if (k.stateNode === null)
                        throw Error(p$2(166));
                    return S$1(k),
                    null
                }
                if (_ = Hh(Eh.current),
                Gg(k)) {
                    et = k.stateNode,
                    J = k.type;
                    var rt = k.memoizedProps;
                    switch (et[Of] = k,
                    et[Pf] = rt,
                    _ = (k.mode & 1) !== 0,
                    J) {
                    case "dialog":
                        D$1("cancel", et),
                        D$1("close", et);
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D$1("load", et);
                        break;
                    case "video":
                    case "audio":
                        for (tt = 0; tt < lf.length; tt++)
                            D$1(lf[tt], et);
                        break;
                    case "source":
                        D$1("error", et);
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D$1("error", et),
                        D$1("load", et);
                        break;
                    case "details":
                        D$1("toggle", et);
                        break;
                    case "input":
                        Za(et, rt),
                        D$1("invalid", et);
                        break;
                    case "select":
                        et._wrapperState = {
                            wasMultiple: !!rt.multiple
                        },
                        D$1("invalid", et);
                        break;
                    case "textarea":
                        hb(et, rt),
                        D$1("invalid", et)
                    }
                    ub(J, rt),
                    tt = null;
                    for (var nt in rt)
                        if (rt.hasOwnProperty(nt)) {
                            var ot = rt[nt];
                            nt === "children" ? typeof ot == "string" ? et.textContent !== ot && (rt.suppressHydrationWarning !== !0 && Af(et.textContent, ot, _),
                            tt = ["children", ot]) : typeof ot == "number" && et.textContent !== "" + ot && (rt.suppressHydrationWarning !== !0 && Af(et.textContent, ot, _),
                            tt = ["children", "" + ot]) : ea.hasOwnProperty(nt) && ot != null && nt === "onScroll" && D$1("scroll", et)
                        }
                    switch (J) {
                    case "input":
                        Va(et),
                        db(et, rt, !0);
                        break;
                    case "textarea":
                        Va(et),
                        jb(et);
                        break;
                    case "select":
                    case "option":
                        break;
                    default:
                        typeof rt.onClick == "function" && (et.onclick = Bf)
                    }
                    et = tt,
                    k.updateQueue = et,
                    et !== null && (k.flags |= 4)
                } else {
                    nt = tt.nodeType === 9 ? tt : tt.ownerDocument,
                    _ === "http://www.w3.org/1999/xhtml" && (_ = kb(J)),
                    _ === "http://www.w3.org/1999/xhtml" ? J === "script" ? (_ = nt.createElement("div"),
                    _.innerHTML = "<script><\/script>",
                    _ = _.removeChild(_.firstChild)) : typeof et.is == "string" ? _ = nt.createElement(J, {
                        is: et.is
                    }) : (_ = nt.createElement(J),
                    J === "select" && (nt = _,
                    et.multiple ? nt.multiple = !0 : et.size && (nt.size = et.size))) : _ = nt.createElementNS(_, J),
                    _[Of] = k,
                    _[Pf] = et,
                    Aj(_, k, !1, !1),
                    k.stateNode = _;
                    e: {
                        switch (nt = vb(J, et),
                        J) {
                        case "dialog":
                            D$1("cancel", _),
                            D$1("close", _),
                            tt = et;
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            D$1("load", _),
                            tt = et;
                            break;
                        case "video":
                        case "audio":
                            for (tt = 0; tt < lf.length; tt++)
                                D$1(lf[tt], _);
                            tt = et;
                            break;
                        case "source":
                            D$1("error", _),
                            tt = et;
                            break;
                        case "img":
                        case "image":
                        case "link":
                            D$1("error", _),
                            D$1("load", _),
                            tt = et;
                            break;
                        case "details":
                            D$1("toggle", _),
                            tt = et;
                            break;
                        case "input":
                            Za(_, et),
                            tt = Ya(_, et),
                            D$1("invalid", _);
                            break;
                        case "option":
                            tt = et;
                            break;
                        case "select":
                            _._wrapperState = {
                                wasMultiple: !!et.multiple
                            },
                            tt = A({}, et, {
                                value: void 0
                            }),
                            D$1("invalid", _);
                            break;
                        case "textarea":
                            hb(_, et),
                            tt = gb(_, et),
                            D$1("invalid", _);
                            break;
                        default:
                            tt = et
                        }
                        ub(J, tt),
                        ot = tt;
                        for (rt in ot)
                            if (ot.hasOwnProperty(rt)) {
                                var it = ot[rt];
                                rt === "style" ? sb(_, it) : rt === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0,
                                it != null && nb(_, it)) : rt === "children" ? typeof it == "string" ? (J !== "textarea" || it !== "") && ob(_, it) : typeof it == "number" && ob(_, "" + it) : rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && rt !== "autoFocus" && (ea.hasOwnProperty(rt) ? it != null && rt === "onScroll" && D$1("scroll", _) : it != null && ta(_, rt, it, nt))
                            }
                        switch (J) {
                        case "input":
                            Va(_),
                            db(_, et, !1);
                            break;
                        case "textarea":
                            Va(_),
                            jb(_);
                            break;
                        case "option":
                            et.value != null && _.setAttribute("value", "" + Sa(et.value));
                            break;
                        case "select":
                            _.multiple = !!et.multiple,
                            rt = et.value,
                            rt != null ? fb(_, !!et.multiple, rt, !1) : et.defaultValue != null && fb(_, !!et.multiple, et.defaultValue, !0);
                            break;
                        default:
                            typeof tt.onClick == "function" && (_.onclick = Bf)
                        }
                        switch (J) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            et = !!et.autoFocus;
                            break e;
                        case "img":
                            et = !0;
                            break e;
                        default:
                            et = !1
                        }
                    }
                    et && (k.flags |= 4)
                }
                k.ref !== null && (k.flags |= 512,
                k.flags |= 2097152)
            }
            return S$1(k),
            null;
        case 6:
            if (_ && k.stateNode != null)
                Dj(_, k, _.memoizedProps, et);
            else {
                if (typeof et != "string" && k.stateNode === null)
                    throw Error(p$2(166));
                if (J = Hh(Gh.current),
                Hh(Eh.current),
                Gg(k)) {
                    if (et = k.stateNode,
                    J = k.memoizedProps,
                    et[Of] = k,
                    (rt = et.nodeValue !== J) && (_ = xg,
                    _ !== null))
                        switch (_.tag) {
                        case 3:
                            Af(et.nodeValue, J, (_.mode & 1) !== 0);
                            break;
                        case 5:
                            _.memoizedProps.suppressHydrationWarning !== !0 && Af(et.nodeValue, J, (_.mode & 1) !== 0)
                        }
                    rt && (k.flags |= 4)
                } else
                    et = (J.nodeType === 9 ? J : J.ownerDocument).createTextNode(et),
                    et[Of] = k,
                    k.stateNode = et
            }
            return S$1(k),
            null;
        case 13:
            if (E$1(M),
            et = k.memoizedState,
            _ === null || _.memoizedState !== null && _.memoizedState.dehydrated !== null) {
                if (I && yg !== null && k.mode & 1 && !(k.flags & 128))
                    Hg(),
                    Ig(),
                    k.flags |= 98560,
                    rt = !1;
                else if (rt = Gg(k),
                et !== null && et.dehydrated !== null) {
                    if (_ === null) {
                        if (!rt)
                            throw Error(p$2(318));
                        if (rt = k.memoizedState,
                        rt = rt !== null ? rt.dehydrated : null,
                        !rt)
                            throw Error(p$2(317));
                        rt[Of] = k
                    } else
                        Ig(),
                        !(k.flags & 128) && (k.memoizedState = null),
                        k.flags |= 4;
                    S$1(k),
                    rt = !1
                } else
                    zg !== null && (Gj(zg),
                    zg = null),
                    rt = !0;
                if (!rt)
                    return k.flags & 65536 ? k : null
            }
            return k.flags & 128 ? (k.lanes = J,
            k) : (et = et !== null,
            et !== (_ !== null && _.memoizedState !== null) && et && (k.child.flags |= 8192,
            k.mode & 1 && (_ === null || M.current & 1 ? T$1 === 0 && (T$1 = 3) : uj())),
            k.updateQueue !== null && (k.flags |= 4),
            S$1(k),
            null);
        case 4:
            return Jh(),
            Bj(_, k),
            _ === null && sf(k.stateNode.containerInfo),
            S$1(k),
            null;
        case 10:
            return Rg(k.type._context),
            S$1(k),
            null;
        case 17:
            return Zf(k.type) && $f(),
            S$1(k),
            null;
        case 19:
            if (E$1(M),
            rt = k.memoizedState,
            rt === null)
                return S$1(k),
                null;
            if (et = (k.flags & 128) !== 0,
            nt = rt.rendering,
            nt === null)
                if (et)
                    Ej(rt, !1);
                else {
                    if (T$1 !== 0 || _ !== null && _.flags & 128)
                        for (_ = k.child; _ !== null; ) {
                            if (nt = Mh(_),
                            nt !== null) {
                                for (k.flags |= 128,
                                Ej(rt, !1),
                                et = nt.updateQueue,
                                et !== null && (k.updateQueue = et,
                                k.flags |= 4),
                                k.subtreeFlags = 0,
                                et = J,
                                J = k.child; J !== null; )
                                    rt = J,
                                    _ = et,
                                    rt.flags &= 14680066,
                                    nt = rt.alternate,
                                    nt === null ? (rt.childLanes = 0,
                                    rt.lanes = _,
                                    rt.child = null,
                                    rt.subtreeFlags = 0,
                                    rt.memoizedProps = null,
                                    rt.memoizedState = null,
                                    rt.updateQueue = null,
                                    rt.dependencies = null,
                                    rt.stateNode = null) : (rt.childLanes = nt.childLanes,
                                    rt.lanes = nt.lanes,
                                    rt.child = nt.child,
                                    rt.subtreeFlags = 0,
                                    rt.deletions = null,
                                    rt.memoizedProps = nt.memoizedProps,
                                    rt.memoizedState = nt.memoizedState,
                                    rt.updateQueue = nt.updateQueue,
                                    rt.type = nt.type,
                                    _ = nt.dependencies,
                                    rt.dependencies = _ === null ? null : {
                                        lanes: _.lanes,
                                        firstContext: _.firstContext
                                    }),
                                    J = J.sibling;
                                return G(M, M.current & 1 | 2),
                                k.child
                            }
                            _ = _.sibling
                        }
                    rt.tail !== null && B$1() > Hj && (k.flags |= 128,
                    et = !0,
                    Ej(rt, !1),
                    k.lanes = 4194304)
                }
            else {
                if (!et)
                    if (_ = Mh(nt),
                    _ !== null) {
                        if (k.flags |= 128,
                        et = !0,
                        J = _.updateQueue,
                        J !== null && (k.updateQueue = J,
                        k.flags |= 4),
                        Ej(rt, !0),
                        rt.tail === null && rt.tailMode === "hidden" && !nt.alternate && !I)
                            return S$1(k),
                            null
                    } else
                        2 * B$1() - rt.renderingStartTime > Hj && J !== 1073741824 && (k.flags |= 128,
                        et = !0,
                        Ej(rt, !1),
                        k.lanes = 4194304);
                rt.isBackwards ? (nt.sibling = k.child,
                k.child = nt) : (J = rt.last,
                J !== null ? J.sibling = nt : k.child = nt,
                rt.last = nt)
            }
            return rt.tail !== null ? (k = rt.tail,
            rt.rendering = k,
            rt.tail = k.sibling,
            rt.renderingStartTime = B$1(),
            k.sibling = null,
            J = M.current,
            G(M, et ? J & 1 | 2 : J & 1),
            k) : (S$1(k),
            null);
        case 22:
        case 23:
            return Ij(),
            et = k.memoizedState !== null,
            _ !== null && _.memoizedState !== null !== et && (k.flags |= 8192),
            et && k.mode & 1 ? gj & 1073741824 && (S$1(k),
            k.subtreeFlags & 6 && (k.flags |= 8192)) : S$1(k),
            null;
        case 24:
            return null;
        case 25:
            return null
        }
        throw Error(p$2(156, k.tag))
    }
    function Jj(_, k) {
        switch (wg(k),
        k.tag) {
        case 1:
            return Zf(k.type) && $f(),
            _ = k.flags,
            _ & 65536 ? (k.flags = _ & -65537 | 128,
            k) : null;
        case 3:
            return Jh(),
            E$1(Wf),
            E$1(H),
            Oh(),
            _ = k.flags,
            _ & 65536 && !(_ & 128) ? (k.flags = _ & -65537 | 128,
            k) : null;
        case 5:
            return Lh(k),
            null;
        case 13:
            if (E$1(M),
            _ = k.memoizedState,
            _ !== null && _.dehydrated !== null) {
                if (k.alternate === null)
                    throw Error(p$2(340));
                Ig()
            }
            return _ = k.flags,
            _ & 65536 ? (k.flags = _ & -65537 | 128,
            k) : null;
        case 19:
            return E$1(M),
            null;
        case 4:
            return Jh(),
            null;
        case 10:
            return Rg(k.type._context),
            null;
        case 22:
        case 23:
            return Ij(),
            null;
        case 24:
            return null;
        default:
            return null
        }
    }
    var Kj = !1
      , U$1 = !1
      , Lj = typeof WeakSet == "function" ? WeakSet : Set
      , V$1 = null;
    function Mj(_, k) {
        var J = _.ref;
        if (J !== null)
            if (typeof J == "function")
                try {
                    J(null)
                } catch (et) {
                    W(_, k, et)
                }
            else
                J.current = null
    }
    function Nj(_, k, J) {
        try {
            J()
        } catch (et) {
            W(_, k, et)
        }
    }
    var Oj = !1;
    function Pj(_, k) {
        if (Cf = dd,
        _ = Me(),
        Ne(_)) {
            if ("selectionStart"in _)
                var J = {
                    start: _.selectionStart,
                    end: _.selectionEnd
                };
            else
                e: {
                    J = (J = _.ownerDocument) && J.defaultView || window;
                    var et = J.getSelection && J.getSelection();
                    if (et && et.rangeCount !== 0) {
                        J = et.anchorNode;
                        var tt = et.anchorOffset
                          , rt = et.focusNode;
                        et = et.focusOffset;
                        try {
                            J.nodeType,
                            rt.nodeType
                        } catch (vt) {
                            J = null;
                            break e
                        }
                        var nt = 0
                          , ot = -1
                          , it = -1
                          , at = 0
                          , lt = 0
                          , st = _
                          , ut = null;
                        t: for (; ; ) {
                            for (var ct; st !== J || tt !== 0 && st.nodeType !== 3 || (ot = nt + tt),
                            st !== rt || et !== 0 && st.nodeType !== 3 || (it = nt + et),
                            st.nodeType === 3 && (nt += st.nodeValue.length),
                            (ct = st.firstChild) !== null; )
                                ut = st,
                                st = ct;
                            for (; ; ) {
                                if (st === _)
                                    break t;
                                if (ut === J && ++at === tt && (ot = nt),
                                ut === rt && ++lt === et && (it = nt),
                                (ct = st.nextSibling) !== null)
                                    break;
                                st = ut,
                                ut = st.parentNode
                            }
                            st = ct
                        }
                        J = ot === -1 || it === -1 ? null : {
                            start: ot,
                            end: it
                        }
                    } else
                        J = null
                }
            J = J || {
                start: 0,
                end: 0
            }
        } else
            J = null;
        for (Df = {
            focusedElem: _,
            selectionRange: J
        },
        dd = !1,
        V$1 = k; V$1 !== null; )
            if (k = V$1,
            _ = k.child,
            (k.subtreeFlags & 1028) !== 0 && _ !== null)
                _.return = k,
                V$1 = _;
            else
                for (; V$1 !== null; ) {
                    k = V$1;
                    try {
                        var pt = k.alternate;
                        if (k.flags & 1024)
                            switch (k.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (pt !== null) {
                                    var ft = pt.memoizedProps
                                      , yt = pt.memoizedState
                                      , ht = k.stateNode
                                      , gt = ht.getSnapshotBeforeUpdate(k.elementType === k.type ? ft : Lg(k.type, ft), yt);
                                    ht.__reactInternalSnapshotBeforeUpdate = gt
                                }
                                break;
                            case 3:
                                var mt = k.stateNode.containerInfo;
                                mt.nodeType === 1 ? mt.textContent = "" : mt.nodeType === 9 && mt.documentElement && mt.removeChild(mt.documentElement);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(p$2(163))
                            }
                    } catch (vt) {
                        W(k, k.return, vt)
                    }
                    if (_ = k.sibling,
                    _ !== null) {
                        _.return = k.return,
                        V$1 = _;
                        break
                    }
                    V$1 = k.return
                }
        return pt = Oj,
        Oj = !1,
        pt
    }
    function Qj(_, k, J) {
        var et = k.updateQueue;
        if (et = et !== null ? et.lastEffect : null,
        et !== null) {
            var tt = et = et.next;
            do {
                if ((tt.tag & _) === _) {
                    var rt = tt.destroy;
                    tt.destroy = void 0,
                    rt !== void 0 && Nj(k, J, rt)
                }
                tt = tt.next
            } while (tt !== et)
        }
    }
    function Rj(_, k) {
        if (k = k.updateQueue,
        k = k !== null ? k.lastEffect : null,
        k !== null) {
            var J = k = k.next;
            do {
                if ((J.tag & _) === _) {
                    var et = J.create;
                    J.destroy = et()
                }
                J = J.next
            } while (J !== k)
        }
    }
    function Sj(_) {
        var k = _.ref;
        if (k !== null) {
            var J = _.stateNode;
            switch (_.tag) {
            case 5:
                _ = J;
                break;
            default:
                _ = J
            }
            typeof k == "function" ? k(_) : k.current = _
        }
    }
    function Tj(_) {
        var k = _.alternate;
        k !== null && (_.alternate = null,
        Tj(k)),
        _.child = null,
        _.deletions = null,
        _.sibling = null,
        _.tag === 5 && (k = _.stateNode,
        k !== null && (delete k[Of],
        delete k[Pf],
        delete k[of],
        delete k[Qf],
        delete k[Rf])),
        _.stateNode = null,
        _.return = null,
        _.dependencies = null,
        _.memoizedProps = null,
        _.memoizedState = null,
        _.pendingProps = null,
        _.stateNode = null,
        _.updateQueue = null
    }
    function Uj(_) {
        return _.tag === 5 || _.tag === 3 || _.tag === 4
    }
    function Vj(_) {
        e: for (; ; ) {
            for (; _.sibling === null; ) {
                if (_.return === null || Uj(_.return))
                    return null;
                _ = _.return
            }
            for (_.sibling.return = _.return,
            _ = _.sibling; _.tag !== 5 && _.tag !== 6 && _.tag !== 18; ) {
                if (_.flags & 2 || _.child === null || _.tag === 4)
                    continue e;
                _.child.return = _,
                _ = _.child
            }
            if (!(_.flags & 2))
                return _.stateNode
        }
    }
    function Wj(_, k, J) {
        var et = _.tag;
        if (et === 5 || et === 6)
            _ = _.stateNode,
            k ? J.nodeType === 8 ? J.parentNode.insertBefore(_, k) : J.insertBefore(_, k) : (J.nodeType === 8 ? (k = J.parentNode,
            k.insertBefore(_, J)) : (k = J,
            k.appendChild(_)),
            J = J._reactRootContainer,
            J != null || k.onclick !== null || (k.onclick = Bf));
        else if (et !== 4 && (_ = _.child,
        _ !== null))
            for (Wj(_, k, J),
            _ = _.sibling; _ !== null; )
                Wj(_, k, J),
                _ = _.sibling
    }
    function Xj(_, k, J) {
        var et = _.tag;
        if (et === 5 || et === 6)
            _ = _.stateNode,
            k ? J.insertBefore(_, k) : J.appendChild(_);
        else if (et !== 4 && (_ = _.child,
        _ !== null))
            for (Xj(_, k, J),
            _ = _.sibling; _ !== null; )
                Xj(_, k, J),
                _ = _.sibling
    }
    var X = null
      , Yj = !1;
    function Zj(_, k, J) {
        for (J = J.child; J !== null; )
            ak(_, k, J),
            J = J.sibling
    }
    function ak(_, k, J) {
        if (lc && typeof lc.onCommitFiberUnmount == "function")
            try {
                lc.onCommitFiberUnmount(kc, J)
            } catch (ot) {}
        switch (J.tag) {
        case 5:
            U$1 || Mj(J, k);
        case 6:
            var et = X
              , tt = Yj;
            X = null,
            Zj(_, k, J),
            X = et,
            Yj = tt,
            X !== null && (Yj ? (_ = X,
            J = J.stateNode,
            _.nodeType === 8 ? _.parentNode.removeChild(J) : _.removeChild(J)) : X.removeChild(J.stateNode));
            break;
        case 18:
            X !== null && (Yj ? (_ = X,
            J = J.stateNode,
            _.nodeType === 8 ? Kf(_.parentNode, J) : _.nodeType === 1 && Kf(_, J),
            bd(_)) : Kf(X, J.stateNode));
            break;
        case 4:
            et = X,
            tt = Yj,
            X = J.stateNode.containerInfo,
            Yj = !0,
            Zj(_, k, J),
            X = et,
            Yj = tt;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!U$1 && (et = J.updateQueue,
            et !== null && (et = et.lastEffect,
            et !== null))) {
                tt = et = et.next;
                do {
                    var rt = tt
                      , nt = rt.destroy;
                    rt = rt.tag,
                    nt !== void 0 && (rt & 2 || rt & 4) && Nj(J, k, nt),
                    tt = tt.next
                } while (tt !== et)
            }
            Zj(_, k, J);
            break;
        case 1:
            if (!U$1 && (Mj(J, k),
            et = J.stateNode,
            typeof et.componentWillUnmount == "function"))
                try {
                    et.props = J.memoizedProps,
                    et.state = J.memoizedState,
                    et.componentWillUnmount()
                } catch (ot) {
                    W(J, k, ot)
                }
            Zj(_, k, J);
            break;
        case 21:
            Zj(_, k, J);
            break;
        case 22:
            J.mode & 1 ? (U$1 = (et = U$1) || J.memoizedState !== null,
            Zj(_, k, J),
            U$1 = et) : Zj(_, k, J);
            break;
        default:
            Zj(_, k, J)
        }
    }
    function bk(_) {
        var k = _.updateQueue;
        if (k !== null) {
            _.updateQueue = null;
            var J = _.stateNode;
            J === null && (J = _.stateNode = new Lj),
            k.forEach(function(et) {
                var tt = ck.bind(null, _, et);
                J.has(et) || (J.add(et),
                et.then(tt, tt))
            })
        }
    }
    function dk(_, k) {
        var J = k.deletions;
        if (J !== null)
            for (var et = 0; et < J.length; et++) {
                var tt = J[et];
                try {
                    var rt = _
                      , nt = k
                      , ot = nt;
                    e: for (; ot !== null; ) {
                        switch (ot.tag) {
                        case 5:
                            X = ot.stateNode,
                            Yj = !1;
                            break e;
                        case 3:
                            X = ot.stateNode.containerInfo,
                            Yj = !0;
                            break e;
                        case 4:
                            X = ot.stateNode.containerInfo,
                            Yj = !0;
                            break e
                        }
                        ot = ot.return
                    }
                    if (X === null)
                        throw Error(p$2(160));
                    ak(rt, nt, tt),
                    X = null,
                    Yj = !1;
                    var it = tt.alternate;
                    it !== null && (it.return = null),
                    tt.return = null
                } catch (at) {
                    W(tt, k, at)
                }
            }
        if (k.subtreeFlags & 12854)
            for (k = k.child; k !== null; )
                ek(k, _),
                k = k.sibling
    }
    function ek(_, k) {
        var J = _.alternate
          , et = _.flags;
        switch (_.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (dk(k, _),
            fk(_),
            et & 4) {
                try {
                    Qj(3, _, _.return),
                    Rj(3, _)
                } catch (ft) {
                    W(_, _.return, ft)
                }
                try {
                    Qj(5, _, _.return)
                } catch (ft) {
                    W(_, _.return, ft)
                }
            }
            break;
        case 1:
            dk(k, _),
            fk(_),
            et & 512 && J !== null && Mj(J, J.return);
            break;
        case 5:
            if (dk(k, _),
            fk(_),
            et & 512 && J !== null && Mj(J, J.return),
            _.flags & 32) {
                var tt = _.stateNode;
                try {
                    ob(tt, "")
                } catch (ft) {
                    W(_, _.return, ft)
                }
            }
            if (et & 4 && (tt = _.stateNode,
            tt != null)) {
                var rt = _.memoizedProps
                  , nt = J !== null ? J.memoizedProps : rt
                  , ot = _.type
                  , it = _.updateQueue;
                if (_.updateQueue = null,
                it !== null)
                    try {
                        ot === "input" && rt.type === "radio" && rt.name != null && ab(tt, rt),
                        vb(ot, nt);
                        var at = vb(ot, rt);
                        for (nt = 0; nt < it.length; nt += 2) {
                            var lt = it[nt]
                              , st = it[nt + 1];
                            lt === "style" ? sb(tt, st) : lt === "dangerouslySetInnerHTML" ? nb(tt, st) : lt === "children" ? ob(tt, st) : ta(tt, lt, st, at)
                        }
                        switch (ot) {
                        case "input":
                            bb(tt, rt);
                            break;
                        case "textarea":
                            ib(tt, rt);
                            break;
                        case "select":
                            var ut = tt._wrapperState.wasMultiple;
                            tt._wrapperState.wasMultiple = !!rt.multiple;
                            var ct = rt.value;
                            ct != null ? fb(tt, !!rt.multiple, ct, !1) : ut !== !!rt.multiple && (rt.defaultValue != null ? fb(tt, !!rt.multiple, rt.defaultValue, !0) : fb(tt, !!rt.multiple, rt.multiple ? [] : "", !1))
                        }
                        tt[Pf] = rt
                    } catch (ft) {
                        W(_, _.return, ft)
                    }
            }
            break;
        case 6:
            if (dk(k, _),
            fk(_),
            et & 4) {
                if (_.stateNode === null)
                    throw Error(p$2(162));
                tt = _.stateNode,
                rt = _.memoizedProps;
                try {
                    tt.nodeValue = rt
                } catch (ft) {
                    W(_, _.return, ft)
                }
            }
            break;
        case 3:
            if (dk(k, _),
            fk(_),
            et & 4 && J !== null && J.memoizedState.isDehydrated)
                try {
                    bd(k.containerInfo)
                } catch (ft) {
                    W(_, _.return, ft)
                }
            break;
        case 4:
            dk(k, _),
            fk(_);
            break;
        case 13:
            dk(k, _),
            fk(_),
            tt = _.child,
            tt.flags & 8192 && (rt = tt.memoizedState !== null,
            tt.stateNode.isHidden = rt,
            !rt || tt.alternate !== null && tt.alternate.memoizedState !== null || (gk = B$1())),
            et & 4 && bk(_);
            break;
        case 22:
            if (lt = J !== null && J.memoizedState !== null,
            _.mode & 1 ? (U$1 = (at = U$1) || lt,
            dk(k, _),
            U$1 = at) : dk(k, _),
            fk(_),
            et & 8192) {
                if (at = _.memoizedState !== null,
                (_.stateNode.isHidden = at) && !lt && _.mode & 1)
                    for (V$1 = _,
                    lt = _.child; lt !== null; ) {
                        for (st = V$1 = lt; V$1 !== null; ) {
                            switch (ut = V$1,
                            ct = ut.child,
                            ut.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                                Qj(4, ut, ut.return);
                                break;
                            case 1:
                                Mj(ut, ut.return);
                                var pt = ut.stateNode;
                                if (typeof pt.componentWillUnmount == "function") {
                                    et = ut,
                                    J = ut.return;
                                    try {
                                        k = et,
                                        pt.props = k.memoizedProps,
                                        pt.state = k.memoizedState,
                                        pt.componentWillUnmount()
                                    } catch (ft) {
                                        W(et, J, ft)
                                    }
                                }
                                break;
                            case 5:
                                Mj(ut, ut.return);
                                break;
                            case 22:
                                if (ut.memoizedState !== null) {
                                    hk(st);
                                    continue
                                }
                            }
                            ct !== null ? (ct.return = ut,
                            V$1 = ct) : hk(st)
                        }
                        lt = lt.sibling
                    }
                e: for (lt = null,
                st = _; ; ) {
                    if (st.tag === 5) {
                        if (lt === null) {
                            lt = st;
                            try {
                                tt = st.stateNode,
                                at ? (rt = tt.style,
                                typeof rt.setProperty == "function" ? rt.setProperty("display", "none", "important") : rt.display = "none") : (ot = st.stateNode,
                                it = st.memoizedProps.style,
                                nt = it != null && it.hasOwnProperty("display") ? it.display : null,
                                ot.style.display = rb("display", nt))
                            } catch (ft) {
                                W(_, _.return, ft)
                            }
                        }
                    } else if (st.tag === 6) {
                        if (lt === null)
                            try {
                                st.stateNode.nodeValue = at ? "" : st.memoizedProps
                            } catch (ft) {
                                W(_, _.return, ft)
                            }
                    } else if ((st.tag !== 22 && st.tag !== 23 || st.memoizedState === null || st === _) && st.child !== null) {
                        st.child.return = st,
                        st = st.child;
                        continue
                    }
                    if (st === _)
                        break e;
                    for (; st.sibling === null; ) {
                        if (st.return === null || st.return === _)
                            break e;
                        lt === st && (lt = null),
                        st = st.return
                    }
                    lt === st && (lt = null),
                    st.sibling.return = st.return,
                    st = st.sibling
                }
            }
            break;
        case 19:
            dk(k, _),
            fk(_),
            et & 4 && bk(_);
            break;
        case 21:
            break;
        default:
            dk(k, _),
            fk(_)
        }
    }
    function fk(_) {
        var k = _.flags;
        if (k & 2) {
            try {
                e: {
                    for (var J = _.return; J !== null; ) {
                        if (Uj(J)) {
                            var et = J;
                            break e
                        }
                        J = J.return
                    }
                    throw Error(p$2(160))
                }
                switch (et.tag) {
                case 5:
                    var tt = et.stateNode;
                    et.flags & 32 && (ob(tt, ""),
                    et.flags &= -33);
                    var rt = Vj(_);
                    Xj(_, rt, tt);
                    break;
                case 3:
                case 4:
                    var nt = et.stateNode.containerInfo
                      , ot = Vj(_);
                    Wj(_, ot, nt);
                    break;
                default:
                    throw Error(p$2(161))
                }
            } catch (it) {
                W(_, _.return, it)
            }
            _.flags &= -3
        }
        k & 4096 && (_.flags &= -4097)
    }
    function ik(_, k, J) {
        V$1 = _,
        jk(_)
    }
    function jk(_, k, J) {
        for (var et = (_.mode & 1) !== 0; V$1 !== null; ) {
            var tt = V$1
              , rt = tt.child;
            if (tt.tag === 22 && et) {
                var nt = tt.memoizedState !== null || Kj;
                if (!nt) {
                    var ot = tt.alternate
                      , it = ot !== null && ot.memoizedState !== null || U$1;
                    ot = Kj;
                    var at = U$1;
                    if (Kj = nt,
                    (U$1 = it) && !at)
                        for (V$1 = tt; V$1 !== null; )
                            nt = V$1,
                            it = nt.child,
                            nt.tag === 22 && nt.memoizedState !== null ? kk(tt) : it !== null ? (it.return = nt,
                            V$1 = it) : kk(tt);
                    for (; rt !== null; )
                        V$1 = rt,
                        jk(rt),
                        rt = rt.sibling;
                    V$1 = tt,
                    Kj = ot,
                    U$1 = at
                }
                lk(_)
            } else
                tt.subtreeFlags & 8772 && rt !== null ? (rt.return = tt,
                V$1 = rt) : lk(_)
        }
    }
    function lk(_) {
        for (; V$1 !== null; ) {
            var k = V$1;
            if (k.flags & 8772) {
                var J = k.alternate;
                try {
                    if (k.flags & 8772)
                        switch (k.tag) {
                        case 0:
                        case 11:
                        case 15:
                            U$1 || Rj(5, k);
                            break;
                        case 1:
                            var et = k.stateNode;
                            if (k.flags & 4 && !U$1)
                                if (J === null)
                                    et.componentDidMount();
                                else {
                                    var tt = k.elementType === k.type ? J.memoizedProps : Lg(k.type, J.memoizedProps);
                                    et.componentDidUpdate(tt, J.memoizedState, et.__reactInternalSnapshotBeforeUpdate)
                                }
                            var rt = k.updateQueue;
                            rt !== null && ih(k, rt, et);
                            break;
                        case 3:
                            var nt = k.updateQueue;
                            if (nt !== null) {
                                if (J = null,
                                k.child !== null)
                                    switch (k.child.tag) {
                                    case 5:
                                        J = k.child.stateNode;
                                        break;
                                    case 1:
                                        J = k.child.stateNode
                                    }
                                ih(k, nt, J)
                            }
                            break;
                        case 5:
                            var ot = k.stateNode;
                            if (J === null && k.flags & 4) {
                                J = ot;
                                var it = k.memoizedProps;
                                switch (k.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    it.autoFocus && J.focus();
                                    break;
                                case "img":
                                    it.src && (J.src = it.src)
                                }
                            }
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (k.memoizedState === null) {
                                var at = k.alternate;
                                if (at !== null) {
                                    var lt = at.memoizedState;
                                    if (lt !== null) {
                                        var st = lt.dehydrated;
                                        st !== null && bd(st)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                        case 25:
                            break;
                        default:
                            throw Error(p$2(163))
                        }
                    U$1 || k.flags & 512 && Sj(k)
                } catch (ut) {
                    W(k, k.return, ut)
                }
            }
            if (k === _) {
                V$1 = null;
                break
            }
            if (J = k.sibling,
            J !== null) {
                J.return = k.return,
                V$1 = J;
                break
            }
            V$1 = k.return
        }
    }
    function hk(_) {
        for (; V$1 !== null; ) {
            var k = V$1;
            if (k === _) {
                V$1 = null;
                break
            }
            var J = k.sibling;
            if (J !== null) {
                J.return = k.return,
                V$1 = J;
                break
            }
            V$1 = k.return
        }
    }
    function kk(_) {
        for (; V$1 !== null; ) {
            var k = V$1;
            try {
                switch (k.tag) {
                case 0:
                case 11:
                case 15:
                    var J = k.return;
                    try {
                        Rj(4, k)
                    } catch (it) {
                        W(k, J, it)
                    }
                    break;
                case 1:
                    var et = k.stateNode;
                    if (typeof et.componentDidMount == "function") {
                        var tt = k.return;
                        try {
                            et.componentDidMount()
                        } catch (it) {
                            W(k, tt, it)
                        }
                    }
                    var rt = k.return;
                    try {
                        Sj(k)
                    } catch (it) {
                        W(k, rt, it)
                    }
                    break;
                case 5:
                    var nt = k.return;
                    try {
                        Sj(k)
                    } catch (it) {
                        W(k, nt, it)
                    }
                }
            } catch (it) {
                W(k, k.return, it)
            }
            if (k === _) {
                V$1 = null;
                break
            }
            var ot = k.sibling;
            if (ot !== null) {
                ot.return = k.return,
                V$1 = ot;
                break
            }
            V$1 = k.return
        }
    }
    var mk = Math.ceil
      , nk = ua.ReactCurrentDispatcher
      , ok = ua.ReactCurrentOwner
      , pk = ua.ReactCurrentBatchConfig
      , K = 0
      , R$1 = null
      , Y = null
      , Z = 0
      , gj = 0
      , fj = Uf(0)
      , T$1 = 0
      , qk = null
      , hh = 0
      , rk = 0
      , sk = 0
      , tk = null
      , uk = null
      , gk = 0
      , Hj = 1 / 0
      , vk = null
      , Pi = !1
      , Qi = null
      , Si = null
      , wk = !1
      , xk = null
      , yk = 0
      , zk = 0
      , Ak = null
      , Bk = -1
      , Ck = 0;
    function L() {
        return K & 6 ? B$1() : Bk !== -1 ? Bk : Bk = B$1()
    }
    function lh(_) {
        return _.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Ck === 0 && (Ck = yc()),
        Ck) : (_ = C$1,
        _ !== 0 || (_ = window.event,
        _ = _ === void 0 ? 16 : jd(_.type)),
        _) : 1
    }
    function mh(_, k, J, et) {
        if (50 < zk)
            throw zk = 0,
            Ak = null,
            Error(p$2(185));
        Ac(_, J, et),
        (!(K & 2) || _ !== R$1) && (_ === R$1 && (!(K & 2) && (rk |= J),
        T$1 === 4 && Dk(_, Z)),
        Ek(_, et),
        J === 1 && K === 0 && !(k.mode & 1) && (Hj = B$1() + 500,
        fg && jg()))
    }
    function Ek(_, k) {
        var J = _.callbackNode;
        wc(_, k);
        var et = uc(_, _ === R$1 ? Z : 0);
        if (et === 0)
            J !== null && bc(J),
            _.callbackNode = null,
            _.callbackPriority = 0;
        else if (k = et & -et,
        _.callbackPriority !== k) {
            if (J != null && bc(J),
            k === 1)
                _.tag === 0 ? ig(Fk.bind(null, _)) : hg(Fk.bind(null, _)),
                Jf(function() {
                    !(K & 6) && jg()
                }),
                J = null;
            else {
                switch (Dc(et)) {
                case 1:
                    J = fc;
                    break;
                case 4:
                    J = gc;
                    break;
                case 16:
                    J = hc;
                    break;
                case 536870912:
                    J = jc;
                    break;
                default:
                    J = hc
                }
                J = Gk(J, Hk.bind(null, _))
            }
            _.callbackPriority = k,
            _.callbackNode = J
        }
    }
    function Hk(_, k) {
        if (Bk = -1,
        Ck = 0,
        K & 6)
            throw Error(p$2(327));
        var J = _.callbackNode;
        if (Ik() && _.callbackNode !== J)
            return null;
        var et = uc(_, _ === R$1 ? Z : 0);
        if (et === 0)
            return null;
        if (et & 30 || et & _.expiredLanes || k)
            k = Jk(_, et);
        else {
            k = et;
            var tt = K;
            K |= 2;
            var rt = Kk();
            (R$1 !== _ || Z !== k) && (vk = null,
            Hj = B$1() + 500,
            Lk(_, k));
            do
                try {
                    Mk();
                    break
                } catch (ot) {
                    Nk(_, ot)
                }
            while (1);
            Qg(),
            nk.current = rt,
            K = tt,
            Y !== null ? k = 0 : (R$1 = null,
            Z = 0,
            k = T$1)
        }
        if (k !== 0) {
            if (k === 2 && (tt = xc(_),
            tt !== 0 && (et = tt,
            k = Ok(_, tt))),
            k === 1)
                throw J = qk,
                Lk(_, 0),
                Dk(_, et),
                Ek(_, B$1()),
                J;
            if (k === 6)
                Dk(_, et);
            else {
                if (tt = _.current.alternate,
                !(et & 30) && !Pk(tt) && (k = Jk(_, et),
                k === 2 && (rt = xc(_),
                rt !== 0 && (et = rt,
                k = Ok(_, rt))),
                k === 1))
                    throw J = qk,
                    Lk(_, 0),
                    Dk(_, et),
                    Ek(_, B$1()),
                    J;
                switch (_.finishedWork = tt,
                _.finishedLanes = et,
                k) {
                case 0:
                case 1:
                    throw Error(p$2(345));
                case 2:
                    Qk(_, uk, vk);
                    break;
                case 3:
                    if (Dk(_, et),
                    (et & 130023424) === et && (k = gk + 500 - B$1(),
                    10 < k)) {
                        if (uc(_, 0) !== 0)
                            break;
                        if (tt = _.suspendedLanes,
                        (tt & et) !== et) {
                            L(),
                            _.pingedLanes |= _.suspendedLanes & tt;
                            break
                        }
                        _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), k);
                        break
                    }
                    Qk(_, uk, vk);
                    break;
                case 4:
                    if (Dk(_, et),
                    (et & 4194240) === et)
                        break;
                    for (k = _.eventTimes,
                    tt = -1; 0 < et; ) {
                        var nt = 31 - oc(et);
                        rt = 1 << nt,
                        nt = k[nt],
                        nt > tt && (tt = nt),
                        et &= ~rt
                    }
                    if (et = tt,
                    et = B$1() - et,
                    et = (120 > et ? 120 : 480 > et ? 480 : 1080 > et ? 1080 : 1920 > et ? 1920 : 3e3 > et ? 3e3 : 4320 > et ? 4320 : 1960 * mk(et / 1960)) - et,
                    10 < et) {
                        _.timeoutHandle = Ff(Qk.bind(null, _, uk, vk), et);
                        break
                    }
                    Qk(_, uk, vk);
                    break;
                case 5:
                    Qk(_, uk, vk);
                    break;
                default:
                    throw Error(p$2(329))
                }
            }
        }
        return Ek(_, B$1()),
        _.callbackNode === J ? Hk.bind(null, _) : null
    }
    function Ok(_, k) {
        var J = tk;
        return _.current.memoizedState.isDehydrated && (Lk(_, k).flags |= 256),
        _ = Jk(_, k),
        _ !== 2 && (k = uk,
        uk = J,
        k !== null && Gj(k)),
        _
    }
    function Gj(_) {
        uk === null ? uk = _ : uk.push.apply(uk, _)
    }
    function Pk(_) {
        for (var k = _; ; ) {
            if (k.flags & 16384) {
                var J = k.updateQueue;
                if (J !== null && (J = J.stores,
                J !== null))
                    for (var et = 0; et < J.length; et++) {
                        var tt = J[et]
                          , rt = tt.getSnapshot;
                        tt = tt.value;
                        try {
                            if (!He(rt(), tt))
                                return !1
                        } catch (nt) {
                            return !1
                        }
                    }
            }
            if (J = k.child,
            k.subtreeFlags & 16384 && J !== null)
                J.return = k,
                k = J;
            else {
                if (k === _)
                    break;
                for (; k.sibling === null; ) {
                    if (k.return === null || k.return === _)
                        return !0;
                    k = k.return
                }
                k.sibling.return = k.return,
                k = k.sibling
            }
        }
        return !0
    }
    function Dk(_, k) {
        for (k &= ~sk,
        k &= ~rk,
        _.suspendedLanes |= k,
        _.pingedLanes &= ~k,
        _ = _.expirationTimes; 0 < k; ) {
            var J = 31 - oc(k)
              , et = 1 << J;
            _[J] = -1,
            k &= ~et
        }
    }
    function Fk(_) {
        if (K & 6)
            throw Error(p$2(327));
        Ik();
        var k = uc(_, 0);
        if (!(k & 1))
            return Ek(_, B$1()),
            null;
        var J = Jk(_, k);
        if (_.tag !== 0 && J === 2) {
            var et = xc(_);
            et !== 0 && (k = et,
            J = Ok(_, et))
        }
        if (J === 1)
            throw J = qk,
            Lk(_, 0),
            Dk(_, k),
            Ek(_, B$1()),
            J;
        if (J === 6)
            throw Error(p$2(345));
        return _.finishedWork = _.current.alternate,
        _.finishedLanes = k,
        Qk(_, uk, vk),
        Ek(_, B$1()),
        null
    }
    function Rk(_, k) {
        var J = K;
        K |= 1;
        try {
            return _(k)
        } finally {
            K = J,
            K === 0 && (Hj = B$1() + 500,
            fg && jg())
        }
    }
    function Sk(_) {
        xk !== null && xk.tag === 0 && !(K & 6) && Ik();
        var k = K;
        K |= 1;
        var J = pk.transition
          , et = C$1;
        try {
            if (pk.transition = null,
            C$1 = 1,
            _)
                return _()
        } finally {
            C$1 = et,
            pk.transition = J,
            K = k,
            !(K & 6) && jg()
        }
    }
    function Ij() {
        gj = fj.current,
        E$1(fj)
    }
    function Lk(_, k) {
        _.finishedWork = null,
        _.finishedLanes = 0;
        var J = _.timeoutHandle;
        if (J !== -1 && (_.timeoutHandle = -1,
        Gf(J)),
        Y !== null)
            for (J = Y.return; J !== null; ) {
                var et = J;
                switch (wg(et),
                et.tag) {
                case 1:
                    et = et.type.childContextTypes,
                    et != null && $f();
                    break;
                case 3:
                    Jh(),
                    E$1(Wf),
                    E$1(H),
                    Oh();
                    break;
                case 5:
                    Lh(et);
                    break;
                case 4:
                    Jh();
                    break;
                case 13:
                    E$1(M);
                    break;
                case 19:
                    E$1(M);
                    break;
                case 10:
                    Rg(et.type._context);
                    break;
                case 22:
                case 23:
                    Ij()
                }
                J = J.return
            }
        if (R$1 = _,
        Y = _ = wh(_.current, null),
        Z = gj = k,
        T$1 = 0,
        qk = null,
        sk = rk = hh = 0,
        uk = tk = null,
        Wg !== null) {
            for (k = 0; k < Wg.length; k++)
                if (J = Wg[k],
                et = J.interleaved,
                et !== null) {
                    J.interleaved = null;
                    var tt = et.next
                      , rt = J.pending;
                    if (rt !== null) {
                        var nt = rt.next;
                        rt.next = tt,
                        et.next = nt
                    }
                    J.pending = et
                }
            Wg = null
        }
        return _
    }
    function Nk(_, k) {
        do {
            var J = Y;
            try {
                if (Qg(),
                Ph.current = ai,
                Sh) {
                    for (var et = N.memoizedState; et !== null; ) {
                        var tt = et.queue;
                        tt !== null && (tt.pending = null),
                        et = et.next
                    }
                    Sh = !1
                }
                if (Rh = 0,
                P$2 = O$1 = N = null,
                Th = !1,
                Uh = 0,
                ok.current = null,
                J === null || J.return === null) {
                    T$1 = 1,
                    qk = k,
                    Y = null;
                    break
                }
                e: {
                    var rt = _
                      , nt = J.return
                      , ot = J
                      , it = k;
                    if (k = Z,
                    ot.flags |= 32768,
                    it !== null && typeof it == "object" && typeof it.then == "function") {
                        var at = it
                          , lt = ot
                          , st = lt.tag;
                        if (!(lt.mode & 1) && (st === 0 || st === 11 || st === 15)) {
                            var ut = lt.alternate;
                            ut ? (lt.updateQueue = ut.updateQueue,
                            lt.memoizedState = ut.memoizedState,
                            lt.lanes = ut.lanes) : (lt.updateQueue = null,
                            lt.memoizedState = null)
                        }
                        var ct = Vi(nt);
                        if (ct !== null) {
                            ct.flags &= -257,
                            Wi(ct, nt, ot, rt, k),
                            ct.mode & 1 && Ti(rt, at, k),
                            k = ct,
                            it = at;
                            var pt = k.updateQueue;
                            if (pt === null) {
                                var ft = new Set;
                                ft.add(it),
                                k.updateQueue = ft
                            } else
                                pt.add(it);
                            break e
                        } else {
                            if (!(k & 1)) {
                                Ti(rt, at, k),
                                uj();
                                break e
                            }
                            it = Error(p$2(426))
                        }
                    } else if (I && ot.mode & 1) {
                        var yt = Vi(nt);
                        if (yt !== null) {
                            !(yt.flags & 65536) && (yt.flags |= 256),
                            Wi(yt, nt, ot, rt, k),
                            Jg(Ki(it, ot));
                            break e
                        }
                    }
                    rt = it = Ki(it, ot),
                    T$1 !== 4 && (T$1 = 2),
                    tk === null ? tk = [rt] : tk.push(rt),
                    rt = nt;
                    do {
                        switch (rt.tag) {
                        case 3:
                            rt.flags |= 65536,
                            k &= -k,
                            rt.lanes |= k;
                            var ht = Oi(rt, it, k);
                            fh(rt, ht);
                            break e;
                        case 1:
                            ot = it;
                            var gt = rt.type
                              , mt = rt.stateNode;
                            if (!(rt.flags & 128) && (typeof gt.getDerivedStateFromError == "function" || mt !== null && typeof mt.componentDidCatch == "function" && (Si === null || !Si.has(mt)))) {
                                rt.flags |= 65536,
                                k &= -k,
                                rt.lanes |= k;
                                var vt = Ri(rt, ot, k);
                                fh(rt, vt);
                                break e
                            }
                        }
                        rt = rt.return
                    } while (rt !== null)
                }
                Tk(J)
            } catch (bt) {
                k = bt,
                Y === J && J !== null && (Y = J = J.return);
                continue
            }
            break
        } while (1)
    }
    function Kk() {
        var _ = nk.current;
        return nk.current = ai,
        _ === null ? ai : _
    }
    function uj() {
        (T$1 === 0 || T$1 === 3 || T$1 === 2) && (T$1 = 4),
        R$1 === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R$1, Z)
    }
    function Jk(_, k) {
        var J = K;
        K |= 2;
        var et = Kk();
        (R$1 !== _ || Z !== k) && (vk = null,
        Lk(_, k));
        do
            try {
                Uk();
                break
            } catch (tt) {
                Nk(_, tt)
            }
        while (1);
        if (Qg(),
        K = J,
        nk.current = et,
        Y !== null)
            throw Error(p$2(261));
        return R$1 = null,
        Z = 0,
        T$1
    }
    function Uk() {
        for (; Y !== null; )
            Vk(Y)
    }
    function Mk() {
        for (; Y !== null && !cc(); )
            Vk(Y)
    }
    function Vk(_) {
        var k = Wk(_.alternate, _, gj);
        _.memoizedProps = _.pendingProps,
        k === null ? Tk(_) : Y = k,
        ok.current = null
    }
    function Tk(_) {
        var k = _;
        do {
            var J = k.alternate;
            if (_ = k.return,
            k.flags & 32768) {
                if (J = Jj(J, k),
                J !== null) {
                    J.flags &= 32767,
                    Y = J;
                    return
                }
                if (_ !== null)
                    _.flags |= 32768,
                    _.subtreeFlags = 0,
                    _.deletions = null;
                else {
                    T$1 = 6,
                    Y = null;
                    return
                }
            } else if (J = Fj(J, k, gj),
            J !== null) {
                Y = J;
                return
            }
            if (k = k.sibling,
            k !== null) {
                Y = k;
                return
            }
            Y = k = _
        } while (k !== null);
        T$1 === 0 && (T$1 = 5)
    }
    function Qk(_, k, J) {
        var et = C$1
          , tt = pk.transition;
        try {
            pk.transition = null,
            C$1 = 1,
            Xk(_, k, J, et)
        } finally {
            pk.transition = tt,
            C$1 = et
        }
        return null
    }
    function Xk(_, k, J, et) {
        do
            Ik();
        while (xk !== null);
        if (K & 6)
            throw Error(p$2(327));
        J = _.finishedWork;
        var tt = _.finishedLanes;
        if (J === null)
            return null;
        if (_.finishedWork = null,
        _.finishedLanes = 0,
        J === _.current)
            throw Error(p$2(177));
        _.callbackNode = null,
        _.callbackPriority = 0;
        var rt = J.lanes | J.childLanes;
        if (Bc(_, rt),
        _ === R$1 && (Y = R$1 = null,
        Z = 0),
        !(J.subtreeFlags & 2064) && !(J.flags & 2064) || wk || (wk = !0,
        Gk(hc, function() {
            return Ik(),
            null
        })),
        rt = (J.flags & 15990) !== 0,
        J.subtreeFlags & 15990 || rt) {
            rt = pk.transition,
            pk.transition = null;
            var nt = C$1;
            C$1 = 1;
            var ot = K;
            K |= 4,
            ok.current = null,
            Pj(_, J),
            ek(J, _),
            Oe$1(Df),
            dd = !!Cf,
            Df = Cf = null,
            _.current = J,
            ik(J),
            dc(),
            K = ot,
            C$1 = nt,
            pk.transition = rt
        } else
            _.current = J;
        if (wk && (wk = !1,
        xk = _,
        yk = tt),
        rt = _.pendingLanes,
        rt === 0 && (Si = null),
        mc(J.stateNode),
        Ek(_, B$1()),
        k !== null)
            for (et = _.onRecoverableError,
            J = 0; J < k.length; J++)
                tt = k[J],
                et(tt.value, {
                    componentStack: tt.stack,
                    digest: tt.digest
                });
        if (Pi)
            throw Pi = !1,
            _ = Qi,
            Qi = null,
            _;
        return yk & 1 && _.tag !== 0 && Ik(),
        rt = _.pendingLanes,
        rt & 1 ? _ === Ak ? zk++ : (zk = 0,
        Ak = _) : zk = 0,
        jg(),
        null
    }
    function Ik() {
        if (xk !== null) {
            var _ = Dc(yk)
              , k = pk.transition
              , J = C$1;
            try {
                if (pk.transition = null,
                C$1 = 16 > _ ? 16 : _,
                xk === null)
                    var et = !1;
                else {
                    if (_ = xk,
                    xk = null,
                    yk = 0,
                    K & 6)
                        throw Error(p$2(331));
                    var tt = K;
                    for (K |= 4,
                    V$1 = _.current; V$1 !== null; ) {
                        var rt = V$1
                          , nt = rt.child;
                        if (V$1.flags & 16) {
                            var ot = rt.deletions;
                            if (ot !== null) {
                                for (var it = 0; it < ot.length; it++) {
                                    var at = ot[it];
                                    for (V$1 = at; V$1 !== null; ) {
                                        var lt = V$1;
                                        switch (lt.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Qj(8, lt, rt)
                                        }
                                        var st = lt.child;
                                        if (st !== null)
                                            st.return = lt,
                                            V$1 = st;
                                        else
                                            for (; V$1 !== null; ) {
                                                lt = V$1;
                                                var ut = lt.sibling
                                                  , ct = lt.return;
                                                if (Tj(lt),
                                                lt === at) {
                                                    V$1 = null;
                                                    break
                                                }
                                                if (ut !== null) {
                                                    ut.return = ct,
                                                    V$1 = ut;
                                                    break
                                                }
                                                V$1 = ct
                                            }
                                    }
                                }
                                var pt = rt.alternate;
                                if (pt !== null) {
                                    var ft = pt.child;
                                    if (ft !== null) {
                                        pt.child = null;
                                        do {
                                            var yt = ft.sibling;
                                            ft.sibling = null,
                                            ft = yt
                                        } while (ft !== null)
                                    }
                                }
                                V$1 = rt
                            }
                        }
                        if (rt.subtreeFlags & 2064 && nt !== null)
                            nt.return = rt,
                            V$1 = nt;
                        else
                            e: for (; V$1 !== null; ) {
                                if (rt = V$1,
                                rt.flags & 2048)
                                    switch (rt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, rt, rt.return)
                                    }
                                var ht = rt.sibling;
                                if (ht !== null) {
                                    ht.return = rt.return,
                                    V$1 = ht;
                                    break e
                                }
                                V$1 = rt.return
                            }
                    }
                    var gt = _.current;
                    for (V$1 = gt; V$1 !== null; ) {
                        nt = V$1;
                        var mt = nt.child;
                        if (nt.subtreeFlags & 2064 && mt !== null)
                            mt.return = nt,
                            V$1 = mt;
                        else
                            e: for (nt = gt; V$1 !== null; ) {
                                if (ot = V$1,
                                ot.flags & 2048)
                                    try {
                                        switch (ot.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            Rj(9, ot)
                                        }
                                    } catch (bt) {
                                        W(ot, ot.return, bt)
                                    }
                                if (ot === nt) {
                                    V$1 = null;
                                    break e
                                }
                                var vt = ot.sibling;
                                if (vt !== null) {
                                    vt.return = ot.return,
                                    V$1 = vt;
                                    break e
                                }
                                V$1 = ot.return
                            }
                    }
                    if (K = tt,
                    jg(),
                    lc && typeof lc.onPostCommitFiberRoot == "function")
                        try {
                            lc.onPostCommitFiberRoot(kc, _)
                        } catch (bt) {}
                    et = !0
                }
                return et
            } finally {
                C$1 = J,
                pk.transition = k
            }
        }
        return !1
    }
    function Yk(_, k, J) {
        k = Ki(J, k),
        k = Oi(_, k, 1),
        _ = dh(_, k, 1),
        k = L(),
        _ !== null && (Ac(_, 1, k),
        Ek(_, k))
    }
    function W(_, k, J) {
        if (_.tag === 3)
            Yk(_, _, J);
        else
            for (; k !== null; ) {
                if (k.tag === 3) {
                    Yk(k, _, J);
                    break
                } else if (k.tag === 1) {
                    var et = k.stateNode;
                    if (typeof k.type.getDerivedStateFromError == "function" || typeof et.componentDidCatch == "function" && (Si === null || !Si.has(et))) {
                        _ = Ki(J, _),
                        _ = Ri(k, _, 1),
                        k = dh(k, _, 1),
                        _ = L(),
                        k !== null && (Ac(k, 1, _),
                        Ek(k, _));
                        break
                    }
                }
                k = k.return
            }
    }
    function Ui(_, k, J) {
        var et = _.pingCache;
        et !== null && et.delete(k),
        k = L(),
        _.pingedLanes |= _.suspendedLanes & J,
        R$1 === _ && (Z & J) === J && (T$1 === 4 || T$1 === 3 && (Z & 130023424) === Z && 500 > B$1() - gk ? Lk(_, 0) : sk |= J),
        Ek(_, k)
    }
    function Zk(_, k) {
        k === 0 && (_.mode & 1 ? (k = sc,
        sc <<= 1,
        !(sc & 130023424) && (sc = 4194304)) : k = 1);
        var J = L();
        _ = Zg(_, k),
        _ !== null && (Ac(_, k, J),
        Ek(_, J))
    }
    function vj(_) {
        var k = _.memoizedState
          , J = 0;
        k !== null && (J = k.retryLane),
        Zk(_, J)
    }
    function ck(_, k) {
        var J = 0;
        switch (_.tag) {
        case 13:
            var et = _.stateNode
              , tt = _.memoizedState;
            tt !== null && (J = tt.retryLane);
            break;
        case 19:
            et = _.stateNode;
            break;
        default:
            throw Error(p$2(314))
        }
        et !== null && et.delete(k),
        Zk(_, J)
    }
    var Wk;
    Wk = function(_, k, J) {
        if (_ !== null)
            if (_.memoizedProps !== k.pendingProps || Wf.current)
                Ug = !0;
            else {
                if (!(_.lanes & J) && !(k.flags & 128))
                    return Ug = !1,
                    zj(_, k, J);
                Ug = !!(_.flags & 131072)
            }
        else
            Ug = !1,
            I && k.flags & 1048576 && ug(k, ng, k.index);
        switch (k.lanes = 0,
        k.tag) {
        case 2:
            var et = k.type;
            jj(_, k),
            _ = k.pendingProps;
            var tt = Yf(k, H.current);
            Tg(k, J),
            tt = Xh(null, k, et, _, tt, J);
            var rt = bi();
            return k.flags |= 1,
            typeof tt == "object" && tt !== null && typeof tt.render == "function" && tt.$$typeof === void 0 ? (k.tag = 1,
            k.memoizedState = null,
            k.updateQueue = null,
            Zf(et) ? (rt = !0,
            cg(k)) : rt = !1,
            k.memoizedState = tt.state !== null && tt.state !== void 0 ? tt.state : null,
            ah(k),
            tt.updater = nh,
            k.stateNode = tt,
            tt._reactInternals = k,
            rh(k, et, _, J),
            k = kj(null, k, et, !0, rt, J)) : (k.tag = 0,
            I && rt && vg(k),
            Yi(null, k, tt, J),
            k = k.child),
            k;
        case 16:
            et = k.elementType;
            e: {
                switch (jj(_, k),
                _ = k.pendingProps,
                tt = et._init,
                et = tt(et._payload),
                k.type = et,
                tt = k.tag = $k(et),
                _ = Lg(et, _),
                tt) {
                case 0:
                    k = dj(null, k, et, _, J);
                    break e;
                case 1:
                    k = ij(null, k, et, _, J);
                    break e;
                case 11:
                    k = Zi(null, k, et, _, J);
                    break e;
                case 14:
                    k = aj(null, k, et, Lg(et.type, _), J);
                    break e
                }
                throw Error(p$2(306, et, ""))
            }
            return k;
        case 0:
            return et = k.type,
            tt = k.pendingProps,
            tt = k.elementType === et ? tt : Lg(et, tt),
            dj(_, k, et, tt, J);
        case 1:
            return et = k.type,
            tt = k.pendingProps,
            tt = k.elementType === et ? tt : Lg(et, tt),
            ij(_, k, et, tt, J);
        case 3:
            e: {
                if (lj(k),
                _ === null)
                    throw Error(p$2(387));
                et = k.pendingProps,
                rt = k.memoizedState,
                tt = rt.element,
                bh(_, k),
                gh(k, et, null, J);
                var nt = k.memoizedState;
                if (et = nt.element,
                rt.isDehydrated)
                    if (rt = {
                        element: et,
                        isDehydrated: !1,
                        cache: nt.cache,
                        pendingSuspenseBoundaries: nt.pendingSuspenseBoundaries,
                        transitions: nt.transitions
                    },
                    k.updateQueue.baseState = rt,
                    k.memoizedState = rt,
                    k.flags & 256) {
                        tt = Ki(Error(p$2(423)), k),
                        k = mj(_, k, et, J, tt);
                        break e
                    } else if (et !== tt) {
                        tt = Ki(Error(p$2(424)), k),
                        k = mj(_, k, et, J, tt);
                        break e
                    } else
                        for (yg = Lf(k.stateNode.containerInfo.firstChild),
                        xg = k,
                        I = !0,
                        zg = null,
                        J = Ch(k, null, et, J),
                        k.child = J; J; )
                            J.flags = J.flags & -3 | 4096,
                            J = J.sibling;
                else {
                    if (Ig(),
                    et === tt) {
                        k = $i(_, k, J);
                        break e
                    }
                    Yi(_, k, et, J)
                }
                k = k.child
            }
            return k;
        case 5:
            return Kh(k),
            _ === null && Eg(k),
            et = k.type,
            tt = k.pendingProps,
            rt = _ !== null ? _.memoizedProps : null,
            nt = tt.children,
            Ef(et, tt) ? nt = null : rt !== null && Ef(et, rt) && (k.flags |= 32),
            hj(_, k),
            Yi(_, k, nt, J),
            k.child;
        case 6:
            return _ === null && Eg(k),
            null;
        case 13:
            return pj(_, k, J);
        case 4:
            return Ih(k, k.stateNode.containerInfo),
            et = k.pendingProps,
            _ === null ? k.child = Bh(k, null, et, J) : Yi(_, k, et, J),
            k.child;
        case 11:
            return et = k.type,
            tt = k.pendingProps,
            tt = k.elementType === et ? tt : Lg(et, tt),
            Zi(_, k, et, tt, J);
        case 7:
            return Yi(_, k, k.pendingProps, J),
            k.child;
        case 8:
            return Yi(_, k, k.pendingProps.children, J),
            k.child;
        case 12:
            return Yi(_, k, k.pendingProps.children, J),
            k.child;
        case 10:
            e: {
                if (et = k.type._context,
                tt = k.pendingProps,
                rt = k.memoizedProps,
                nt = tt.value,
                G(Mg, et._currentValue),
                et._currentValue = nt,
                rt !== null)
                    if (He(rt.value, nt)) {
                        if (rt.children === tt.children && !Wf.current) {
                            k = $i(_, k, J);
                            break e
                        }
                    } else
                        for (rt = k.child,
                        rt !== null && (rt.return = k); rt !== null; ) {
                            var ot = rt.dependencies;
                            if (ot !== null) {
                                nt = rt.child;
                                for (var it = ot.firstContext; it !== null; ) {
                                    if (it.context === et) {
                                        if (rt.tag === 1) {
                                            it = ch(-1, J & -J),
                                            it.tag = 2;
                                            var at = rt.updateQueue;
                                            if (at !== null) {
                                                at = at.shared;
                                                var lt = at.pending;
                                                lt === null ? it.next = it : (it.next = lt.next,
                                                lt.next = it),
                                                at.pending = it
                                            }
                                        }
                                        rt.lanes |= J,
                                        it = rt.alternate,
                                        it !== null && (it.lanes |= J),
                                        Sg(rt.return, J, k),
                                        ot.lanes |= J;
                                        break
                                    }
                                    it = it.next
                                }
                            } else if (rt.tag === 10)
                                nt = rt.type === k.type ? null : rt.child;
                            else if (rt.tag === 18) {
                                if (nt = rt.return,
                                nt === null)
                                    throw Error(p$2(341));
                                nt.lanes |= J,
                                ot = nt.alternate,
                                ot !== null && (ot.lanes |= J),
                                Sg(nt, J, k),
                                nt = rt.sibling
                            } else
                                nt = rt.child;
                            if (nt !== null)
                                nt.return = rt;
                            else
                                for (nt = rt; nt !== null; ) {
                                    if (nt === k) {
                                        nt = null;
                                        break
                                    }
                                    if (rt = nt.sibling,
                                    rt !== null) {
                                        rt.return = nt.return,
                                        nt = rt;
                                        break
                                    }
                                    nt = nt.return
                                }
                            rt = nt
                        }
                Yi(_, k, tt.children, J),
                k = k.child
            }
            return k;
        case 9:
            return tt = k.type,
            et = k.pendingProps.children,
            Tg(k, J),
            tt = Vg(tt),
            et = et(tt),
            k.flags |= 1,
            Yi(_, k, et, J),
            k.child;
        case 14:
            return et = k.type,
            tt = Lg(et, k.pendingProps),
            tt = Lg(et.type, tt),
            aj(_, k, et, tt, J);
        case 15:
            return cj(_, k, k.type, k.pendingProps, J);
        case 17:
            return et = k.type,
            tt = k.pendingProps,
            tt = k.elementType === et ? tt : Lg(et, tt),
            jj(_, k),
            k.tag = 1,
            Zf(et) ? (_ = !0,
            cg(k)) : _ = !1,
            Tg(k, J),
            ph(k, et, tt),
            rh(k, et, tt, J),
            kj(null, k, et, !0, _, J);
        case 19:
            return yj(_, k, J);
        case 22:
            return ej(_, k, J)
        }
        throw Error(p$2(156, k.tag))
    }
    ;
    function Gk(_, k) {
        return ac(_, k)
    }
    function al(_, k, J, et) {
        this.tag = _,
        this.key = J,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.ref = null,
        this.pendingProps = k,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = et,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Bg(_, k, J, et) {
        return new al(_,k,J,et)
    }
    function bj(_) {
        return _ = _.prototype,
        !(!_ || !_.isReactComponent)
    }
    function $k(_) {
        if (typeof _ == "function")
            return bj(_) ? 1 : 0;
        if (_ != null) {
            if (_ = _.$$typeof,
            _ === Da)
                return 11;
            if (_ === Ga)
                return 14
        }
        return 2
    }
    function wh(_, k) {
        var J = _.alternate;
        return J === null ? (J = Bg(_.tag, k, _.key, _.mode),
        J.elementType = _.elementType,
        J.type = _.type,
        J.stateNode = _.stateNode,
        J.alternate = _,
        _.alternate = J) : (J.pendingProps = k,
        J.type = _.type,
        J.flags = 0,
        J.subtreeFlags = 0,
        J.deletions = null),
        J.flags = _.flags & 14680064,
        J.childLanes = _.childLanes,
        J.lanes = _.lanes,
        J.child = _.child,
        J.memoizedProps = _.memoizedProps,
        J.memoizedState = _.memoizedState,
        J.updateQueue = _.updateQueue,
        k = _.dependencies,
        J.dependencies = k === null ? null : {
            lanes: k.lanes,
            firstContext: k.firstContext
        },
        J.sibling = _.sibling,
        J.index = _.index,
        J.ref = _.ref,
        J
    }
    function yh(_, k, J, et, tt, rt) {
        var nt = 2;
        if (et = _,
        typeof _ == "function")
            bj(_) && (nt = 1);
        else if (typeof _ == "string")
            nt = 5;
        else
            e: switch (_) {
            case ya:
                return Ah(J.children, tt, rt, k);
            case za:
                nt = 8,
                tt |= 8;
                break;
            case Aa:
                return _ = Bg(12, J, k, tt | 2),
                _.elementType = Aa,
                _.lanes = rt,
                _;
            case Ea:
                return _ = Bg(13, J, k, tt),
                _.elementType = Ea,
                _.lanes = rt,
                _;
            case Fa:
                return _ = Bg(19, J, k, tt),
                _.elementType = Fa,
                _.lanes = rt,
                _;
            case Ia:
                return qj(J, tt, rt, k);
            default:
                if (typeof _ == "object" && _ !== null)
                    switch (_.$$typeof) {
                    case Ba:
                        nt = 10;
                        break e;
                    case Ca:
                        nt = 9;
                        break e;
                    case Da:
                        nt = 11;
                        break e;
                    case Ga:
                        nt = 14;
                        break e;
                    case Ha:
                        nt = 16,
                        et = null;
                        break e
                    }
                throw Error(p$2(130, _ == null ? _ : typeof _, ""))
            }
        return k = Bg(nt, J, k, tt),
        k.elementType = _,
        k.type = et,
        k.lanes = rt,
        k
    }
    function Ah(_, k, J, et) {
        return _ = Bg(7, _, et, k),
        _.lanes = J,
        _
    }
    function qj(_, k, J, et) {
        return _ = Bg(22, _, et, k),
        _.elementType = Ia,
        _.lanes = J,
        _.stateNode = {
            isHidden: !1
        },
        _
    }
    function xh(_, k, J) {
        return _ = Bg(6, _, null, k),
        _.lanes = J,
        _
    }
    function zh(_, k, J) {
        return k = Bg(4, _.children !== null ? _.children : [], _.key, k),
        k.lanes = J,
        k.stateNode = {
            containerInfo: _.containerInfo,
            pendingChildren: null,
            implementation: _.implementation
        },
        k
    }
    function bl(_, k, J, et, tt) {
        this.tag = k,
        this.containerInfo = _,
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.pendingContext = this.context = null,
        this.callbackPriority = 0,
        this.eventTimes = zc(0),
        this.expirationTimes = zc(-1),
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = zc(0),
        this.identifierPrefix = et,
        this.onRecoverableError = tt,
        this.mutableSourceEagerHydrationData = null
    }
    function cl(_, k, J, et, tt, rt, nt, ot, it) {
        return _ = new bl(_,k,J,ot,it),
        k === 1 ? (k = 1,
        rt === !0 && (k |= 8)) : k = 0,
        rt = Bg(3, null, null, k),
        _.current = rt,
        rt.stateNode = _,
        rt.memoizedState = {
            element: et,
            isDehydrated: J,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
        },
        ah(rt),
        _
    }
    function dl(_, k, J) {
        var et = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: wa,
            key: et == null ? null : "" + et,
            children: _,
            containerInfo: k,
            implementation: J
        }
    }
    function el(_) {
        if (!_)
            return Vf;
        _ = _._reactInternals;
        e: {
            if (Vb(_) !== _ || _.tag !== 1)
                throw Error(p$2(170));
            var k = _;
            do {
                switch (k.tag) {
                case 3:
                    k = k.stateNode.context;
                    break e;
                case 1:
                    if (Zf(k.type)) {
                        k = k.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
                }
                k = k.return
            } while (k !== null);
            throw Error(p$2(171))
        }
        if (_.tag === 1) {
            var J = _.type;
            if (Zf(J))
                return bg(_, J, k)
        }
        return k
    }
    function fl(_, k, J, et, tt, rt, nt, ot, it) {
        return _ = cl(J, et, !0, _, tt, rt, nt, ot, it),
        _.context = el(null),
        J = _.current,
        et = L(),
        tt = lh(J),
        rt = ch(et, tt),
        rt.callback = k != null ? k : null,
        dh(J, rt, tt),
        _.current.lanes = tt,
        Ac(_, tt, et),
        Ek(_, et),
        _
    }
    function gl(_, k, J, et) {
        var tt = k.current
          , rt = L()
          , nt = lh(tt);
        return J = el(J),
        k.context === null ? k.context = J : k.pendingContext = J,
        k = ch(rt, nt),
        k.payload = {
            element: _
        },
        et = et === void 0 ? null : et,
        et !== null && (k.callback = et),
        _ = dh(tt, k, nt),
        _ !== null && (mh(_, tt, nt, rt),
        eh(_, tt, nt)),
        nt
    }
    function hl(_) {
        if (_ = _.current,
        !_.child)
            return null;
        switch (_.child.tag) {
        case 5:
            return _.child.stateNode;
        default:
            return _.child.stateNode
        }
    }
    function il(_, k) {
        if (_ = _.memoizedState,
        _ !== null && _.dehydrated !== null) {
            var J = _.retryLane;
            _.retryLane = J !== 0 && J < k ? J : k
        }
    }
    function jl(_, k) {
        il(_, k),
        (_ = _.alternate) && il(_, k)
    }
    function kl() {
        return null
    }
    var ll = typeof reportError == "function" ? reportError : function(_) {}
    ;
    function ml(_) {
        this._internalRoot = _
    }
    nl.prototype.render = ml.prototype.render = function(_) {
        var k = this._internalRoot;
        if (k === null)
            throw Error(p$2(409));
        gl(_, k, null, null)
    }
    ,
    nl.prototype.unmount = ml.prototype.unmount = function() {
        var _ = this._internalRoot;
        if (_ !== null) {
            this._internalRoot = null;
            var k = _.containerInfo;
            Sk(function() {
                gl(null, _, null, null)
            }),
            k[uf] = null
        }
    }
    ;
    function nl(_) {
        this._internalRoot = _
    }
    nl.prototype.unstable_scheduleHydration = function(_) {
        if (_) {
            var k = Hc();
            _ = {
                blockedOn: null,
                target: _,
                priority: k
            };
            for (var J = 0; J < Qc.length && k !== 0 && k < Qc[J].priority; J++)
                ;
            Qc.splice(J, 0, _),
            J === 0 && Vc(_)
        }
    }
    ;
    function ol(_) {
        return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11)
    }
    function pl(_) {
        return !(!_ || _.nodeType !== 1 && _.nodeType !== 9 && _.nodeType !== 11 && (_.nodeType !== 8 || _.nodeValue !== " react-mount-point-unstable "))
    }
    function ql() {}
    function rl(_, k, J, et, tt) {
        if (tt) {
            if (typeof et == "function") {
                var rt = et;
                et = function() {
                    var at = hl(nt);
                    rt.call(at)
                }
            }
            var nt = fl(k, et, _, 0, null, !1, !1, "", ql);
            return _._reactRootContainer = nt,
            _[uf] = nt.current,
            sf(_.nodeType === 8 ? _.parentNode : _),
            Sk(),
            nt
        }
        for (; tt = _.lastChild; )
            _.removeChild(tt);
        if (typeof et == "function") {
            var ot = et;
            et = function() {
                var at = hl(it);
                ot.call(at)
            }
        }
        var it = cl(_, 0, !1, null, null, !1, !1, "", ql);
        return _._reactRootContainer = it,
        _[uf] = it.current,
        sf(_.nodeType === 8 ? _.parentNode : _),
        Sk(function() {
            gl(k, it, J, et)
        }),
        it
    }
    function sl(_, k, J, et, tt) {
        var rt = J._reactRootContainer;
        if (rt) {
            var nt = rt;
            if (typeof tt == "function") {
                var ot = tt;
                tt = function() {
                    var it = hl(nt);
                    ot.call(it)
                }
            }
            gl(k, nt, _, tt)
        } else
            nt = rl(J, k, _, tt, et);
        return hl(nt)
    }
    Ec = function(_) {
        switch (_.tag) {
        case 3:
            var k = _.stateNode;
            if (k.current.memoizedState.isDehydrated) {
                var J = tc(k.pendingLanes);
                J !== 0 && (Cc(k, J | 1),
                Ek(k, B$1()),
                !(K & 6) && (Hj = B$1() + 500,
                jg()))
            }
            break;
        case 13:
            Sk(function() {
                var et = Zg(_, 1);
                if (et !== null) {
                    var tt = L();
                    mh(et, _, 1, tt)
                }
            }),
            jl(_, 1)
        }
    }
    ,
    Fc = function(_) {
        if (_.tag === 13) {
            var k = Zg(_, 134217728);
            if (k !== null) {
                var J = L();
                mh(k, _, 134217728, J)
            }
            jl(_, 134217728)
        }
    }
    ,
    Gc = function(_) {
        if (_.tag === 13) {
            var k = lh(_)
              , J = Zg(_, k);
            if (J !== null) {
                var et = L();
                mh(J, _, k, et)
            }
            jl(_, k)
        }
    }
    ,
    Hc = function() {
        return C$1
    }
    ,
    Ic = function(_, k) {
        var J = C$1;
        try {
            return C$1 = _,
            k()
        } finally {
            C$1 = J
        }
    }
    ,
    yb = function(_, k, J) {
        switch (k) {
        case "input":
            if (bb(_, J),
            k = J.name,
            J.type === "radio" && k != null) {
                for (J = _; J.parentNode; )
                    J = J.parentNode;
                for (J = J.querySelectorAll("input[name=" + JSON.stringify("" + k) + '][type="radio"]'),
                k = 0; k < J.length; k++) {
                    var et = J[k];
                    if (et !== _ && et.form === _.form) {
                        var tt = Db(et);
                        if (!tt)
                            throw Error(p$2(90));
                        Wa(et),
                        bb(et, tt)
                    }
                }
            }
            break;
        case "textarea":
            ib(_, J);
            break;
        case "select":
            k = J.value,
            k != null && fb(_, !!J.multiple, k, !1)
        }
    }
    ,
    Gb = Rk,
    Hb = Sk;
    var tl = {
        usingClientEntryPoint: !1,
        Events: [Cb, ue, Db, Eb, Fb, Rk]
    }
      , ul = {
        findFiberByHostInstance: Wc,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    }
      , vl = {
        bundleType: ul.bundleType,
        version: ul.version,
        rendererPackageName: ul.rendererPackageName,
        rendererConfig: ul.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ua.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(_) {
            return _ = Zb(_),
            _ === null ? null : _.stateNode
        },
        findFiberByHostInstance: ul.findFiberByHostInstance || kl,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wl.isDisabled && wl.supportsFiber)
            try {
                kc = wl.inject(vl),
                lc = wl
            } catch (_) {}
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl,
    reactDom_production_min.createPortal = function(_, k) {
        var J = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!ol(k))
            throw Error(p$2(200));
        return dl(_, k, null, J)
    }
    ,
    reactDom_production_min.createRoot = function(_, k) {
        if (!ol(_))
            throw Error(p$2(299));
        var J = !1
          , et = ""
          , tt = ll;
        return k != null && (k.unstable_strictMode === !0 && (J = !0),
        k.identifierPrefix !== void 0 && (et = k.identifierPrefix),
        k.onRecoverableError !== void 0 && (tt = k.onRecoverableError)),
        k = cl(_, 1, !1, null, null, J, !1, et, tt),
        _[uf] = k.current,
        sf(_.nodeType === 8 ? _.parentNode : _),
        new ml(k)
    }
    ,
    reactDom_production_min.findDOMNode = function(_) {
        if (_ == null)
            return null;
        if (_.nodeType === 1)
            return _;
        var k = _._reactInternals;
        if (k === void 0)
            throw typeof _.render == "function" ? Error(p$2(188)) : (_ = Object.keys(_).join(","),
            Error(p$2(268, _)));
        return _ = Zb(k),
        _ = _ === null ? null : _.stateNode,
        _
    }
    ,
    reactDom_production_min.flushSync = function(_) {
        return Sk(_)
    }
    ,
    reactDom_production_min.hydrate = function(_, k, J) {
        if (!pl(k))
            throw Error(p$2(200));
        return sl(null, _, k, !0, J)
    }
    ,
    reactDom_production_min.hydrateRoot = function(_, k, J) {
        if (!ol(_))
            throw Error(p$2(405));
        var et = J != null && J.hydratedSources || null
          , tt = !1
          , rt = ""
          , nt = ll;
        if (J != null && (J.unstable_strictMode === !0 && (tt = !0),
        J.identifierPrefix !== void 0 && (rt = J.identifierPrefix),
        J.onRecoverableError !== void 0 && (nt = J.onRecoverableError)),
        k = fl(k, null, _, 1, J != null ? J : null, tt, !1, rt, nt),
        _[uf] = k.current,
        sf(_),
        et)
            for (_ = 0; _ < et.length; _++)
                J = et[_],
                tt = J._getVersion,
                tt = tt(J._source),
                k.mutableSourceEagerHydrationData == null ? k.mutableSourceEagerHydrationData = [J, tt] : k.mutableSourceEagerHydrationData.push(J, tt);
        return new nl(k)
    }
    ,
    reactDom_production_min.render = function(_, k, J) {
        if (!pl(k))
            throw Error(p$2(200));
        return sl(null, _, k, !1, J)
    }
    ,
    reactDom_production_min.unmountComponentAtNode = function(_) {
        if (!pl(_))
            throw Error(p$2(40));
        return _._reactRootContainer ? (Sk(function() {
            sl(null, null, _, !1, function() {
                _._reactRootContainer = null,
                _[uf] = null
            })
        }),
        !0) : !1
    }
    ,
    reactDom_production_min.unstable_batchedUpdates = Rk,
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(_, k, J, et) {
        if (!pl(J))
            throw Error(p$2(200));
        if (_ == null || _._reactInternals === void 0)
            throw Error(p$2(38));
        return sl(_, k, J, !1, et)
    }
    ,
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    function checkDCE() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
            } catch (_) {}
    }
    checkDCE(),
    reactDom.exports = reactDom_production_min,
    reactDomExports = reactDom.exports,
    ReactDOM = getDefaultExportFromCjs$1(reactDomExports),
    react_dom = _mergeNamespaces({
        
        default: ReactDOM
    }, [reactDomExports]);
    function _extends$4() {
        return _extends$4 = Object.assign ? Object.assign.bind() : function(_) {
            for (var k = 1; k < arguments.length; k++) {
                var J = arguments[k];
                for (var et in J)
                    Object.prototype.hasOwnProperty.call(J, et) && (_[et] = J[et])
            }
            return _
        }
        ,
        _extends$4.apply(this, arguments)
    }
    var Action;
    (function(_) {
        _.Pop = "POP",
        _.Push = "PUSH",
        _.Replace = "REPLACE"
    }
    )(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createMemoryHistory(_) {
        _ === void 0 && (_ = {});
        let {initialEntries: k=["/"], initialIndex: J, v5Compat: et=!1} = _, tt;
        tt = k.map((ut,ct)=>lt(ut, typeof ut == "string" ? null : ut.state, ct === 0 ? "default" : void 0));
        let rt = it(J != null ? J : tt.length - 1)
          , nt = Action.Pop
          , ot = null;
        function it(ut) {
            return Math.min(Math.max(ut, 0), tt.length - 1)
        }
        function at() {
            return tt[rt]
        }
        function lt(ut, ct, pt) {
            ct === void 0 && (ct = null);
            let ft = createLocation(tt ? at().pathname : "/", ut, ct, pt);
            return warning(ft.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(ut)),
            ft
        }
        function st(ut) {
            return typeof ut == "string" ? ut : createPath(ut)
        }
        return {
            get index() {
                return rt
            },
            get action() {
                return nt
            },
            get location() {
                return at()
            },
            createHref: st,
            createURL(ut) {
                return new URL(st(ut),"http://localhost")
            },
            encodeLocation(ut) {
                let ct = typeof ut == "string" ? parsePath(ut) : ut;
                return {
                    pathname: ct.pathname || "",
                    search: ct.search || "",
                    hash: ct.hash || ""
                }
            },
            push(ut, ct) {
                nt = Action.Push;
                let pt = lt(ut, ct);
                rt += 1,
                tt.splice(rt, tt.length, pt),
                et && ot && ot({
                    action: nt,
                    location: pt,
                    delta: 1
                })
            },
            replace(ut, ct) {
                nt = Action.Replace;
                let pt = lt(ut, ct);
                tt[rt] = pt,
                et && ot && ot({
                    action: nt,
                    location: pt,
                    delta: 0
                })
            },
            go(ut) {
                nt = Action.Pop;
                let ct = it(rt + ut)
                  , pt = tt[ct];
                rt = ct,
                ot && ot({
                    action: nt,
                    location: pt,
                    delta: ut
                })
            },
            listen(ut) {
                return ot = ut,
                ()=>{
                    ot = null
                }
            }
        }
    }
    function createBrowserHistory(_) {
        _ === void 0 && (_ = {});
        function k(et, tt) {
            let {pathname: rt, search: nt, hash: ot} = et.location;
            return createLocation("", {
                pathname: rt,
                search: nt,
                hash: ot
            }, tt.state && tt.state.usr || null, tt.state && tt.state.key || "default")
        }
        function J(et, tt) {
            return typeof tt == "string" ? tt : createPath(tt)
        }
        return getUrlBasedHistory(k, J, null, _)
    }
    function createHashHistory(_) {
        _ === void 0 && (_ = {});
        function k(tt, rt) {
            let {pathname: nt="/", search: ot="", hash: it=""} = parsePath(tt.location.hash.substr(1));
            return !nt.startsWith("/") && !nt.startsWith(".") && (nt = "/" + nt),
            createLocation("", {
                pathname: nt,
                search: ot,
                hash: it
            }, rt.state && rt.state.usr || null, rt.state && rt.state.key || "default")
        }
        function J(tt, rt) {
            let nt = tt.document.querySelector("base")
              , ot = "";
            if (nt && nt.getAttribute("href")) {
                let it = tt.location.href
                  , at = it.indexOf("#");
                ot = at === -1 ? it : it.slice(0, at)
            }
            return ot + "#" + (typeof rt == "string" ? rt : createPath(rt))
        }
        function et(tt, rt) {
            warning(tt.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(rt) + ")")
        }
        return getUrlBasedHistory(k, J, et, _)
    }
    function invariant(_, k) {
        if (_ === !1 || _ === null || typeof _ > "u")
            throw new Error(k)
    }
    function warning(_, k) {
        if (!_)
            try {
                throw new Error(k)
            } catch (J) {}
    }
    function createKey() {
        return Math.random().toString(36).substr(2, 8)
    }
    function getHistoryState(_, k) {
        return {
            usr: _.state,
            key: _.key,
            idx: k
        }
    }
    function createLocation(_, k, J, et) {
        return J === void 0 && (J = null),
        _extends$4({
            pathname: typeof _ == "string" ? _ : _.pathname,
            search: "",
            hash: ""
        }, typeof k == "string" ? parsePath(k) : k, {
            state: J,
            key: k && k.key || et || createKey()
        })
    }
    function createPath(_) {
        let {pathname: k="/", search: J="", hash: et=""} = _;
        return J && J !== "?" && (k += J.charAt(0) === "?" ? J : "?" + J),
        et && et !== "#" && (k += et.charAt(0) === "#" ? et : "#" + et),
        k
    }
    function parsePath(_) {
        let k = {};
        if (_) {
            let J = _.indexOf("#");
            J >= 0 && (k.hash = _.substr(J),
            _ = _.substr(0, J));
            let et = _.indexOf("?");
            et >= 0 && (k.search = _.substr(et),
            _ = _.substr(0, et)),
            _ && (k.pathname = _)
        }
        return k
    }
    function getUrlBasedHistory(_, k, J, et) {
        et === void 0 && (et = {});
        let {window: tt=document.defaultView, v5Compat: rt=!1} = et
          , nt = tt.history
          , ot = Action.Pop
          , it = null
          , at = lt();
        at == null && (at = 0,
        nt.replaceState(_extends$4({}, nt.state, {
            idx: at
        }), ""));
        function lt() {
            return (nt.state || {
                idx: null
            }).idx
        }
        function st() {
            ot = Action.Pop;
            let yt = lt()
              , ht = yt == null ? null : yt - at;
            at = yt,
            it && it({
                action: ot,
                location: ft.location,
                delta: ht
            })
        }
        function ut(yt, ht) {
            ot = Action.Push;
            let gt = createLocation(ft.location, yt, ht);
            J && J(gt, yt),
            at = lt() + 1;
            let mt = getHistoryState(gt, at)
              , vt = ft.createHref(gt);
            try {
                nt.pushState(mt, "", vt)
            } catch (bt) {
                if (bt instanceof DOMException && bt.name === "DataCloneError")
                    throw bt;
                tt.location.assign(vt)
            }
            rt && it && it({
                action: ot,
                location: ft.location,
                delta: 1
            })
        }
        function ct(yt, ht) {
            ot = Action.Replace;
            let gt = createLocation(ft.location, yt, ht);
            J && J(gt, yt),
            at = lt();
            let mt = getHistoryState(gt, at)
              , vt = ft.createHref(gt);
            nt.replaceState(mt, "", vt),
            rt && it && it({
                action: ot,
                location: ft.location,
                delta: 0
            })
        }
        function pt(yt) {
            let ht = tt.location.origin !== "null" ? tt.location.origin : tt.location.href
              , gt = typeof yt == "string" ? yt : createPath(yt);
            return gt = gt.replace(/ $/, "%20"),
            invariant(ht, "No window.location.(origin|href) available to create URL for href: " + gt),
            new URL(gt,ht)
        }
        let ft = {
            get action() {
                return ot
            },
            get location() {
                return _(tt, nt)
            },
            listen(yt) {
                if (it)
                    throw new Error("A history only accepts one active listener");
                return tt.addEventListener(PopStateEventType, st),
                it = yt,
                ()=>{
                    tt.removeEventListener(PopStateEventType, st),
                    it = null
                }
            },
            createHref(yt) {
                return k(tt, yt)
            },
            createURL: pt,
            encodeLocation(yt) {
                let ht = pt(yt);
                return {
                    pathname: ht.pathname,
                    search: ht.search,
                    hash: ht.hash
                }
            },
            push: ut,
            replace: ct,
            go(yt) {
                return nt.go(yt)
            }
        };
        return ft
    }
    var ResultType;
    (function(_) {
        _.data = "data",
        _.deferred = "deferred",
        _.redirect = "redirect",
        _.error = "error"
    }
    )(ResultType || (ResultType = {}));
    const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
    function isIndexRoute(_) {
        return _.index === !0
    }
    function convertRoutesToDataRoutes(_, k, J, et) {
        return J === void 0 && (J = []),
        et === void 0 && (et = {}),
        _.map((tt,rt)=>{
            let nt = [...J, rt]
              , ot = typeof tt.id == "string" ? tt.id : nt.join("-");
            if (invariant(tt.index !== !0 || !tt.children, "Cannot specify children on an index route"),
            invariant(!et[ot], 'Found a route id collision on id "' + ot + `".  Route id's must be globally unique within Data Router usages`),
            isIndexRoute(tt)) {
                let it = _extends$4({}, tt, k(tt), {
                    id: ot
                });
                return et[ot] = it,
                it
            } else {
                let it = _extends$4({}, tt, k(tt), {
                    id: ot,
                    children: void 0
                });
                return et[ot] = it,
                tt.children && (it.children = convertRoutesToDataRoutes(tt.children, k, nt, et)),
                it
            }
        }
        )
    }
    function matchRoutes(_, k, J) {
        J === void 0 && (J = "/");
        let et = typeof k == "string" ? parsePath(k) : k
          , tt = stripBasename(et.pathname || "/", J);
        if (tt == null)
            return null;
        let rt = flattenRoutes(_);
        rankRouteBranches(rt);
        let nt = null;
        for (let ot = 0; nt == null && ot < rt.length; ++ot) {
            let it = decodePath(tt);
            nt = matchRouteBranch(rt[ot], it)
        }
        return nt
    }
    function convertRouteMatchToUiMatch(_, k) {
        let {route: J, pathname: et, params: tt} = _;
        return {
            id: J.id,
            pathname: et,
            params: tt,
            data: k[J.id],
            handle: J.handle
        }
    }
    function flattenRoutes(_, k, J, et) {
        k === void 0 && (k = []),
        J === void 0 && (J = []),
        et === void 0 && (et = "");
        let tt = (rt,nt,ot)=>{
            let it = {
                relativePath: ot === void 0 ? rt.path || "" : ot,
                caseSensitive: rt.caseSensitive === !0,
                childrenIndex: nt,
                route: rt
            };
            it.relativePath.startsWith("/") && (invariant(it.relativePath.startsWith(et), 'Absolute route path "' + it.relativePath + '" nested under path ' + ('"' + et + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
            it.relativePath = it.relativePath.slice(et.length));
            let at = joinPaths([et, it.relativePath])
              , lt = J.concat(it);
            rt.children && rt.children.length > 0 && (invariant(rt.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + at + '".')),
            flattenRoutes(rt.children, k, lt, at)),
            !(rt.path == null && !rt.index) && k.push({
                path: at,
                score: computeScore(at, rt.index),
                routesMeta: lt
            })
        }
        ;
        return _.forEach((rt,nt)=>{
            var ot;
            if (rt.path === "" || !((ot = rt.path) != null && ot.includes("?")))
                tt(rt, nt);
            else
                for (let it of explodeOptionalSegments(rt.path))
                    tt(rt, nt, it)
        }
        ),
        k
    }
    function explodeOptionalSegments(_) {
        let k = _.split("/");
        if (k.length === 0)
            return [];
        let[J,...et] = k
          , tt = J.endsWith("?")
          , rt = J.replace(/\?$/, "");
        if (et.length === 0)
            return tt ? [rt, ""] : [rt];
        let nt = explodeOptionalSegments(et.join("/"))
          , ot = [];
        return ot.push(...nt.map(it=>it === "" ? rt : [rt, it].join("/"))),
        tt && ot.push(...nt),
        ot.map(it=>_.startsWith("/") && it === "" ? "/" : it)
    }
    function rankRouteBranches(_) {
        _.sort((k,J)=>k.score !== J.score ? J.score - k.score : compareIndexes(k.routesMeta.map(et=>et.childrenIndex), J.routesMeta.map(et=>et.childrenIndex)))
    }
    const paramRe = /^:[\w-]+$/
      , dynamicSegmentValue = 3
      , indexRouteValue = 2
      , emptySegmentValue = 1
      , staticSegmentValue = 10
      , splatPenalty = -2
      , isSplat = _=>_ === "*";
    function computeScore(_, k) {
        let J = _.split("/")
          , et = J.length;
        return J.some(isSplat) && (et += splatPenalty),
        k && (et += indexRouteValue),
        J.filter(tt=>!isSplat(tt)).reduce((tt,rt)=>tt + (paramRe.test(rt) ? dynamicSegmentValue : rt === "" ? emptySegmentValue : staticSegmentValue), et)
    }
    function compareIndexes(_, k) {
        return _.length === k.length && _.slice(0, -1).every((J,et)=>J === k[et]) ? _[_.length - 1] - k[k.length - 1] : 0
    }
    function matchRouteBranch(_, k) {
        let {routesMeta: J} = _
          , et = {}
          , tt = "/"
          , rt = [];
        for (let nt = 0; nt < J.length; ++nt) {
            let ot = J[nt]
              , it = nt === J.length - 1
              , at = tt === "/" ? k : k.slice(tt.length) || "/"
              , lt = matchPath({
                path: ot.relativePath,
                caseSensitive: ot.caseSensitive,
                end: it
            }, at);
            if (!lt)
                return null;
            Object.assign(et, lt.params);
            let st = ot.route;
            rt.push({
                params: et,
                pathname: joinPaths([tt, lt.pathname]),
                pathnameBase: normalizePathname(joinPaths([tt, lt.pathnameBase])),
                route: st
            }),
            lt.pathnameBase !== "/" && (tt = joinPaths([tt, lt.pathnameBase]))
        }
        return rt
    }
    function generatePath(_, k) {
        k === void 0 && (k = {});
        let J = _;
        J.endsWith("*") && J !== "*" && !J.endsWith("/*") && (warning(!1, 'Route path "' + J + '" will be treated as if it were ' + ('"' + J.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + J.replace(/\*$/, "/*") + '".')),
        J = J.replace(/\*$/, "/*"));
        const et = J.startsWith("/") ? "/" : ""
          , tt = nt=>nt == null ? "" : typeof nt == "string" ? nt : String(nt)
          , rt = J.split(/\/+/).map((nt,ot,it)=>{
            if (ot === it.length - 1 && nt === "*")
                return tt(k["*"]);
            const at = nt.match(/^:([\w-]+)(\??)$/);
            if (at) {
                const [,lt,st] = at;
                let ut = k[lt];
                return invariant(st === "?" || ut != null, 'Missing ":' + lt + '" param'),
                tt(ut)
            }
            return nt.replace(/\?$/g, "")
        }
        ).filter(nt=>!!nt);
        return et + rt.join("/")
    }
    function matchPath(_, k) {
        typeof _ == "string" && (_ = {
            path: _,
            caseSensitive: !1,
            end: !0
        });
        let[J,et] = compilePath(_.path, _.caseSensitive, _.end)
          , tt = k.match(J);
        if (!tt)
            return null;
        let rt = tt[0]
          , nt = rt.replace(/(.)\/+$/, "$1")
          , ot = tt.slice(1);
        return {
            params: et.reduce((it,at,lt)=>{
                let {paramName: st, isOptional: ut} = at;
                if (st === "*") {
                    let pt = ot[lt] || "";
                    nt = rt.slice(0, rt.length - pt.length).replace(/(.)\/+$/, "$1")
                }
                const ct = ot[lt];
                return ut && !ct ? it[st] = void 0 : it[st] = (ct || "").replace(/%2F/g, "/"),
                it
            }
            , {}),
            pathname: rt,
            pathnameBase: nt,
            pattern: _
        }
    }
    function compilePath(_, k, J) {
        k === void 0 && (k = !1),
        J === void 0 && (J = !0),
        warning(_ === "*" || !_.endsWith("*") || _.endsWith("/*"), 'Route path "' + _ + '" will be treated as if it were ' + ('"' + _.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + _.replace(/\*$/, "/*") + '".'));
        let et = []
          , tt = "^" + _.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (rt,nt,ot)=>(et.push({
            paramName: nt,
            isOptional: ot != null
        }),
        ot ? "/?([^\\/]+)?" : "/([^\\/]+)"));
        return _.endsWith("*") ? (et.push({
            paramName: "*"
        }),
        tt += _ === "*" || _ === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : J ? tt += "\\/*$" : _ !== "" && _ !== "/" && (tt += "(?:(?=\\/|$))"),
        [new RegExp(tt,k ? void 0 : "i"), et]
    }
    function decodePath(_) {
        try {
            return _.split("/").map(k=>decodeURIComponent(k).replace(/\//g, "%2F")).join("/")
        } catch (k) {
            return warning(!1, 'The URL path "' + _ + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + k + ").")),
            _
        }
    }
    function stripBasename(_, k) {
        if (k === "/")
            return _;
        if (!_.toLowerCase().startsWith(k.toLowerCase()))
            return null;
        let J = k.endsWith("/") ? k.length - 1 : k.length
          , et = _.charAt(J);
        return et && et !== "/" ? null : _.slice(J) || "/"
    }
    function resolvePath(_, k) {
        k === void 0 && (k = "/");
        let {pathname: J, search: et="", hash: tt=""} = typeof _ == "string" ? parsePath(_) : _;
        return {
            pathname: J ? J.startsWith("/") ? J : resolvePathname(J, k) : k,
            search: normalizeSearch(et),
            hash: normalizeHash(tt)
        }
    }
    function resolvePathname(_, k) {
        let J = k.replace(/\/+$/, "").split("/");
        return _.split("/").forEach(et=>{
            et === ".." ? J.length > 1 && J.pop() : et !== "." && J.push(et)
        }
        ),
        J.length > 1 ? J.join("/") : "/"
    }
    function getInvalidPathError(_, k, J, et) {
        return "Cannot include a '" + _ + "' character in a manually specified " + ("`to." + k + "` field [" + JSON.stringify(et) + "].  Please separate it out to the ") + ("`to." + J + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
    }
    function getPathContributingMatches(_) {
        return _.filter((k,J)=>J === 0 || k.route.path && k.route.path.length > 0)
    }
    function getResolveToMatches(_, k) {
        let J = getPathContributingMatches(_);
        return k ? J.map((et,tt)=>tt === _.length - 1 ? et.pathname : et.pathnameBase) : J.map(et=>et.pathnameBase)
    }
    function resolveTo(_, k, J, et) {
        et === void 0 && (et = !1);
        let tt;
        typeof _ == "string" ? tt = parsePath(_) : (tt = _extends$4({}, _),
        invariant(!tt.pathname || !tt.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", tt)),
        invariant(!tt.pathname || !tt.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", tt)),
        invariant(!tt.search || !tt.search.includes("#"), getInvalidPathError("#", "search", "hash", tt)));
        let rt = _ === "" || tt.pathname === "", nt = rt ? "/" : tt.pathname, ot;
        if (nt == null)
            ot = J;
        else {
            let st = k.length - 1;
            if (!et && nt.startsWith("..")) {
                let ut = nt.split("/");
                for (; ut[0] === ".."; )
                    ut.shift(),
                    st -= 1;
                tt.pathname = ut.join("/")
            }
            ot = st >= 0 ? k[st] : "/"
        }
        let it = resolvePath(tt, ot)
          , at = nt && nt !== "/" && nt.endsWith("/")
          , lt = (rt || nt === ".") && J.endsWith("/");
        return !it.pathname.endsWith("/") && (at || lt) && (it.pathname += "/"),
        it
    }
    const joinPaths = _=>_.join("/").replace(/\/\/+/g, "/")
      , normalizePathname = _=>_.replace(/\/+$/, "").replace(/^\/*/, "/")
      , normalizeSearch = _=>!_ || _ === "?" ? "" : _.startsWith("?") ? _ : "?" + _
      , normalizeHash = _=>!_ || _ === "#" ? "" : _.startsWith("#") ? _ : "#" + _
      , json = function(_, k) {
        k === void 0 && (k = {});
        let J = typeof k == "number" ? {
            status: k
        } : k
          , et = new Headers(J.headers);
        return et.has("Content-Type") || et.set("Content-Type", "application/json; charset=utf-8"),
        new Response(JSON.stringify(_),_extends$4({}, J, {
            headers: et
        }))
    };
    class AbortedDeferredError extends Error {
    }
    class DeferredData {
        constructor(k, J) {
            this.pendingKeysSet = new Set,
            this.subscribers = new Set,
            this.deferredKeys = [],
            invariant(k && typeof k == "object" && !Array.isArray(k), "defer() only accepts plain objects");
            let et;
            this.abortPromise = new Promise((rt,nt)=>et = nt),
            this.controller = new AbortController;
            let tt = ()=>et(new AbortedDeferredError("Deferred data aborted"));
            this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener("abort", tt),
            this.controller.signal.addEventListener("abort", tt),
            this.data = Object.entries(k).reduce((rt,nt)=>{
                let[ot,it] = nt;
                return Object.assign(rt, {
                    [ot]: this.trackPromise(ot, it)
                })
            }
            , {}),
            this.done && this.unlistenAbortSignal(),
            this.init = J
        }
        trackPromise(k, J) {
            if (!(J instanceof Promise))
                return J;
            this.deferredKeys.push(k),
            this.pendingKeysSet.add(k);
            let et = Promise.race([J, this.abortPromise]).then(tt=>this.onSettle(et, k, void 0, tt), tt=>this.onSettle(et, k, tt));
            return et.catch(()=>{}
            ),
            Object.defineProperty(et, "_tracked", {
                get: ()=>!0
            }),
            et
        }
        onSettle(k, J, et, tt) {
            if (this.controller.signal.aborted && et instanceof AbortedDeferredError)
                return this.unlistenAbortSignal(),
                Object.defineProperty(k, "_error", {
                    get: ()=>et
                }),
                Promise.reject(et);
            if (this.pendingKeysSet.delete(J),
            this.done && this.unlistenAbortSignal(),
            et === void 0 && tt === void 0) {
                let rt = new Error('Deferred data for key "' + J + '" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
                return Object.defineProperty(k, "_error", {
                    get: ()=>rt
                }),
                this.emit(!1, J),
                Promise.reject(rt)
            }
            return tt === void 0 ? (Object.defineProperty(k, "_error", {
                get: ()=>et
            }),
            this.emit(!1, J),
            Promise.reject(et)) : (Object.defineProperty(k, "_data", {
                get: ()=>tt
            }),
            this.emit(!1, J),
            tt)
        }
        emit(k, J) {
            this.subscribers.forEach(et=>et(k, J))
        }
        subscribe(k) {
            return this.subscribers.add(k),
            ()=>this.subscribers.delete(k)
        }
        cancel() {
            this.controller.abort(),
            this.pendingKeysSet.forEach((k,J)=>this.pendingKeysSet.delete(J)),
            this.emit(!0)
        }
        async resolveData(k) {
            let J = !1;
            if (!this.done) {
                let et = ()=>this.cancel();
                k.addEventListener("abort", et),
                J = await new Promise(tt=>{
                    this.subscribe(rt=>{
                        k.removeEventListener("abort", et),
                        (rt || this.done) && tt(rt)
                    }
                    )
                }
                )
            }
            return J
        }
        get done() {
            return this.pendingKeysSet.size === 0
        }
        get unwrappedData() {
            return invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"),
            Object.entries(this.data).reduce((k,J)=>{
                let[et,tt] = J;
                return Object.assign(k, {
                    [et]: unwrapTrackedPromise(tt)
                })
            }
            , {})
        }
        get pendingKeys() {
            return Array.from(this.pendingKeysSet)
        }
    }
    function isTrackedPromise(_) {
        return _ instanceof Promise && _._tracked === !0
    }
    function unwrapTrackedPromise(_) {
        if (!isTrackedPromise(_))
            return _;
        if (_._error)
            throw _._error;
        return _._data
    }
    const defer$1 = function(_, k) {
        k === void 0 && (k = {});
        let J = typeof k == "number" ? {
            status: k
        } : k;
        return new DeferredData(_,J)
    }
      , redirect = function(_, k) {
        k === void 0 && (k = 302);
        let J = k;
        typeof J == "number" ? J = {
            status: J
        } : typeof J.status > "u" && (J.status = 302);
        let et = new Headers(J.headers);
        return et.set("Location", _),
        new Response(null,_extends$4({}, J, {
            headers: et
        }))
    }
      , redirectDocument = (_,k)=>{
        let J = redirect(_, k);
        return J.headers.set("X-Remix-Reload-Document", "true"),
        J
    }
    ;
    class ErrorResponseImpl {
        constructor(k, J, et, tt) {
            tt === void 0 && (tt = !1),
            this.status = k,
            this.statusText = J || "",
            this.internal = tt,
            et instanceof Error ? (this.data = et.toString(),
            this.error = et) : this.data = et
        }
    }
    function isRouteErrorResponse(_) {
        return _ != null && typeof _.status == "number" && typeof _.statusText == "string" && typeof _.internal == "boolean" && "data"in _
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"]
      , validMutationMethods = new Set(validMutationMethodsArr)
      , validRequestMethodsArr = ["get", ...validMutationMethodsArr]
      , validRequestMethods = new Set(validRequestMethodsArr)
      , redirectStatusCodes = new Set([301, 302, 303, 307, 308])
      , redirectPreserveMethodStatusCodes = new Set([307, 308])
      , IDLE_NAVIGATION = {
        state: "idle",
        location: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
      , IDLE_FETCHER = {
        state: "idle",
        data: void 0,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
      , IDLE_BLOCKER = {
        state: "unblocked",
        proceed: void 0,
        reset: void 0,
        location: void 0
    }
      , ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
      , defaultMapRouteProperties = _=>({
        hasErrorBoundary: !!_.hasErrorBoundary
    })
      , TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
    function createRouter(_) {
        const k = _.window ? _.window : typeof window < "u" ? window : void 0
          , J = typeof k < "u" && typeof k.document < "u" && typeof k.document.createElement < "u"
          , et = !J;
        invariant(_.routes.length > 0, "You must provide a non-empty routes array to createRouter");
        let tt;
        if (_.mapRouteProperties)
            tt = _.mapRouteProperties;
        else if (_.detectErrorBoundary) {
            let Tt = _.detectErrorBoundary;
            tt = Lt=>({
                hasErrorBoundary: Tt(Lt)
            })
        } else
            tt = defaultMapRouteProperties;
        let rt = {}, nt = convertRoutesToDataRoutes(_.routes, tt, void 0, rt), ot, it = _.basename || "/", at = _.unstable_dataStrategy || defaultDataStrategy, lt = _extends$4({
            v7_fetcherPersist: !1,
            v7_normalizeFormMethod: !1,
            v7_partialHydration: !1,
            v7_prependBasename: !1,
            v7_relativeSplatPath: !1,
            unstable_skipActionErrorRevalidation: !1
        }, _.future), st = null, ut = new Set, ct = null, pt = null, ft = null, yt = _.hydrationData != null, ht = matchRoutes(nt, _.history.location, it), gt = null;
        if (ht == null) {
            let Tt = getInternalRouterError(404, {
                pathname: _.history.location.pathname
            })
              , {matches: Lt, route: Dt} = getShortCircuitMatches(nt);
            ht = Lt,
            gt = {
                [Dt.id]: Tt
            }
        }
        let mt, vt = ht.some(Tt=>Tt.route.lazy), bt = ht.some(Tt=>Tt.route.loader);
        if (vt)
            mt = !1;
        else if (!bt)
            mt = !0;
        else if (lt.v7_partialHydration) {
            let Tt = _.hydrationData ? _.hydrationData.loaderData : null
              , Lt = _.hydrationData ? _.hydrationData.errors : null
              , Dt = Ft=>Ft.route.loader ? typeof Ft.route.loader == "function" && Ft.route.loader.hydrate === !0 ? !1 : Tt && Tt[Ft.route.id] !== void 0 || Lt && Lt[Ft.route.id] !== void 0 : !0;
            if (Lt) {
                let Ft = ht.findIndex(zt=>Lt[zt.route.id] !== void 0);
                mt = ht.slice(0, Ft + 1).every(Dt)
            } else
                mt = ht.every(Dt)
        } else
            mt = _.hydrationData != null;
        let Et, xt = {
            historyAction: _.history.action,
            location: _.history.location,
            matches: ht,
            initialized: mt,
            navigation: IDLE_NAVIGATION,
            restoreScrollPosition: _.hydrationData != null ? !1 : null,
            preventScrollReset: !1,
            revalidation: "idle",
            loaderData: _.hydrationData && _.hydrationData.loaderData || {},
            actionData: _.hydrationData && _.hydrationData.actionData || null,
            errors: _.hydrationData && _.hydrationData.errors || gt,
            fetchers: new Map,
            blockers: new Map
        }, wt = Action.Pop, St = !1, Pt, Rt = !1, At = new Map, Nt = null, Ot = !1, It = !1, Mt = [], Wt = [], jt = new Map, Bt = 0, Ut = -1, Xt = new Map, Yt = new Set, Gt = new Map, er = new Map, lr = new Set, sr = new Map, fr = new Map, Er = !1;
        function mr() {
            if (st = _.history.listen(Tt=>{
                let {action: Lt, location: Dt, delta: Ft} = Tt;
                if (Er) {
                    Er = !1;
                    return
                }
                warning(fr.size === 0 || Ft != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
                let zt = rn({
                    currentLocation: xt.location,
                    nextLocation: Dt,
                    historyAction: Lt
                });
                if (zt && Ft != null) {
                    Er = !0,
                    _.history.go(Ft * -1),
                    qr(zt, {
                        state: "blocked",
                        location: Dt,
                        proceed() {
                            qr(zt, {
                                state: "proceeding",
                                proceed: void 0,
                                reset: void 0,
                                location: Dt
                            }),
                            _.history.go(Ft)
                        },
                        reset() {
                            let kt = new Map(xt.blockers);
                            kt.set(zt, IDLE_BLOCKER),
                            nr({
                                blockers: kt
                            })
                        }
                    });
                    return
                }
                return ar(Lt, Dt)
            }
            ),
            J) {
                restoreAppliedTransitions(k, At);
                let Tt = ()=>persistAppliedTransitions(k, At);
                k.addEventListener("pagehide", Tt),
                Nt = ()=>k.removeEventListener("pagehide", Tt)
            }
            return xt.initialized || ar(Action.Pop, xt.location, {
                initialHydration: !0
            }),
            Et
        }
        function wr() {
            st && st(),
            Nt && Nt(),
            ut.clear(),
            Pt && Pt.abort(),
            xt.fetchers.forEach((Tt,Lt)=>Dr(Lt)),
            xt.blockers.forEach((Tt,Lt)=>tn(Lt))
        }
        function Pr(Tt) {
            return ut.add(Tt),
            ()=>ut.delete(Tt)
        }
        function nr(Tt, Lt) {
            Lt === void 0 && (Lt = {}),
            xt = _extends$4({}, xt, Tt);
            let Dt = []
              , Ft = [];
            lt.v7_fetcherPersist && xt.fetchers.forEach((zt,kt)=>{
                zt.state === "idle" && (lr.has(kt) ? Ft.push(kt) : Dt.push(kt))
            }
            ),
            [...ut].forEach(zt=>zt(xt, {
                deletedFetchers: Ft,
                unstable_viewTransitionOpts: Lt.viewTransitionOpts,
                unstable_flushSync: Lt.flushSync === !0
            })),
            lt.v7_fetcherPersist && (Dt.forEach(zt=>xt.fetchers.delete(zt)),
            Ft.forEach(zt=>Dr(zt)))
        }
        function pr(Tt, Lt, Dt) {
            var Ft, zt;
            let {flushSync: kt} = Dt === void 0 ? {} : Dt, Qt = xt.actionData != null && xt.navigation.formMethod != null && isMutationMethod(xt.navigation.formMethod) && xt.navigation.state === "loading" && ((Ft = Tt.state) == null ? void 0 : Ft._isRedirect) !== !0, Ht;
            Lt.actionData ? Object.keys(Lt.actionData).length > 0 ? Ht = Lt.actionData : Ht = null : Qt ? Ht = xt.actionData : Ht = null;
            let Jt = Lt.loaderData ? mergeLoaderData(xt.loaderData, Lt.loaderData, Lt.matches || [], Lt.errors) : xt.loaderData
              , Zt = xt.blockers;
            Zt.size > 0 && (Zt = new Map(Zt),
            Zt.forEach((ir,cr)=>Zt.set(cr, IDLE_BLOCKER)));
            let vr = St === !0 || xt.navigation.formMethod != null && isMutationMethod(xt.navigation.formMethod) && ((zt = Tt.state) == null ? void 0 : zt._isRedirect) !== !0;
            ot && (nt = ot,
            ot = void 0),
            Ot || wt === Action.Pop || (wt === Action.Push ? _.history.push(Tt, Tt.state) : wt === Action.Replace && _.history.replace(Tt, Tt.state));
            let tr;
            if (wt === Action.Pop) {
                let ir = At.get(xt.location.pathname);
                ir && ir.has(Tt.pathname) ? tr = {
                    currentLocation: xt.location,
                    nextLocation: Tt
                } : At.has(Tt.pathname) && (tr = {
                    currentLocation: Tt,
                    nextLocation: xt.location
                })
            } else if (Rt) {
                let ir = At.get(xt.location.pathname);
                ir ? ir.add(Tt.pathname) : (ir = new Set([Tt.pathname]),
                At.set(xt.location.pathname, ir)),
                tr = {
                    currentLocation: xt.location,
                    nextLocation: Tt
                }
            }
            nr(_extends$4({}, Lt, {
                actionData: Ht,
                loaderData: Jt,
                historyAction: wt,
                location: Tt,
                initialized: !0,
                navigation: IDLE_NAVIGATION,
                revalidation: "idle",
                restoreScrollPosition: an(Tt, Lt.matches || xt.matches),
                preventScrollReset: vr,
                blockers: Zt
            }), {
                viewTransitionOpts: tr,
                flushSync: kt === !0
            }),
            wt = Action.Pop,
            St = !1,
            Rt = !1,
            Ot = !1,
            It = !1,
            Mt = [],
            Wt = []
        }
        async function Or(Tt, Lt) {
            if (typeof Tt == "number") {
                _.history.go(Tt);
                return
            }
            let Dt = normalizeTo(xt.location, xt.matches, it, lt.v7_prependBasename, Tt, lt.v7_relativeSplatPath, Lt == null ? void 0 : Lt.fromRouteId, Lt == null ? void 0 : Lt.relative)
              , {path: Ft, submission: zt, error: kt} = normalizeNavigateOptions(lt.v7_normalizeFormMethod, !1, Dt, Lt)
              , Qt = xt.location
              , Ht = createLocation(xt.location, Ft, Lt && Lt.state);
            Ht = _extends$4({}, Ht, _.history.encodeLocation(Ht));
            let Jt = Lt && Lt.replace != null ? Lt.replace : void 0
              , Zt = Action.Push;
            Jt === !0 ? Zt = Action.Replace : Jt === !1 || zt != null && isMutationMethod(zt.formMethod) && zt.formAction === xt.location.pathname + xt.location.search && (Zt = Action.Replace);
            let vr = Lt && "preventScrollReset"in Lt ? Lt.preventScrollReset === !0 : void 0
              , tr = (Lt && Lt.unstable_flushSync) === !0
              , ir = rn({
                currentLocation: Qt,
                nextLocation: Ht,
                historyAction: Zt
            });
            if (ir) {
                qr(ir, {
                    state: "blocked",
                    location: Ht,
                    proceed() {
                        qr(ir, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: Ht
                        }),
                        Or(Tt, Lt)
                    },
                    reset() {
                        let cr = new Map(xt.blockers);
                        cr.set(ir, IDLE_BLOCKER),
                        nr({
                            blockers: cr
                        })
                    }
                });
                return
            }
            return await ar(Zt, Ht, {
                submission: zt,
                pendingError: kt,
                preventScrollReset: vr,
                replace: Lt && Lt.replace,
                enableViewTransition: Lt && Lt.unstable_viewTransition,
                flushSync: tr
            })
        }
        function ur() {
            if (Cr(),
            nr({
                revalidation: "loading"
            }),
            xt.navigation.state !== "submitting") {
                if (xt.navigation.state === "idle") {
                    ar(xt.historyAction, xt.location, {
                        startUninterruptedRevalidation: !0
                    });
                    return
                }
                ar(wt || xt.historyAction, xt.navigation.location, {
                    overrideNavigation: xt.navigation
                })
            }
        }
        async function ar(Tt, Lt, Dt) {
            Pt && Pt.abort(),
            Pt = null,
            wt = Tt,
            Ot = (Dt && Dt.startUninterruptedRevalidation) === !0,
            bn(xt.location, xt.matches),
            St = (Dt && Dt.preventScrollReset) === !0,
            Rt = (Dt && Dt.enableViewTransition) === !0;
            let Ft = ot || nt
              , zt = Dt && Dt.overrideNavigation
              , kt = matchRoutes(Ft, Lt, it)
              , Qt = (Dt && Dt.flushSync) === !0;
            if (!kt) {
                let ir = getInternalRouterError(404, {
                    pathname: Lt.pathname
                })
                  , {matches: cr, route: yr} = getShortCircuitMatches(Ft);
                Zr(),
                pr(Lt, {
                    matches: cr,
                    loaderData: {},
                    errors: {
                        [yr.id]: ir
                    }
                }, {
                    flushSync: Qt
                });
                return
            }
            if (xt.initialized && !It && isHashChangeOnly(xt.location, Lt) && !(Dt && Dt.submission && isMutationMethod(Dt.submission.formMethod))) {
                pr(Lt, {
                    matches: kt
                }, {
                    flushSync: Qt
                });
                return
            }
            Pt = new AbortController;
            let Ht = createClientSideRequest(_.history, Lt, Pt.signal, Dt && Dt.submission), Jt;
            if (Dt && Dt.pendingError)
                Jt = [findNearestBoundary(kt).route.id, {
                    type: ResultType.error,
                    error: Dt.pendingError
                }];
            else if (Dt && Dt.submission && isMutationMethod(Dt.submission.formMethod)) {
                let ir = await or(Ht, Lt, Dt.submission, kt, {
                    replace: Dt.replace,
                    flushSync: Qt
                });
                if (ir.shortCircuited)
                    return;
                Jt = ir.pendingActionResult,
                zt = getLoadingNavigation(Lt, Dt.submission),
                Qt = !1,
                Ht = createClientSideRequest(_.history, Ht.url, Ht.signal)
            }
            let {shortCircuited: Zt, loaderData: vr, errors: tr} = await Tr(Ht, Lt, kt, zt, Dt && Dt.submission, Dt && Dt.fetcherSubmission, Dt && Dt.replace, Dt && Dt.initialHydration === !0, Qt, Jt);
            Zt || (Pt = null,
            pr(Lt, _extends$4({
                matches: kt
            }, getActionDataForCommit(Jt), {
                loaderData: vr,
                errors: tr
            })))
        }
        async function or(Tt, Lt, Dt, Ft, zt) {
            zt === void 0 && (zt = {}),
            Cr();
            let kt = getSubmittingNavigation(Lt, Dt);
            nr({
                navigation: kt
            }, {
                flushSync: zt.flushSync === !0
            });
            let Qt, Ht = getTargetMatch(Ft, Lt);
            if (!Ht.route.action && !Ht.route.lazy)
                Qt = {
                    type: ResultType.error,
                    error: getInternalRouterError(405, {
                        method: Tt.method,
                        pathname: Lt.pathname,
                        routeId: Ht.route.id
                    })
                };
            else if (Qt = (await gr("action", Tt, [Ht], Ft))[0],
            Tt.signal.aborted)
                return {
                    shortCircuited: !0
                };
            if (isRedirectResult(Qt)) {
                let Jt;
                return zt && zt.replace != null ? Jt = zt.replace : Jt = normalizeRedirectLocation(Qt.response.headers.get("Location"), new URL(Tt.url), it) === xt.location.pathname + xt.location.search,
                await Rr(Tt, Qt, {
                    submission: Dt,
                    replace: Jt
                }),
                {
                    shortCircuited: !0
                }
            }
            if (isDeferredResult(Qt))
                throw getInternalRouterError(400, {
                    type: "defer-action"
                });
            if (isErrorResult(Qt)) {
                let Jt = findNearestBoundary(Ft, Ht.route.id);
                return (zt && zt.replace) !== !0 && (wt = Action.Push),
                {
                    pendingActionResult: [Jt.route.id, Qt]
                }
            }
            return {
                pendingActionResult: [Ht.route.id, Qt]
            }
        }
        async function Tr(Tt, Lt, Dt, Ft, zt, kt, Qt, Ht, Jt, Zt) {
            let vr = Ft || getLoadingNavigation(Lt, zt)
              , tr = zt || kt || getSubmissionFromNavigation(vr)
              , ir = ot || nt
              , [cr,yr] = getMatchesToLoad(_.history, xt, Dt, tr, Lt, lt.v7_partialHydration && Ht === !0, lt.unstable_skipActionErrorRevalidation, It, Mt, Wt, lr, Gt, Yt, ir, it, Zt);
            if (Zr(rr=>!(Dt && Dt.some(xr=>xr.route.id === rr)) || cr && cr.some(xr=>xr.route.id === rr)),
            Ut = ++Bt,
            cr.length === 0 && yr.length === 0) {
                let rr = Jr();
                return pr(Lt, _extends$4({
                    matches: Dt,
                    loaderData: {},
                    errors: Zt && isErrorResult(Zt[1]) ? {
                        [Zt[0]]: Zt[1].error
                    } : null
                }, getActionDataForCommit(Zt), rr ? {
                    fetchers: new Map(xt.fetchers)
                } : {}), {
                    flushSync: Jt
                }),
                {
                    shortCircuited: !0
                }
            }
            if (!Ot && (!lt.v7_partialHydration || !Ht)) {
                yr.forEach(xr=>{
                    let dr = xt.fetchers.get(xr.key)
                      , Fr = getLoadingFetcher(void 0, dr ? dr.data : void 0);
                    xt.fetchers.set(xr.key, Fr)
                }
                );
                let rr;
                Zt && !isErrorResult(Zt[1]) ? rr = {
                    [Zt[0]]: Zt[1].data
                } : xt.actionData && (Object.keys(xt.actionData).length === 0 ? rr = null : rr = xt.actionData),
                nr(_extends$4({
                    navigation: vr
                }, rr !== void 0 ? {
                    actionData: rr
                } : {}, yr.length > 0 ? {
                    fetchers: new Map(xt.fetchers)
                } : {}), {
                    flushSync: Jt
                })
            }
            yr.forEach(rr=>{
                jt.has(rr.key) && jr(rr.key),
                rr.controller && jt.set(rr.key, rr.controller)
            }
            );
            let Nr = ()=>yr.forEach(rr=>jr(rr.key));
            Pt && Pt.signal.addEventListener("abort", Nr);
            let {loaderResults: Br, fetcherResults: Gr} = await Mr(xt.matches, Dt, cr, yr, Tt);
            if (Tt.signal.aborted)
                return {
                    shortCircuited: !0
                };
            Pt && Pt.signal.removeEventListener("abort", Nr),
            yr.forEach(rr=>jt.delete(rr.key));
            let Lr = findRedirect([...Br, ...Gr]);
            if (Lr) {
                if (Lr.idx >= cr.length) {
                    let rr = yr[Lr.idx - cr.length].key;
                    Yt.add(rr)
                }
                return await Rr(Tt, Lr.result, {
                    replace: Qt
                }),
                {
                    shortCircuited: !0
                }
            }
            let {loaderData: Ir, errors: Vr} = processLoaderData(xt, Dt, cr, Br, Zt, yr, Gr, sr);
            sr.forEach((rr,xr)=>{
                rr.subscribe(dr=>{
                    (dr || rr.done) && sr.delete(xr)
                }
                )
            }
            ),
            lt.v7_partialHydration && Ht && xt.errors && Object.entries(xt.errors).filter(rr=>{
                let[xr] = rr;
                return !cr.some(dr=>dr.route.id === xr)
            }
            ).forEach(rr=>{
                let[xr,dr] = rr;
                Vr = Object.assign(Vr || {}, {
                    [xr]: dr
                })
            }
            );
            let Kr = Jr()
              , Qr = en(Ut)
              , Ur = Kr || Qr || yr.length > 0;
            return _extends$4({
                loaderData: Ir,
                errors: Vr
            }, Ur ? {
                fetchers: new Map(xt.fetchers)
            } : {})
        }
        function br(Tt, Lt, Dt, Ft) {
            if (et)
                throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
            jt.has(Tt) && jr(Tt);
            let zt = (Ft && Ft.unstable_flushSync) === !0
              , kt = ot || nt
              , Qt = normalizeTo(xt.location, xt.matches, it, lt.v7_prependBasename, Dt, lt.v7_relativeSplatPath, Lt, Ft == null ? void 0 : Ft.relative)
              , Ht = matchRoutes(kt, Qt, it);
            if (!Ht) {
                _r(Tt, Lt, getInternalRouterError(404, {
                    pathname: Qt
                }), {
                    flushSync: zt
                });
                return
            }
            let {path: Jt, submission: Zt, error: vr} = normalizeNavigateOptions(lt.v7_normalizeFormMethod, !0, Qt, Ft);
            if (vr) {
                _r(Tt, Lt, vr, {
                    flushSync: zt
                });
                return
            }
            let tr = getTargetMatch(Ht, Jt);
            if (St = (Ft && Ft.preventScrollReset) === !0,
            Zt && isMutationMethod(Zt.formMethod)) {
                Sr(Tt, Lt, Jt, tr, Ht, zt, Zt);
                return
            }
            Gt.set(Tt, {
                routeId: Lt,
                path: Jt
            }),
            $r(Tt, Lt, Jt, tr, Ht, zt, Zt)
        }
        async function Sr(Tt, Lt, Dt, Ft, zt, kt, Qt) {
            if (Cr(),
            Gt.delete(Tt),
            !Ft.route.action && !Ft.route.lazy) {
                let dr = getInternalRouterError(405, {
                    method: Qt.formMethod,
                    pathname: Dt,
                    routeId: Lt
                });
                _r(Tt, Lt, dr, {
                    flushSync: kt
                });
                return
            }
            let Ht = xt.fetchers.get(Tt);
            Ar(Tt, getSubmittingFetcher(Qt, Ht), {
                flushSync: kt
            });
            let Jt = new AbortController
              , Zt = createClientSideRequest(_.history, Dt, Jt.signal, Qt);
            jt.set(Tt, Jt);
            let vr = Bt
              , tr = (await gr("action", Zt, [Ft], zt))[0];
            if (Zt.signal.aborted) {
                jt.get(Tt) === Jt && jt.delete(Tt);
                return
            }
            if (lt.v7_fetcherPersist && lr.has(Tt)) {
                if (isRedirectResult(tr) || isErrorResult(tr)) {
                    Ar(Tt, getDoneFetcher(void 0));
                    return
                }
            } else {
                if (isRedirectResult(tr))
                    if (jt.delete(Tt),
                    Ut > vr) {
                        Ar(Tt, getDoneFetcher(void 0));
                        return
                    } else
                        return Yt.add(Tt),
                        Ar(Tt, getLoadingFetcher(Qt)),
                        Rr(Zt, tr, {
                            fetcherSubmission: Qt
                        });
                if (isErrorResult(tr)) {
                    _r(Tt, Lt, tr.error);
                    return
                }
            }
            if (isDeferredResult(tr))
                throw getInternalRouterError(400, {
                    type: "defer-action"
                });
            let ir = xt.navigation.location || xt.location
              , cr = createClientSideRequest(_.history, ir, Jt.signal)
              , yr = ot || nt
              , Nr = xt.navigation.state !== "idle" ? matchRoutes(yr, xt.navigation.location, it) : xt.matches;
            invariant(Nr, "Didn't find any matches after fetcher action");
            let Br = ++Bt;
            Xt.set(Tt, Br);
            let Gr = getLoadingFetcher(Qt, tr.data);
            xt.fetchers.set(Tt, Gr);
            let[Lr,Ir] = getMatchesToLoad(_.history, xt, Nr, Qt, ir, !1, lt.unstable_skipActionErrorRevalidation, It, Mt, Wt, lr, Gt, Yt, yr, it, [Ft.route.id, tr]);
            Ir.filter(dr=>dr.key !== Tt).forEach(dr=>{
                let Fr = dr.key
                  , sn = xt.fetchers.get(Fr)
                  , En = getLoadingFetcher(void 0, sn ? sn.data : void 0);
                xt.fetchers.set(Fr, En),
                jt.has(Fr) && jr(Fr),
                dr.controller && jt.set(Fr, dr.controller)
            }
            ),
            nr({
                fetchers: new Map(xt.fetchers)
            });
            let Vr = ()=>Ir.forEach(dr=>jr(dr.key));
            Jt.signal.addEventListener("abort", Vr);
            let {loaderResults: Kr, fetcherResults: Qr} = await Mr(xt.matches, Nr, Lr, Ir, cr);
            if (Jt.signal.aborted)
                return;
            Jt.signal.removeEventListener("abort", Vr),
            Xt.delete(Tt),
            jt.delete(Tt),
            Ir.forEach(dr=>jt.delete(dr.key));
            let Ur = findRedirect([...Kr, ...Qr]);
            if (Ur) {
                if (Ur.idx >= Lr.length) {
                    let dr = Ir[Ur.idx - Lr.length].key;
                    Yt.add(dr)
                }
                return Rr(cr, Ur.result)
            }
            let {loaderData: rr, errors: xr} = processLoaderData(xt, xt.matches, Lr, Kr, void 0, Ir, Qr, sr);
            if (xt.fetchers.has(Tt)) {
                let dr = getDoneFetcher(tr.data);
                xt.fetchers.set(Tt, dr)
            }
            en(Br),
            xt.navigation.state === "loading" && Br > Ut ? (invariant(wt, "Expected pending action"),
            Pt && Pt.abort(),
            pr(xt.navigation.location, {
                matches: Nr,
                loaderData: rr,
                errors: xr,
                fetchers: new Map(xt.fetchers)
            })) : (nr({
                errors: xr,
                loaderData: mergeLoaderData(xt.loaderData, rr, Nr, xr),
                fetchers: new Map(xt.fetchers)
            }),
            It = !1)
        }
        async function $r(Tt, Lt, Dt, Ft, zt, kt, Qt) {
            let Ht = xt.fetchers.get(Tt);
            Ar(Tt, getLoadingFetcher(Qt, Ht ? Ht.data : void 0), {
                flushSync: kt
            });
            let Jt = new AbortController
              , Zt = createClientSideRequest(_.history, Dt, Jt.signal);
            jt.set(Tt, Jt);
            let vr = Bt
              , tr = (await gr("loader", Zt, [Ft], zt))[0];
            if (isDeferredResult(tr) && (tr = await resolveDeferredData(tr, Zt.signal, !0) || tr),
            jt.get(Tt) === Jt && jt.delete(Tt),
            !Zt.signal.aborted) {
                if (lr.has(Tt)) {
                    Ar(Tt, getDoneFetcher(void 0));
                    return
                }
                if (isRedirectResult(tr))
                    if (Ut > vr) {
                        Ar(Tt, getDoneFetcher(void 0));
                        return
                    } else {
                        Yt.add(Tt),
                        await Rr(Zt, tr);
                        return
                    }
                if (isErrorResult(tr)) {
                    _r(Tt, Lt, tr.error);
                    return
                }
                invariant(!isDeferredResult(tr), "Unhandled fetcher deferred data"),
                Ar(Tt, getDoneFetcher(tr.data))
            }
        }
        async function Rr(Tt, Lt, Dt) {
            let {submission: Ft, fetcherSubmission: zt, replace: kt} = Dt === void 0 ? {} : Dt;
            Lt.response.headers.has("X-Remix-Revalidate") && (It = !0);
            let Qt = Lt.response.headers.get("Location");
            invariant(Qt, "Expected a Location header on the redirect Response"),
            Qt = normalizeRedirectLocation(Qt, new URL(Tt.url), it);
            let Ht = createLocation(xt.location, Qt, {
                _isRedirect: !0
            });
            if (J) {
                let cr = !1;
                if (Lt.response.headers.has("X-Remix-Reload-Document"))
                    cr = !0;
                else if (ABSOLUTE_URL_REGEX$1.test(Qt)) {
                    const yr = _.history.createURL(Qt);
                    cr = yr.origin !== k.location.origin || stripBasename(yr.pathname, it) == null
                }
                if (cr) {
                    kt ? k.location.replace(Qt) : k.location.assign(Qt);
                    return
                }
            }
            Pt = null;
            let Jt = kt === !0 ? Action.Replace : Action.Push
              , {formMethod: Zt, formAction: vr, formEncType: tr} = xt.navigation;
            !Ft && !zt && Zt && vr && tr && (Ft = getSubmissionFromNavigation(xt.navigation));
            let ir = Ft || zt;
            if (redirectPreserveMethodStatusCodes.has(Lt.response.status) && ir && isMutationMethod(ir.formMethod))
                await ar(Jt, Ht, {
                    submission: _extends$4({}, ir, {
                        formAction: Qt
                    }),
                    preventScrollReset: St
                });
            else {
                let cr = getLoadingNavigation(Ht, Ft);
                await ar(Jt, Ht, {
                    overrideNavigation: cr,
                    fetcherSubmission: zt,
                    preventScrollReset: St
                })
            }
        }
        async function gr(Tt, Lt, Dt, Ft) {
            try {
                let zt = await callDataStrategyImpl(at, Tt, Lt, Dt, Ft, rt, tt);
                return await Promise.all(zt.map((kt,Qt)=>{
                    if (isRedirectHandlerResult(kt)) {
                        let Ht = kt.result;
                        return {
                            type: ResultType.redirect,
                            response: normalizeRelativeRoutingRedirectResponse(Ht, Lt, Dt[Qt].route.id, Ft, it, lt.v7_relativeSplatPath)
                        }
                    }
                    return convertHandlerResultToDataResult(kt)
                }
                ))
            } catch (zt) {
                return Dt.map(()=>({
                    type: ResultType.error,
                    error: zt
                }))
            }
        }
        async function Mr(Tt, Lt, Dt, Ft, zt) {
            let[kt,...Qt] = await Promise.all([Dt.length ? gr("loader", zt, Dt, Lt) : [], ...Ft.map(Ht=>{
                if (Ht.matches && Ht.match && Ht.controller) {
                    let Jt = createClientSideRequest(_.history, Ht.path, Ht.controller.signal);
                    return gr("loader", Jt, [Ht.match], Ht.matches).then(Zt=>Zt[0])
                } else
                    return Promise.resolve({
                        type: ResultType.error,
                        error: getInternalRouterError(404, {
                            pathname: Ht.path
                        })
                    })
            }
            )]);
            return await Promise.all([resolveDeferredResults(Tt, Dt, kt, kt.map(()=>zt.signal), !1, xt.loaderData), resolveDeferredResults(Tt, Ft.map(Ht=>Ht.match), Qt, Ft.map(Ht=>Ht.controller ? Ht.controller.signal : null), !0)]),
            {
                loaderResults: kt,
                fetcherResults: Qt
            }
        }
        function Cr() {
            It = !0,
            Mt.push(...Zr()),
            Gt.forEach((Tt,Lt)=>{
                jt.has(Lt) && (Wt.push(Lt),
                jr(Lt))
            }
            )
        }
        function Ar(Tt, Lt, Dt) {
            Dt === void 0 && (Dt = {}),
            xt.fetchers.set(Tt, Lt),
            nr({
                fetchers: new Map(xt.fetchers)
            }, {
                flushSync: (Dt && Dt.flushSync) === !0
            })
        }
        function _r(Tt, Lt, Dt, Ft) {
            Ft === void 0 && (Ft = {});
            let zt = findNearestBoundary(xt.matches, Lt);
            Dr(Tt),
            nr({
                errors: {
                    [zt.route.id]: Dt
                },
                fetchers: new Map(xt.fetchers)
            }, {
                flushSync: (Ft && Ft.flushSync) === !0
            })
        }
        function Wr(Tt) {
            return lt.v7_fetcherPersist && (er.set(Tt, (er.get(Tt) || 0) + 1),
            lr.has(Tt) && lr.delete(Tt)),
            xt.fetchers.get(Tt) || IDLE_FETCHER
        }
        function Dr(Tt) {
            let Lt = xt.fetchers.get(Tt);
            jt.has(Tt) && !(Lt && Lt.state === "loading" && Xt.has(Tt)) && jr(Tt),
            Gt.delete(Tt),
            Xt.delete(Tt),
            Yt.delete(Tt),
            lr.delete(Tt),
            xt.fetchers.delete(Tt)
        }
        function gn(Tt) {
            if (lt.v7_fetcherPersist) {
                let Lt = (er.get(Tt) || 0) - 1;
                Lt <= 0 ? (er.delete(Tt),
                lr.add(Tt)) : er.set(Tt, Lt)
            } else
                Dr(Tt);
            nr({
                fetchers: new Map(xt.fetchers)
            })
        }
        function jr(Tt) {
            let Lt = jt.get(Tt);
            invariant(Lt, "Expected fetch controller: " + Tt),
            Lt.abort(),
            jt.delete(Tt)
        }
        function kr(Tt) {
            for (let Lt of Tt) {
                let Dt = Wr(Lt)
                  , Ft = getDoneFetcher(Dt.data);
                xt.fetchers.set(Lt, Ft)
            }
        }
        function Jr() {
            let Tt = []
              , Lt = !1;
            for (let Dt of Yt) {
                let Ft = xt.fetchers.get(Dt);
                invariant(Ft, "Expected fetcher: " + Dt),
                Ft.state === "loading" && (Yt.delete(Dt),
                Tt.push(Dt),
                Lt = !0)
            }
            return kr(Tt),
            Lt
        }
        function en(Tt) {
            let Lt = [];
            for (let[Dt,Ft] of Xt)
                if (Ft < Tt) {
                    let zt = xt.fetchers.get(Dt);
                    invariant(zt, "Expected fetcher: " + Dt),
                    zt.state === "loading" && (jr(Dt),
                    Xt.delete(Dt),
                    Lt.push(Dt))
                }
            return kr(Lt),
            Lt.length > 0
        }
        function yn(Tt, Lt) {
            let Dt = xt.blockers.get(Tt) || IDLE_BLOCKER;
            return fr.get(Tt) !== Lt && fr.set(Tt, Lt),
            Dt
        }
        function tn(Tt) {
            xt.blockers.delete(Tt),
            fr.delete(Tt)
        }
        function qr(Tt, Lt) {
            let Dt = xt.blockers.get(Tt) || IDLE_BLOCKER;
            invariant(Dt.state === "unblocked" && Lt.state === "blocked" || Dt.state === "blocked" && Lt.state === "blocked" || Dt.state === "blocked" && Lt.state === "proceeding" || Dt.state === "blocked" && Lt.state === "unblocked" || Dt.state === "proceeding" && Lt.state === "unblocked", "Invalid blocker state transition: " + Dt.state + " -> " + Lt.state);
            let Ft = new Map(xt.blockers);
            Ft.set(Tt, Lt),
            nr({
                blockers: Ft
            })
        }
        function rn(Tt) {
            let {currentLocation: Lt, nextLocation: Dt, historyAction: Ft} = Tt;
            if (fr.size === 0)
                return;
            fr.size > 1 && warning(!1, "A router only supports one blocker at a time");
            let zt = Array.from(fr.entries())
              , [kt,Qt] = zt[zt.length - 1]
              , Ht = xt.blockers.get(kt);
            if (!(Ht && Ht.state === "proceeding") && Qt({
                currentLocation: Lt,
                nextLocation: Dt,
                historyAction: Ft
            }))
                return kt
        }
        function Zr(Tt) {
            let Lt = [];
            return sr.forEach((Dt,Ft)=>{
                (!Tt || Tt(Ft)) && (Dt.cancel(),
                Lt.push(Ft),
                sr.delete(Ft))
            }
            ),
            Lt
        }
        function vn(Tt, Lt, Dt) {
            if (ct = Tt,
            ft = Lt,
            pt = Dt || null,
            !yt && xt.navigation === IDLE_NAVIGATION) {
                yt = !0;
                let Ft = an(xt.location, xt.matches);
                Ft != null && nr({
                    restoreScrollPosition: Ft
                })
            }
            return ()=>{
                ct = null,
                ft = null,
                pt = null
            }
        }
        function nn(Tt, Lt) {
            return pt && pt(Tt, Lt.map(Dt=>convertRouteMatchToUiMatch(Dt, xt.loaderData))) || Tt.key
        }
        function bn(Tt, Lt) {
            if (ct && ft) {
                let Dt = nn(Tt, Lt);
                ct[Dt] = ft()
            }
        }
        function an(Tt, Lt) {
            if (ct) {
                let Dt = nn(Tt, Lt)
                  , Ft = ct[Dt];
                if (typeof Ft == "number")
                    return Ft
            }
            return null
        }
        function xn(Tt) {
            rt = {},
            ot = convertRoutesToDataRoutes(Tt, tt, void 0, rt)
        }
        return Et = {
            get basename() {
                return it
            },
            get future() {
                return lt
            },
            get state() {
                return xt
            },
            get routes() {
                return nt
            },
            get window() {
                return k
            },
            initialize: mr,
            subscribe: Pr,
            enableScrollRestoration: vn,
            navigate: Or,
            fetch: br,
            revalidate: ur,
            createHref: Tt=>_.history.createHref(Tt),
            encodeLocation: Tt=>_.history.encodeLocation(Tt),
            getFetcher: Wr,
            deleteFetcher: gn,
            dispose: wr,
            getBlocker: yn,
            deleteBlocker: tn,
            _internalFetchControllers: jt,
            _internalActiveDeferreds: sr,
            _internalSetRoutes: xn
        },
        Et
    }
    function isSubmissionNavigation(_) {
        return _ != null && ("formData"in _ && _.formData != null || "body"in _ && _.body !== void 0)
    }
    function normalizeTo(_, k, J, et, tt, rt, nt, ot) {
        let it, at;
        if (nt) {
            it = [];
            for (let st of k)
                if (it.push(st),
                st.route.id === nt) {
                    at = st;
                    break
                }
        } else
            it = k,
            at = k[k.length - 1];
        let lt = resolveTo(tt || ".", getResolveToMatches(it, rt), stripBasename(_.pathname, J) || _.pathname, ot === "path");
        return tt == null && (lt.search = _.search,
        lt.hash = _.hash),
        (tt == null || tt === "" || tt === ".") && at && at.route.index && !hasNakedIndexQuery(lt.search) && (lt.search = lt.search ? lt.search.replace(/^\?/, "?index&") : "?index"),
        et && J !== "/" && (lt.pathname = lt.pathname === "/" ? J : joinPaths([J, lt.pathname])),
        createPath(lt)
    }
    function normalizeNavigateOptions(_, k, J, et) {
        if (!et || !isSubmissionNavigation(et))
            return {
                path: J
            };
        if (et.formMethod && !isValidMethod(et.formMethod))
            return {
                path: J,
                error: getInternalRouterError(405, {
                    method: et.formMethod
                })
            };
        let tt = ()=>({
            path: J,
            error: getInternalRouterError(400, {
                type: "invalid-body"
            })
        })
          , rt = et.formMethod || "get"
          , nt = _ ? rt.toUpperCase() : rt.toLowerCase()
          , ot = stripHashFromPath(J);
        if (et.body !== void 0) {
            if (et.formEncType === "text/plain") {
                if (!isMutationMethod(nt))
                    return tt();
                let ut = typeof et.body == "string" ? et.body : et.body instanceof FormData || et.body instanceof URLSearchParams ? Array.from(et.body.entries()).reduce((ct,pt)=>{
                    let[ft,yt] = pt;
                    return "" + ct + ft + "=" + yt + `
`
                }
                , "") : String(et.body);
                return {
                    path: J,
                    submission: {
                        formMethod: nt,
                        formAction: ot,
                        formEncType: et.formEncType,
                        formData: void 0,
                        json: void 0,
                        text: ut
                    }
                }
            } else if (et.formEncType === "application/json") {
                if (!isMutationMethod(nt))
                    return tt();
                try {
                    let ut = typeof et.body == "string" ? JSON.parse(et.body) : et.body;
                    return {
                        path: J,
                        submission: {
                            formMethod: nt,
                            formAction: ot,
                            formEncType: et.formEncType,
                            formData: void 0,
                            json: ut,
                            text: void 0
                        }
                    }
                } catch (ut) {
                    return tt()
                }
            }
        }
        invariant(typeof FormData == "function", "FormData is not available in this environment");
        let it, at;
        if (et.formData)
            it = convertFormDataToSearchParams(et.formData),
            at = et.formData;
        else if (et.body instanceof FormData)
            it = convertFormDataToSearchParams(et.body),
            at = et.body;
        else if (et.body instanceof URLSearchParams)
            it = et.body,
            at = convertSearchParamsToFormData(it);
        else if (et.body == null)
            it = new URLSearchParams,
            at = new FormData;
        else
            try {
                it = new URLSearchParams(et.body),
                at = convertSearchParamsToFormData(it)
            } catch (ut) {
                return tt()
            }
        let lt = {
            formMethod: nt,
            formAction: ot,
            formEncType: et && et.formEncType || "application/x-www-form-urlencoded",
            formData: at,
            json: void 0,
            text: void 0
        };
        if (isMutationMethod(lt.formMethod))
            return {
                path: J,
                submission: lt
            };
        let st = parsePath(J);
        return k && st.search && hasNakedIndexQuery(st.search) && it.append("index", ""),
        st.search = "?" + it,
        {
            path: createPath(st),
            submission: lt
        }
    }
    function getLoaderMatchesUntilBoundary(_, k) {
        let J = _;
        if (k) {
            let et = _.findIndex(tt=>tt.route.id === k);
            et >= 0 && (J = _.slice(0, et))
        }
        return J
    }
    function getMatchesToLoad(_, k, J, et, tt, rt, nt, ot, it, at, lt, st, ut, ct, pt, ft) {
        let yt = ft ? isErrorResult(ft[1]) ? ft[1].error : ft[1].data : void 0
          , ht = _.createURL(k.location)
          , gt = _.createURL(tt)
          , mt = ft && isErrorResult(ft[1]) ? ft[0] : void 0
          , vt = mt ? getLoaderMatchesUntilBoundary(J, mt) : J
          , bt = ft ? ft[1].statusCode : void 0
          , Et = nt && bt && bt >= 400
          , xt = vt.filter((St,Pt)=>{
            let {route: Rt} = St;
            if (Rt.lazy)
                return !0;
            if (Rt.loader == null)
                return !1;
            if (rt)
                return typeof Rt.loader != "function" || Rt.loader.hydrate ? !0 : k.loaderData[Rt.id] === void 0 && (!k.errors || k.errors[Rt.id] === void 0);
            if (isNewLoader(k.loaderData, k.matches[Pt], St) || it.some(Ot=>Ot === St.route.id))
                return !0;
            let At = k.matches[Pt]
              , Nt = St;
            return shouldRevalidateLoader(St, _extends$4({
                currentUrl: ht,
                currentParams: At.params,
                nextUrl: gt,
                nextParams: Nt.params
            }, et, {
                actionResult: yt,
                unstable_actionStatus: bt,
                defaultShouldRevalidate: Et ? !1 : ot || ht.pathname + ht.search === gt.pathname + gt.search || ht.search !== gt.search || isNewRouteInstance(At, Nt)
            }))
        }
        )
          , wt = [];
        return st.forEach((St,Pt)=>{
            if (rt || !J.some(It=>It.route.id === St.routeId) || lt.has(Pt))
                return;
            let Rt = matchRoutes(ct, St.path, pt);
            if (!Rt) {
                wt.push({
                    key: Pt,
                    routeId: St.routeId,
                    path: St.path,
                    matches: null,
                    match: null,
                    controller: null
                });
                return
            }
            let At = k.fetchers.get(Pt)
              , Nt = getTargetMatch(Rt, St.path)
              , Ot = !1;
            ut.has(Pt) ? Ot = !1 : at.includes(Pt) ? Ot = !0 : At && At.state !== "idle" && At.data === void 0 ? Ot = ot : Ot = shouldRevalidateLoader(Nt, _extends$4({
                currentUrl: ht,
                currentParams: k.matches[k.matches.length - 1].params,
                nextUrl: gt,
                nextParams: J[J.length - 1].params
            }, et, {
                actionResult: yt,
                unstable_actionStatus: bt,
                defaultShouldRevalidate: Et ? !1 : ot
            })),
            Ot && wt.push({
                key: Pt,
                routeId: St.routeId,
                path: St.path,
                matches: Rt,
                match: Nt,
                controller: new AbortController
            })
        }
        ),
        [xt, wt]
    }
    function isNewLoader(_, k, J) {
        let et = !k || J.route.id !== k.route.id
          , tt = _[J.route.id] === void 0;
        return et || tt
    }
    function isNewRouteInstance(_, k) {
        let J = _.route.path;
        return _.pathname !== k.pathname || J != null && J.endsWith("*") && _.params["*"] !== k.params["*"]
    }
    function shouldRevalidateLoader(_, k) {
        if (_.route.shouldRevalidate) {
            let J = _.route.shouldRevalidate(k);
            if (typeof J == "boolean")
                return J
        }
        return k.defaultShouldRevalidate
    }
    async function loadLazyRouteModule(_, k, J) {
        if (!_.lazy)
            return;
        let et = await _.lazy();
        if (!_.lazy)
            return;
        let tt = J[_.id];
        invariant(tt, "No route found in manifest");
        let rt = {};
        for (let nt in et) {
            let ot = tt[nt] !== void 0 && nt !== "hasErrorBoundary";
            warning(!ot, 'Route "' + tt.id + '" has a static property "' + nt + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + nt + '" will be ignored.')),
            !ot && !immutableRouteKeys.has(nt) && (rt[nt] = et[nt])
        }
        Object.assign(tt, rt),
        Object.assign(tt, _extends$4({}, k(tt), {
            lazy: void 0
        }))
    }
    function defaultDataStrategy(_) {
        return Promise.all(_.matches.map(k=>k.resolve()))
    }
    async function callDataStrategyImpl(_, k, J, et, tt, rt, nt, ot) {
        let it = et.reduce((st,ut)=>st.add(ut.route.id), new Set)
          , at = new Set
          , lt = await _({
            matches: tt.map(st=>{
                let ut = it.has(st.route.id);
                return _extends$4({}, st, {
                    shouldLoad: ut,
                    resolve: ct=>(at.add(st.route.id),
                    ut ? callLoaderOrAction(k, J, st, rt, nt, ct, ot) : Promise.resolve({
                        type: ResultType.data,
                        result: void 0
                    }))
                })
            }
            ),
            request: J,
            params: tt[0].params,
            context: ot
        });
        return tt.forEach(st=>invariant(at.has(st.route.id), '`match.resolve()` was not called for route id "' + st.route.id + '". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')),
        lt.filter((st,ut)=>it.has(tt[ut].route.id))
    }
    async function callLoaderOrAction(_, k, J, et, tt, rt, nt) {
        let ot, it, at = lt=>{
            let st, ut = new Promise((ft,yt)=>st = yt);
            it = ()=>st(),
            k.signal.addEventListener("abort", it);
            let ct = ft=>typeof lt != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + _ + '" [routeId: ' + J.route.id + "]"))) : lt({
                request: k,
                params: J.params,
                context: nt
            }, ...ft !== void 0 ? [ft] : []), pt;
            return rt ? pt = rt(ft=>ct(ft)) : pt = (async()=>{
                try {
                    return {
                        type: "data",
                        result: await ct()
                    }
                } catch (ft) {
                    return {
                        type: "error",
                        result: ft
                    }
                }
            }
            )(),
            Promise.race([pt, ut])
        }
        ;
        try {
            let lt = J.route[_];
            if (J.route.lazy)
                if (lt) {
                    let st, [ut] = await Promise.all([at(lt).catch(ct=>{
                        st = ct
                    }
                    ), loadLazyRouteModule(J.route, tt, et)]);
                    if (st !== void 0)
                        throw st;
                    ot = ut
                } else if (await loadLazyRouteModule(J.route, tt, et),
                lt = J.route[_],
                lt)
                    ot = await at(lt);
                else if (_ === "action") {
                    let st = new URL(k.url)
                      , ut = st.pathname + st.search;
                    throw getInternalRouterError(405, {
                        method: k.method,
                        pathname: ut,
                        routeId: J.route.id
                    })
                } else
                    return {
                        type: ResultType.data,
                        result: void 0
                    };
            else if (lt)
                ot = await at(lt);
            else {
                let st = new URL(k.url)
                  , ut = st.pathname + st.search;
                throw getInternalRouterError(404, {
                    pathname: ut
                })
            }
            invariant(ot.result !== void 0, "You defined " + (_ === "action" ? "an action" : "a loader") + " for route " + ('"' + J.route.id + "\" but didn't return anything from your `" + _ + "` ") + "function. Please return a value or `null`.")
        } catch (lt) {
            return {
                type: ResultType.error,
                result: lt
            }
        } finally {
            it && k.signal.removeEventListener("abort", it)
        }
        return ot
    }
    async function convertHandlerResultToDataResult(_) {
        let {result: k, type: J, status: et} = _;
        if (isResponse(k)) {
            let nt;
            try {
                let ot = k.headers.get("Content-Type");
                ot && /\bapplication\/json\b/.test(ot) ? k.body == null ? nt = null : nt = await k.json() : nt = await k.text()
            } catch (ot) {
                return {
                    type: ResultType.error,
                    error: ot
                }
            }
            return J === ResultType.error ? {
                type: ResultType.error,
                error: new ErrorResponseImpl(k.status,k.statusText,nt),
                statusCode: k.status,
                headers: k.headers
            } : {
                type: ResultType.data,
                data: nt,
                statusCode: k.status,
                headers: k.headers
            }
        }
        if (J === ResultType.error)
            return {
                type: ResultType.error,
                error: k,
                statusCode: isRouteErrorResponse(k) ? k.status : et
            };
        if (isDeferredData(k)) {
            var tt, rt;
            return {
                type: ResultType.deferred,
                deferredData: k,
                statusCode: (tt = k.init) == null ? void 0 : tt.status,
                headers: ((rt = k.init) == null ? void 0 : rt.headers) && new Headers(k.init.headers)
            }
        }
        return {
            type: ResultType.data,
            data: k,
            statusCode: et
        }
    }
    function normalizeRelativeRoutingRedirectResponse(_, k, J, et, tt, rt) {
        let nt = _.headers.get("Location");
        if (invariant(nt, "Redirects returned/thrown from loaders/actions must have a Location header"),
        !ABSOLUTE_URL_REGEX$1.test(nt)) {
            let ot = et.slice(0, et.findIndex(it=>it.route.id === J) + 1);
            nt = normalizeTo(new URL(k.url), ot, tt, !0, nt, rt),
            _.headers.set("Location", nt)
        }
        return _
    }
    function normalizeRedirectLocation(_, k, J) {
        if (ABSOLUTE_URL_REGEX$1.test(_)) {
            let et = _
              , tt = et.startsWith("//") ? new URL(k.protocol + et) : new URL(et)
              , rt = stripBasename(tt.pathname, J) != null;
            if (tt.origin === k.origin && rt)
                return tt.pathname + tt.search + tt.hash
        }
        return _
    }
    function createClientSideRequest(_, k, J, et) {
        let tt = _.createURL(stripHashFromPath(k)).toString()
          , rt = {
            signal: J
        };
        if (et && isMutationMethod(et.formMethod)) {
            let {formMethod: nt, formEncType: ot} = et;
            rt.method = nt.toUpperCase(),
            ot === "application/json" ? (rt.headers = new Headers({
                "Content-Type": ot
            }),
            rt.body = JSON.stringify(et.json)) : ot === "text/plain" ? rt.body = et.text : ot === "application/x-www-form-urlencoded" && et.formData ? rt.body = convertFormDataToSearchParams(et.formData) : rt.body = et.formData
        }
        return new Request(tt,rt)
    }
    function convertFormDataToSearchParams(_) {
        let k = new URLSearchParams;
        for (let[J,et] of _.entries())
            k.append(J, typeof et == "string" ? et : et.name);
        return k
    }
    function convertSearchParamsToFormData(_) {
        let k = new FormData;
        for (let[J,et] of _.entries())
            k.append(J, et);
        return k
    }
    function processRouteLoaderData(_, k, J, et, tt, rt) {
        let nt = {}, ot = null, it, at = !1, lt = {}, st = et && isErrorResult(et[1]) ? et[1].error : void 0;
        return J.forEach((ut,ct)=>{
            let pt = k[ct].route.id;
            if (invariant(!isRedirectResult(ut), "Cannot handle redirect results in processLoaderData"),
            isErrorResult(ut)) {
                let ft = ut.error;
                if (st !== void 0 && (ft = st,
                st = void 0),
                ot = ot || {},
                rt)
                    ot[pt] = ft;
                else {
                    let yt = findNearestBoundary(_, pt);
                    ot[yt.route.id] == null && (ot[yt.route.id] = ft)
                }
                nt[pt] = void 0,
                at || (at = !0,
                it = isRouteErrorResponse(ut.error) ? ut.error.status : 500),
                ut.headers && (lt[pt] = ut.headers)
            } else
                isDeferredResult(ut) ? (tt.set(pt, ut.deferredData),
                nt[pt] = ut.deferredData.data,
                ut.statusCode != null && ut.statusCode !== 200 && !at && (it = ut.statusCode),
                ut.headers && (lt[pt] = ut.headers)) : (nt[pt] = ut.data,
                ut.statusCode && ut.statusCode !== 200 && !at && (it = ut.statusCode),
                ut.headers && (lt[pt] = ut.headers))
        }
        ),
        st !== void 0 && et && (ot = {
            [et[0]]: st
        },
        nt[et[0]] = void 0),
        {
            loaderData: nt,
            errors: ot,
            statusCode: it || 200,
            loaderHeaders: lt
        }
    }
    function processLoaderData(_, k, J, et, tt, rt, nt, ot) {
        let {loaderData: it, errors: at} = processRouteLoaderData(k, J, et, tt, ot, !1);
        for (let lt = 0; lt < rt.length; lt++) {
            let {key: st, match: ut, controller: ct} = rt[lt];
            invariant(nt !== void 0 && nt[lt] !== void 0, "Did not find corresponding fetcher result");
            let pt = nt[lt];
            if (!(ct && ct.signal.aborted))
                if (isErrorResult(pt)) {
                    let ft = findNearestBoundary(_.matches, ut == null ? void 0 : ut.route.id);
                    at && at[ft.route.id] || (at = _extends$4({}, at, {
                        [ft.route.id]: pt.error
                    })),
                    _.fetchers.delete(st)
                } else if (isRedirectResult(pt))
                    invariant(!1, "Unhandled fetcher revalidation redirect");
                else if (isDeferredResult(pt))
                    invariant(!1, "Unhandled fetcher deferred data");
                else {
                    let ft = getDoneFetcher(pt.data);
                    _.fetchers.set(st, ft)
                }
        }
        return {
            loaderData: it,
            errors: at
        }
    }
    function mergeLoaderData(_, k, J, et) {
        let tt = _extends$4({}, k);
        for (let rt of J) {
            let nt = rt.route.id;
            if (k.hasOwnProperty(nt) ? k[nt] !== void 0 && (tt[nt] = k[nt]) : _[nt] !== void 0 && rt.route.loader && (tt[nt] = _[nt]),
            et && et.hasOwnProperty(nt))
                break
        }
        return tt
    }
    function getActionDataForCommit(_) {
        return _ ? isErrorResult(_[1]) ? {
            actionData: {}
        } : {
            actionData: {
                [_[0]]: _[1].data
            }
        } : {}
    }
    function findNearestBoundary(_, k) {
        return (k ? _.slice(0, _.findIndex(J=>J.route.id === k) + 1) : [..._]).reverse().find(J=>J.route.hasErrorBoundary === !0) || _[0]
    }
    function getShortCircuitMatches(_) {
        let k = _.length === 1 ? _[0] : _.find(J=>J.index || !J.path || J.path === "/") || {
            id: "__shim-error-route__"
        };
        return {
            matches: [{
                params: {},
                pathname: "",
                pathnameBase: "",
                route: k
            }],
            route: k
        }
    }
    function getInternalRouterError(_, k) {
        let {pathname: J, routeId: et, method: tt, type: rt} = k === void 0 ? {} : k
          , nt = "Unknown Server Error"
          , ot = "Unknown @remix-run/router error";
        return _ === 400 ? (nt = "Bad Request",
        tt && J && et ? ot = "You made a " + tt + ' request to "' + J + '" but ' + ('did not provide a `loader` for route "' + et + '", ') + "so there is no way to handle the request." : rt === "defer-action" ? ot = "defer() is not supported in actions" : rt === "invalid-body" && (ot = "Unable to encode submission body")) : _ === 403 ? (nt = "Forbidden",
        ot = 'Route "' + et + '" does not match URL "' + J + '"') : _ === 404 ? (nt = "Not Found",
        ot = 'No route matches URL "' + J + '"') : _ === 405 && (nt = "Method Not Allowed",
        tt && J && et ? ot = "You made a " + tt.toUpperCase() + ' request to "' + J + '" but ' + ('did not provide an `action` for route "' + et + '", ') + "so there is no way to handle the request." : tt && (ot = 'Invalid request method "' + tt.toUpperCase() + '"')),
        new ErrorResponseImpl(_ || 500,nt,new Error(ot),!0)
    }
    function findRedirect(_) {
        for (let k = _.length - 1; k >= 0; k--) {
            let J = _[k];
            if (isRedirectResult(J))
                return {
                    result: J,
                    idx: k
                }
        }
    }
    function stripHashFromPath(_) {
        let k = typeof _ == "string" ? parsePath(_) : _;
        return createPath(_extends$4({}, k, {
            hash: ""
        }))
    }
    function isHashChangeOnly(_, k) {
        return _.pathname !== k.pathname || _.search !== k.search ? !1 : _.hash === "" ? k.hash !== "" : _.hash === k.hash ? !0 : k.hash !== ""
    }
    function isRedirectHandlerResult(_) {
        return isResponse(_.result) && redirectStatusCodes.has(_.result.status)
    }
    function isDeferredResult(_) {
        return _.type === ResultType.deferred
    }
    function isErrorResult(_) {
        return _.type === ResultType.error
    }
    function isRedirectResult(_) {
        return (_ && _.type) === ResultType.redirect
    }
    function isDeferredData(_) {
        let k = _;
        return k && typeof k == "object" && typeof k.data == "object" && typeof k.subscribe == "function" && typeof k.cancel == "function" && typeof k.resolveData == "function"
    }
    function isResponse(_) {
        return _ != null && typeof _.status == "number" && typeof _.statusText == "string" && typeof _.headers == "object" && typeof _.body < "u"
    }
    function isValidMethod(_) {
        return validRequestMethods.has(_.toLowerCase())
    }
    function isMutationMethod(_) {
        return validMutationMethods.has(_.toLowerCase())
    }
    async function resolveDeferredResults(_, k, J, et, tt, rt) {
        for (let nt = 0; nt < J.length; nt++) {
            let ot = J[nt]
              , it = k[nt];
            if (!it)
                continue;
            let at = _.find(st=>st.route.id === it.route.id)
              , lt = at != null && !isNewRouteInstance(at, it) && (rt && rt[it.route.id]) !== void 0;
            if (isDeferredResult(ot) && (tt || lt)) {
                let st = et[nt];
                invariant(st, "Expected an AbortSignal for revalidating fetcher deferred result"),
                await resolveDeferredData(ot, st, tt).then(ut=>{
                    ut && (J[nt] = ut || J[nt])
                }
                )
            }
        }
    }
    async function resolveDeferredData(_, k, J) {
        if (J === void 0 && (J = !1),
        !await _.deferredData.resolveData(k)) {
            if (J)
                try {
                    return {
                        type: ResultType.data,
                        data: _.deferredData.unwrappedData
                    }
                } catch (et) {
                    return {
                        type: ResultType.error,
                        error: et
                    }
                }
            return {
                type: ResultType.data,
                data: _.deferredData.data
            }
        }
    }
    function hasNakedIndexQuery(_) {
        return new URLSearchParams(_).getAll("index").some(k=>k === "")
    }
    function getTargetMatch(_, k) {
        let J = typeof k == "string" ? parsePath(k).search : k.search;
        if (_[_.length - 1].route.index && hasNakedIndexQuery(J || ""))
            return _[_.length - 1];
        let et = getPathContributingMatches(_);
        return et[et.length - 1]
    }
    function getSubmissionFromNavigation(_) {
        let {formMethod: k, formAction: J, formEncType: et, text: tt, formData: rt, json: nt} = _;
        if (!(!k || !J || !et)) {
            if (tt != null)
                return {
                    formMethod: k,
                    formAction: J,
                    formEncType: et,
                    formData: void 0,
                    json: void 0,
                    text: tt
                };
            if (rt != null)
                return {
                    formMethod: k,
                    formAction: J,
                    formEncType: et,
                    formData: rt,
                    json: void 0,
                    text: void 0
                };
            if (nt !== void 0)
                return {
                    formMethod: k,
                    formAction: J,
                    formEncType: et,
                    formData: void 0,
                    json: nt,
                    text: void 0
                }
        }
    }
    function getLoadingNavigation(_, k) {
        return k ? {
            state: "loading",
            location: _,
            formMethod: k.formMethod,
            formAction: k.formAction,
            formEncType: k.formEncType,
            formData: k.formData,
            json: k.json,
            text: k.text
        } : {
            state: "loading",
            location: _,
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0
        }
    }
    function getSubmittingNavigation(_, k) {
        return {
            state: "submitting",
            location: _,
            formMethod: k.formMethod,
            formAction: k.formAction,
            formEncType: k.formEncType,
            formData: k.formData,
            json: k.json,
            text: k.text
        }
    }
    function getLoadingFetcher(_, k) {
        return _ ? {
            state: "loading",
            formMethod: _.formMethod,
            formAction: _.formAction,
            formEncType: _.formEncType,
            formData: _.formData,
            json: _.json,
            text: _.text,
            data: k
        } : {
            state: "loading",
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0,
            data: k
        }
    }
    function getSubmittingFetcher(_, k) {
        return {
            state: "submitting",
            formMethod: _.formMethod,
            formAction: _.formAction,
            formEncType: _.formEncType,
            formData: _.formData,
            json: _.json,
            text: _.text,
            data: k ? k.data : void 0
        }
    }
    function getDoneFetcher(_) {
        return {
            state: "idle",
            formMethod: void 0,
            formAction: void 0,
            formEncType: void 0,
            formData: void 0,
            json: void 0,
            text: void 0,
            data: _
        }
    }
    function restoreAppliedTransitions(_, k) {
        try {
            let J = _.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
            if (J) {
                let et = JSON.parse(J);
                for (let[tt,rt] of Object.entries(et || {}))
                    rt && Array.isArray(rt) && k.set(tt, new Set(rt || []))
            }
        } catch (J) {}
    }
    function persistAppliedTransitions(_, k) {
        if (k.size > 0) {
            let J = {};
            for (let[et,tt] of k)
                J[et] = [...tt];
            try {
                _.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(J))
            } catch (et) {
                warning(!1, "Failed to save applied view transitions in sessionStorage (" + et + ").")
            }
        }
    }
    function _extends$3() {
        return _extends$3 = Object.assign ? Object.assign.bind() : function(_) {
            for (var k = 1; k < arguments.length; k++) {
                var J = arguments[k];
                for (var et in J)
                    Object.prototype.hasOwnProperty.call(J, et) && (_[et] = J[et])
            }
            return _
        }
        ,
        _extends$3.apply(this, arguments)
    }
    const DataRouterContext = reactExports.createContext(null)
      , DataRouterStateContext = reactExports.createContext(null)
      , AwaitContext = reactExports.createContext(null)
      , NavigationContext = reactExports.createContext(null)
      , LocationContext = reactExports.createContext(null)
      , RouteContext = reactExports.createContext({
        outlet: null,
        matches: [],
        isDataRoute: !1
    })
      , RouteErrorContext = reactExports.createContext(null);
    function useHref(_, k) {
        let {relative: J} = k === void 0 ? {} : k;
        useInRouterContext() || invariant(!1);
        let {basename: et, navigator: tt} = reactExports.useContext(NavigationContext)
          , {hash: rt, pathname: nt, search: ot} = useResolvedPath(_, {
            relative: J
        })
          , it = nt;
        return et !== "/" && (it = nt === "/" ? et : joinPaths([et, nt])),
        tt.createHref({
            pathname: it,
            search: ot,
            hash: rt
        })
    }
    function useInRouterContext() {
        return reactExports.useContext(LocationContext) != null
    }
    useLocation$1 = function() {
        return useInRouterContext() || invariant(!1),
        reactExports.useContext(LocationContext).location
    }
    ;
    function useNavigationType() {
        return reactExports.useContext(LocationContext).navigationType
    }
    function useMatch(_) {
        useInRouterContext() || invariant(!1);
        let {pathname: k} = useLocation$1();
        return reactExports.useMemo(()=>matchPath(_, k), [k, _])
    }
    function useIsomorphicLayoutEffect$1(_) {
        reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(_)
    }
    function useNavigate$1() {
        let {isDataRoute: _} = reactExports.useContext(RouteContext);
        return _ ? useNavigateStable() : useNavigateUnstable()
    }
    function useNavigateUnstable() {
        useInRouterContext() || invariant(!1);
        let _ = reactExports.useContext(DataRouterContext)
          , {basename: k, future: J, navigator: et} = reactExports.useContext(NavigationContext)
          , {matches: tt} = reactExports.useContext(RouteContext)
          , {pathname: rt} = useLocation$1()
          , nt = JSON.stringify(getResolveToMatches(tt, J.v7_relativeSplatPath))
          , ot = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$1(()=>{
            ot.current = !0
        }
        ),
        reactExports.useCallback(function(it, at) {
            if (at === void 0 && (at = {}),
            !ot.current)
                return;
            if (typeof it == "number") {
                et.go(it);
                return
            }
            let lt = resolveTo(it, JSON.parse(nt), rt, at.relative === "path");
            _ == null && k !== "/" && (lt.pathname = lt.pathname === "/" ? k : joinPaths([k, lt.pathname])),
            (at.replace ? et.replace : et.push)(lt, at.state, at)
        }, [k, et, nt, rt, _])
    }
    const OutletContext = reactExports.createContext(null);
    function useOutletContext() {
        return reactExports.useContext(OutletContext)
    }
    function useOutlet(_) {
        let k = reactExports.useContext(RouteContext).outlet;
        return k && reactExports.createElement(OutletContext.Provider, {
            value: _
        }, k)
    }
    function useParams() {
        let {matches: _} = reactExports.useContext(RouteContext)
          , k = _[_.length - 1];
        return k ? k.params : {}
    }
    function useResolvedPath(_, k) {
        let {relative: J} = k === void 0 ? {} : k
          , {future: et} = reactExports.useContext(NavigationContext)
          , {matches: tt} = reactExports.useContext(RouteContext)
          , {pathname: rt} = useLocation$1()
          , nt = JSON.stringify(getResolveToMatches(tt, et.v7_relativeSplatPath));
        return reactExports.useMemo(()=>resolveTo(_, JSON.parse(nt), rt, J === "path"), [_, nt, rt, J])
    }
    function useRoutes(_, k) {
        return useRoutesImpl(_, k)
    }
    function useRoutesImpl(_, k, J, et) {
        useInRouterContext() || invariant(!1);
        let {navigator: tt} = reactExports.useContext(NavigationContext)
          , {matches: rt} = reactExports.useContext(RouteContext)
          , nt = rt[rt.length - 1]
          , ot = nt ? nt.params : {};
        nt && nt.pathname;
        let it = nt ? nt.pathnameBase : "/";
        nt && nt.route;
        let at = useLocation$1(), lt;
        if (k) {
            var st;
            let yt = typeof k == "string" ? parsePath(k) : k;
            it === "/" || (st = yt.pathname) != null && st.startsWith(it) || invariant(!1),
            lt = yt
        } else
            lt = at;
        let ut = lt.pathname || "/"
          , ct = ut;
        if (it !== "/") {
            let yt = it.replace(/^\//, "").split("/");
            ct = "/" + ut.replace(/^\//, "").split("/").slice(yt.length).join("/")
        }
        let pt = matchRoutes(_, {
            pathname: ct
        })
          , ft = _renderMatches(pt && pt.map(yt=>Object.assign({}, yt, {
            params: Object.assign({}, ot, yt.params),
            pathname: joinPaths([it, tt.encodeLocation ? tt.encodeLocation(yt.pathname).pathname : yt.pathname]),
            pathnameBase: yt.pathnameBase === "/" ? it : joinPaths([it, tt.encodeLocation ? tt.encodeLocation(yt.pathnameBase).pathname : yt.pathnameBase])
        })), rt, J, et);
        return k && ft ? reactExports.createElement(LocationContext.Provider, {
            value: {
                location: _extends$3({
                    pathname: "/",
                    search: "",
                    hash: "",
                    state: null,
                    key: "default"
                }, lt),
                navigationType: Action.Pop
            }
        }, ft) : ft
    }
    function DefaultErrorComponent() {
        let _ = useRouteError()
          , k = isRouteErrorResponse(_) ? _.status + " " + _.statusText : _ instanceof Error ? _.message : JSON.stringify(_)
          , J = _ instanceof Error ? _.stack : null
          , et = {
            padding: "0.5rem",
            backgroundColor: "rgba(200,200,200, 0.5)"
        }
          , tt = null;
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
            style: {
                fontStyle: "italic"
            }
        }, k), J ? reactExports.createElement("pre", {
            style: et
        }, J) : null, tt)
    }
    const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
        constructor(k) {
            super(k),
            this.state = {
                location: k.location,
                revalidation: k.revalidation,
                error: k.error
            }
        }
        static getDerivedStateFromError(k) {
            return {
                error: k
            }
        }
        static getDerivedStateFromProps(k, J) {
            return J.location !== k.location || J.revalidation !== "idle" && k.revalidation === "idle" ? {
                error: k.error,
                location: k.location,
                revalidation: k.revalidation
            } : {
                error: k.error !== void 0 ? k.error : J.error,
                location: J.location,
                revalidation: k.revalidation || J.revalidation
            }
        }
        componentDidCatch(k, J) {}
        render() {
            return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
                value: this.props.routeContext
            }, reactExports.createElement(RouteErrorContext.Provider, {
                value: this.state.error,
                children: this.props.component
            })) : this.props.children
        }
    }
    function RenderedRoute(_) {
        let {routeContext: k, match: J, children: et} = _
          , tt = reactExports.useContext(DataRouterContext);
        return tt && tt.static && tt.staticContext && (J.route.errorElement || J.route.ErrorBoundary) && (tt.staticContext._deepestRenderedBoundaryId = J.route.id),
        reactExports.createElement(RouteContext.Provider, {
            value: k
        }, et)
    }
    function _renderMatches(_, k, J, et) {
        var tt;
        if (k === void 0 && (k = []),
        J === void 0 && (J = null),
        et === void 0 && (et = null),
        _ == null) {
            var rt;
            if ((rt = J) != null && rt.errors)
                _ = J.matches;
            else
                return null
        }
        let nt = _
          , ot = (tt = J) == null ? void 0 : tt.errors;
        if (ot != null) {
            let lt = nt.findIndex(st=>st.route.id && (ot == null ? void 0 : ot[st.route.id]) !== void 0);
            lt >= 0 || invariant(!1),
            nt = nt.slice(0, Math.min(nt.length, lt + 1))
        }
        let it = !1
          , at = -1;
        if (J && et && et.v7_partialHydration)
            for (let lt = 0; lt < nt.length; lt++) {
                let st = nt[lt];
                if ((st.route.HydrateFallback || st.route.hydrateFallbackElement) && (at = lt),
                st.route.id) {
                    let {loaderData: ut, errors: ct} = J
                      , pt = st.route.loader && ut[st.route.id] === void 0 && (!ct || ct[st.route.id] === void 0);
                    if (st.route.lazy || pt) {
                        it = !0,
                        at >= 0 ? nt = nt.slice(0, at + 1) : nt = [nt[0]];
                        break
                    }
                }
            }
        return nt.reduceRight((lt,st,ut)=>{
            let ct, pt = !1, ft = null, yt = null;
            J && (ct = ot && st.route.id ? ot[st.route.id] : void 0,
            ft = st.route.errorElement || defaultErrorElement,
            it && (at < 0 && ut === 0 ? (warningOnce("route-fallback", !1),
            pt = !0,
            yt = null) : at === ut && (pt = !0,
            yt = st.route.hydrateFallbackElement || null)));
            let ht = k.concat(nt.slice(0, ut + 1))
              , gt = ()=>{
                let mt;
                return ct ? mt = ft : pt ? mt = yt : st.route.Component ? mt = reactExports.createElement(st.route.Component, null) : st.route.element ? mt = st.route.element : mt = lt,
                reactExports.createElement(RenderedRoute, {
                    match: st,
                    routeContext: {
                        outlet: lt,
                        matches: ht,
                        isDataRoute: J != null
                    },
                    children: mt
                })
            }
            ;
            return J && (st.route.ErrorBoundary || st.route.errorElement || ut === 0) ? reactExports.createElement(RenderErrorBoundary, {
                location: J.location,
                revalidation: J.revalidation,
                component: ft,
                error: ct,
                children: gt(),
                routeContext: {
                    outlet: null,
                    matches: ht,
                    isDataRoute: !0
                }
            }) : gt()
        }
        , null)
    }
    var DataRouterHook$1 = function(_) {
        return _.UseBlocker = "useBlocker",
        _.UseRevalidator = "useRevalidator",
        _.UseNavigateStable = "useNavigate",
        _
    }(DataRouterHook$1 || {})
      , DataRouterStateHook$1 = function(_) {
        return _.UseBlocker = "useBlocker",
        _.UseLoaderData = "useLoaderData",
        _.UseActionData = "useActionData",
        _.UseRouteError = "useRouteError",
        _.UseNavigation = "useNavigation",
        _.UseRouteLoaderData = "useRouteLoaderData",
        _.UseMatches = "useMatches",
        _.UseRevalidator = "useRevalidator",
        _.UseNavigateStable = "useNavigate",
        _.UseRouteId = "useRouteId",
        _
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext$1(_) {
        let k = reactExports.useContext(DataRouterContext);
        return k || invariant(!1),
        k
    }
    function useDataRouterState$1(_) {
        let k = reactExports.useContext(DataRouterStateContext);
        return k || invariant(!1),
        k
    }
    function useRouteContext(_) {
        let k = reactExports.useContext(RouteContext);
        return k || invariant(!1),
        k
    }
    function useCurrentRouteId(_) {
        let k = useRouteContext()
          , J = k.matches[k.matches.length - 1];
        return J.route.id || invariant(!1),
        J.route.id
    }
    function useRouteId() {
        return useCurrentRouteId(DataRouterStateHook$1.UseRouteId)
    }
    function useNavigation() {
        return useDataRouterState$1(DataRouterStateHook$1.UseNavigation).navigation
    }
    function useRevalidator() {
        let _ = useDataRouterContext$1(DataRouterHook$1.UseRevalidator)
          , k = useDataRouterState$1(DataRouterStateHook$1.UseRevalidator);
        return reactExports.useMemo(()=>({
            revalidate: _.router.revalidate,
            state: k.revalidation
        }), [_.router.revalidate, k.revalidation])
    }
    function useMatches() {
        let {matches: _, loaderData: k} = useDataRouterState$1(DataRouterStateHook$1.UseMatches);
        return reactExports.useMemo(()=>_.map(J=>convertRouteMatchToUiMatch(J, k)), [_, k])
    }
    function useLoaderData() {
        let _ = useDataRouterState$1(DataRouterStateHook$1.UseLoaderData)
          , k = useCurrentRouteId(DataRouterStateHook$1.UseLoaderData);
        if (!(_.errors && _.errors[k] != null))
            return _.loaderData[k]
    }
    function useRouteLoaderData(_) {
        return useDataRouterState$1(DataRouterStateHook$1.UseRouteLoaderData).loaderData[_]
    }
    function useActionData() {
        let _ = useDataRouterState$1(DataRouterStateHook$1.UseActionData)
          , k = useCurrentRouteId(DataRouterStateHook$1.UseLoaderData);
        return _.actionData ? _.actionData[k] : void 0
    }
    function useRouteError() {
        var _;
        let k = reactExports.useContext(RouteErrorContext)
          , J = useDataRouterState$1(DataRouterStateHook$1.UseRouteError)
          , et = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
        return k !== void 0 ? k : (_ = J.errors) == null ? void 0 : _[et]
    }
    function useAsyncValue() {
        let _ = reactExports.useContext(AwaitContext);
        return _ == null ? void 0 : _._data
    }
    function useAsyncError() {
        let _ = reactExports.useContext(AwaitContext);
        return _ == null ? void 0 : _._error
    }
    let blockerId = 0;
    function useBlocker(_) {
        let {router: k, basename: J} = useDataRouterContext$1(DataRouterHook$1.UseBlocker)
          , et = useDataRouterState$1(DataRouterStateHook$1.UseBlocker)
          , [tt,rt] = reactExports.useState("")
          , nt = reactExports.useCallback(ot=>{
            if (typeof _ != "function")
                return !!_;
            if (J === "/")
                return _(ot);
            let {currentLocation: it, nextLocation: at, historyAction: lt} = ot;
            return _({
                currentLocation: _extends$3({}, it, {
                    pathname: stripBasename(it.pathname, J) || it.pathname
                }),
                nextLocation: _extends$3({}, at, {
                    pathname: stripBasename(at.pathname, J) || at.pathname
                }),
                historyAction: lt
            })
        }
        , [J, _]);
        return reactExports.useEffect(()=>{
            let ot = String(++blockerId);
            return rt(ot),
            ()=>k.deleteBlocker(ot)
        }
        , [k]),
        reactExports.useEffect(()=>{
            tt !== "" && k.getBlocker(tt, nt)
        }
        , [k, tt, nt]),
        tt && et.blockers.has(tt) ? et.blockers.get(tt) : IDLE_BLOCKER
    }
    function useNavigateStable() {
        let {router: _} = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable)
          , k = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
          , J = reactExports.useRef(!1);
        return useIsomorphicLayoutEffect$1(()=>{
            J.current = !0
        }
        ),
        reactExports.useCallback(function(et, tt) {
            tt === void 0 && (tt = {}),
            J.current && (typeof et == "number" ? _.navigate(et) : _.navigate(et, _extends$3({
                fromRouteId: k
            }, tt)))
        }, [_, k])
    }
    const alreadyWarned$1 = {};
    function warningOnce(_, k, J) {
        !k && !alreadyWarned$1[_] && (alreadyWarned$1[_] = !0)
    }
    const START_TRANSITION$1 = "startTransition"
      , startTransitionImpl$1 = react[START_TRANSITION$1];
    function MemoryRouter(_) {
        let {basename: k, children: J, initialEntries: et, initialIndex: tt, future: rt} = _
          , nt = reactExports.useRef();
        nt.current == null && (nt.current = createMemoryHistory({
            initialEntries: et,
            initialIndex: tt,
            v5Compat: !0
        }));
        let ot = nt.current
          , [it,at] = reactExports.useState({
            action: ot.action,
            location: ot.location
        })
          , {v7_startTransition: lt} = rt || {}
          , st = reactExports.useCallback(ut=>{
            lt && startTransitionImpl$1 ? startTransitionImpl$1(()=>at(ut)) : at(ut)
        }
        , [at, lt]);
        return reactExports.useLayoutEffect(()=>ot.listen(st), [ot, st]),
        reactExports.createElement(Router, {
            basename: k,
            children: J,
            location: it.location,
            navigationType: it.action,
            navigator: ot,
            future: rt
        })
    }
    function Navigate(_) {
        let {to: k, replace: J, state: et, relative: tt} = _;
        useInRouterContext() || invariant(!1);
        let {future: rt, static: nt} = reactExports.useContext(NavigationContext)
          , {matches: ot} = reactExports.useContext(RouteContext)
          , {pathname: it} = useLocation$1()
          , at = useNavigate$1()
          , lt = resolveTo(k, getResolveToMatches(ot, rt.v7_relativeSplatPath), it, tt === "path")
          , st = JSON.stringify(lt);
        return reactExports.useEffect(()=>at(JSON.parse(st), {
            replace: J,
            state: et,
            relative: tt
        }), [at, st, tt, J, et]),
        null
    }
    function Outlet(_) {
        return useOutlet(_.context)
    }
    function Route(_) {
        invariant(!1)
    }
    function Router(_) {
        let {basename: k="/", children: J=null, location: et, navigationType: tt=Action.Pop, navigator: rt, static: nt=!1, future: ot} = _;
        useInRouterContext() && invariant(!1);
        let it = k.replace(/^\/*/, "/")
          , at = reactExports.useMemo(()=>({
            basename: it,
            navigator: rt,
            static: nt,
            future: _extends$3({
                v7_relativeSplatPath: !1
            }, ot)
        }), [it, ot, rt, nt]);
        typeof et == "string" && (et = parsePath(et));
        let {pathname: lt="/", search: st="", hash: ut="", state: ct=null, key: pt="default"} = et
          , ft = reactExports.useMemo(()=>{
            let yt = stripBasename(lt, it);
            return yt == null ? null : {
                location: {
                    pathname: yt,
                    search: st,
                    hash: ut,
                    state: ct,
                    key: pt
                },
                navigationType: tt
            }
        }
        , [it, lt, st, ut, ct, pt, tt]);
        return ft == null ? null : reactExports.createElement(NavigationContext.Provider, {
            value: at
        }, reactExports.createElement(LocationContext.Provider, {
            children: J,
            value: ft
        }))
    }
    function Routes(_) {
        let {children: k, location: J} = _;
        return useRoutes(createRoutesFromChildren(k), J)
    }
    function Await(_) {
        let {children: k, errorElement: J, resolve: et} = _;
        return reactExports.createElement(AwaitErrorBoundary, {
            resolve: et,
            errorElement: J
        }, reactExports.createElement(ResolveAwait, null, k))
    }
    var AwaitRenderStatus = function(_) {
        return _[_.pending = 0] = "pending",
        _[_.success = 1] = "success",
        _[_.error = 2] = "error",
        _
    }(AwaitRenderStatus || {});
    const neverSettledPromise = new Promise(()=>{}
    );
    class AwaitErrorBoundary extends reactExports.Component {
        constructor(k) {
            super(k),
            this.state = {
                error: null
            }
        }
        static getDerivedStateFromError(k) {
            return {
                error: k
            }
        }
        componentDidCatch(k, J) {}
        render() {
            let {children: k, errorElement: J, resolve: et} = this.props
              , tt = null
              , rt = AwaitRenderStatus.pending;
            if (!(et instanceof Promise))
                rt = AwaitRenderStatus.success,
                tt = Promise.resolve(),
                Object.defineProperty(tt, "_tracked", {
                    get: ()=>!0
                }),
                Object.defineProperty(tt, "_data", {
                    get: ()=>et
                });
            else if (this.state.error) {
                rt = AwaitRenderStatus.error;
                let nt = this.state.error;
                tt = Promise.reject().catch(()=>{}
                ),
                Object.defineProperty(tt, "_tracked", {
                    get: ()=>!0
                }),
                Object.defineProperty(tt, "_error", {
                    get: ()=>nt
                })
            } else
                et._tracked ? (tt = et,
                rt = "_error"in tt ? AwaitRenderStatus.error : "_data"in tt ? AwaitRenderStatus.success : AwaitRenderStatus.pending) : (rt = AwaitRenderStatus.pending,
                Object.defineProperty(et, "_tracked", {
                    get: ()=>!0
                }),
                tt = et.then(nt=>Object.defineProperty(et, "_data", {
                    get: ()=>nt
                }), nt=>Object.defineProperty(et, "_error", {
                    get: ()=>nt
                })));
            if (rt === AwaitRenderStatus.error && tt._error instanceof AbortedDeferredError)
                throw neverSettledPromise;
            if (rt === AwaitRenderStatus.error && !J)
                throw tt._error;
            if (rt === AwaitRenderStatus.error)
                return reactExports.createElement(AwaitContext.Provider, {
                    value: tt,
                    children: J
                });
            if (rt === AwaitRenderStatus.success)
                return reactExports.createElement(AwaitContext.Provider, {
                    value: tt,
                    children: k
                });
            throw tt
        }
    }
    function ResolveAwait(_) {
        let {children: k} = _
          , J = useAsyncValue()
          , et = typeof k == "function" ? k(J) : k;
        return reactExports.createElement(reactExports.Fragment, null, et)
    }
    function createRoutesFromChildren(_, k) {
        k === void 0 && (k = []);
        let J = [];
        return reactExports.Children.forEach(_, (et,tt)=>{
            if (!reactExports.isValidElement(et))
                return;
            let rt = [...k, tt];
            if (et.type === reactExports.Fragment) {
                J.push.apply(J, createRoutesFromChildren(et.props.children, rt));
                return
            }
            et.type !== Route && invariant(!1),
            !et.props.index || !et.props.children || invariant(!1);
            let nt = {
                id: et.props.id || rt.join("-"),
                caseSensitive: et.props.caseSensitive,
                element: et.props.element,
                Component: et.props.Component,
                index: et.props.index,
                path: et.props.path,
                loader: et.props.loader,
                action: et.props.action,
                errorElement: et.props.errorElement,
                ErrorBoundary: et.props.ErrorBoundary,
                hasErrorBoundary: et.props.ErrorBoundary != null || et.props.errorElement != null,
                shouldRevalidate: et.props.shouldRevalidate,
                handle: et.props.handle,
                lazy: et.props.lazy
            };
            et.props.children && (nt.children = createRoutesFromChildren(et.props.children, rt)),
            J.push(nt)
        }
        ),
        J
    }
    function renderMatches(_) {
        return _renderMatches(_)
    }
    function mapRouteProperties(_) {
        let k = {
            hasErrorBoundary: _.ErrorBoundary != null || _.errorElement != null
        };
        return _.Component && Object.assign(k, {
            element: reactExports.createElement(_.Component),
            Component: void 0
        }),
        _.HydrateFallback && Object.assign(k, {
            hydrateFallbackElement: reactExports.createElement(_.HydrateFallback),
            HydrateFallback: void 0
        }),
        _.ErrorBoundary && Object.assign(k, {
            errorElement: reactExports.createElement(_.ErrorBoundary),
            ErrorBoundary: void 0
        }),
        k
    }
    function createMemoryRouter(_, k) {
        return createRouter({
            basename: k == null ? void 0 : k.basename,
            future: _extends$3({}, k == null ? void 0 : k.future, {
                v7_prependBasename: !0
            }),
            history: createMemoryHistory({
                initialEntries: k == null ? void 0 : k.initialEntries,
                initialIndex: k == null ? void 0 : k.initialIndex
            }),
            hydrationData: k == null ? void 0 : k.hydrationData,
            routes: _,
            mapRouteProperties,
            unstable_dataStrategy: k == null ? void 0 : k.unstable_dataStrategy
        }).initialize()
    }
    function _extends$2() {
        return _extends$2 = Object.assign ? Object.assign.bind() : function(_) {
            for (var k = 1; k < arguments.length; k++) {
                var J = arguments[k];
                for (var et in J)
                    Object.prototype.hasOwnProperty.call(J, et) && (_[et] = J[et])
            }
            return _
        }
        ,
        _extends$2.apply(this, arguments)
    }
    function _objectWithoutPropertiesLoose$1(_, k) {
        if (_ == null)
            return {};
        var J = {}, et = Object.keys(_), tt, rt;
        for (rt = 0; rt < et.length; rt++)
            tt = et[rt],
            !(k.indexOf(tt) >= 0) && (J[tt] = _[tt]);
        return J
    }
    const defaultMethod = "get"
      , defaultEncType = "application/x-www-form-urlencoded";
    function isHtmlElement(_) {
        return _ != null && typeof _.tagName == "string"
    }
    function isButtonElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "button"
    }
    function isFormElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "form"
    }
    function isInputElement(_) {
        return isHtmlElement(_) && _.tagName.toLowerCase() === "input"
    }
    function isModifiedEvent(_) {
        return !!(_.metaKey || _.altKey || _.ctrlKey || _.shiftKey)
    }
    function shouldProcessLinkClick(_, k) {
        return _.button === 0 && (!k || k === "_self") && !isModifiedEvent(_)
    }
    function createSearchParams(_) {
        return _ === void 0 && (_ = ""),
        new URLSearchParams(typeof _ == "string" || Array.isArray(_) || _ instanceof URLSearchParams ? _ : Object.keys(_).reduce((k,J)=>{
            let et = _[J];
            return k.concat(Array.isArray(et) ? et.map(tt=>[J, tt]) : [[J, et]])
        }
        , []))
    }
    function getSearchParamsForLocation(_, k) {
        let J = createSearchParams(_);
        return k && k.forEach((et,tt)=>{
            J.has(tt) || k.getAll(tt).forEach(rt=>{
                J.append(tt, rt)
            }
            )
        }
        ),
        J
    }
    let _formDataSupportsSubmitter = null;
    function isFormDataSubmitterSupported() {
        if (_formDataSupportsSubmitter === null)
            try {
                new FormData(document.createElement("form"),0),
                _formDataSupportsSubmitter = !1
            } catch (_) {
                _formDataSupportsSubmitter = !0
            }
        return _formDataSupportsSubmitter
    }
    const supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
    function getFormEncType(_) {
        return _ != null && !supportedFormEncTypes.has(_) ? null : _
    }
    function getFormSubmissionInfo(_, k) {
        let J, et, tt, rt, nt;
        if (isFormElement(_)) {
            let ot = _.getAttribute("action");
            et = ot ? stripBasename(ot, k) : null,
            J = _.getAttribute("method") || defaultMethod,
            tt = getFormEncType(_.getAttribute("enctype")) || defaultEncType,
            rt = new FormData(_)
        } else if (isButtonElement(_) || isInputElement(_) && (_.type === "submit" || _.type === "image")) {
            let ot = _.form;
            if (ot == null)
                throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
            let it = _.getAttribute("formaction") || ot.getAttribute("action");
            if (et = it ? stripBasename(it, k) : null,
            J = _.getAttribute("formmethod") || ot.getAttribute("method") || defaultMethod,
            tt = getFormEncType(_.getAttribute("formenctype")) || getFormEncType(ot.getAttribute("enctype")) || defaultEncType,
            rt = new FormData(ot,_),
            !isFormDataSubmitterSupported()) {
                let {name: at, type: lt, value: st} = _;
                if (lt === "image") {
                    let ut = at ? at + "." : "";
                    rt.append(ut + "x", "0"),
                    rt.append(ut + "y", "0")
                } else
                    at && rt.append(at, st)
            }
        } else {
            if (isHtmlElement(_))
                throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
            J = defaultMethod,
            et = null,
            tt = defaultEncType,
            nt = _
        }
        return rt && tt === "text/plain" && (nt = rt,
        rt = void 0),
        {
            action: et,
            method: J.toLowerCase(),
            encType: tt,
            formData: rt,
            body: nt
        }
    }
    const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]
      , _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"]
      , _excluded3 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "unstable_viewTransition"]
      , REACT_ROUTER_VERSION = "6";
    try {
        window.__reactRouterVersion = REACT_ROUTER_VERSION
    } catch (_) {}
    function createBrowserRouter(_, k) {
        return createRouter({
            basename: k == null ? void 0 : k.basename,
            future: _extends$2({}, k == null ? void 0 : k.future, {
                v7_prependBasename: !0
            }),
            history: createBrowserHistory({
                window: k == null ? void 0 : k.window
            }),
            hydrationData: (k == null ? void 0 : k.hydrationData) || parseHydrationData(),
            routes: _,
            mapRouteProperties,
            unstable_dataStrategy: k == null ? void 0 : k.unstable_dataStrategy,
            window: k == null ? void 0 : k.window
        }).initialize()
    }
    function createHashRouter(_, k) {
        return createRouter({
            basename: k == null ? void 0 : k.basename,
            future: _extends$2({}, k == null ? void 0 : k.future, {
                v7_prependBasename: !0
            }),
            history: createHashHistory({
                window: k == null ? void 0 : k.window
            }),
            hydrationData: (k == null ? void 0 : k.hydrationData) || parseHydrationData(),
            routes: _,
            mapRouteProperties,
            unstable_dataStrategy: k == null ? void 0 : k.unstable_dataStrategy,
            window: k == null ? void 0 : k.window
        }).initialize()
    }
    function parseHydrationData() {
        var _;
        let k = (_ = window) == null ? void 0 : _.__staticRouterHydrationData;
        return k && k.errors && (k = _extends$2({}, k, {
            errors: deserializeErrors(k.errors)
        })),
        k
    }
    function deserializeErrors(_) {
        if (!_)
            return null;
        let k = Object.entries(_)
          , J = {};
        for (let[et,tt] of k)
            if (tt && tt.__type === "RouteErrorResponse")
                J[et] = new ErrorResponseImpl(tt.status,tt.statusText,tt.data,tt.internal === !0);
            else if (tt && tt.__type === "Error") {
                if (tt.__subType) {
                    let rt = window[tt.__subType];
                    if (typeof rt == "function")
                        try {
                            let nt = new rt(tt.message);
                            nt.stack = "",
                            J[et] = nt
                        } catch (nt) {}
                }
                if (J[et] == null) {
                    let rt = new Error(tt.message);
                    rt.stack = "",
                    J[et] = rt
                }
            } else
                J[et] = tt;
        return J
    }
    const ViewTransitionContext = reactExports.createContext({
        isTransitioning: !1
    })
      , FetchersContext = reactExports.createContext(new Map)
      , START_TRANSITION = "startTransition"
      , startTransitionImpl = react[START_TRANSITION]
      , FLUSH_SYNC = "flushSync"
      , flushSyncImpl = react_dom[FLUSH_SYNC]
      , USE_ID = "useId"
      , useIdImpl = react[USE_ID];
    function startTransitionSafe(_) {
        startTransitionImpl ? startTransitionImpl(_) : _()
    }
    function flushSyncSafe(_) {
        flushSyncImpl ? flushSyncImpl(_) : _()
    }
    class Deferred {
        constructor() {
            this.status = "pending",
            this.promise = new Promise((k,J)=>{
                this.resolve = et=>{
                    this.status === "pending" && (this.status = "resolved",
                    k(et))
                }
                ,
                this.reject = et=>{
                    this.status === "pending" && (this.status = "rejected",
                    J(et))
                }
            }
            )
        }
    }
    function RouterProvider(_) {
        let {fallbackElement: k, router: J, future: et} = _
          , [tt,rt] = reactExports.useState(J.state)
          , [nt,ot] = reactExports.useState()
          , [it,at] = reactExports.useState({
            isTransitioning: !1
        })
          , [lt,st] = reactExports.useState()
          , [ut,ct] = reactExports.useState()
          , [pt,ft] = reactExports.useState()
          , yt = reactExports.useRef(new Map)
          , {v7_startTransition: ht} = et || {}
          , gt = reactExports.useCallback(xt=>{
            ht ? startTransitionSafe(xt) : xt()
        }
        , [ht])
          , mt = reactExports.useCallback((xt,wt)=>{
            let {deletedFetchers: St, unstable_flushSync: Pt, unstable_viewTransitionOpts: Rt} = wt;
            St.forEach(Nt=>yt.current.delete(Nt)),
            xt.fetchers.forEach((Nt,Ot)=>{
                Nt.data !== void 0 && yt.current.set(Ot, Nt.data)
            }
            );
            let At = J.window == null || J.window.document == null || typeof J.window.document.startViewTransition != "function";
            if (!Rt || At) {
                Pt ? flushSyncSafe(()=>rt(xt)) : gt(()=>rt(xt));
                return
            }
            if (Pt) {
                flushSyncSafe(()=>{
                    ut && (lt && lt.resolve(),
                    ut.skipTransition()),
                    at({
                        isTransitioning: !0,
                        flushSync: !0,
                        currentLocation: Rt.currentLocation,
                        nextLocation: Rt.nextLocation
                    })
                }
                );
                let Nt = J.window.document.startViewTransition(()=>{
                    flushSyncSafe(()=>rt(xt))
                }
                );
                Nt.finished.finally(()=>{
                    flushSyncSafe(()=>{
                        st(void 0),
                        ct(void 0),
                        ot(void 0),
                        at({
                            isTransitioning: !1
                        })
                    }
                    )
                }
                ),
                flushSyncSafe(()=>ct(Nt));
                return
            }
            ut ? (lt && lt.resolve(),
            ut.skipTransition(),
            ft({
                state: xt,
                currentLocation: Rt.currentLocation,
                nextLocation: Rt.nextLocation
            })) : (ot(xt),
            at({
                isTransitioning: !0,
                flushSync: !1,
                currentLocation: Rt.currentLocation,
                nextLocation: Rt.nextLocation
            }))
        }
        , [J.window, ut, lt, yt, gt]);
        reactExports.useLayoutEffect(()=>J.subscribe(mt), [J, mt]),
        reactExports.useEffect(()=>{
            it.isTransitioning && !it.flushSync && st(new Deferred)
        }
        , [it]),
        reactExports.useEffect(()=>{
            if (lt && nt && J.window) {
                let xt = nt
                  , wt = lt.promise
                  , St = J.window.document.startViewTransition(async()=>{
                    gt(()=>rt(xt)),
                    await wt
                }
                );
                St.finished.finally(()=>{
                    st(void 0),
                    ct(void 0),
                    ot(void 0),
                    at({
                        isTransitioning: !1
                    })
                }
                ),
                ct(St)
            }
        }
        , [gt, nt, lt, J.window]),
        reactExports.useEffect(()=>{
            lt && nt && tt.location.key === nt.location.key && lt.resolve()
        }
        , [lt, ut, tt.location, nt]),
        reactExports.useEffect(()=>{
            !it.isTransitioning && pt && (ot(pt.state),
            at({
                isTransitioning: !0,
                flushSync: !1,
                currentLocation: pt.currentLocation,
                nextLocation: pt.nextLocation
            }),
            ft(void 0))
        }
        , [it.isTransitioning, pt]),
        reactExports.useEffect(()=>{}
        , []);
        let vt = reactExports.useMemo(()=>({
            createHref: J.createHref,
            encodeLocation: J.encodeLocation,
            go: xt=>J.navigate(xt),
            push: (xt,wt,St)=>J.navigate(xt, {
                state: wt,
                preventScrollReset: St == null ? void 0 : St.preventScrollReset
            }),
            replace: (xt,wt,St)=>J.navigate(xt, {
                replace: !0,
                state: wt,
                preventScrollReset: St == null ? void 0 : St.preventScrollReset
            })
        }), [J])
          , bt = J.basename || "/"
          , Et = reactExports.useMemo(()=>({
            router: J,
            navigator: vt,
            static: !1,
            basename: bt
        }), [J, vt, bt]);
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(DataRouterContext.Provider, {
            value: Et
        }, reactExports.createElement(DataRouterStateContext.Provider, {
            value: tt
        }, reactExports.createElement(FetchersContext.Provider, {
            value: yt.current
        }, reactExports.createElement(ViewTransitionContext.Provider, {
            value: it
        }, reactExports.createElement(Router, {
            basename: bt,
            location: tt.location,
            navigationType: tt.historyAction,
            navigator: vt,
            future: {
                v7_relativeSplatPath: J.future.v7_relativeSplatPath
            }
        }, tt.initialized || J.future.v7_partialHydration ? reactExports.createElement(DataRoutes, {
            routes: J.routes,
            future: J.future,
            state: tt
        }) : k))))), null)
    }
    function DataRoutes(_) {
        let {routes: k, future: J, state: et} = _;
        return useRoutesImpl(k, void 0, et, J)
    }
    function BrowserRouter(_) {
        let {basename: k, children: J, future: et, window: tt} = _
          , rt = reactExports.useRef();
        rt.current == null && (rt.current = createBrowserHistory({
            window: tt,
            v5Compat: !0
        }));
        let nt = rt.current
          , [ot,it] = reactExports.useState({
            action: nt.action,
            location: nt.location
        })
          , {v7_startTransition: at} = et || {}
          , lt = reactExports.useCallback(st=>{
            at && startTransitionImpl ? startTransitionImpl(()=>it(st)) : it(st)
        }
        , [it, at]);
        return reactExports.useLayoutEffect(()=>nt.listen(lt), [nt, lt]),
        reactExports.createElement(Router, {
            basename: k,
            children: J,
            location: ot.location,
            navigationType: ot.action,
            navigator: nt,
            future: et
        })
    }
    function HashRouter(_) {
        let {basename: k, children: J, future: et, window: tt} = _
          , rt = reactExports.useRef();
        rt.current == null && (rt.current = createHashHistory({
            window: tt,
            v5Compat: !0
        }));
        let nt = rt.current
          , [ot,it] = reactExports.useState({
            action: nt.action,
            location: nt.location
        })
          , {v7_startTransition: at} = et || {}
          , lt = reactExports.useCallback(st=>{
            at && startTransitionImpl ? startTransitionImpl(()=>it(st)) : it(st)
        }
        , [it, at]);
        return reactExports.useLayoutEffect(()=>nt.listen(lt), [nt, lt]),
        reactExports.createElement(Router, {
            basename: k,
            children: J,
            location: ot.location,
            navigationType: ot.action,
            navigator: nt,
            future: et
        })
    }
    function HistoryRouter(_) {
        let {basename: k, children: J, future: et, history: tt} = _
          , [rt,nt] = reactExports.useState({
            action: tt.action,
            location: tt.location
        })
          , {v7_startTransition: ot} = et || {}
          , it = reactExports.useCallback(at=>{
            ot && startTransitionImpl ? startTransitionImpl(()=>nt(at)) : nt(at)
        }
        , [nt, ot]);
        return reactExports.useLayoutEffect(()=>tt.listen(it), [tt, it]),
        reactExports.createElement(Router, {
            basename: k,
            children: J,
            location: rt.location,
            navigationType: rt.action,
            navigator: tt,
            future: et
        })
    }
    const isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
      , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
      , Link$1 = reactExports.forwardRef(function(_, k) {
        let {onClick: J, relative: et, reloadDocument: tt, replace: rt, state: nt, target: ot, to: it, preventScrollReset: at, unstable_viewTransition: lt} = _, st = _objectWithoutPropertiesLoose$1(_, _excluded), {basename: ut} = reactExports.useContext(NavigationContext), ct, pt = !1;
        if (typeof it == "string" && ABSOLUTE_URL_REGEX.test(it) && (ct = it,
        isBrowser))
            try {
                let gt = new URL(window.location.href)
                  , mt = it.startsWith("//") ? new URL(gt.protocol + it) : new URL(it)
                  , vt = stripBasename(mt.pathname, ut);
                mt.origin === gt.origin && vt != null ? it = vt + mt.search + mt.hash : pt = !0
            } catch (gt) {}
        let ft = useHref(it, {
            relative: et
        })
          , yt = useLinkClickHandler(it, {
            replace: rt,
            state: nt,
            target: ot,
            preventScrollReset: at,
            relative: et,
            unstable_viewTransition: lt
        });
        function ht(gt) {
            J && J(gt),
            gt.defaultPrevented || yt(gt)
        }
        return reactExports.createElement("a", _extends$2({}, st, {
            href: ct || ft,
            onClick: pt || tt ? J : ht,
            ref: k,
            target: ot
        }))
    })
      , NavLink = reactExports.forwardRef(function(_, k) {
        let {"aria-current": J="page", caseSensitive: et=!1, className: tt="", end: rt=!1, style: nt, to: ot, unstable_viewTransition: it, children: at} = _
          , lt = _objectWithoutPropertiesLoose$1(_, _excluded2)
          , st = useResolvedPath(ot, {
            relative: lt.relative
        })
          , ut = useLocation$1()
          , ct = reactExports.useContext(DataRouterStateContext)
          , {navigator: pt, basename: ft} = reactExports.useContext(NavigationContext)
          , yt = ct != null && useViewTransitionState(st) && it === !0
          , ht = pt.encodeLocation ? pt.encodeLocation(st).pathname : st.pathname
          , gt = ut.pathname
          , mt = ct && ct.navigation && ct.navigation.location ? ct.navigation.location.pathname : null;
        et || (gt = gt.toLowerCase(),
        mt = mt ? mt.toLowerCase() : null,
        ht = ht.toLowerCase()),
        mt && ft && (mt = stripBasename(mt, ft) || mt);
        const vt = ht !== "/" && ht.endsWith("/") ? ht.length - 1 : ht.length;
        let bt = gt === ht || !rt && gt.startsWith(ht) && gt.charAt(vt) === "/", Et = mt != null && (mt === ht || !rt && mt.startsWith(ht) && mt.charAt(ht.length) === "/"), xt = {
            isActive: bt,
            isPending: Et,
            isTransitioning: yt
        }, wt = bt ? J : void 0, St;
        typeof tt == "function" ? St = tt(xt) : St = [tt, bt ? "active" : null, Et ? "pending" : null, yt ? "transitioning" : null].filter(Boolean).join(" ");
        let Pt = typeof nt == "function" ? nt(xt) : nt;
        return reactExports.createElement(Link$1, _extends$2({}, lt, {
            "aria-current": wt,
            className: St,
            ref: k,
            style: Pt,
            to: ot,
            unstable_viewTransition: it
        }), typeof at == "function" ? at(xt) : at)
    })
      , Form = reactExports.forwardRef((_,k)=>{
        let {fetcherKey: J, navigate: et, reloadDocument: tt, replace: rt, state: nt, method: ot=defaultMethod, action: it, onSubmit: at, relative: lt, preventScrollReset: st, unstable_viewTransition: ut} = _
          , ct = _objectWithoutPropertiesLoose$1(_, _excluded3)
          , pt = useSubmit()
          , ft = useFormAction(it, {
            relative: lt
        })
          , yt = ot.toLowerCase() === "get" ? "get" : "post"
          , ht = gt=>{
            if (at && at(gt),
            gt.defaultPrevented)
                return;
            gt.preventDefault();
            let mt = gt.nativeEvent.submitter
              , vt = (mt == null ? void 0 : mt.getAttribute("formmethod")) || ot;
            pt(mt || gt.currentTarget, {
                fetcherKey: J,
                method: vt,
                navigate: et,
                replace: rt,
                state: nt,
                relative: lt,
                preventScrollReset: st,
                unstable_viewTransition: ut
            })
        }
        ;
        return reactExports.createElement("form", _extends$2({
            ref: k,
            method: yt,
            action: ft,
            onSubmit: tt ? at : ht
        }, ct))
    }
    );
    function ScrollRestoration(_) {
        let {getKey: k, storageKey: J} = _;
        return useScrollRestoration({
            getKey: k,
            storageKey: J
        }),
        null
    }
    var DataRouterHook;
    (function(_) {
        _.UseScrollRestoration = "useScrollRestoration",
        _.UseSubmit = "useSubmit",
        _.UseSubmitFetcher = "useSubmitFetcher",
        _.UseFetcher = "useFetcher",
        _.useViewTransitionState = "useViewTransitionState"
    }
    )(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(_) {
        _.UseFetcher = "useFetcher",
        _.UseFetchers = "useFetchers",
        _.UseScrollRestoration = "useScrollRestoration"
    }
    )(DataRouterStateHook || (DataRouterStateHook = {}));
    function useDataRouterContext(_) {
        let k = reactExports.useContext(DataRouterContext);
        return k || invariant(!1),
        k
    }
    function useDataRouterState(_) {
        let k = reactExports.useContext(DataRouterStateContext);
        return k || invariant(!1),
        k
    }
    function useLinkClickHandler(_, k) {
        let {target: J, replace: et, state: tt, preventScrollReset: rt, relative: nt, unstable_viewTransition: ot} = k === void 0 ? {} : k
          , it = useNavigate$1()
          , at = useLocation$1()
          , lt = useResolvedPath(_, {
            relative: nt
        });
        return reactExports.useCallback(st=>{
            if (shouldProcessLinkClick(st, J)) {
                st.preventDefault();
                let ut = et !== void 0 ? et : createPath(at) === createPath(lt);
                it(_, {
                    replace: ut,
                    state: tt,
                    preventScrollReset: rt,
                    relative: nt,
                    unstable_viewTransition: ot
                })
            }
        }
        , [at, it, lt, et, tt, J, _, rt, nt, ot])
    }
    function useSearchParams(_) {
        let k = reactExports.useRef(createSearchParams(_))
          , J = reactExports.useRef(!1)
          , et = useLocation$1()
          , tt = reactExports.useMemo(()=>getSearchParamsForLocation(et.search, J.current ? null : k.current), [et.search])
          , rt = useNavigate$1()
          , nt = reactExports.useCallback((ot,it)=>{
            const at = createSearchParams(typeof ot == "function" ? ot(tt) : ot);
            J.current = !0,
            rt("?" + at, it)
        }
        , [rt, tt]);
        return [tt, nt]
    }
    function validateClientSideSubmission() {
        if (typeof document > "u")
            throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.")
    }
    let fetcherId = 0
      , getUniqueFetcherId = ()=>"__" + String(++fetcherId) + "__";
    function useSubmit() {
        let {router: _} = useDataRouterContext(DataRouterHook.UseSubmit)
          , {basename: k} = reactExports.useContext(NavigationContext)
          , J = useRouteId();
        return reactExports.useCallback(function(et, tt) {
            tt === void 0 && (tt = {}),
            validateClientSideSubmission();
            let {action: rt, method: nt, encType: ot, formData: it, body: at} = getFormSubmissionInfo(et, k);
            if (tt.navigate === !1) {
                let lt = tt.fetcherKey || getUniqueFetcherId();
                _.fetch(lt, J, tt.action || rt, {
                    preventScrollReset: tt.preventScrollReset,
                    formData: it,
                    body: at,
                    formMethod: tt.method || nt,
                    formEncType: tt.encType || ot,
                    unstable_flushSync: tt.unstable_flushSync
                })
            } else
                _.navigate(tt.action || rt, {
                    preventScrollReset: tt.preventScrollReset,
                    formData: it,
                    body: at,
                    formMethod: tt.method || nt,
                    formEncType: tt.encType || ot,
                    replace: tt.replace,
                    state: tt.state,
                    fromRouteId: J,
                    unstable_flushSync: tt.unstable_flushSync,
                    unstable_viewTransition: tt.unstable_viewTransition
                })
        }, [_, k, J])
    }
    function useFormAction(_, k) {
        let {relative: J} = k === void 0 ? {} : k
          , {basename: et} = reactExports.useContext(NavigationContext)
          , tt = reactExports.useContext(RouteContext);
        tt || invariant(!1);
        let[rt] = tt.matches.slice(-1)
          , nt = _extends$2({}, useResolvedPath(_ || ".", {
            relative: J
        }))
          , ot = useLocation$1();
        if (_ == null) {
            nt.search = ot.search;
            let it = new URLSearchParams(nt.search);
            it.has("index") && it.get("index") === "" && (it.delete("index"),
            nt.search = it.toString() ? "?" + it.toString() : "")
        }
        return (!_ || _ === ".") && rt.route.index && (nt.search = nt.search ? nt.search.replace(/^\?/, "?index&") : "?index"),
        et !== "/" && (nt.pathname = nt.pathname === "/" ? et : joinPaths([et, nt.pathname])),
        createPath(nt)
    }
    function useFetcher(_) {
        var k;
        let {key: J} = _ === void 0 ? {} : _
          , {router: et} = useDataRouterContext(DataRouterHook.UseFetcher)
          , tt = useDataRouterState(DataRouterStateHook.UseFetcher)
          , rt = reactExports.useContext(FetchersContext)
          , nt = reactExports.useContext(RouteContext)
          , ot = (k = nt.matches[nt.matches.length - 1]) == null ? void 0 : k.route.id;
        rt || invariant(!1),
        nt || invariant(!1),
        ot == null && invariant(!1);
        let it = useIdImpl ? useIdImpl() : ""
          , [at,lt] = reactExports.useState(J || it);
        J && J !== at ? lt(J) : at || lt(getUniqueFetcherId()),
        reactExports.useEffect(()=>(et.getFetcher(at),
        ()=>{
            et.deleteFetcher(at)
        }
        ), [et, at]);
        let st = reactExports.useCallback((ht,gt)=>{
            ot || invariant(!1),
            et.fetch(at, ot, ht, gt)
        }
        , [at, ot, et])
          , ut = useSubmit()
          , ct = reactExports.useCallback((ht,gt)=>{
            ut(ht, _extends$2({}, gt, {
                navigate: !1,
                fetcherKey: at
            }))
        }
        , [at, ut])
          , pt = reactExports.useMemo(()=>reactExports.forwardRef((ht,gt)=>reactExports.createElement(Form, _extends$2({}, ht, {
            navigate: !1,
            fetcherKey: at,
            ref: gt
        }))), [at])
          , ft = tt.fetchers.get(at) || IDLE_FETCHER
          , yt = rt.get(at);
        return reactExports.useMemo(()=>_extends$2({
            Form: pt,
            submit: ct,
            load: st
        }, ft, {
            data: yt
        }), [pt, ct, st, ft, yt])
    }
    function useFetchers() {
        let _ = useDataRouterState(DataRouterStateHook.UseFetchers);
        return Array.from(_.fetchers.entries()).map(k=>{
            let[J,et] = k;
            return _extends$2({}, et, {
                key: J
            })
        }
        )
    }
    const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
    let savedScrollPositions = {};
    function useScrollRestoration(_) {
        let {getKey: k, storageKey: J} = _ === void 0 ? {} : _
          , {router: et} = useDataRouterContext(DataRouterHook.UseScrollRestoration)
          , {restoreScrollPosition: tt, preventScrollReset: rt} = useDataRouterState(DataRouterStateHook.UseScrollRestoration)
          , {basename: nt} = reactExports.useContext(NavigationContext)
          , ot = useLocation$1()
          , it = useMatches()
          , at = useNavigation();
        reactExports.useEffect(()=>(window.history.scrollRestoration = "manual",
        ()=>{
            window.history.scrollRestoration = "auto"
        }
        ), []),
        usePageHide(reactExports.useCallback(()=>{
            if (at.state === "idle") {
                let lt = (k ? k(ot, it) : null) || ot.key;
                savedScrollPositions[lt] = window.scrollY
            }
            try {
                sessionStorage.setItem(J || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions))
            } catch (lt) {}
            window.history.scrollRestoration = "auto"
        }
        , [J, k, at.state, ot, it])),
        typeof document < "u" && (reactExports.useLayoutEffect(()=>{
            try {
                let lt = sessionStorage.getItem(J || SCROLL_RESTORATION_STORAGE_KEY);
                lt && (savedScrollPositions = JSON.parse(lt))
            } catch (lt) {}
        }
        , [J]),
        reactExports.useLayoutEffect(()=>{
            let lt = k && nt !== "/" ? (ut,ct)=>k(_extends$2({}, ut, {
                pathname: stripBasename(ut.pathname, nt) || ut.pathname
            }), ct) : k
              , st = et == null ? void 0 : et.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, lt);
            return ()=>st && st()
        }
        , [et, nt, k]),
        reactExports.useLayoutEffect(()=>{
            if (tt !== !1) {
                if (typeof tt == "number") {
                    window.scrollTo(0, tt);
                    return
                }
                if (ot.hash) {
                    let lt = document.getElementById(decodeURIComponent(ot.hash.slice(1)));
                    if (lt) {
                        lt.scrollIntoView();
                        return
                    }
                }
                rt !== !0 && window.scrollTo(0, 0)
            }
        }
        , [ot, tt, rt]))
    }
    function useBeforeUnload(_, k) {
        let {capture: J} = k || {};
        reactExports.useEffect(()=>{
            let et = J != null ? {
                capture: J
            } : void 0;
            return window.addEventListener("beforeunload", _, et),
            ()=>{
                window.removeEventListener("beforeunload", _, et)
            }
        }
        , [_, J])
    }
    function usePageHide(_, k) {
        let {capture: J} = k || {};
        reactExports.useEffect(()=>{
            let et = J != null ? {
                capture: J
            } : void 0;
            return window.addEventListener("pagehide", _, et),
            ()=>{
                window.removeEventListener("pagehide", _, et)
            }
        }
        , [_, J])
    }
    function usePrompt(_) {
        let {when: k, message: J} = _
          , et = useBlocker(k);
        reactExports.useEffect(()=>{
            et.state === "blocked" && (window.confirm(J) ? setTimeout(et.proceed, 0) : et.reset())
        }
        , [et, J]),
        reactExports.useEffect(()=>{
            et.state === "blocked" && !k && et.reset()
        }
        , [et, k])
    }
    function useViewTransitionState(_, k) {
        k === void 0 && (k = {});
        let J = reactExports.useContext(ViewTransitionContext);
        J == null && invariant(!1);
        let {basename: et} = useDataRouterContext(DataRouterHook.useViewTransitionState)
          , tt = useResolvedPath(_, {
            relative: k.relative
        });
        if (!J.isTransitioning)
            return !1;
        let rt = stripBasename(J.currentLocation.pathname, et) || J.currentLocation.pathname
          , nt = stripBasename(J.nextLocation.pathname, et) || J.nextLocation.pathname;
        return matchPath(tt.pathname, nt) != null || matchPath(tt.pathname, rt) != null
    }
    react_router_dom = Object.assign(Object.defineProperty({
        
        AbortedDeferredError,
        Await,
        BrowserRouter,
        Form,
        HashRouter,
        Link: Link$1,
        MemoryRouter,
        NavLink,
        Navigate,
        get NavigationType() {
            return Action
        },
        Outlet,
        Route,
        Router,
        RouterProvider,
        Routes,
        ScrollRestoration,
        UNSAFE_DataRouterContext: DataRouterContext,
        UNSAFE_DataRouterStateContext: DataRouterStateContext,
        UNSAFE_ErrorResponseImpl: ErrorResponseImpl,
        UNSAFE_FetchersContext: FetchersContext,
        UNSAFE_LocationContext: LocationContext,
        UNSAFE_NavigationContext: NavigationContext,
        UNSAFE_RouteContext: RouteContext,
        UNSAFE_ViewTransitionContext: ViewTransitionContext,
        UNSAFE_useRouteId: useRouteId,
        UNSAFE_useScrollRestoration: useScrollRestoration,
        createBrowserRouter,
        createHashRouter,
        createMemoryRouter,
        createPath,
        createRoutesFromChildren,
        createRoutesFromElements: createRoutesFromChildren,
        createSearchParams,
        defer: defer$1,
        generatePath,
        isRouteErrorResponse,
        json,
        matchPath,
        matchRoutes,
        parsePath,
        redirect,
        redirectDocument,
        renderMatches,
        resolvePath,
        unstable_HistoryRouter: HistoryRouter,
        unstable_usePrompt: usePrompt,
        unstable_useViewTransitionState: useViewTransitionState,
        useActionData,
        useAsyncError,
        useAsyncValue,
        useBeforeUnload,
        useBlocker,
        useFetcher,
        useFetchers,
        useFormAction,
        useHref,
        useInRouterContext,
        useLinkClickHandler,
        useLoaderData,
        useLocation: useLocation$1,
        useMatch,
        useMatches,
        useNavigate: useNavigate$1,
        useNavigation,
        useNavigationType,
        useOutlet,
        useOutletContext,
        useParams,
        useResolvedPath,
        useRevalidator,
        useRouteError,
        useRouteLoaderData,
        useRoutes,
        useSearchParams,
        useSubmit
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var qt = Object.defineProperty
      , Vt = (_,k,J)=>k in _ ? qt(_, k, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: J
    }) : _[k] = J
      , _e = (_,k,J)=>(Vt(_, typeof k != "symbol" ? k + "" : k, J),
    J);
    function _mergeNamespaces$1(_, k) {
        for (var J = 0; J < k.length; J++) {
            const et = k[J];
            if (typeof et != "string" && !Array.isArray(et)) {
                for (const tt in et)
                    if (tt !== "default" && !(tt in _)) {
                        const rt = Object.getOwnPropertyDescriptor(et, tt);
                        rt && Object.defineProperty(_, tt, rt.get ? rt : {
                            enumerable: !0,
                            get: ()=>et[tt]
                        })
                    }
            }
        }
        return Object.assign(Object.defineProperty(_, Symbol.toStringTag, {
            value: "Module"
        }))
    }
    commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    getDefaultExportFromCjs = function(_) {
        return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _
    }
    ;
    function getAugmentedNamespace(_) {
        if (_.__esModule)
            return _;
        var k = _.default;
        if (typeof k == "function") {
            var J = function et() {
                return this instanceof et ? Reflect.construct(k, arguments, this.constructor) : k.apply(this, arguments)
            };
            J.prototype = k.prototype
        } else
            J = {};
        return Object.defineProperty(J, "__esModule", {
            value: !0
        }),
        Object.keys(_).forEach(function(et) {
            var tt = Object.getOwnPropertyDescriptor(_, et);
            Object.defineProperty(J, et, tt.get ? tt : {
                enumerable: !0,
                get: function() {
                    return _[et]
                }
            })
        }),
        J
    }
    var indexMinimal$1 = {}
      , minimal$4 = {}
      , aspromise = asPromise;
    function asPromise(_, k) {
        for (var J = new Array(arguments.length - 1), et = 0, tt = 2, rt = !0; tt < arguments.length; )
            J[et++] = arguments[tt++];
        return new Promise(function(nt, ot) {
            J[et] = function(it) {
                if (rt)
                    if (rt = !1,
                    it)
                        ot(it);
                    else {
                        for (var at = new Array(arguments.length - 1), lt = 0; lt < at.length; )
                            at[lt++] = arguments[lt];
                        nt.apply(null, at)
                    }
            }
            ;
            try {
                _.apply(k || null, J)
            } catch (it) {
                rt && (rt = !1,
                ot(it))
            }
        }
        )
    }
    var base64$2 = {};
    (function(_) {
        var k = _;
        k.length = function(nt) {
            var ot = nt.length;
            if (!ot)
                return 0;
            for (var it = 0; --ot % 4 > 1 && nt.charAt(ot) === "="; )
                ++it;
            return Math.ceil(nt.length * 3) / 4 - it
        }
        ;
        for (var J = new Array(64), et = new Array(123), tt = 0; tt < 64; )
            et[J[tt] = tt < 26 ? tt + 65 : tt < 52 ? tt + 71 : tt < 62 ? tt - 4 : tt - 59 | 43] = tt++;
        k.encode = function(nt, ot, it) {
            for (var at = null, lt = [], st = 0, ut = 0, ct; ot < it; ) {
                var pt = nt[ot++];
                switch (ut) {
                case 0:
                    lt[st++] = J[pt >> 2],
                    ct = (pt & 3) << 4,
                    ut = 1;
                    break;
                case 1:
                    lt[st++] = J[ct | pt >> 4],
                    ct = (pt & 15) << 2,
                    ut = 2;
                    break;
                case 2:
                    lt[st++] = J[ct | pt >> 6],
                    lt[st++] = J[pt & 63],
                    ut = 0;
                    break
                }
                st > 8191 && ((at || (at = [])).push(String.fromCharCode.apply(String, lt)),
                st = 0)
            }
            return ut && (lt[st++] = J[ct],
            lt[st++] = 61,
            ut === 1 && (lt[st++] = 61)),
            at ? (st && at.push(String.fromCharCode.apply(String, lt.slice(0, st))),
            at.join("")) : String.fromCharCode.apply(String, lt.slice(0, st))
        }
        ;
        var rt = "invalid encoding";
        k.decode = function(nt, ot, it) {
            for (var at = it, lt = 0, st, ut = 0; ut < nt.length; ) {
                var ct = nt.charCodeAt(ut++);
                if (ct === 61 && lt > 1)
                    break;
                if ((ct = et[ct]) === void 0)
                    throw Error(rt);
                switch (lt) {
                case 0:
                    st = ct,
                    lt = 1;
                    break;
                case 1:
                    ot[it++] = st << 2 | (ct & 48) >> 4,
                    st = ct,
                    lt = 2;
                    break;
                case 2:
                    ot[it++] = (st & 15) << 4 | (ct & 60) >> 2,
                    st = ct,
                    lt = 3;
                    break;
                case 3:
                    ot[it++] = (st & 3) << 6 | ct,
                    lt = 0;
                    break
                }
            }
            if (lt === 1)
                throw Error(rt);
            return it - at
        }
        ,
        k.test = function(nt) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(nt)
        }
    }
    )(base64$2);
    var eventemitter = EventEmitter$3;
    function EventEmitter$3() {
        this._listeners = {}
    }
    EventEmitter$3.prototype.on = function(_, k, J) {
        return (this._listeners[_] || (this._listeners[_] = [])).push({
            fn: k,
            ctx: J || this
        }),
        this
    }
    ,
    EventEmitter$3.prototype.off = function(_, k) {
        if (_ === void 0)
            this._listeners = {};
        else if (k === void 0)
            this._listeners[_] = [];
        else
            for (var J = this._listeners[_], et = 0; et < J.length; )
                J[et].fn === k ? J.splice(et, 1) : ++et;
        return this
    }
    ,
    EventEmitter$3.prototype.emit = function(_) {
        var k = this._listeners[_];
        if (k) {
            for (var J = [], et = 1; et < arguments.length; )
                J.push(arguments[et++]);
            for (et = 0; et < k.length; )
                k[et].fn.apply(k[et++].ctx, J)
        }
        return this
    }
    ;
    var float = factory(factory);
    function factory(_) {
        return typeof Float32Array < "u" ? function() {
            var k = new Float32Array([-0])
              , J = new Uint8Array(k.buffer)
              , et = J[3] === 128;
            function tt(it, at, lt) {
                k[0] = it,
                at[lt] = J[0],
                at[lt + 1] = J[1],
                at[lt + 2] = J[2],
                at[lt + 3] = J[3]
            }
            function rt(it, at, lt) {
                k[0] = it,
                at[lt] = J[3],
                at[lt + 1] = J[2],
                at[lt + 2] = J[1],
                at[lt + 3] = J[0]
            }
            _.writeFloatLE = et ? tt : rt,
            _.writeFloatBE = et ? rt : tt;
            function nt(it, at) {
                return J[0] = it[at],
                J[1] = it[at + 1],
                J[2] = it[at + 2],
                J[3] = it[at + 3],
                k[0]
            }
            function ot(it, at) {
                return J[3] = it[at],
                J[2] = it[at + 1],
                J[1] = it[at + 2],
                J[0] = it[at + 3],
                k[0]
            }
            _.readFloatLE = et ? nt : ot,
            _.readFloatBE = et ? ot : nt
        }() : function() {
            function k(et, tt, rt, nt) {
                var ot = tt < 0 ? 1 : 0;
                if (ot && (tt = -tt),
                tt === 0)
                    et(1 / tt > 0 ? 0 : 2147483648, rt, nt);
                else if (isNaN(tt))
                    et(2143289344, rt, nt);
                else if (tt > 3402823466385289e23)
                    et((ot << 31 | 2139095040) >>> 0, rt, nt);
                else if (tt < 11754943508222875e-54)
                    et((ot << 31 | Math.round(tt / 1401298464324817e-60)) >>> 0, rt, nt);
                else {
                    var it = Math.floor(Math.log(tt) / Math.LN2)
                      , at = Math.round(tt * Math.pow(2, -it) * 8388608) & 8388607;
                    et((ot << 31 | it + 127 << 23 | at) >>> 0, rt, nt)
                }
            }
            _.writeFloatLE = k.bind(null, writeUintLE),
            _.writeFloatBE = k.bind(null, writeUintBE);
            function J(et, tt, rt) {
                var nt = et(tt, rt)
                  , ot = (nt >> 31) * 2 + 1
                  , it = nt >>> 23 & 255
                  , at = nt & 8388607;
                return it === 255 ? at ? NaN : ot * (1 / 0) : it === 0 ? ot * 1401298464324817e-60 * at : ot * Math.pow(2, it - 150) * (at + 8388608)
            }
            _.readFloatLE = J.bind(null, readUintLE),
            _.readFloatBE = J.bind(null, readUintBE)
        }(),
        typeof Float64Array < "u" ? function() {
            var k = new Float64Array([-0])
              , J = new Uint8Array(k.buffer)
              , et = J[7] === 128;
            function tt(it, at, lt) {
                k[0] = it,
                at[lt] = J[0],
                at[lt + 1] = J[1],
                at[lt + 2] = J[2],
                at[lt + 3] = J[3],
                at[lt + 4] = J[4],
                at[lt + 5] = J[5],
                at[lt + 6] = J[6],
                at[lt + 7] = J[7]
            }
            function rt(it, at, lt) {
                k[0] = it,
                at[lt] = J[7],
                at[lt + 1] = J[6],
                at[lt + 2] = J[5],
                at[lt + 3] = J[4],
                at[lt + 4] = J[3],
                at[lt + 5] = J[2],
                at[lt + 6] = J[1],
                at[lt + 7] = J[0]
            }
            _.writeDoubleLE = et ? tt : rt,
            _.writeDoubleBE = et ? rt : tt;
            function nt(it, at) {
                return J[0] = it[at],
                J[1] = it[at + 1],
                J[2] = it[at + 2],
                J[3] = it[at + 3],
                J[4] = it[at + 4],
                J[5] = it[at + 5],
                J[6] = it[at + 6],
                J[7] = it[at + 7],
                k[0]
            }
            function ot(it, at) {
                return J[7] = it[at],
                J[6] = it[at + 1],
                J[5] = it[at + 2],
                J[4] = it[at + 3],
                J[3] = it[at + 4],
                J[2] = it[at + 5],
                J[1] = it[at + 6],
                J[0] = it[at + 7],
                k[0]
            }
            _.readDoubleLE = et ? nt : ot,
            _.readDoubleBE = et ? ot : nt
        }() : function() {
            function k(et, tt, rt, nt, ot, it) {
                var at = nt < 0 ? 1 : 0;
                if (at && (nt = -nt),
                nt === 0)
                    et(0, ot, it + tt),
                    et(1 / nt > 0 ? 0 : 2147483648, ot, it + rt);
                else if (isNaN(nt))
                    et(0, ot, it + tt),
                    et(2146959360, ot, it + rt);
                else if (nt > 17976931348623157e292)
                    et(0, ot, it + tt),
                    et((at << 31 | 2146435072) >>> 0, ot, it + rt);
                else {
                    var lt;
                    if (nt < 22250738585072014e-324)
                        lt = nt / 5e-324,
                        et(lt >>> 0, ot, it + tt),
                        et((at << 31 | lt / 4294967296) >>> 0, ot, it + rt);
                    else {
                        var st = Math.floor(Math.log(nt) / Math.LN2);
                        st === 1024 && (st = 1023),
                        lt = nt * Math.pow(2, -st),
                        et(lt * 4503599627370496 >>> 0, ot, it + tt),
                        et((at << 31 | st + 1023 << 20 | lt * 1048576 & 1048575) >>> 0, ot, it + rt)
                    }
                }
            }
            _.writeDoubleLE = k.bind(null, writeUintLE, 0, 4),
            _.writeDoubleBE = k.bind(null, writeUintBE, 4, 0);
            function J(et, tt, rt, nt, ot) {
                var it = et(nt, ot + tt)
                  , at = et(nt, ot + rt)
                  , lt = (at >> 31) * 2 + 1
                  , st = at >>> 20 & 2047
                  , ut = 4294967296 * (at & 1048575) + it;
                return st === 2047 ? ut ? NaN : lt * (1 / 0) : st === 0 ? lt * 5e-324 * ut : lt * Math.pow(2, st - 1075) * (ut + 4503599627370496)
            }
            _.readDoubleLE = J.bind(null, readUintLE, 0, 4),
            _.readDoubleBE = J.bind(null, readUintBE, 4, 0)
        }(),
        _
    }
    function writeUintLE(_, k, J) {
        k[J] = _ & 255,
        k[J + 1] = _ >>> 8 & 255,
        k[J + 2] = _ >>> 16 & 255,
        k[J + 3] = _ >>> 24
    }
    function writeUintBE(_, k, J) {
        k[J] = _ >>> 24,
        k[J + 1] = _ >>> 16 & 255,
        k[J + 2] = _ >>> 8 & 255,
        k[J + 3] = _ & 255
    }
    function readUintLE(_, k) {
        return (_[k] | _[k + 1] << 8 | _[k + 2] << 16 | _[k + 3] << 24) >>> 0
    }
    function readUintBE(_, k) {
        return (_[k] << 24 | _[k + 1] << 16 | _[k + 2] << 8 | _[k + 3]) >>> 0
    }
    var inquire_1 = inquire;
    function inquire(moduleName) {
        try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
                return mod
        } catch (_) {}
        return null
    }
    var utf8$5 = {};
    (function(_) {
        var k = _;
        k.length = function(J) {
            for (var et = 0, tt = 0, rt = 0; rt < J.length; ++rt)
                tt = J.charCodeAt(rt),
                tt < 128 ? et += 1 : tt < 2048 ? et += 2 : (tt & 64512) === 55296 && (J.charCodeAt(rt + 1) & 64512) === 56320 ? (++rt,
                et += 4) : et += 3;
            return et
        }
        ,
        k.read = function(J, et, tt) {
            var rt = tt - et;
            if (rt < 1)
                return "";
            for (var nt = null, ot = [], it = 0, at; et < tt; )
                at = J[et++],
                at < 128 ? ot[it++] = at : at > 191 && at < 224 ? ot[it++] = (at & 31) << 6 | J[et++] & 63 : at > 239 && at < 365 ? (at = ((at & 7) << 18 | (J[et++] & 63) << 12 | (J[et++] & 63) << 6 | J[et++] & 63) - 65536,
                ot[it++] = 55296 + (at >> 10),
                ot[it++] = 56320 + (at & 1023)) : ot[it++] = (at & 15) << 12 | (J[et++] & 63) << 6 | J[et++] & 63,
                it > 8191 && ((nt || (nt = [])).push(String.fromCharCode.apply(String, ot)),
                it = 0);
            return nt ? (it && nt.push(String.fromCharCode.apply(String, ot.slice(0, it))),
            nt.join("")) : String.fromCharCode.apply(String, ot.slice(0, it))
        }
        ,
        k.write = function(J, et, tt) {
            for (var rt = tt, nt, ot, it = 0; it < J.length; ++it)
                nt = J.charCodeAt(it),
                nt < 128 ? et[tt++] = nt : nt < 2048 ? (et[tt++] = nt >> 6 | 192,
                et[tt++] = nt & 63 | 128) : (nt & 64512) === 55296 && ((ot = J.charCodeAt(it + 1)) & 64512) === 56320 ? (nt = 65536 + ((nt & 1023) << 10) + (ot & 1023),
                ++it,
                et[tt++] = nt >> 18 | 240,
                et[tt++] = nt >> 12 & 63 | 128,
                et[tt++] = nt >> 6 & 63 | 128,
                et[tt++] = nt & 63 | 128) : (et[tt++] = nt >> 12 | 224,
                et[tt++] = nt >> 6 & 63 | 128,
                et[tt++] = nt & 63 | 128);
            return tt - rt
        }
    }
    )(utf8$5);
    var pool_1 = pool;
    function pool(_, k, J) {
        var et = J || 8192
          , tt = et >>> 1
          , rt = null
          , nt = et;
        return function(ot) {
            if (ot < 1 || ot > tt)
                return _(ot);
            nt + ot > et && (rt = _(et),
            nt = 0);
            var it = k.call(rt, nt, nt += ot);
            return nt & 7 && (nt = (nt | 7) + 1),
            it
        }
    }
    var longbits$1, hasRequiredLongbits$1;
    function requireLongbits$1() {
        if (hasRequiredLongbits$1)
            return longbits$1;
        hasRequiredLongbits$1 = 1,
        longbits$1 = k;
        var _ = requireMinimal$1();
        function k(rt, nt) {
            this.lo = rt >>> 0,
            this.hi = nt >>> 0
        }
        var J = k.zero = new k(0,0);
        J.toNumber = function() {
            return 0
        }
        ,
        J.zzEncode = J.zzDecode = function() {
            return this
        }
        ,
        J.length = function() {
            return 1
        }
        ;
        var et = k.zeroHash = "\0\0\0\0\0\0\0\0";
        k.fromNumber = function(rt) {
            if (rt === 0)
                return J;
            var nt = rt < 0;
            nt && (rt = -rt);
            var ot = rt >>> 0
              , it = (rt - ot) / 4294967296 >>> 0;
            return nt && (it = ~it >>> 0,
            ot = ~ot >>> 0,
            ++ot > 4294967295 && (ot = 0,
            ++it > 4294967295 && (it = 0))),
            new k(ot,it)
        }
        ,
        k.from = function(rt) {
            if (typeof rt == "number")
                return k.fromNumber(rt);
            if (_.isString(rt))
                if (_.Long)
                    rt = _.Long.fromString(rt);
                else
                    return k.fromNumber(parseInt(rt, 10));
            return rt.low || rt.high ? new k(rt.low >>> 0,rt.high >>> 0) : J
        }
        ,
        k.prototype.toNumber = function(rt) {
            if (!rt && this.hi >>> 31) {
                var nt = ~this.lo + 1 >>> 0
                  , ot = ~this.hi >>> 0;
                return nt || (ot = ot + 1 >>> 0),
                -(nt + ot * 4294967296)
            }
            return this.lo + this.hi * 4294967296
        }
        ,
        k.prototype.toLong = function(rt) {
            return _.Long ? new _.Long(this.lo | 0,this.hi | 0,!!rt) : {
                low: this.lo | 0,
                high: this.hi | 0,
                unsigned: !!rt
            }
        }
        ;
        var tt = String.prototype.charCodeAt;
        return k.fromHash = function(rt) {
            return rt === et ? J : new k((tt.call(rt, 0) | tt.call(rt, 1) << 8 | tt.call(rt, 2) << 16 | tt.call(rt, 3) << 24) >>> 0,(tt.call(rt, 4) | tt.call(rt, 5) << 8 | tt.call(rt, 6) << 16 | tt.call(rt, 7) << 24) >>> 0)
        }
        ,
        k.prototype.toHash = function() {
            return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
        }
        ,
        k.prototype.zzEncode = function() {
            var rt = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ rt) >>> 0,
            this.lo = (this.lo << 1 ^ rt) >>> 0,
            this
        }
        ,
        k.prototype.zzDecode = function() {
            var rt = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ rt) >>> 0,
            this.hi = (this.hi >>> 1 ^ rt) >>> 0,
            this
        }
        ,
        k.prototype.length = function() {
            var rt = this.lo
              , nt = (this.lo >>> 28 | this.hi << 4) >>> 0
              , ot = this.hi >>> 24;
            return ot === 0 ? nt === 0 ? rt < 16384 ? rt < 128 ? 1 : 2 : rt < 2097152 ? 3 : 4 : nt < 16384 ? nt < 128 ? 5 : 6 : nt < 2097152 ? 7 : 8 : ot < 128 ? 9 : 10
        }
        ,
        longbits$1
    }
    var hasRequiredMinimal$1;
    function requireMinimal$1() {
        return hasRequiredMinimal$1 || (hasRequiredMinimal$1 = 1,
        function(_) {
            var k = _;
            k.asPromise = aspromise,
            k.base64 = base64$2,
            k.EventEmitter = eventemitter,
            k.float = float,
            k.inquire = inquire_1,
            k.utf8 = utf8$5,
            k.pool = pool_1,
            k.LongBits = requireLongbits$1(),
            k.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node),
            k.global = k.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal,
            k.emptyArray = Object.freeze ? Object.freeze([]) : [],
            k.emptyObject = Object.freeze ? Object.freeze({}) : {},
            k.isInteger = Number.isInteger || function(tt) {
                return typeof tt == "number" && isFinite(tt) && Math.floor(tt) === tt
            }
            ,
            k.isString = function(tt) {
                return typeof tt == "string" || tt instanceof String
            }
            ,
            k.isObject = function(tt) {
                return tt && typeof tt == "object"
            }
            ,
            k.isset = k.isSet = function(tt, rt) {
                var nt = tt[rt];
                return nt != null && tt.hasOwnProperty(rt) ? typeof nt != "object" || (Array.isArray(nt) ? nt.length : Object.keys(nt).length) > 0 : !1
            }
            ,
            k.Buffer = function() {
                try {
                    var tt = k.inquire("buffer").Buffer;
                    return tt.prototype.utf8Write ? tt : null
                } catch (rt) {
                    return null
                }
            }(),
            k._Buffer_from = null,
            k._Buffer_allocUnsafe = null,
            k.newBuffer = function(tt) {
                return typeof tt == "number" ? k.Buffer ? k._Buffer_allocUnsafe(tt) : new k.Array(tt) : k.Buffer ? k._Buffer_from(tt) : typeof Uint8Array > "u" ? tt : new Uint8Array(tt)
            }
            ,
            k.Array = typeof Uint8Array < "u" ? Uint8Array : Array,
            k.Long = k.global.dcodeIO && k.global.dcodeIO.Long || k.global.Long || k.inquire("long"),
            k.key2Re = /^true|false|0|1$/,
            k.key32Re = /^-?(?:0|[1-9][0-9]*)$/,
            k.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,
            k.longToHash = function(tt) {
                return tt ? k.LongBits.from(tt).toHash() : k.LongBits.zeroHash
            }
            ,
            k.longFromHash = function(tt, rt) {
                var nt = k.LongBits.fromHash(tt);
                return k.Long ? k.Long.fromBits(nt.lo, nt.hi, rt) : nt.toNumber(!!rt)
            }
            ;
            function J(tt, rt, nt) {
                for (var ot = Object.keys(rt), it = 0; it < ot.length; ++it)
                    (tt[ot[it]] === void 0 || !nt) && (tt[ot[it]] = rt[ot[it]]);
                return tt
            }
            k.merge = J,
            k.lcFirst = function(tt) {
                return tt.charAt(0).toLowerCase() + tt.substring(1)
            }
            ;
            function et(tt) {
                function rt(nt, ot) {
                    if (!(this instanceof rt))
                        return new rt(nt,ot);
                    Object.defineProperty(this, "message", {
                        get: function() {
                            return nt
                        }
                    }),
                    Error.captureStackTrace ? Error.captureStackTrace(this, rt) : Object.defineProperty(this, "stack", {
                        value: new Error().stack || ""
                    }),
                    ot && J(this, ot)
                }
                return rt.prototype = Object.create(Error.prototype, {
                    constructor: {
                        value: rt,
                        writable: !0,
                        enumerable: !1,
                        configurable: !0
                    },
                    name: {
                        get: function() {
                            return tt
                        },
                        set: void 0,
                        enumerable: !1,
                        configurable: !0
                    },
                    toString: {
                        value: function() {
                            return this.name + ": " + this.message
                        },
                        writable: !0,
                        enumerable: !1,
                        configurable: !0
                    }
                }),
                rt
            }
            k.newError = et,
            k.ProtocolError = et("ProtocolError"),
            k.oneOfGetter = function(tt) {
                for (var rt = {}, nt = 0; nt < tt.length; ++nt)
                    rt[tt[nt]] = 1;
                return function() {
                    for (var ot = Object.keys(this), it = ot.length - 1; it > -1; --it)
                        if (rt[ot[it]] === 1 && this[ot[it]] !== void 0 && this[ot[it]] !== null)
                            return ot[it]
                }
            }
            ,
            k.oneOfSetter = function(tt) {
                return function(rt) {
                    for (var nt = 0; nt < tt.length; ++nt)
                        tt[nt] !== rt && delete this[tt[nt]]
                }
            }
            ,
            k.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: !0
            },
            k._configure = function() {
                var tt = k.Buffer;
                if (!tt) {
                    k._Buffer_from = k._Buffer_allocUnsafe = null;
                    return
                }
                k._Buffer_from = tt.from !== Uint8Array.from && tt.from || function(rt, nt) {
                    return new tt(rt,nt)
                }
                ,
                k._Buffer_allocUnsafe = tt.allocUnsafe || function(rt) {
                    return new tt(rt)
                }
            }
        }(minimal$4)),
        minimal$4
    }
    var writer$1 = Writer$3, util$9 = requireMinimal$1(), BufferWriter$3, LongBits$3 = util$9.LongBits, base64$1 = util$9.base64, utf8$4 = util$9.utf8;
    function Op$1(_, k, J) {
        this.fn = _,
        this.len = k,
        this.next = void 0,
        this.val = J
    }
    function noop$3() {}
    function State$2(_) {
        this.head = _.head,
        this.tail = _.tail,
        this.len = _.len,
        this.next = _.states
    }
    function Writer$3() {
        this.len = 0,
        this.head = new Op$1(noop$3,0,0),
        this.tail = this.head,
        this.states = null
    }
    var create$3 = function _() {
        return util$9.Buffer ? function() {
            return (Writer$3.create = function() {
                return new BufferWriter$3
            }
            )()
        }
        : function() {
            return new Writer$3
        }
    };
    Writer$3.create = create$3(),
    Writer$3.alloc = function _(k) {
        return new util$9.Array(k)
    }
    ,
    util$9.Array !== Array && (Writer$3.alloc = util$9.pool(Writer$3.alloc, util$9.Array.prototype.subarray)),
    Writer$3.prototype._push = function _(k, J, et) {
        return this.tail = this.tail.next = new Op$1(k,J,et),
        this.len += J,
        this
    }
    ;
    function writeByte$1(_, k, J) {
        k[J] = _ & 255
    }
    function writeVarint32$1(_, k, J) {
        for (; _ > 127; )
            k[J++] = _ & 127 | 128,
            _ >>>= 7;
        k[J] = _
    }
    function VarintOp$1(_, k) {
        this.len = _,
        this.next = void 0,
        this.val = k
    }
    VarintOp$1.prototype = Object.create(Op$1.prototype),
    VarintOp$1.prototype.fn = writeVarint32$1,
    Writer$3.prototype.uint32 = function _(k) {
        return this.len += (this.tail = this.tail.next = new VarintOp$1((k = k >>> 0) < 128 ? 1 : k < 16384 ? 2 : k < 2097152 ? 3 : k < 268435456 ? 4 : 5,k)).len,
        this
    }
    ,
    Writer$3.prototype.int32 = function _(k) {
        return k < 0 ? this._push(writeVarint64$1, 10, LongBits$3.fromNumber(k)) : this.uint32(k)
    }
    ,
    Writer$3.prototype.sint32 = function _(k) {
        return this.uint32((k << 1 ^ k >> 31) >>> 0)
    }
    ;
    function writeVarint64$1(_, k, J) {
        for (; _.hi; )
            k[J++] = _.lo & 127 | 128,
            _.lo = (_.lo >>> 7 | _.hi << 25) >>> 0,
            _.hi >>>= 7;
        for (; _.lo > 127; )
            k[J++] = _.lo & 127 | 128,
            _.lo = _.lo >>> 7;
        k[J++] = _.lo
    }
    Writer$3.prototype.uint64 = function _(k) {
        var J = LongBits$3.from(k);
        return this._push(writeVarint64$1, J.length(), J)
    }
    ,
    Writer$3.prototype.int64 = Writer$3.prototype.uint64,
    Writer$3.prototype.sint64 = function _(k) {
        var J = LongBits$3.from(k).zzEncode();
        return this._push(writeVarint64$1, J.length(), J)
    }
    ,
    Writer$3.prototype.bool = function _(k) {
        return this._push(writeByte$1, 1, k ? 1 : 0)
    }
    ;
    function writeFixed32$1(_, k, J) {
        k[J] = _ & 255,
        k[J + 1] = _ >>> 8 & 255,
        k[J + 2] = _ >>> 16 & 255,
        k[J + 3] = _ >>> 24
    }
    Writer$3.prototype.fixed32 = function _(k) {
        return this._push(writeFixed32$1, 4, k >>> 0)
    }
    ,
    Writer$3.prototype.sfixed32 = Writer$3.prototype.fixed32,
    Writer$3.prototype.fixed64 = function _(k) {
        var J = LongBits$3.from(k);
        return this._push(writeFixed32$1, 4, J.lo)._push(writeFixed32$1, 4, J.hi)
    }
    ,
    Writer$3.prototype.sfixed64 = Writer$3.prototype.fixed64,
    Writer$3.prototype.float = function _(k) {
        return this._push(util$9.float.writeFloatLE, 4, k)
    }
    ,
    Writer$3.prototype.double = function _(k) {
        return this._push(util$9.float.writeDoubleLE, 8, k)
    }
    ;
    var writeBytes$1 = util$9.Array.prototype.set ? function _(k, J, et) {
        J.set(k, et)
    }
    : function _(k, J, et) {
        for (var tt = 0; tt < k.length; ++tt)
            J[et + tt] = k[tt]
    }
    ;
    Writer$3.prototype.bytes = function _(k) {
        var J = k.length >>> 0;
        if (!J)
            return this._push(writeByte$1, 1, 0);
        if (util$9.isString(k)) {
            var et = Writer$3.alloc(J = base64$1.length(k));
            base64$1.decode(k, et, 0),
            k = et
        }
        return this.uint32(J)._push(writeBytes$1, J, k)
    }
    ,
    Writer$3.prototype.string = function _(k) {
        var J = utf8$4.length(k);
        return J ? this.uint32(J)._push(utf8$4.write, J, k) : this._push(writeByte$1, 1, 0)
    }
    ,
    Writer$3.prototype.fork = function _() {
        return this.states = new State$2(this),
        this.head = this.tail = new Op$1(noop$3,0,0),
        this.len = 0,
        this
    }
    ,
    Writer$3.prototype.reset = function _() {
        return this.states ? (this.head = this.states.head,
        this.tail = this.states.tail,
        this.len = this.states.len,
        this.states = this.states.next) : (this.head = this.tail = new Op$1(noop$3,0,0),
        this.len = 0),
        this
    }
    ,
    Writer$3.prototype.ldelim = function _() {
        var k = this.head
          , J = this.tail
          , et = this.len;
        return this.reset().uint32(et),
        et && (this.tail.next = k.next,
        this.tail = J,
        this.len += et),
        this
    }
    ,
    Writer$3.prototype.finish = function _() {
        for (var k = this.head.next, J = this.constructor.alloc(this.len), et = 0; k; )
            k.fn(k.val, J, et),
            et += k.len,
            k = k.next;
        return J
    }
    ,
    Writer$3._configure = function(_) {
        BufferWriter$3 = _,
        Writer$3.create = create$3(),
        BufferWriter$3._configure()
    }
    ;
    var writer_buffer$1 = BufferWriter$2
      , Writer$2 = writer$1;
    (BufferWriter$2.prototype = Object.create(Writer$2.prototype)).constructor = BufferWriter$2;
    var util$8 = requireMinimal$1();
    function BufferWriter$2() {
        Writer$2.call(this)
    }
    BufferWriter$2._configure = function() {
        BufferWriter$2.alloc = util$8._Buffer_allocUnsafe,
        BufferWriter$2.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(_, k, J) {
            k.set(_, J)
        }
        : function(_, k, J) {
            if (_.copy)
                _.copy(k, J, 0, _.length);
            else
                for (var et = 0; et < _.length; )
                    k[J++] = _[et++]
        }
    }
    ,
    BufferWriter$2.prototype.bytes = function _(k) {
        util$8.isString(k) && (k = util$8._Buffer_from(k, "base64"));
        var J = k.length >>> 0;
        return this.uint32(J),
        J && this._push(BufferWriter$2.writeBytesBuffer, J, k),
        this
    }
    ;
    function writeStringBuffer$1(_, k, J) {
        _.length < 40 ? util$8.utf8.write(_, k, J) : k.utf8Write ? k.utf8Write(_, J) : k.write(_, J)
    }
    BufferWriter$2.prototype.string = function _(k) {
        var J = util$8.Buffer.byteLength(k);
        return this.uint32(J),
        J && this._push(writeStringBuffer$1, J, k),
        this
    }
    ,
    BufferWriter$2._configure();
    var reader$1 = Reader$3, util$7 = requireMinimal$1(), BufferReader$3, LongBits$2 = util$7.LongBits, utf8$3 = util$7.utf8;
    function indexOutOfRange$1(_, k) {
        return RangeError("index out of range: " + _.pos + " + " + (k || 1) + " > " + _.len)
    }
    function Reader$3(_) {
        this.buf = _,
        this.pos = 0,
        this.len = _.length
    }
    var create_array$1 = typeof Uint8Array < "u" ? function _(k) {
        if (k instanceof Uint8Array || Array.isArray(k))
            return new Reader$3(k);
        throw Error("illegal buffer")
    }
    : function _(k) {
        if (Array.isArray(k))
            return new Reader$3(k);
        throw Error("illegal buffer")
    }
      , create$2 = function _() {
        return util$7.Buffer ? function(k) {
            return (Reader$3.create = function(J) {
                return util$7.Buffer.isBuffer(J) ? new BufferReader$3(J) : create_array$1(J)
            }
            )(k)
        }
        : create_array$1
    };
    Reader$3.create = create$2(),
    Reader$3.prototype._slice = util$7.Array.prototype.subarray || util$7.Array.prototype.slice,
    Reader$3.prototype.uint32 = function _() {
        var k = 4294967295;
        return function() {
            if (k = (this.buf[this.pos] & 127) >>> 0,
            this.buf[this.pos++] < 128 || (k = (k | (this.buf[this.pos] & 127) << 7) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 127) << 14) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 127) << 21) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 15) << 28) >>> 0,
            this.buf[this.pos++] < 128))
                return k;
            if ((this.pos += 5) > this.len)
                throw this.pos = this.len,
                indexOutOfRange$1(this, 10);
            return k
        }
    }(),
    Reader$3.prototype.int32 = function _() {
        return this.uint32() | 0
    }
    ,
    Reader$3.prototype.sint32 = function _() {
        var k = this.uint32();
        return k >>> 1 ^ -(k & 1) | 0
    }
    ;
    function readLongVarint$1() {
        var _ = new LongBits$2(0,0)
          , k = 0;
        if (this.len - this.pos > 4) {
            for (; k < 4; ++k)
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << k * 7) >>> 0,
                this.buf[this.pos++] < 128)
                    return _;
            if (_.lo = (_.lo | (this.buf[this.pos] & 127) << 28) >>> 0,
            _.hi = (_.hi | (this.buf[this.pos] & 127) >> 4) >>> 0,
            this.buf[this.pos++] < 128)
                return _;
            k = 0
        } else {
            for (; k < 3; ++k) {
                if (this.pos >= this.len)
                    throw indexOutOfRange$1(this);
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << k * 7) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
            }
            return _.lo = (_.lo | (this.buf[this.pos++] & 127) << k * 7) >>> 0,
            _
        }
        if (this.len - this.pos > 4) {
            for (; k < 5; ++k)
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << k * 7 + 3) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
        } else
            for (; k < 5; ++k) {
                if (this.pos >= this.len)
                    throw indexOutOfRange$1(this);
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << k * 7 + 3) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
            }
        throw Error("invalid varint encoding")
    }
    Reader$3.prototype.bool = function _() {
        return this.uint32() !== 0
    }
    ;
    function readFixed32_end$1(_, k) {
        return (_[k - 4] | _[k - 3] << 8 | _[k - 2] << 16 | _[k - 1] << 24) >>> 0
    }
    Reader$3.prototype.fixed32 = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange$1(this, 4);
        return readFixed32_end$1(this.buf, this.pos += 4)
    }
    ,
    Reader$3.prototype.sfixed32 = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange$1(this, 4);
        return readFixed32_end$1(this.buf, this.pos += 4) | 0
    }
    ;
    function readFixed64$1() {
        if (this.pos + 8 > this.len)
            throw indexOutOfRange$1(this, 8);
        return new LongBits$2(readFixed32_end$1(this.buf, this.pos += 4),readFixed32_end$1(this.buf, this.pos += 4))
    }
    Reader$3.prototype.float = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange$1(this, 4);
        var k = util$7.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4,
        k
    }
    ,
    Reader$3.prototype.double = function _() {
        if (this.pos + 8 > this.len)
            throw indexOutOfRange$1(this, 4);
        var k = util$7.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8,
        k
    }
    ,
    Reader$3.prototype.bytes = function _() {
        var k = this.uint32()
          , J = this.pos
          , et = this.pos + k;
        if (et > this.len)
            throw indexOutOfRange$1(this, k);
        if (this.pos += k,
        Array.isArray(this.buf))
            return this.buf.slice(J, et);
        if (J === et) {
            var tt = util$7.Buffer;
            return tt ? tt.alloc(0) : new this.buf.constructor(0)
        }
        return this._slice.call(this.buf, J, et)
    }
    ,
    Reader$3.prototype.string = function _() {
        var k = this.bytes();
        return utf8$3.read(k, 0, k.length)
    }
    ,
    Reader$3.prototype.skip = function _(k) {
        if (typeof k == "number") {
            if (this.pos + k > this.len)
                throw indexOutOfRange$1(this, k);
            this.pos += k
        } else
            do
                if (this.pos >= this.len)
                    throw indexOutOfRange$1(this);
            while (this.buf[this.pos++] & 128);
        return this
    }
    ,
    Reader$3.prototype.skipType = function(_) {
        switch (_) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            for (; (_ = this.uint32() & 7) !== 4; )
                this.skipType(_);
            break;
        case 5:
            this.skip(4);
            break;
        default:
            throw Error("invalid wire type " + _ + " at offset " + this.pos)
        }
        return this
    }
    ,
    Reader$3._configure = function(_) {
        BufferReader$3 = _,
        Reader$3.create = create$2(),
        BufferReader$3._configure();
        var k = util$7.Long ? "toLong" : "toNumber";
        util$7.merge(Reader$3.prototype, {
            int64: function() {
                return readLongVarint$1.call(this)[k](!1)
            },
            uint64: function() {
                return readLongVarint$1.call(this)[k](!0)
            },
            sint64: function() {
                return readLongVarint$1.call(this).zzDecode()[k](!1)
            },
            fixed64: function() {
                return readFixed64$1.call(this)[k](!0)
            },
            sfixed64: function() {
                return readFixed64$1.call(this)[k](!1)
            }
        })
    }
    ;
    var reader_buffer$1 = BufferReader$2
      , Reader$2 = reader$1;
    (BufferReader$2.prototype = Object.create(Reader$2.prototype)).constructor = BufferReader$2;
    var util$6 = requireMinimal$1();
    function BufferReader$2(_) {
        Reader$2.call(this, _)
    }
    BufferReader$2._configure = function() {
        util$6.Buffer && (BufferReader$2.prototype._slice = util$6.Buffer.prototype.slice)
    }
    ,
    BufferReader$2.prototype.string = function _() {
        var k = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + k, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + k, this.len))
    }
    ,
    BufferReader$2._configure();
    var rpc$1 = {}
      , service$1 = Service$1
      , util$5 = requireMinimal$1();
    (Service$1.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service$1;
    function Service$1(_, k, J) {
        if (typeof _ != "function")
            throw TypeError("rpcImpl must be a function");
        util$5.EventEmitter.call(this),
        this.rpcImpl = _,
        this.requestDelimited = !!k,
        this.responseDelimited = !!J
    }
    Service$1.prototype.rpcCall = function _(k, J, et, tt, rt) {
        if (!tt)
            throw TypeError("request must be specified");
        var nt = this;
        if (!rt)
            return util$5.asPromise(_, nt, k, J, et, tt);
        if (!nt.rpcImpl) {
            setTimeout(function() {
                rt(Error("already ended"))
            }, 0);
            return
        }
        try {
            return nt.rpcImpl(k, J[nt.requestDelimited ? "encodeDelimited" : "encode"](tt).finish(), function(ot, it) {
                if (ot)
                    return nt.emit("error", ot, k),
                    rt(ot);
                if (it === null) {
                    nt.end(!0);
                    return
                }
                if (!(it instanceof et))
                    try {
                        it = et[nt.responseDelimited ? "decodeDelimited" : "decode"](it)
                    } catch (at) {
                        return nt.emit("error", at, k),
                        rt(at)
                    }
                return nt.emit("data", it, k),
                rt(null, it)
            })
        } catch (ot) {
            nt.emit("error", ot, k),
            setTimeout(function() {
                rt(ot)
            }, 0);
            return
        }
    }
    ,
    Service$1.prototype.end = function _(k) {
        return this.rpcImpl && (k || this.rpcImpl(null, null, null),
        this.rpcImpl = null,
        this.emit("end").off()),
        this
    }
    ,
    function(_) {
        var k = _;
        k.Service = service$1
    }(rpc$1);
    var roots$1 = {};
    (function(_) {
        var k = _;
        k.build = "minimal",
        k.Writer = writer$1,
        k.BufferWriter = writer_buffer$1,
        k.Reader = reader$1,
        k.BufferReader = reader_buffer$1,
        k.util = requireMinimal$1(),
        k.rpc = rpc$1,
        k.roots = roots$1,
        k.configure = J;
        function J() {
            k.util._configure(),
            k.Writer._configure(k.BufferWriter),
            k.Reader._configure(k.BufferReader)
        }
        J()
    }
    )(indexMinimal$1);
    var minimal$2 = indexMinimal$1;
    let $protobuf;
    $protobuf = getDefaultExportFromCjs(minimal$2),
    minimal$3 = _mergeNamespaces$1({
        
        default: $protobuf
    }, [minimal$2]),
    function() {
        if (typeof window != "object")
            return;
        if ("IntersectionObserver"in window && "IntersectionObserverEntry"in window && "intersectionRatio"in window.IntersectionObserverEntry.prototype) {
            "isIntersecting"in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function() {
                    return this.intersectionRatio > 0
                }
            });
            return
        }
        function _(mt) {
            try {
                return mt.defaultView && mt.defaultView.frameElement || null
            } catch (vt) {
                return null
            }
        }
        var k = function(mt) {
            for (var vt = mt, bt = _(vt); bt; )
                vt = bt.ownerDocument,
                bt = _(vt);
            return vt
        }(window.document)
          , J = []
          , et = null
          , tt = null;
        function rt(mt) {
            this.time = mt.time,
            this.target = mt.target,
            this.rootBounds = pt(mt.rootBounds),
            this.boundingClientRect = pt(mt.boundingClientRect),
            this.intersectionRect = pt(mt.intersectionRect || ct()),
            this.isIntersecting = !!mt.intersectionRect;
            var vt = this.boundingClientRect
              , bt = vt.width * vt.height
              , Et = this.intersectionRect
              , xt = Et.width * Et.height;
            bt ? this.intersectionRatio = Number((xt / bt).toFixed(4)) : this.intersectionRatio = this.isIntersecting ? 1 : 0
        }
        function nt(mt, vt) {
            var bt = vt || {};
            if (typeof mt != "function")
                throw new Error("callback must be a function");
            if (bt.root && bt.root.nodeType != 1 && bt.root.nodeType != 9)
                throw new Error("root must be a Document or Element");
            this._checkForIntersections = it(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT),
            this._callback = mt,
            this._observationTargets = [],
            this._queuedEntries = [],
            this._rootMarginValues = this._parseRootMargin(bt.rootMargin),
            this.thresholds = this._initThresholds(bt.threshold),
            this.root = bt.root || null,
            this.rootMargin = this._rootMarginValues.map(function(Et) {
                return Et.value + Et.unit
            }).join(" "),
            this._monitoringDocuments = [],
            this._monitoringUnsubscribes = []
        }
        nt.prototype.THROTTLE_TIMEOUT = 100,
        nt.prototype.POLL_INTERVAL = null,
        nt.prototype.USE_MUTATION_OBSERVER = !0,
        nt._setupCrossOriginUpdater = function() {
            return et || (et = function(mt, vt) {
                !mt || !vt ? tt = ct() : tt = ft(mt, vt),
                J.forEach(function(bt) {
                    bt._checkForIntersections()
                })
            }
            ),
            et
        }
        ,
        nt._resetCrossOriginUpdater = function() {
            et = null,
            tt = null
        }
        ,
        nt.prototype.observe = function(mt) {
            var vt = this._observationTargets.some(function(bt) {
                return bt.element == mt
            });
            if (!vt) {
                if (!(mt && mt.nodeType == 1))
                    throw new Error("target must be an Element");
                this._registerInstance(),
                this._observationTargets.push({
                    element: mt,
                    entry: null
                }),
                this._monitorIntersections(mt.ownerDocument),
                this._checkForIntersections()
            }
        }
        ,
        nt.prototype.unobserve = function(mt) {
            this._observationTargets = this._observationTargets.filter(function(vt) {
                return vt.element != mt
            }),
            this._unmonitorIntersections(mt.ownerDocument),
            this._observationTargets.length == 0 && this._unregisterInstance()
        }
        ,
        nt.prototype.disconnect = function() {
            this._observationTargets = [],
            this._unmonitorAllIntersections(),
            this._unregisterInstance()
        }
        ,
        nt.prototype.takeRecords = function() {
            var mt = this._queuedEntries.slice();
            return this._queuedEntries = [],
            mt
        }
        ,
        nt.prototype._initThresholds = function(mt) {
            var vt = mt || [0];
            return Array.isArray(vt) || (vt = [vt]),
            vt.sort().filter(function(bt, Et, xt) {
                if (typeof bt != "number" || isNaN(bt) || bt < 0 || bt > 1)
                    throw new Error("threshold must be a number between 0 and 1 inclusively");
                return bt !== xt[Et - 1]
            })
        }
        ,
        nt.prototype._parseRootMargin = function(mt) {
            var vt = mt || "0px"
              , bt = vt.split(/\s+/).map(function(Et) {
                var xt = /^(-?\d*\.?\d+)(px|%)$/.exec(Et);
                if (!xt)
                    throw new Error("rootMargin must be specified in pixels or percent");
                return {
                    value: parseFloat(xt[1]),
                    unit: xt[2]
                }
            });
            return bt[1] = bt[1] || bt[0],
            bt[2] = bt[2] || bt[0],
            bt[3] = bt[3] || bt[1],
            bt
        }
        ,
        nt.prototype._monitorIntersections = function(mt) {
            var vt = mt.defaultView;
            if (vt && this._monitoringDocuments.indexOf(mt) == -1) {
                var bt = this._checkForIntersections
                  , Et = null
                  , xt = null;
                this.POLL_INTERVAL ? Et = vt.setInterval(bt, this.POLL_INTERVAL) : (at(vt, "resize", bt, !0),
                at(mt, "scroll", bt, !0),
                this.USE_MUTATION_OBSERVER && "MutationObserver"in vt && (xt = new vt.MutationObserver(bt),
                xt.observe(mt, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                }))),
                this._monitoringDocuments.push(mt),
                this._monitoringUnsubscribes.push(function() {
                    var Pt = mt.defaultView;
                    Pt && (Et && Pt.clearInterval(Et),
                    lt(Pt, "resize", bt, !0)),
                    lt(mt, "scroll", bt, !0),
                    xt && xt.disconnect()
                });
                var wt = this.root && (this.root.ownerDocument || this.root) || k;
                if (mt != wt) {
                    var St = _(mt);
                    St && this._monitorIntersections(St.ownerDocument)
                }
            }
        }
        ,
        nt.prototype._unmonitorIntersections = function(mt) {
            var vt = this._monitoringDocuments.indexOf(mt);
            if (vt != -1) {
                var bt = this.root && (this.root.ownerDocument || this.root) || k
                  , Et = this._observationTargets.some(function(St) {
                    var Pt = St.element.ownerDocument;
                    if (Pt == mt)
                        return !0;
                    for (; Pt && Pt != bt; ) {
                        var Rt = _(Pt);
                        if (Pt = Rt && Rt.ownerDocument,
                        Pt == mt)
                            return !0
                    }
                    return !1
                });
                if (!Et) {
                    var xt = this._monitoringUnsubscribes[vt];
                    if (this._monitoringDocuments.splice(vt, 1),
                    this._monitoringUnsubscribes.splice(vt, 1),
                    xt(),
                    mt != bt) {
                        var wt = _(mt);
                        wt && this._unmonitorIntersections(wt.ownerDocument)
                    }
                }
            }
        }
        ,
        nt.prototype._unmonitorAllIntersections = function() {
            var mt = this._monitoringUnsubscribes.slice(0);
            this._monitoringDocuments.length = 0,
            this._monitoringUnsubscribes.length = 0;
            for (var vt = 0; vt < mt.length; vt++)
                mt[vt]()
        }
        ,
        nt.prototype._checkForIntersections = function() {
            if (!(!this.root && et && !tt)) {
                var mt = this._rootIsInDom()
                  , vt = mt ? this._getRootRect() : ct();
                this._observationTargets.forEach(function(bt) {
                    var Et = bt.element
                      , xt = ut(Et)
                      , wt = this._rootContainsTarget(Et)
                      , St = bt.entry
                      , Pt = mt && wt && this._computeTargetAndRootIntersection(Et, xt, vt)
                      , Rt = null;
                    this._rootContainsTarget(Et) ? (!et || this.root) && (Rt = vt) : Rt = ct();
                    var At = bt.entry = new rt({
                        time: ot(),
                        target: Et,
                        boundingClientRect: xt,
                        rootBounds: Rt,
                        intersectionRect: Pt
                    });
                    St ? mt && wt ? this._hasCrossedThreshold(St, At) && this._queuedEntries.push(At) : St && St.isIntersecting && this._queuedEntries.push(At) : this._queuedEntries.push(At)
                }, this),
                this._queuedEntries.length && this._callback(this.takeRecords(), this)
            }
        }
        ,
        nt.prototype._computeTargetAndRootIntersection = function(mt, vt, bt) {
            if (window.getComputedStyle(mt).display != "none") {
                for (var Et = vt, xt = ht(mt), wt = !1; !wt && xt; ) {
                    var St = null
                      , Pt = xt.nodeType == 1 ? window.getComputedStyle(xt) : {};
                    if (Pt.display == "none")
                        return null;
                    if (xt == this.root || xt.nodeType == 9)
                        if (wt = !0,
                        xt == this.root || xt == k)
                            et && !this.root ? !tt || tt.width == 0 && tt.height == 0 ? (xt = null,
                            St = null,
                            Et = null) : St = tt : St = bt;
                        else {
                            var Rt = ht(xt)
                              , At = Rt && ut(Rt)
                              , Nt = Rt && this._computeTargetAndRootIntersection(Rt, At, bt);
                            At && Nt ? (xt = Rt,
                            St = ft(At, Nt)) : (xt = null,
                            Et = null)
                        }
                    else {
                        var Ot = xt.ownerDocument;
                        xt != Ot.body && xt != Ot.documentElement && Pt.overflow != "visible" && (St = ut(xt))
                    }
                    if (St && (Et = st(St, Et)),
                    !Et)
                        break;
                    xt = xt && ht(xt)
                }
                return Et
            }
        }
        ,
        nt.prototype._getRootRect = function() {
            var mt;
            if (this.root && !gt(this.root))
                mt = ut(this.root);
            else {
                var vt = gt(this.root) ? this.root : k
                  , bt = vt.documentElement
                  , Et = vt.body;
                mt = {
                    top: 0,
                    left: 0,
                    right: bt.clientWidth || Et.clientWidth,
                    width: bt.clientWidth || Et.clientWidth,
                    bottom: bt.clientHeight || Et.clientHeight,
                    height: bt.clientHeight || Et.clientHeight
                }
            }
            return this._expandRectByRootMargin(mt)
        }
        ,
        nt.prototype._expandRectByRootMargin = function(mt) {
            var vt = this._rootMarginValues.map(function(Et, xt) {
                return Et.unit == "px" ? Et.value : Et.value * (xt % 2 ? mt.width : mt.height) / 100
            })
              , bt = {
                top: mt.top - vt[0],
                right: mt.right + vt[1],
                bottom: mt.bottom + vt[2],
                left: mt.left - vt[3]
            };
            return bt.width = bt.right - bt.left,
            bt.height = bt.bottom - bt.top,
            bt
        }
        ,
        nt.prototype._hasCrossedThreshold = function(mt, vt) {
            var bt = mt && mt.isIntersecting ? mt.intersectionRatio || 0 : -1
              , Et = vt.isIntersecting ? vt.intersectionRatio || 0 : -1;
            if (bt !== Et)
                for (var xt = 0; xt < this.thresholds.length; xt++) {
                    var wt = this.thresholds[xt];
                    if (wt == bt || wt == Et || wt < bt != wt < Et)
                        return !0
                }
        }
        ,
        nt.prototype._rootIsInDom = function() {
            return !this.root || yt(k, this.root)
        }
        ,
        nt.prototype._rootContainsTarget = function(mt) {
            var vt = this.root && (this.root.ownerDocument || this.root) || k;
            return yt(vt, mt) && (!this.root || vt == mt.ownerDocument)
        }
        ,
        nt.prototype._registerInstance = function() {
            J.indexOf(this) < 0 && J.push(this)
        }
        ,
        nt.prototype._unregisterInstance = function() {
            var mt = J.indexOf(this);
            mt != -1 && J.splice(mt, 1)
        }
        ;
        function ot() {
            return window.performance && performance.now && performance.now()
        }
        function it(mt, vt) {
            var bt = null;
            return function() {
                bt || (bt = setTimeout(function() {
                    mt(),
                    bt = null
                }, vt))
            }
        }
        function at(mt, vt, bt, Et) {
            typeof mt.addEventListener == "function" ? mt.addEventListener(vt, bt, Et || !1) : typeof mt.attachEvent == "function" && mt.attachEvent("on" + vt, bt)
        }
        function lt(mt, vt, bt, Et) {
            typeof mt.removeEventListener == "function" ? mt.removeEventListener(vt, bt, Et || !1) : typeof mt.detachEvent == "function" && mt.detachEvent("on" + vt, bt)
        }
        function st(mt, vt) {
            var bt = Math.max(mt.top, vt.top)
              , Et = Math.min(mt.bottom, vt.bottom)
              , xt = Math.max(mt.left, vt.left)
              , wt = Math.min(mt.right, vt.right)
              , St = wt - xt
              , Pt = Et - bt;
            return St >= 0 && Pt >= 0 && {
                top: bt,
                bottom: Et,
                left: xt,
                right: wt,
                width: St,
                height: Pt
            } || null
        }
        function ut(mt) {
            var vt;
            try {
                vt = mt.getBoundingClientRect()
            } catch (bt) {}
            return vt ? (vt.width && vt.height || (vt = {
                top: vt.top,
                right: vt.right,
                bottom: vt.bottom,
                left: vt.left,
                width: vt.right - vt.left,
                height: vt.bottom - vt.top
            }),
            vt) : ct()
        }
        function ct() {
            return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            }
        }
        function pt(mt) {
            return !mt || "x"in mt ? mt : {
                top: mt.top,
                y: mt.top,
                bottom: mt.bottom,
                left: mt.left,
                x: mt.left,
                right: mt.right,
                width: mt.width,
                height: mt.height
            }
        }
        function ft(mt, vt) {
            var bt = vt.top - mt.top
              , Et = vt.left - mt.left;
            return {
                top: bt,
                left: Et,
                height: vt.height,
                width: vt.width,
                bottom: bt + vt.height,
                right: Et + vt.width
            }
        }
        function yt(mt, vt) {
            for (var bt = vt; bt; ) {
                if (bt == mt)
                    return !0;
                bt = ht(bt)
            }
            return !1
        }
        function ht(mt) {
            var vt = mt.parentNode;
            return mt.nodeType == 9 && mt != k ? _(mt) : (vt && vt.assignedSlot && (vt = vt.assignedSlot.parentNode),
            vt && vt.nodeType == 11 && vt.host ? vt.host : vt)
        }
        function gt(mt) {
            return mt && mt.nodeType === 9
        }
        window.IntersectionObserver = nt,
        window.IntersectionObserverEntry = rt
    }();
    var MAX_DIGITS = 1e9, defaults = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
    }, Decimal, external = !0, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE$1, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P$1 = {};
    P$1.absoluteValue = P$1.abs = function() {
        var _ = new this.constructor(this);
        return _.s && (_.s = 1),
        _
    }
    ,
    P$1.comparedTo = P$1.cmp = function(_) {
        var k, J, et, tt, rt = this;
        if (_ = new rt.constructor(_),
        rt.s !== _.s)
            return rt.s || -_.s;
        if (rt.e !== _.e)
            return rt.e > _.e ^ rt.s < 0 ? 1 : -1;
        for (et = rt.d.length,
        tt = _.d.length,
        k = 0,
        J = et < tt ? et : tt; k < J; ++k)
            if (rt.d[k] !== _.d[k])
                return rt.d[k] > _.d[k] ^ rt.s < 0 ? 1 : -1;
        return et === tt ? 0 : et > tt ^ rt.s < 0 ? 1 : -1
    }
    ,
    P$1.decimalPlaces = P$1.dp = function() {
        var _ = this
          , k = _.d.length - 1
          , J = (k - _.e) * LOG_BASE;
        if (k = _.d[k],
        k)
            for (; k % 10 == 0; k /= 10)
                J--;
        return J < 0 ? 0 : J
    }
    ,
    P$1.dividedBy = P$1.div = function(_) {
        return divide(this, new this.constructor(_))
    }
    ,
    P$1.dividedToIntegerBy = P$1.idiv = function(_) {
        var k = this
          , J = k.constructor;
        return round(divide(k, new J(_), 0, 1), J.precision)
    }
    ,
    P$1.equals = P$1.eq = function(_) {
        return !this.cmp(_)
    }
    ,
    P$1.exponent = function() {
        return getBase10Exponent(this)
    }
    ,
    P$1.greaterThan = P$1.gt = function(_) {
        return this.cmp(_) > 0
    }
    ,
    P$1.greaterThanOrEqualTo = P$1.gte = function(_) {
        return this.cmp(_) >= 0
    }
    ,
    P$1.isInteger = P$1.isint = function() {
        return this.e > this.d.length - 2
    }
    ,
    P$1.isNegative = P$1.isneg = function() {
        return this.s < 0
    }
    ,
    P$1.isPositive = P$1.ispos = function() {
        return this.s > 0
    }
    ,
    P$1.isZero = function() {
        return this.s === 0
    }
    ,
    P$1.lessThan = P$1.lt = function(_) {
        return this.cmp(_) < 0
    }
    ,
    P$1.lessThanOrEqualTo = P$1.lte = function(_) {
        return this.cmp(_) < 1
    }
    ,
    P$1.logarithm = P$1.log = function(_) {
        var k, J = this, et = J.constructor, tt = et.precision, rt = tt + 5;
        if (_ === void 0)
            _ = new et(10);
        else if (_ = new et(_),
        _.s < 1 || _.eq(ONE$1))
            throw Error(decimalError + "NaN");
        if (J.s < 1)
            throw Error(decimalError + (J.s ? "NaN" : "-Infinity"));
        return J.eq(ONE$1) ? new et(0) : (external = !1,
        k = divide(ln(J, rt), ln(_, rt), rt),
        external = !0,
        round(k, tt))
    }
    ,
    P$1.minus = P$1.sub = function(_) {
        var k = this;
        return _ = new k.constructor(_),
        k.s == _.s ? subtract(k, _) : add(k, (_.s = -_.s,
        _))
    }
    ,
    P$1.modulo = P$1.mod = function(_) {
        var k, J = this, et = J.constructor, tt = et.precision;
        if (_ = new et(_),
        !_.s)
            throw Error(decimalError + "NaN");
        return J.s ? (external = !1,
        k = divide(J, _, 0, 1).times(_),
        external = !0,
        J.minus(k)) : round(new et(J), tt)
    }
    ,
    P$1.naturalExponential = P$1.exp = function() {
        return exp(this)
    }
    ,
    P$1.naturalLogarithm = P$1.ln = function() {
        return ln(this)
    }
    ,
    P$1.negated = P$1.neg = function() {
        var _ = new this.constructor(this);
        return _.s = -_.s || 0,
        _
    }
    ,
    P$1.plus = P$1.add = function(_) {
        var k = this;
        return _ = new k.constructor(_),
        k.s == _.s ? add(k, _) : subtract(k, (_.s = -_.s,
        _))
    }
    ,
    P$1.precision = P$1.sd = function(_) {
        var k, J, et, tt = this;
        if (_ !== void 0 && _ !== !!_ && _ !== 1 && _ !== 0)
            throw Error(invalidArgument + _);
        if (k = getBase10Exponent(tt) + 1,
        et = tt.d.length - 1,
        J = et * LOG_BASE + 1,
        et = tt.d[et],
        et) {
            for (; et % 10 == 0; et /= 10)
                J--;
            for (et = tt.d[0]; et >= 10; et /= 10)
                J++
        }
        return _ && k > J ? k : J
    }
    ,
    P$1.squareRoot = P$1.sqrt = function() {
        var _, k, J, et, tt, rt, nt, ot = this, it = ot.constructor;
        if (ot.s < 1) {
            if (!ot.s)
                return new it(0);
            throw Error(decimalError + "NaN")
        }
        for (_ = getBase10Exponent(ot),
        external = !1,
        tt = Math.sqrt(+ot),
        tt == 0 || tt == 1 / 0 ? (k = digitsToString(ot.d),
        (k.length + _) % 2 == 0 && (k += "0"),
        tt = Math.sqrt(k),
        _ = mathfloor((_ + 1) / 2) - (_ < 0 || _ % 2),
        tt == 1 / 0 ? k = "5e" + _ : (k = tt.toExponential(),
        k = k.slice(0, k.indexOf("e") + 1) + _),
        et = new it(k)) : et = new it(tt.toString()),
        J = it.precision,
        tt = nt = J + 3; ; )
            if (rt = et,
            et = rt.plus(divide(ot, rt, nt + 2)).times(.5),
            digitsToString(rt.d).slice(0, nt) === (k = digitsToString(et.d)).slice(0, nt)) {
                if (k = k.slice(nt - 3, nt + 1),
                tt == nt && k == "4999") {
                    if (round(rt, J + 1, 0),
                    rt.times(rt).eq(ot)) {
                        et = rt;
                        break
                    }
                } else if (k != "9999")
                    break;
                nt += 4
            }
        return external = !0,
        round(et, J)
    }
    ,
    P$1.times = P$1.mul = function(_) {
        var k, J, et, tt, rt, nt, ot, it, at, lt = this, st = lt.constructor, ut = lt.d, ct = (_ = new st(_)).d;
        if (!lt.s || !_.s)
            return new st(0);
        for (_.s *= lt.s,
        J = lt.e + _.e,
        it = ut.length,
        at = ct.length,
        it < at && (rt = ut,
        ut = ct,
        ct = rt,
        nt = it,
        it = at,
        at = nt),
        rt = [],
        nt = it + at,
        et = nt; et--; )
            rt.push(0);
        for (et = at; --et >= 0; ) {
            for (k = 0,
            tt = it + et; tt > et; )
                ot = rt[tt] + ct[et] * ut[tt - et - 1] + k,
                rt[tt--] = ot % BASE | 0,
                k = ot / BASE | 0;
            rt[tt] = (rt[tt] + k) % BASE | 0
        }
        for (; !rt[--nt]; )
            rt.pop();
        return k ? ++J : rt.shift(),
        _.d = rt,
        _.e = J,
        external ? round(_, st.precision) : _
    }
    ,
    P$1.toDecimalPlaces = P$1.todp = function(_, k) {
        var J = this
          , et = J.constructor;
        return J = new et(J),
        _ === void 0 ? J : (checkInt32(_, 0, MAX_DIGITS),
        k === void 0 ? k = et.rounding : checkInt32(k, 0, 8),
        round(J, _ + getBase10Exponent(J) + 1, k))
    }
    ,
    P$1.toExponential = function(_, k) {
        var J, et = this, tt = et.constructor;
        return _ === void 0 ? J = toString$3(et, !0) : (checkInt32(_, 0, MAX_DIGITS),
        k === void 0 ? k = tt.rounding : checkInt32(k, 0, 8),
        et = round(new tt(et), _ + 1, k),
        J = toString$3(et, !0, _ + 1)),
        J
    }
    ,
    P$1.toFixed = function(_, k) {
        var J, et, tt = this, rt = tt.constructor;
        return _ === void 0 ? toString$3(tt) : (checkInt32(_, 0, MAX_DIGITS),
        k === void 0 ? k = rt.rounding : checkInt32(k, 0, 8),
        et = round(new rt(tt), _ + getBase10Exponent(tt) + 1, k),
        J = toString$3(et.abs(), !1, _ + getBase10Exponent(et) + 1),
        tt.isneg() && !tt.isZero() ? "-" + J : J)
    }
    ,
    P$1.toInteger = P$1.toint = function() {
        var _ = this
          , k = _.constructor;
        return round(new k(_), getBase10Exponent(_) + 1, k.rounding)
    }
    ,
    P$1.toNumber = function() {
        return +this
    }
    ,
    P$1.toPower = P$1.pow = function(_) {
        var k, J, et, tt, rt, nt, ot = this, it = ot.constructor, at = 12, lt = +(_ = new it(_));
        if (!_.s)
            return new it(ONE$1);
        if (ot = new it(ot),
        !ot.s) {
            if (_.s < 1)
                throw Error(decimalError + "Infinity");
            return ot
        }
        if (ot.eq(ONE$1))
            return ot;
        if (et = it.precision,
        _.eq(ONE$1))
            return round(ot, et);
        if (k = _.e,
        J = _.d.length - 1,
        nt = k >= J,
        rt = ot.s,
        nt) {
            if ((J = lt < 0 ? -lt : lt) <= MAX_SAFE_INTEGER) {
                for (tt = new it(ONE$1),
                k = Math.ceil(et / LOG_BASE + 4),
                external = !1; J % 2 && (tt = tt.times(ot),
                truncate(tt.d, k)),
                J = mathfloor(J / 2),
                J !== 0; )
                    ot = ot.times(ot),
                    truncate(ot.d, k);
                return external = !0,
                _.s < 0 ? new it(ONE$1).div(tt) : round(tt, et)
            }
        } else if (rt < 0)
            throw Error(decimalError + "NaN");
        return rt = rt < 0 && _.d[Math.max(k, J)] & 1 ? -1 : 1,
        ot.s = 1,
        external = !1,
        tt = _.times(ln(ot, et + at)),
        external = !0,
        tt = exp(tt),
        tt.s = rt,
        tt
    }
    ,
    P$1.toPrecision = function(_, k) {
        var J, et, tt = this, rt = tt.constructor;
        return _ === void 0 ? (J = getBase10Exponent(tt),
        et = toString$3(tt, J <= rt.toExpNeg || J >= rt.toExpPos)) : (checkInt32(_, 1, MAX_DIGITS),
        k === void 0 ? k = rt.rounding : checkInt32(k, 0, 8),
        tt = round(new rt(tt), _, k),
        J = getBase10Exponent(tt),
        et = toString$3(tt, _ <= J || J <= rt.toExpNeg, _)),
        et
    }
    ,
    P$1.toSignificantDigits = P$1.tosd = function(_, k) {
        var J = this
          , et = J.constructor;
        return _ === void 0 ? (_ = et.precision,
        k = et.rounding) : (checkInt32(_, 1, MAX_DIGITS),
        k === void 0 ? k = et.rounding : checkInt32(k, 0, 8)),
        round(new et(J), _, k)
    }
    ,
    P$1.toString = P$1.valueOf = P$1.val = P$1.toJSON = P$1[Symbol.for("nodejs.util.inspect.custom")] = function() {
        var _ = this
          , k = getBase10Exponent(_)
          , J = _.constructor;
        return toString$3(_, k <= J.toExpNeg || k >= J.toExpPos)
    }
    ;
    function add(_, k) {
        var J, et, tt, rt, nt, ot, it, at, lt = _.constructor, st = lt.precision;
        if (!_.s || !k.s)
            return k.s || (k = new lt(_)),
            external ? round(k, st) : k;
        if (it = _.d,
        at = k.d,
        nt = _.e,
        tt = k.e,
        it = it.slice(),
        rt = nt - tt,
        rt) {
            for (rt < 0 ? (et = it,
            rt = -rt,
            ot = at.length) : (et = at,
            tt = nt,
            ot = it.length),
            nt = Math.ceil(st / LOG_BASE),
            ot = nt > ot ? nt + 1 : ot + 1,
            rt > ot && (rt = ot,
            et.length = 1),
            et.reverse(); rt--; )
                et.push(0);
            et.reverse()
        }
        for (ot = it.length,
        rt = at.length,
        ot - rt < 0 && (rt = ot,
        et = at,
        at = it,
        it = et),
        J = 0; rt; )
            J = (it[--rt] = it[rt] + at[rt] + J) / BASE | 0,
            it[rt] %= BASE;
        for (J && (it.unshift(J),
        ++tt),
        ot = it.length; it[--ot] == 0; )
            it.pop();
        return k.d = it,
        k.e = tt,
        external ? round(k, st) : k
    }
    function checkInt32(_, k, J) {
        if (_ !== ~~_ || _ < k || _ > J)
            throw Error(invalidArgument + _)
    }
    function digitsToString(_) {
        var k, J, et, tt = _.length - 1, rt = "", nt = _[0];
        if (tt > 0) {
            for (rt += nt,
            k = 1; k < tt; k++)
                et = _[k] + "",
                J = LOG_BASE - et.length,
                J && (rt += getZeroString(J)),
                rt += et;
            nt = _[k],
            et = nt + "",
            J = LOG_BASE - et.length,
            J && (rt += getZeroString(J))
        } else if (nt === 0)
            return "0";
        for (; nt % 10 === 0; )
            nt /= 10;
        return rt + nt
    }
    var divide = function() {
        function _(et, tt) {
            var rt, nt = 0, ot = et.length;
            for (et = et.slice(); ot--; )
                rt = et[ot] * tt + nt,
                et[ot] = rt % BASE | 0,
                nt = rt / BASE | 0;
            return nt && et.unshift(nt),
            et
        }
        function k(et, tt, rt, nt) {
            var ot, it;
            if (rt != nt)
                it = rt > nt ? 1 : -1;
            else
                for (ot = it = 0; ot < rt; ot++)
                    if (et[ot] != tt[ot]) {
                        it = et[ot] > tt[ot] ? 1 : -1;
                        break
                    }
            return it
        }
        function J(et, tt, rt) {
            for (var nt = 0; rt--; )
                et[rt] -= nt,
                nt = et[rt] < tt[rt] ? 1 : 0,
                et[rt] = nt * BASE + et[rt] - tt[rt];
            for (; !et[0] && et.length > 1; )
                et.shift()
        }
        return function(et, tt, rt, nt) {
            var ot, it, at, lt, st, ut, ct, pt, ft, yt, ht, gt, mt, vt, bt, Et, xt, wt, St = et.constructor, Pt = et.s == tt.s ? 1 : -1, Rt = et.d, At = tt.d;
            if (!et.s)
                return new St(et);
            if (!tt.s)
                throw Error(decimalError + "Division by zero");
            for (it = et.e - tt.e,
            xt = At.length,
            bt = Rt.length,
            ct = new St(Pt),
            pt = ct.d = [],
            at = 0; At[at] == (Rt[at] || 0); )
                ++at;
            if (At[at] > (Rt[at] || 0) && --it,
            rt == null ? gt = rt = St.precision : nt ? gt = rt + (getBase10Exponent(et) - getBase10Exponent(tt)) + 1 : gt = rt,
            gt < 0)
                return new St(0);
            if (gt = gt / LOG_BASE + 2 | 0,
            at = 0,
            xt == 1)
                for (lt = 0,
                At = At[0],
                gt++; (at < bt || lt) && gt--; at++)
                    mt = lt * BASE + (Rt[at] || 0),
                    pt[at] = mt / At | 0,
                    lt = mt % At | 0;
            else {
                for (lt = BASE / (At[0] + 1) | 0,
                lt > 1 && (At = _(At, lt),
                Rt = _(Rt, lt),
                xt = At.length,
                bt = Rt.length),
                vt = xt,
                ft = Rt.slice(0, xt),
                yt = ft.length; yt < xt; )
                    ft[yt++] = 0;
                wt = At.slice(),
                wt.unshift(0),
                Et = At[0],
                At[1] >= BASE / 2 && ++Et;
                do
                    lt = 0,
                    ot = k(At, ft, xt, yt),
                    ot < 0 ? (ht = ft[0],
                    xt != yt && (ht = ht * BASE + (ft[1] || 0)),
                    lt = ht / Et | 0,
                    lt > 1 ? (lt >= BASE && (lt = BASE - 1),
                    st = _(At, lt),
                    ut = st.length,
                    yt = ft.length,
                    ot = k(st, ft, ut, yt),
                    ot == 1 && (lt--,
                    J(st, xt < ut ? wt : At, ut))) : (lt == 0 && (ot = lt = 1),
                    st = At.slice()),
                    ut = st.length,
                    ut < yt && st.unshift(0),
                    J(ft, st, yt),
                    ot == -1 && (yt = ft.length,
                    ot = k(At, ft, xt, yt),
                    ot < 1 && (lt++,
                    J(ft, xt < yt ? wt : At, yt))),
                    yt = ft.length) : ot === 0 && (lt++,
                    ft = [0]),
                    pt[at++] = lt,
                    ot && ft[0] ? ft[yt++] = Rt[vt] || 0 : (ft = [Rt[vt]],
                    yt = 1);
                while ((vt++ < bt || ft[0] !== void 0) && gt--)
            }
            return pt[0] || pt.shift(),
            ct.e = it,
            round(ct, nt ? rt + getBase10Exponent(ct) + 1 : rt)
        }
    }();
    function exp(_, k) {
        var J, et, tt, rt, nt, ot, it = 0, at = 0, lt = _.constructor, st = lt.precision;
        if (getBase10Exponent(_) > 16)
            throw Error(exponentOutOfRange + getBase10Exponent(_));
        if (!_.s)
            return new lt(ONE$1);
        for (k == null ? (external = !1,
        ot = st) : ot = k,
        nt = new lt(.03125); _.abs().gte(.1); )
            _ = _.times(nt),
            at += 5;
        for (et = Math.log(mathpow(2, at)) / Math.LN10 * 2 + 5 | 0,
        ot += et,
        J = tt = rt = new lt(ONE$1),
        lt.precision = ot; ; ) {
            if (tt = round(tt.times(_), ot),
            J = J.times(++it),
            nt = rt.plus(divide(tt, J, ot)),
            digitsToString(nt.d).slice(0, ot) === digitsToString(rt.d).slice(0, ot)) {
                for (; at--; )
                    rt = round(rt.times(rt), ot);
                return lt.precision = st,
                k == null ? (external = !0,
                round(rt, st)) : rt
            }
            rt = nt
        }
    }
    function getBase10Exponent(_) {
        for (var k = _.e * LOG_BASE, J = _.d[0]; J >= 10; J /= 10)
            k++;
        return k
    }
    function getLn10(_, k, J) {
        if (k > _.LN10.sd())
            throw external = !0,
            J && (_.precision = J),
            Error(decimalError + "LN10 precision limit exceeded");
        return round(new _(_.LN10), k)
    }
    function getZeroString(_) {
        for (var k = ""; _--; )
            k += "0";
        return k
    }
    function ln(_, k) {
        var J, et, tt, rt, nt, ot, it, at, lt, st = 1, ut = 10, ct = _, pt = ct.d, ft = ct.constructor, yt = ft.precision;
        if (ct.s < 1)
            throw Error(decimalError + (ct.s ? "NaN" : "-Infinity"));
        if (ct.eq(ONE$1))
            return new ft(0);
        if (k == null ? (external = !1,
        at = yt) : at = k,
        ct.eq(10))
            return k == null && (external = !0),
            getLn10(ft, at);
        if (at += ut,
        ft.precision = at,
        J = digitsToString(pt),
        et = J.charAt(0),
        rt = getBase10Exponent(ct),
        Math.abs(rt) < 15e14) {
            for (; et < 7 && et != 1 || et == 1 && J.charAt(1) > 3; )
                ct = ct.times(_),
                J = digitsToString(ct.d),
                et = J.charAt(0),
                st++;
            rt = getBase10Exponent(ct),
            et > 1 ? (ct = new ft("0." + J),
            rt++) : ct = new ft(et + "." + J.slice(1))
        } else
            return it = getLn10(ft, at + 2, yt).times(rt + ""),
            ct = ln(new ft(et + "." + J.slice(1)), at - ut).plus(it),
            ft.precision = yt,
            k == null ? (external = !0,
            round(ct, yt)) : ct;
        for (ot = nt = ct = divide(ct.minus(ONE$1), ct.plus(ONE$1), at),
        lt = round(ct.times(ct), at),
        tt = 3; ; ) {
            if (nt = round(nt.times(lt), at),
            it = ot.plus(divide(nt, new ft(tt), at)),
            digitsToString(it.d).slice(0, at) === digitsToString(ot.d).slice(0, at))
                return ot = ot.times(2),
                rt !== 0 && (ot = ot.plus(getLn10(ft, at + 2, yt).times(rt + ""))),
                ot = divide(ot, new ft(st), at),
                ft.precision = yt,
                k == null ? (external = !0,
                round(ot, yt)) : ot;
            ot = it,
            tt += 2
        }
    }
    function parseDecimal(_, k) {
        var J, et, tt;
        for ((J = k.indexOf(".")) > -1 && (k = k.replace(".", "")),
        (et = k.search(/e/i)) > 0 ? (J < 0 && (J = et),
        J += +k.slice(et + 1),
        k = k.substring(0, et)) : J < 0 && (J = k.length),
        et = 0; k.charCodeAt(et) === 48; )
            ++et;
        for (tt = k.length; k.charCodeAt(tt - 1) === 48; )
            --tt;
        if (k = k.slice(et, tt),
        k) {
            if (tt -= et,
            J = J - et - 1,
            _.e = mathfloor(J / LOG_BASE),
            _.d = [],
            et = (J + 1) % LOG_BASE,
            J < 0 && (et += LOG_BASE),
            et < tt) {
                for (et && _.d.push(+k.slice(0, et)),
                tt -= LOG_BASE; et < tt; )
                    _.d.push(+k.slice(et, et += LOG_BASE));
                k = k.slice(et),
                et = LOG_BASE - k.length
            } else
                et -= tt;
            for (; et--; )
                k += "0";
            if (_.d.push(+k),
            external && (_.e > MAX_E || _.e < -MAX_E))
                throw Error(exponentOutOfRange + J)
        } else
            _.s = 0,
            _.e = 0,
            _.d = [0];
        return _
    }
    function round(_, k, J) {
        var et, tt, rt, nt, ot, it, at, lt, st = _.d;
        for (nt = 1,
        rt = st[0]; rt >= 10; rt /= 10)
            nt++;
        if (et = k - nt,
        et < 0)
            et += LOG_BASE,
            tt = k,
            at = st[lt = 0];
        else {
            if (lt = Math.ceil((et + 1) / LOG_BASE),
            rt = st.length,
            lt >= rt)
                return _;
            for (at = rt = st[lt],
            nt = 1; rt >= 10; rt /= 10)
                nt++;
            et %= LOG_BASE,
            tt = et - LOG_BASE + nt
        }
        if (J !== void 0 && (rt = mathpow(10, nt - tt - 1),
        ot = at / rt % 10 | 0,
        it = k < 0 || st[lt + 1] !== void 0 || at % rt,
        it = J < 4 ? (ot || it) && (J == 0 || J == (_.s < 0 ? 3 : 2)) : ot > 5 || ot == 5 && (J == 4 || it || J == 6 && (et > 0 ? tt > 0 ? at / mathpow(10, nt - tt) : 0 : st[lt - 1]) % 10 & 1 || J == (_.s < 0 ? 8 : 7))),
        k < 1 || !st[0])
            return it ? (rt = getBase10Exponent(_),
            st.length = 1,
            k = k - rt - 1,
            st[0] = mathpow(10, (LOG_BASE - k % LOG_BASE) % LOG_BASE),
            _.e = mathfloor(-k / LOG_BASE) || 0) : (st.length = 1,
            st[0] = _.e = _.s = 0),
            _;
        if (et == 0 ? (st.length = lt,
        rt = 1,
        lt--) : (st.length = lt + 1,
        rt = mathpow(10, LOG_BASE - et),
        st[lt] = tt > 0 ? (at / mathpow(10, nt - tt) % mathpow(10, tt) | 0) * rt : 0),
        it)
            for (; ; )
                if (lt == 0) {
                    (st[0] += rt) == BASE && (st[0] = 1,
                    ++_.e);
                    break
                } else {
                    if (st[lt] += rt,
                    st[lt] != BASE)
                        break;
                    st[lt--] = 0,
                    rt = 1
                }
        for (et = st.length; st[--et] === 0; )
            st.pop();
        if (external && (_.e > MAX_E || _.e < -MAX_E))
            throw Error(exponentOutOfRange + getBase10Exponent(_));
        return _
    }
    function subtract(_, k) {
        var J, et, tt, rt, nt, ot, it, at, lt, st, ut = _.constructor, ct = ut.precision;
        if (!_.s || !k.s)
            return k.s ? k.s = -k.s : k = new ut(_),
            external ? round(k, ct) : k;
        if (it = _.d,
        st = k.d,
        et = k.e,
        at = _.e,
        it = it.slice(),
        nt = at - et,
        nt) {
            for (lt = nt < 0,
            lt ? (J = it,
            nt = -nt,
            ot = st.length) : (J = st,
            et = at,
            ot = it.length),
            tt = Math.max(Math.ceil(ct / LOG_BASE), ot) + 2,
            nt > tt && (nt = tt,
            J.length = 1),
            J.reverse(),
            tt = nt; tt--; )
                J.push(0);
            J.reverse()
        } else {
            for (tt = it.length,
            ot = st.length,
            lt = tt < ot,
            lt && (ot = tt),
            tt = 0; tt < ot; tt++)
                if (it[tt] != st[tt]) {
                    lt = it[tt] < st[tt];
                    break
                }
            nt = 0
        }
        for (lt && (J = it,
        it = st,
        st = J,
        k.s = -k.s),
        ot = it.length,
        tt = st.length - ot; tt > 0; --tt)
            it[ot++] = 0;
        for (tt = st.length; tt > nt; ) {
            if (it[--tt] < st[tt]) {
                for (rt = tt; rt && it[--rt] === 0; )
                    it[rt] = BASE - 1;
                --it[rt],
                it[tt] += BASE
            }
            it[tt] -= st[tt]
        }
        for (; it[--ot] === 0; )
            it.pop();
        for (; it[0] === 0; it.shift())
            --et;
        return it[0] ? (k.d = it,
        k.e = et,
        external ? round(k, ct) : k) : new ut(0)
    }
    function toString$3(_, k, J) {
        var et, tt = getBase10Exponent(_), rt = digitsToString(_.d), nt = rt.length;
        return k ? (J && (et = J - nt) > 0 ? rt = rt.charAt(0) + "." + rt.slice(1) + getZeroString(et) : nt > 1 && (rt = rt.charAt(0) + "." + rt.slice(1)),
        rt = rt + (tt < 0 ? "e" : "e+") + tt) : tt < 0 ? (rt = "0." + getZeroString(-tt - 1) + rt,
        J && (et = J - nt) > 0 && (rt += getZeroString(et))) : tt >= nt ? (rt += getZeroString(tt + 1 - nt),
        J && (et = J - tt - 1) > 0 && (rt = rt + "." + getZeroString(et))) : ((et = tt + 1) < nt && (rt = rt.slice(0, et) + "." + rt.slice(et)),
        J && (et = J - nt) > 0 && (tt + 1 === nt && (rt += "."),
        rt += getZeroString(et))),
        _.s < 0 ? "-" + rt : rt
    }
    function truncate(_, k) {
        if (_.length > k)
            return _.length = k,
            !0
    }
    function clone$1(_) {
        var k, J, et;
        function tt(rt) {
            var nt = this;
            if (!(nt instanceof tt))
                return new tt(rt);
            if (nt.constructor = tt,
            rt instanceof tt) {
                nt.s = rt.s,
                nt.e = rt.e,
                nt.d = (rt = rt.d) ? rt.slice() : rt;
                return
            }
            if (typeof rt == "number") {
                if (rt * 0 !== 0)
                    throw Error(invalidArgument + rt);
                if (rt > 0)
                    nt.s = 1;
                else if (rt < 0)
                    rt = -rt,
                    nt.s = -1;
                else {
                    nt.s = 0,
                    nt.e = 0,
                    nt.d = [0];
                    return
                }
                if (rt === ~~rt && rt < 1e7) {
                    nt.e = 0,
                    nt.d = [rt];
                    return
                }
                return parseDecimal(nt, rt.toString())
            } else if (typeof rt != "string")
                throw Error(invalidArgument + rt);
            if (rt.charCodeAt(0) === 45 ? (rt = rt.slice(1),
            nt.s = -1) : nt.s = 1,
            isDecimal.test(rt))
                parseDecimal(nt, rt);
            else
                throw Error(invalidArgument + rt)
        }
        if (tt.prototype = P$1,
        tt.ROUND_UP = 0,
        tt.ROUND_DOWN = 1,
        tt.ROUND_CEIL = 2,
        tt.ROUND_FLOOR = 3,
        tt.ROUND_HALF_UP = 4,
        tt.ROUND_HALF_DOWN = 5,
        tt.ROUND_HALF_EVEN = 6,
        tt.ROUND_HALF_CEIL = 7,
        tt.ROUND_HALF_FLOOR = 8,
        tt.clone = clone$1,
        tt.config = tt.set = config,
        _ === void 0 && (_ = {}),
        _)
            for (et = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"],
            k = 0; k < et.length; )
                _.hasOwnProperty(J = et[k++]) || (_[J] = this[J]);
        return tt.config(_),
        tt
    }
    function config(_) {
        if (!_ || typeof _ != "object")
            throw Error(decimalError + "Object expected");
        var k, J, et, tt = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
        for (k = 0; k < tt.length; k += 3)
            if ((et = _[J = tt[k]]) !== void 0)
                if (mathfloor(et) === et && et >= tt[k + 1] && et <= tt[k + 2])
                    this[J] = et;
                else
                    throw Error(invalidArgument + J + ": " + et);
        if ((et = _[J = "LN10"]) !== void 0)
            if (et == Math.LN10)
                this[J] = new this(et);
            else
                throw Error(invalidArgument + J + ": " + et);
        return this
    }
    var Decimal = clone$1(defaults);
    ONE$1 = new Decimal(1),
    Decimal$1 = Decimal;
    function indianFormat(_) {
        var k = parseFloat(String(_));
        return isFinite(k) ? _formatAfterCleanup(k) : _
    }
    function _formatAfterCleanup(_) {
        var k, J;
        _ < 0 ? (k = -1 * _,
        J = !0) : (k = _,
        J = !1);
        var et = String(k).split("").reverse(), tt = et.indexOf(".") + 1, rt, nt = [];
        for (rt = 0; rt < tt; rt++)
            nt.push(et[rt]);
        var ot = 0;
        for (rt = tt; rt < et.length; rt++)
            nt.push(et[rt]),
            ot++,
            (ot === 3 || ot === 5 || ot === 7) && rt < et.length - 1 && nt.push(","),
            ot === 7 && (ot = 0);
        return J && nt.push("-"),
        nt.reverse().join("")
    }
    const isWechat = ()=>window.navigator.userAgent.search(/MicroMessenger/i) !== -1;
    function formateAmount(_=0, k=8, J=!1) {
        const et = new Decimal$1(_)
          , tt = J ? Decimal$1.ROUND_UP : Decimal$1.ROUND_DOWN
          , rt = et.abs().toFixed(0, Decimal$1.ROUND_DOWN).length
          , nt = et.toNumber();
        if (k = k > 8 ? 9 : k + 1,
        rt >= k) {
            const ot = et.abs().toFixed(0, tt);
            return nt > 0 ? ot : "-" + ot
        } else
            return et.toFixed(k - rt, tt)
    }
    const linearScale = (_,k,J=!1)=>et=>(J && (et < _[0] ? et = _[0] : et > _[1] && (et = _[1])),
    k[0] + (et - _[0]) * (k[0] - k[1]) / (_[0] - _[1]))
      , toUnderline = _=>_.replace(/[A-Z]/g, k=>`_${k.toLowerCase()}`)
      , toHump = _=>_.replace(/_(\w)/g, (k,J)=>J.toUpperCase())
      , ellipsis = (_,k)=>(_ = String(_),
    _.length > k ? _.slice(0, k) + "..." : _)
      , requestFullscreen = async(_=document.documentElement)=>{
        try {
            _.requestFullscreen ? await _.requestFullscreen() : _.mozRequestFullScreen ? await _.mozRequestFullScreen() : _.msRequestFullscreen ? await _.msRequestFullscreen() : _.webkitRequestFullscreen && await _.webkitRequestFullScreen()
        } catch (k) {}
    }
      , exitFullscreen = async()=>{
        try {
            document.exitFullscreen ? await document.exitFullscreen() : document.msExitFullscreen ? await document.msExitFullscreen() : document.mozCancelFullScreen ? await document.mozCancelFullScreen() : document.webkitExitFullscreen && await document.webkitExitFullscreen()
        } catch (_) {}
    }
      , random = (_=10,k=0)=>k + Math.random() * (_ - k)
      , rotateVector = (_,k)=>{
        const J = Math.cos(k)
          , et = Math.sin(k);
        return [_[0] * J + _[1] * et, _[1] * J + _[0] * et]
    }
      , hexToRgb = _=>{
        _ = _.replace(/#/, "");
        var k = parseInt(_, 16)
          , J = k >> 16 & 255
          , et = k >> 8 & 255
          , tt = k & 255;
        return [J, et, tt]
    }
      , rgbToHex = (_,k,J)=>(_ << 16) + (k << 8) + J
      , loadScript = memoize$1((_,k,J)=>new Promise((et,tt)=>{
        var rt = document.head || document.getElementsByTagName("head")[0];
        const nt = document.createElement("script");
        nt.async = !0,
        nt.src = _,
        J && (nt.id = J),
        nt.charset = "utf8",
        rt.appendChild(nt),
        nt.onload = ()=>{
            let ot = k ? window[k] : null;
            rt.removeChild(nt),
            et(ot)
        }
        ,
        nt.onerror = ot=>{
            rt.removeChild(nt),
            loadScript.cache.delete(`${_}:${k}`),
            tt(new Error(`Load Script Error: ${_}`))
        }
    }
    ), (_,k)=>`${_}:${k}`);
    function bolb2Image(_) {
        return new Promise(k=>{
            const J = new Image;
            J.onload = ()=>{
                URL.revokeObjectURL(J.src),
                k(J)
            }
            ,
            J.src = URL.createObjectURL(_)
        }
        )
    }
    const concatenate = (_,...k)=>{
        let J = 0;
        for (let rt of k)
            J += rt.length;
        let et = new _(J)
          , tt = 0;
        for (let rt of k)
            et.set(rt, tt),
            tt += rt.length;
        return et
    }
      , delay = (_=0)=>new Promise(k=>setTimeout(k, _))
      , delayFrame = (_=0)=>new Promise(k=>gsapWithCSS.delayedCall(_ / 1e3, k))
      , stringSplice = (_,k,J,et)=>_.slice(0, k) + et + _.slice(k + J);
    function precision(_) {
        if (!isFinite(_))
            return 0;
        for (var k = 1, J = 0; Math.round(_ * k) / k !== _; )
            k *= 10,
            J++;
        return J
    }
    function numberWithCommas(_, k, J) {
        const et = (typeof J == "number" ? new Decimal$1(k).toFixed(J, Decimal$1.ROUND_DOWN) : k.toString()).toString().split(".");
        return _ === "INRFIAT" ? (et[0] = indianFormat(et[0]).toString(),
        et.join(".")) : (et[0] = et[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","),
        et.join("."))
    }
    const numberZeroize = _=>_ < 10 && _ >= 0 ? `0${_}` : _.toString()
      , numberOrdinal = _=>{
        let k;
        switch (_) {
        case 1:
            k = "st";
            break;
        case 2:
            k = "nd";
            break;
        case 3:
            k = "rd";
            break;
        default:
            k = "th";
            break
        }
        return `${_}${k}`
    }
    ;
    function numPercent(_) {
        return `${Math.round(_ * 1e6) / 1e4}%`
    }
    function amountValid(_) {
        return _.toFixed(10).slice(0, 10).replace(/\.$/, "")
    }
    function intervalQueue(_, k, J=20) {
        let et = !1;
        const tt = [];
        let rt;
        const nt = ()=>{
            et || (et = !0,
            rt = window.setTimeout(()=>{
                tt.length != 0 && (_.apply(window, tt.shift()),
                et = !1,
                tt.length > 0 && nt())
            }
            , k))
        }
          , ot = (...it)=>{
            tt.length >= J || (tt.push(it),
            nt())
        }
        ;
        return ot.clear = ()=>{
            clearTimeout(rt),
            tt.splice(0, tt.length)
        }
        ,
        ot
    }
    function debounceQueue(_, k=0) {
        let J = [];
        const et = debounce(()=>{
            _(J),
            J = []
        }
        , k);
        return tt=>{
            J.push(tt),
            et()
        }
    }
    const isSSR = typeof window > "u";
    function noSSR(_) {
        return isSSR ? (...k)=>{}
        : _
    }
    function switchSSR(_, k) {
        return isSSR ? k : _
    }
    const pendingWithSSR = new Promise(_=>!isSSR && _())
      , isSupportTouch = isSSR ? !1 : window.hasOwnProperty("ontouchstart");
    let hidden, visibilityChange;
    isSSR || typeof document.hidden < "u" ? (hidden = "hidden",
    visibilityChange = "visibilitychange") : typeof document.msHidden < "u" ? (hidden = "msHidden",
    visibilityChange = "msvisibilitychange") : typeof document.webkitHidden < "u" && (hidden = "webkitHidden",
    visibilityChange = "webkitvisibilitychange");
    function onVisibilityChange(_, k=!1) {
        const J = ()=>_(!document[hidden]);
        return document.addEventListener(visibilityChange, J, !1),
        k && J(),
        ()=>document.removeEventListener(visibilityChange, J, !1)
    }
    function Uint8Array2Hex(_) {
        let k = "";
        for (let J = 0; J < _.length; J++) {
            let et = _[J].toString(16);
            k += et.length === 1 ? "0" + et : et
        }
        return `0x${k}`
    }
    const loadImage = memoize$1(function(_) {
        const k = new Promise((J,et)=>{
            const tt = new Image;
            tt.onload = ()=>J(_),
            tt.src = _,
            tt.onerror = ()=>et(new Error("Image load error!"))
        }
        );
        return k.catch(J=>{
            loadImage.cache.delete(_)
        }
        ),
        k
    });
    function i18nReplace(_, ...k) {
        let J = 0;
        return k.length == 0 ? _ : _.replace(/{\d+}/g, ()=>{
            const et = k[J];
            return J++,
            et
        }
        )
    }
    function isIos() {
        return isSSR ? !1 : ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document
    }
    const emptyPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
    function mergeRefs(_) {
        return reactExports.useCallback(k=>{
            _.forEach(J=>{
                typeof J == "function" ? J(k) : J != null && (J.current = k)
            }
            )
        }
        , _)
    }
    function classList(..._) {
        return _.filter(Boolean).join(" ")
    }
    function copyToClipboard(_) {
        const k = document.createElement("input");
        document.body.appendChild(k);
        try {
            k.setAttribute("readonly", "readonly"),
            k.setAttribute("value", _),
            k.setSelectionRange(0, 99999),
            k.select(),
            document.execCommand("copy")
        } catch (J) {
            throw J
        } finally {
            document.body.removeChild(k)
        }
    }
    const springConfigs = {
        fast: {
            stiffness: 640,
            damping: 60
        }
    };
    function singlePromise(_) {
        let k;
        return (...J)=>(k === void 0 && (k = _(...J),
        k.then(()=>k = void 0)),
        k)
    }
    function dataBind(_, k) {
        return {
            value: _[k],
            onChange(J) {
                _[k] = J
            }
        }
    }
    function detectAuto() {
        const _ = [];
        return window.atob("d2ViZHJpdmVyLF9fZHJpdmVyX2V2YWx1YXRlLF9fd2ViZHJpdmVyX2V2YWx1YXRlLCBfX3NlbGVuaXVtX2V2YWx1YXRlLF9fZnhkcml2ZXJfZXZhbHVhdGUsX19kcml2ZXJfdW53cmFwcGVkLF9fd2ViZHJpdmVyX3Vud3JhcHBlZCxfX3NlbGVuaXVtX3Vud3JhcHBlZCxfX2Z4ZHJpdmVyX3Vud3JhcHBlZCxfU2VsZW5pdW1fSURFX1JlY29yZGVyLF9zZWxlbml1bSxjYWxsZWRTZWxlbml1bSxfV0VCRFJJVkVSX0VMRU1fQ0FDSEUsQ2hyb21lRHJpdmVydyxkcml2ZXItZXZhbHVhdGUsd2ViZHJpdmVyLWV2YWx1YXRlLHNlbGVuaXVtLWV2YWx1YXRlLHdlYmRyaXZlckNvbW1hbmQsd2ViZHJpdmVyLWV2YWx1YXRlLXJlc3BvbnNlLF9fd2ViZHJpdmVyRnVuYyxfX3dlYmRyaXZlcl9zY3JpcHRfZm4sX18kd2ViZHJpdmVyQXN5bmNFeGVjdXRvcixfX2xhc3RXYXRpckFsZXJ0LF9fbGFzdFdhdGlyQ29uZmlybSxfX2xhc3RXYXRpclByb21wdCwkY2hyb21lX2FzeW5jU2NyaXB0SW5mbywkY2RjX2FzZGpmbGFzdXRvcGZodmNaTG1jZmxfLF9waGFudG9tLF9waGFudG9tYXM=").split(",").forEach(k=>{
            (window[k] || window.document.documentElement.getAttribute(k) || navigator[k]) && _.push(k)
        }
        ),
        _.length > 0
    }
    function getUrlParms(_, k=5) {
        return (_["*"] || "").split("/").concat(Array(k).fill(""))
    }
    function formatWrapString(_) {
        return _.replace(/\n/g, "<br />")
    }
    function collapseElement(_, k=_.clientHeight === 0, J=.2) {
        const et = J > 0 ? `height ${J}s ease-out` : "";
        if (k) {
            var tt = _.scrollHeight;
            if (_.style.transition = et,
            _.style.height = tt + "px",
            et !== "") {
                let rt = function() {
                    _.removeEventListener("transitionend", rt),
                    _.style.height = ""
                };
                _.addEventListener("transitionend", rt)
            }
        } else
            _.style.transition = "",
            _.style.height = _.clientHeight + "px",
            requestAnimationFrame(()=>{
                _.style.transition = et,
                _.style.height = "0px"
            }
            )
    }
    function intersectionObserver(_, k, J) {
        const et = new IntersectionObserver(([tt])=>{
            k(tt.isIntersecting)
        }
        ,{
            rootMargin: J,
            threshold: .5
        });
        return et.observe(_),
        et
    }
    class SharedResizeObserver {
        constructor() {
            _e(this, "observerMap", new Map),
            _e(this, "observer"),
            this.observer = new ResizeObserver(k=>{
                for (var J of k) {
                    var et = this.observerMap.get(J.target);
                    et && et(J.contentRect)
                }
            }
            )
        }
        add(k, J) {
            this.observerMap.set(k, J),
            this.observer.observe(k)
        }
        remove(k) {
            this.observerMap.has(k) && (this.observerMap.delete(k),
            this.observer.unobserve(k))
        }
    }
    const SRObserver = isSSR ? null : new SharedResizeObserver;
    class SharedIntersectionObserver {
        constructor() {
            _e(this, "observerMap", new Map),
            _e(this, "observer"),
            this.observer = new IntersectionObserver(k=>{
                for (var J of k) {
                    var et = this.observerMap.get(J.target);
                    et && et(J.isIntersecting)
                }
            }
            ,{
                threshold: .5
            })
        }
        add(k, J) {
            this.observerMap.set(k, J),
            this.observer.observe(k)
        }
        remove(k) {
            this.observerMap.has(k) && (this.observerMap.delete(k),
            this.observer.unobserve(k))
        }
    }
    const SIObserver = isSSR ? null : new SharedIntersectionObserver;
    function timeMemoize(_, {timeout: k=6e4, getKey: J}={}) {
        const et = new TimeCache(k)
          , tt = memoize$1((...rt)=>{
            const nt = _(...rt);
            return nt.catch(()=>et.delete(J ? J(...rt) : rt[0])),
            nt
        }
        , J);
        return tt.cache = et,
        tt
    }
    class TimeCache extends Map {
        constructor(k=6e4) {
            super(),
            _e(this, "timeout"),
            _e(this, "lastTimeout", 0),
            this.timeout = k
        }
        has(k) {
            const J = Math.round(Date.now() / this.timeout);
            return J !== this.lastTimeout && (this.lastTimeout = J,
            this.clear()),
            super.has(k)
        }
    }
    function splitFillList(_, k) {
        if (!_ || _.length === 0)
            return [];
        const J = Math.ceil(_.length / k)
          , et = _.concat(_);
        return chunk(et, k).splice(0, J)
    }
    let timeDiff = 0;
    function serverTime(_) {
        if (typeof _ > "u")
            return new Date(Date.now() - timeDiff);
        timeDiff = Date.now() - _
    }
    function pick(_, ...k) {
        return k.length == 0 ? _ : k.reduce((J,et)=>(J[et] = _[et],
        J), {})
    }
    function shallow(_, k) {
        for (let J in _)
            if (_[J] !== k[J])
                return !1;
        return !0
    }
    function currencyFormat(_, k) {
        return _.toFixed() + k
    }
    function toValidAmount(_, k) {
        return _.gte(1e7) || _.lte(-1e7) ? _.toFixed() : _.toFixed(k).substring(0, _.gt(0) ? 10 : 11).replace(/\.0+$/, "")
    }
    function _getHostType(_) {
        const k = ["bc.me", "bc.ai", "bcga.me"]
          , J = ["bcgame.ke", "bcbet.ng", "bcsports.game"]
          , et = ["bc.xyz"]
          , tt = ["bcgame.sk"]
          , rt = ["bcgame.us"]
          , nt = ["bcbet.ng"]
          , ot = ["bcigra.com", "bcfeast88.com", "bcwildwagers.com"]
          , it = ["87.com"]
          , at = ["bcgamebet.ng"]
          , lt = ["bcgame.vc"]
          , st = ["bckm.top"];
        return {
            isBrHost: k.includes(_),
            isKenyaHost: J.includes(_),
            isSpreadHost: et.includes(_),
            isUsHost: rt.includes(_),
            isSkHost: tt.includes(_),
            isNgHost: nt.includes(_),
            isRuHosts: ot.includes(_),
            isSpHost: it.includes(_),
            isNg2Host: at.includes(_),
            isIdHost: lt.includes(_),
            isAnjouanHost: st.includes(_)
        }
    }
    let getHostType, e$1, t$1, r$2, n$1;
    getHostType = memoize$1(_getHostType),
    index$1 = Object.assign(Object.defineProperty({
        
        SIObserver,
        SRObserver,
        Uint8Array2Hex,
        amountValid,
        bolb2Image,
        classList,
        collapseElement,
        concatenate,
        copyToClipboard,
        currencyFormat,
        dataBind,
        debounceQueue,
        delay,
        delayFrame,
        detectAuto,
        ellipsis,
        emptyPng,
        exitFullscreen,
        formatWrapString,
        formateAmount,
        getHostType,
        getUrlParms,
        hexToRgb,
        i18nReplace,
        intersectionObserver,
        intervalQueue,
        isIos,
        isSSR,
        isSupportTouch,
        isWechat,
        linearScale,
        loadImage,
        loadScript,
        mergeRefs,
        noSSR,
        numPercent,
        numberOrdinal,
        numberWithCommas,
        numberZeroize,
        onVisibilityChange,
        pendingWithSSR,
        pick,
        precision,
        random,
        requestFullscreen,
        rgbToHex,
        rotateVector,
        serverTime,
        shallow,
        singlePromise,
        splitFillList,
        springConfigs,
        stringSplice,
        switchSSR,
        timeMemoize,
        toHump,
        toUnderline,
        toValidAmount
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    useIsomorphicEffect = isSSR ? reactExports.useEffect : reactExports.useLayoutEffect,
    e$1 = Symbol(),
    t$1 = Symbol(),
    r$2 = "a",
    n$1 = "w";
    let o$1 = (_,k)=>new Proxy(_,k);
    const s$5 = Object.getPrototypeOf
      , c$2 = new WeakMap
      , l$1 = _=>_ && (c$2.has(_) ? c$2.get(_) : s$5(_) === Object.prototype || s$5(_) === Array.prototype)
      , f$2 = _=>typeof _ == "object" && _ !== null
      , i$2 = _=>{
        if (Array.isArray(_))
            return Array.from(_);
        const k = Object.getOwnPropertyDescriptors(_);
        return Object.values(k).forEach(J=>{
            J.configurable = !0
        }
        ),
        Object.create(s$5(_), k)
    }
      , u$1 = _=>_[t$1] || _
      , a$3 = (_,k,J,et)=>{
        if (!l$1(_))
            return _;
        let tt = et && et.get(_);
        if (!tt) {
            const it = u$1(_);
            tt = (at=>Object.values(Object.getOwnPropertyDescriptors(at)).some(lt=>!lt.configurable && !lt.writable))(it) ? [it, i$2(it)] : [it],
            et == null || et.set(_, tt)
        }
        const [rt,nt] = tt;
        let ot = J && J.get(rt);
        return ot && ot[1].f === !!nt || (ot = ((it,at)=>{
            const lt = {
                f: at
            };
            let st = !1;
            const ut = (pt,ft)=>{
                if (!st) {
                    let yt = lt[r$2].get(it);
                    if (yt || (yt = {},
                    lt[r$2].set(it, yt)),
                    pt === n$1)
                        yt[n$1] = !0;
                    else {
                        let ht = yt[pt];
                        ht || (ht = new Set,
                        yt[pt] = ht),
                        ht.add(ft)
                    }
                }
            }
              , ct = {
                get: (pt,ft)=>ft === t$1 ? it : (ut("k", ft),
                a$3(Reflect.get(pt, ft), lt[r$2], lt.c, lt.t)),
                has: (pt,ft)=>ft === e$1 ? (st = !0,
                lt[r$2].delete(it),
                !0) : (ut("h", ft),
                Reflect.has(pt, ft)),
                getOwnPropertyDescriptor: (pt,ft)=>(ut("o", ft),
                Reflect.getOwnPropertyDescriptor(pt, ft)),
                ownKeys: pt=>(ut(n$1),
                Reflect.ownKeys(pt))
            };
            return at && (ct.set = ct.deleteProperty = ()=>!1),
            [ct, lt]
        }
        )(rt, !!nt),
        ot[1].p = o$1(nt || rt, ot[0]),
        J && J.set(rt, ot)),
        ot[1][r$2] = k,
        ot[1].c = J,
        ot[1].t = et,
        ot[1].p
    }
      , p$1 = (_,k,J,et,tt=Object.is)=>{
        if (tt(_, k))
            return !1;
        if (!f$2(_) || !f$2(k))
            return !0;
        const rt = J.get(u$1(_));
        if (!rt)
            return !0;
        if (et) {
            const ot = et.get(_);
            if (ot && ot.n === k)
                return ot.g;
            et.set(_, {
                n: k,
                g: !1
            })
        }
        let nt = null;
        try {
            for (const ot of rt.h || [])
                if (nt = Reflect.has(_, ot) !== Reflect.has(k, ot),
                nt)
                    return nt;
            if (rt[n$1] === !0) {
                if (nt = ((ot,it)=>{
                    const at = Reflect.ownKeys(ot)
                      , lt = Reflect.ownKeys(it);
                    return at.length !== lt.length || at.some((st,ut)=>st !== lt[ut])
                }
                )(_, k),
                nt)
                    return nt
            } else
                for (const ot of rt.o || [])
                    if (nt = !!Reflect.getOwnPropertyDescriptor(_, ot) != !!Reflect.getOwnPropertyDescriptor(k, ot),
                    nt)
                        return nt;
            for (const ot of rt.k || [])
                if (nt = p$1(_[ot], k[ot], J, et, tt),
                nt)
                    return nt;
            return nt === null && (nt = !0),
            nt
        } finally {
            et && et.set(_, {
                n: k,
                g: nt
            })
        }
    }
      , y$4 = _=>l$1(_) && _[t$1] || null
      , h$3 = (_,k=!0)=>{
        c$2.set(_, k)
    }
      , isObject = _=>typeof _ == "object" && _ !== null
      , proxyStateMap = new WeakMap
      , refSet = new WeakSet
      , buildProxyFunction = (_=Object.is,k=(at,lt)=>new Proxy(at,lt),J=at=>isObject(at) && !refSet.has(at) && (Array.isArray(at) || !(Symbol.iterator in at)) && !(at instanceof WeakMap) && !(at instanceof WeakSet) && !(at instanceof Error) && !(at instanceof Number) && !(at instanceof Date) && !(at instanceof String) && !(at instanceof RegExp) && !(at instanceof ArrayBuffer),et=at=>{
        switch (at.status) {
        case "fulfilled":
            return at.value;
        case "rejected":
            throw at.reason;
        default:
            throw at
        }
    }
    ,tt=new WeakMap,rt=(at,lt,st=et)=>{
        const ut = tt.get(at);
        if ((ut == null ? void 0 : ut[0]) === lt)
            return ut[1];
        const ct = Array.isArray(at) ? [] : Object.create(Object.getPrototypeOf(at));
        return h$3(ct, !0),
        tt.set(at, [lt, ct]),
        Reflect.ownKeys(at).forEach(pt=>{
            if (Object.getOwnPropertyDescriptor(ct, pt))
                return;
            const ft = Reflect.get(at, pt)
              , {enumerable: yt} = Reflect.getOwnPropertyDescriptor(at, pt)
              , ht = {
                value: ft,
                enumerable: yt,
                configurable: !0
            };
            if (refSet.has(ft))
                h$3(ft, !1);
            else if (ft instanceof Promise)
                delete ht.value,
                ht.get = ()=>st(ft);
            else if (proxyStateMap.has(ft)) {
                const [gt,mt] = proxyStateMap.get(ft);
                ht.value = rt(gt, mt(), st)
            }
            Object.defineProperty(ct, pt, ht)
        }
        ),
        Object.preventExtensions(ct)
    }
    ,nt=new WeakMap,ot=[1, 1],it=at=>{
        if (!isObject(at))
            throw new Error("object required");
        const lt = nt.get(at);
        if (lt)
            return lt;
        let st = ot[0];
        const ut = new Set
          , ct = (wt,St=++ot[0])=>{
            st !== St && (st = St,
            ut.forEach(Pt=>Pt(wt, St)))
        }
        ;
        let pt = ot[1];
        const ft = (wt=++ot[1])=>(pt !== wt && !ut.size && (pt = wt,
        ht.forEach(([St])=>{
            const Pt = St[1](wt);
            Pt > st && (st = Pt)
        }
        )),
        st)
          , yt = wt=>(St,Pt)=>{
            const Rt = [...St];
            Rt[1] = [wt, ...Rt[1]],
            ct(Rt, Pt)
        }
          , ht = new Map
          , gt = (wt,St)=>{
            if (ut.size) {
                const Pt = St[3](yt(wt));
                ht.set(wt, [St, Pt])
            } else
                ht.set(wt, [St])
        }
          , mt = wt=>{
            var St;
            const Pt = ht.get(wt);
            Pt && (ht.delete(wt),
            (St = Pt[1]) == null || St.call(Pt))
        }
          , vt = wt=>(ut.add(wt),
        ut.size === 1 && ht.forEach(([St,Pt],Rt)=>{
            const At = St[3](yt(Rt));
            ht.set(Rt, [St, At])
        }
        ),
        ()=>{
            ut.delete(wt),
            ut.size === 0 && ht.forEach(([St,Pt],Rt)=>{
                Pt && (Pt(),
                ht.set(Rt, [St]))
            }
            )
        }
        )
          , bt = Array.isArray(at) ? [] : Object.create(Object.getPrototypeOf(at))
          , Et = k(bt, {
            deleteProperty(wt, St) {
                const Pt = Reflect.get(wt, St);
                mt(St);
                const Rt = Reflect.deleteProperty(wt, St);
                return Rt && ct(["delete", [St], Pt]),
                Rt
            },
            set(wt, St, Pt, Rt) {
                const At = Reflect.has(wt, St)
                  , Nt = Reflect.get(wt, St, Rt);
                if (At && (_(Nt, Pt) || nt.has(Pt) && _(Nt, nt.get(Pt))))
                    return !0;
                mt(St),
                isObject(Pt) && (Pt = y$4(Pt) || Pt);
                let Ot = Pt;
                if (Pt instanceof Promise)
                    Pt.then(It=>{
                        Pt.status = "fulfilled",
                        Pt.value = It,
                        ct(["resolve", [St], It])
                    }
                    ).catch(It=>{
                        Pt.status = "rejected",
                        Pt.reason = It,
                        ct(["reject", [St], It])
                    }
                    );
                else {
                    !proxyStateMap.has(Pt) && J(Pt) && (Ot = it(Pt));
                    const It = !refSet.has(Ot) && proxyStateMap.get(Ot);
                    It && gt(St, It)
                }
                return Reflect.set(wt, St, Ot, Rt),
                ct(["set", [St], Pt, Nt]),
                !0
            }
        });
        nt.set(at, Et);
        const xt = [bt, ft, rt, vt];
        return proxyStateMap.set(Et, xt),
        Reflect.ownKeys(at).forEach(wt=>{
            const St = Object.getOwnPropertyDescriptor(at, wt);
            "value"in St && (Et[wt] = at[wt],
            delete St.value,
            delete St.writable),
            Object.defineProperty(bt, wt, St)
        }
        ),
        Et
    }
    )=>[it, proxyStateMap, refSet, _, k, J, et, tt, rt, nt, ot]
      , [defaultProxyFunction] = buildProxyFunction();
    function proxy$a(_={}) {
        return defaultProxyFunction(_)
    }
    function getVersion(_) {
        const k = proxyStateMap.get(_);
        return k == null ? void 0 : k[1]()
    }
    function subscribe$2(_, k, J) {
        const et = proxyStateMap.get(_);
        let tt;
        const rt = []
          , nt = et[3];
        let ot = !1;
        const it = nt(at=>{
            if (rt.push(at),
            J) {
                k(rt.splice(0));
                return
            }
            tt || (tt = Promise.resolve().then(()=>{
                tt = void 0,
                ot && k(rt.splice(0))
            }
            ))
        }
        );
        return ot = !0,
        ()=>{
            ot = !1,
            it()
        }
    }
    function snapshot(_, k) {
        const J = proxyStateMap.get(_)
          , [et,tt,rt] = J;
        return rt(et, tt(), k)
    }
    function ref$4(_) {
        return refSet.add(_),
        _
    }
    var shim = {
        exports: {}
    }, useSyncExternalStoreShim_production_min = {}, hasRequiredUseSyncExternalStoreShim_production_min;
    function requireUseSyncExternalStoreShim_production_min() {
        if (hasRequiredUseSyncExternalStoreShim_production_min)
            return useSyncExternalStoreShim_production_min;
        hasRequiredUseSyncExternalStoreShim_production_min = 1;
        var _ = React;
        function k(st, ut) {
            return st === ut && (st !== 0 || 1 / st === 1 / ut) || st !== st && ut !== ut
        }
        var J = typeof Object.is == "function" ? Object.is : k
          , et = _.useState
          , tt = _.useEffect
          , rt = _.useLayoutEffect
          , nt = _.useDebugValue;
        function ot(st, ut) {
            var ct = ut()
              , pt = et({
                inst: {
                    value: ct,
                    getSnapshot: ut
                }
            })
              , ft = pt[0].inst
              , yt = pt[1];
            return rt(function() {
                ft.value = ct,
                ft.getSnapshot = ut,
                it(ft) && yt({
                    inst: ft
                })
            }, [st, ct, ut]),
            tt(function() {
                return it(ft) && yt({
                    inst: ft
                }),
                st(function() {
                    it(ft) && yt({
                        inst: ft
                    })
                })
            }, [st]),
            nt(ct),
            ct
        }
        function it(st) {
            var ut = st.getSnapshot;
            st = st.value;
            try {
                var ct = ut();
                return !J(st, ct)
            } catch (pt) {
                return !0
            }
        }
        function at(st, ut) {
            return ut()
        }
        var lt = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? at : ot;
        return useSyncExternalStoreShim_production_min.useSyncExternalStore = _.useSyncExternalStore !== void 0 ? _.useSyncExternalStore : lt,
        useSyncExternalStoreShim_production_min
    }
    shim.exports = requireUseSyncExternalStoreShim_production_min();
    var shimExports = shim.exports;
    const useSyncExternalStoreExports = getDefaultExportFromCjs(shimExports)
      , {use} = React
      , {useSyncExternalStore} = useSyncExternalStoreExports
      , targetCache = new WeakMap;
    function useSnapshot(_, k) {
        const J = k == null ? void 0 : k.sync
          , et = reactExports.useRef()
          , tt = reactExports.useRef();
        let rt = !0;
        const nt = useSyncExternalStore(reactExports.useCallback(at=>{
            const lt = subscribe$2(_, at, J);
            return at(),
            lt
        }
        , [_, J]), ()=>{
            const at = snapshot(_, use);
            try {
                if (!rt && et.current && tt.current && !p$1(et.current, at, tt.current, new WeakMap))
                    return et.current
            } catch (lt) {}
            return at
        }
        , ()=>snapshot(_, use));
        rt = !1;
        const ot = new WeakMap;
        reactExports.useEffect(()=>{
            et.current = nt,
            tt.current = ot
        }
        );
        const it = reactExports.useMemo(()=>new WeakMap, []);
        return a$3(nt, ot, it, targetCache)
    }
    const o = new WeakMap
      , r$1 = new WeakMap
      , s$4 = (_,k)=>{
        const J = o.get(_);
        J && (J[0].forEach(et=>{
            const {d: tt} = et;
            _ !== tt && s$4(tt)
        }
        ),
        ++J[2],
        k && J[3].add(k))
    }
      , l = _=>{
        const k = o.get(_);
        k && (--k[2],
        k[2] || (k[3].forEach(J=>J()),
        k[3].clear()),
        k[0].forEach(J=>{
            const {d: et} = J;
            _ !== et && l(et)
        }
        ))
    }
      , c$1 = _=>{
        const {s: k, d: J} = _;
        let et = r$1.get(J);
        et || (et = [new Set],
        r$1.set(_.d, et)),
        et[0].add(_);
        let tt = o.get(k);
        if (!tt) {
            const rt = new Set
              , nt = subscribe$2(k, ot=>{
                rt.forEach(it=>{
                    const {d: at, c: lt, n: st, i: ut} = it;
                    k === at && ot.every(ct=>ct[1].length === 1 && ut.includes(ct[1][0])) || it.p || (s$4(k, lt),
                    st ? l(k) : it.p = Promise.resolve().then(()=>{
                        delete it.p,
                        l(k)
                    }
                    ))
                }
                )
            }
            , !0);
            tt = [rt, nt, 0, new Set],
            o.set(k, tt)
        }
        tt[0].add(_)
    }
      , a$2 = _=>{
        const {s: k, d: J} = _
          , et = r$1.get(J);
        et == null || et[0].delete(_),
        (et == null ? void 0 : et[0].size) === 0 && r$1.delete(J);
        const tt = o.get(k);
        if (tt) {
            const [rt,nt] = tt;
            rt.delete(_),
            rt.size || (nt(),
            o.delete(k))
        }
    }
      , d$4 = _=>{
        const k = r$1.get(_);
        return k ? Array.from(k[0]) : []
    }
    ;
    function f$1(_, k) {
        const J = (k == null ? void 0 : k.proxy) || proxy$a({})
          , et = !(k == null || !k.sync)
          , tt = Object.keys(_);
        return tt.forEach(rt=>{
            if (Object.getOwnPropertyDescriptor(J, rt))
                throw new Error("object property already defined");
            const nt = _[rt];
            let ot = null;
            const it = ()=>{
                if (ot && (Array.from(ot).map(([ut])=>((ct,pt)=>{
                    const ft = o.get(ct);
                    return !(ft == null || !ft[2] || (ft[3].add(pt),
                    0))
                }
                )(ut, it)).some(ut=>ut) || Array.from(ot).every(([ut,ct])=>getVersion(ut) === ct.v)))
                    return;
                const at = new Map
                  , lt = nt(ut=>(at.set(ut, {
                    v: getVersion(ut)
                }),
                ut))
                  , st = ()=>{
                    var ut;
                    at.forEach((ct,pt)=>{
                        var ft;
                        const yt = (ft = ot) == null || (ft = ft.get(pt)) == null ? void 0 : ft.s;
                        if (yt)
                            ct.s = yt;
                        else {
                            const ht = {
                                s: pt,
                                d: J,
                                k: rt,
                                c: it,
                                n: et,
                                i: tt
                            };
                            c$1(ht),
                            ct.s = ht
                        }
                    }
                    ),
                    (ut = ot) == null || ut.forEach((ct,pt)=>{
                        !at.has(pt) && ct.s && a$2(ct.s)
                    }
                    ),
                    ot = at
                }
                ;
                lt instanceof Promise ? lt.finally(st) : st(),
                J[rt] = lt
            }
            ;
            it()
        }
        ),
        J
    }
    function u(_, k) {
        const J = k != null && k.delete ? new Set : null;
        d$4(_).forEach(et=>{
            const {k: tt} = et;
            k != null && k.keys && !k.keys.includes(tt) || (a$2(et),
            J && J.add(tt))
        }
        ),
        J && J.forEach(et=>{
            delete _[et]
        }
        )
    }
    function subscribeKey$2(_, k, J, et) {
        let tt = _[k];
        return subscribe$2(_, ()=>{
            const rt = _[k];
            Object.is(tt, rt) || J(tt = rt)
        }
        , et)
    }
    let currentCleanups;
    function watch(_, k) {
        let J = !0;
        const et = new Set
          , tt = new Map
          , rt = ()=>{
            J && (J = !1,
            et.forEach(ot=>ot()),
            et.clear(),
            tt.forEach(ot=>ot()),
            tt.clear())
        }
          , nt = async()=>{
            if (!J)
                return;
            et.forEach(at=>at()),
            et.clear();
            const ot = new Set
              , it = currentCleanups;
            currentCleanups = et;
            try {
                const at = _(st=>{
                    if (ot.add(st),
                    J && !tt.has(st)) {
                        const ut = subscribe$2(st, nt, k == null ? void 0 : k.sync);
                        tt.set(st, ut)
                    }
                    return st
                }
                )
                  , lt = at && at instanceof Promise ? await at : at;
                lt && (J ? et.add(lt) : rt())
            } finally {
                currentCleanups = it
            }
            tt.forEach((at,lt)=>{
                ot.has(lt) || (tt.delete(lt),
                at())
            }
            )
        }
        ;
        return currentCleanups && currentCleanups.add(rt),
        nt(),
        rt
    }
    function useProxy$a(_, k) {
        const J = useSnapshot(_, k);
        let et = !0;
        return useIsomorphicEffect(()=>{
            et = !1
        }
        ),
        new Proxy(_,{
            get(tt, rt) {
                return et ? J[rt] : tt[rt]
            }
        })
    }
    valtio = {
        getVersion,
        proxy: proxy$a,
        ref: ref$4,
        snapshot,
        subscribe: subscribe$2,
        useSnapshot,
        derive: f$1,
        subscribeKey: subscribeKey$2,
        underive: u,
        watch,
        useProxy: useProxy$a
    },
    howler = {},
    function(_) {
        (function() {
            var k = function() {
                this.init()
            };
            k.prototype = {
                init: function() {
                    var st = this || J;
                    return st._counter = 1e3,
                    st._html5AudioPool = [],
                    st.html5PoolSize = 10,
                    st._codecs = {},
                    st._howls = [],
                    st._muted = !1,
                    st._volume = 1,
                    st._canPlayEvent = "canplaythrough",
                    st._navigator = typeof window < "u" && window.navigator ? window.navigator : null,
                    st.masterGain = null,
                    st.noAudio = !1,
                    st.usingWebAudio = !0,
                    st.autoSuspend = !0,
                    st.ctx = null,
                    st.autoUnlock = !0,
                    st._setup(),
                    st
                },
                volume: function(st) {
                    var ut = this || J;
                    if (st = parseFloat(st),
                    ut.ctx || lt(),
                    typeof st < "u" && st >= 0 && st <= 1) {
                        if (ut._volume = st,
                        ut._muted)
                            return ut;
                        ut.usingWebAudio && ut.masterGain.gain.setValueAtTime(st, J.ctx.currentTime);
                        for (var ct = 0; ct < ut._howls.length; ct++)
                            if (!ut._howls[ct]._webAudio)
                                for (var pt = ut._howls[ct]._getSoundIds(), ft = 0; ft < pt.length; ft++) {
                                    var yt = ut._howls[ct]._soundById(pt[ft]);
                                    yt && yt._node && (yt._node.volume = yt._volume * st)
                                }
                        return ut
                    }
                    return ut._volume
                },
                mute: function(st) {
                    var ut = this || J;
                    ut.ctx || lt(),
                    ut._muted = st,
                    ut.usingWebAudio && ut.masterGain.gain.setValueAtTime(st ? 0 : ut._volume, J.ctx.currentTime);
                    for (var ct = 0; ct < ut._howls.length; ct++)
                        if (!ut._howls[ct]._webAudio)
                            for (var pt = ut._howls[ct]._getSoundIds(), ft = 0; ft < pt.length; ft++) {
                                var yt = ut._howls[ct]._soundById(pt[ft]);
                                yt && yt._node && (yt._node.muted = st ? !0 : yt._muted)
                            }
                    return ut
                },
                stop: function() {
                    for (var st = this || J, ut = 0; ut < st._howls.length; ut++)
                        st._howls[ut].stop();
                    return st
                },
                unload: function() {
                    for (var st = this || J, ut = st._howls.length - 1; ut >= 0; ut--)
                        st._howls[ut].unload();
                    return st.usingWebAudio && st.ctx && typeof st.ctx.close < "u" && (st.ctx.close(),
                    st.ctx = null,
                    lt()),
                    st
                },
                codecs: function(st) {
                    return (this || J)._codecs[st.replace(/^x-/, "")]
                },
                _setup: function() {
                    var st = this || J;
                    if (st.state = st.ctx && st.ctx.state || "suspended",
                    st._autoSuspend(),
                    !st.usingWebAudio)
                        if (typeof Audio < "u")
                            try {
                                var ut = new Audio;
                                typeof ut.oncanplaythrough > "u" && (st._canPlayEvent = "canplay")
                            } catch (ct) {
                                st.noAudio = !0
                            }
                        else
                            st.noAudio = !0;
                    try {
                        var ut = new Audio;
                        ut.muted && (st.noAudio = !0)
                    } catch (ct) {}
                    return st.noAudio || st._setupCodecs(),
                    st
                },
                _setupCodecs: function() {
                    var st = this || J
                      , ut = null;
                    try {
                        ut = typeof Audio < "u" ? new Audio : null
                    } catch (vt) {
                        return st
                    }
                    if (!ut || typeof ut.canPlayType != "function")
                        return st;
                    var ct = ut.canPlayType("audio/mpeg;").replace(/^no$/, "")
                      , pt = st._navigator ? st._navigator.userAgent : ""
                      , ft = pt.match(/OPR\/(\d+)/g)
                      , yt = ft && parseInt(ft[0].split("/")[1], 10) < 33
                      , ht = pt.indexOf("Safari") !== -1 && pt.indexOf("Chrome") === -1
                      , gt = pt.match(/Version\/(.*?) /)
                      , mt = ht && gt && parseInt(gt[1], 10) < 15;
                    return st._codecs = {
                        mp3: !!(!yt && (ct || ut.canPlayType("audio/mp3;").replace(/^no$/, ""))),
                        mpeg: !!ct,
                        opus: !!ut.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                        ogg: !!ut.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        oga: !!ut.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        wav: !!(ut.canPlayType('audio/wav; codecs="1"') || ut.canPlayType("audio/wav")).replace(/^no$/, ""),
                        aac: !!ut.canPlayType("audio/aac;").replace(/^no$/, ""),
                        caf: !!ut.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                        m4a: !!(ut.canPlayType("audio/x-m4a;") || ut.canPlayType("audio/m4a;") || ut.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        m4b: !!(ut.canPlayType("audio/x-m4b;") || ut.canPlayType("audio/m4b;") || ut.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        mp4: !!(ut.canPlayType("audio/x-mp4;") || ut.canPlayType("audio/mp4;") || ut.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        weba: !!(!mt && ut.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        webm: !!(!mt && ut.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        dolby: !!ut.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                        flac: !!(ut.canPlayType("audio/x-flac;") || ut.canPlayType("audio/flac;")).replace(/^no$/, "")
                    },
                    st
                },
                _unlockAudio: function() {
                    var st = this || J;
                    if (!(st._audioUnlocked || !st.ctx)) {
                        st._audioUnlocked = !1,
                        st.autoUnlock = !1,
                        !st._mobileUnloaded && st.ctx.sampleRate !== 44100 && (st._mobileUnloaded = !0,
                        st.unload()),
                        st._scratchBuffer = st.ctx.createBuffer(1, 1, 22050);
                        var ut = function(ct) {
                            for (; st._html5AudioPool.length < st.html5PoolSize; )
                                try {
                                    var pt = new Audio;
                                    pt._unlocked = !0,
                                    st._releaseHtml5Audio(pt)
                                } catch (vt) {
                                    st.noAudio = !0;
                                    break
                                }
                            for (var ft = 0; ft < st._howls.length; ft++)
                                if (!st._howls[ft]._webAudio)
                                    for (var yt = st._howls[ft]._getSoundIds(), ht = 0; ht < yt.length; ht++) {
                                        var gt = st._howls[ft]._soundById(yt[ht]);
                                        gt && gt._node && !gt._node._unlocked && (gt._node._unlocked = !0,
                                        gt._node.load())
                                    }
                            st._autoResume();
                            var mt = st.ctx.createBufferSource();
                            mt.buffer = st._scratchBuffer,
                            mt.connect(st.ctx.destination),
                            typeof mt.start > "u" ? mt.noteOn(0) : mt.start(0),
                            typeof st.ctx.resume == "function" && st.ctx.resume(),
                            mt.onended = function() {
                                mt.disconnect(0),
                                st._audioUnlocked = !0,
                                document.removeEventListener("touchstart", ut, !0),
                                document.removeEventListener("touchend", ut, !0),
                                document.removeEventListener("click", ut, !0),
                                document.removeEventListener("keydown", ut, !0);
                                for (var vt = 0; vt < st._howls.length; vt++)
                                    st._howls[vt]._emit("unlock")
                            }
                        };
                        return document.addEventListener("touchstart", ut, !0),
                        document.addEventListener("touchend", ut, !0),
                        document.addEventListener("click", ut, !0),
                        document.addEventListener("keydown", ut, !0),
                        st
                    }
                },
                _obtainHtml5Audio: function() {
                    var st = this || J;
                    if (st._html5AudioPool.length)
                        return st._html5AudioPool.pop();
                    var ut = new Audio().play();
                    return ut && typeof Promise < "u" && (ut instanceof Promise || typeof ut.then == "function") && ut.catch(function() {}),
                    new Audio
                },
                _releaseHtml5Audio: function(st) {
                    var ut = this || J;
                    return st._unlocked && ut._html5AudioPool.push(st),
                    ut
                },
                _autoSuspend: function() {
                    var st = this;
                    if (!(!st.autoSuspend || !st.ctx || typeof st.ctx.suspend > "u" || !J.usingWebAudio)) {
                        for (var ut = 0; ut < st._howls.length; ut++)
                            if (st._howls[ut]._webAudio) {
                                for (var ct = 0; ct < st._howls[ut]._sounds.length; ct++)
                                    if (!st._howls[ut]._sounds[ct]._paused)
                                        return st
                            }
                        return st._suspendTimer && clearTimeout(st._suspendTimer),
                        st._suspendTimer = setTimeout(function() {
                            if (st.autoSuspend) {
                                st._suspendTimer = null,
                                st.state = "suspending";
                                var pt = function() {
                                    st.state = "suspended",
                                    st._resumeAfterSuspend && (delete st._resumeAfterSuspend,
                                    st._autoResume())
                                };
                                st.ctx.suspend().then(pt, pt)
                            }
                        }, 3e4),
                        st
                    }
                },
                _autoResume: function() {
                    var st = this;
                    if (!(!st.ctx || typeof st.ctx.resume > "u" || !J.usingWebAudio))
                        return st.state === "running" && st.ctx.state !== "interrupted" && st._suspendTimer ? (clearTimeout(st._suspendTimer),
                        st._suspendTimer = null) : st.state === "suspended" || st.state === "running" && st.ctx.state === "interrupted" ? (st.ctx.resume().then(function() {
                            st.state = "running";
                            for (var ut = 0; ut < st._howls.length; ut++)
                                st._howls[ut]._emit("resume")
                        }),
                        st._suspendTimer && (clearTimeout(st._suspendTimer),
                        st._suspendTimer = null)) : st.state === "suspending" && (st._resumeAfterSuspend = !0),
                        st
                }
            };
            var J = new k
              , et = function(st) {
                var ut = this;
                !st.src || st.src.length === 0 || ut.init(st)
            };
            et.prototype = {
                init: function(st) {
                    var ut = this;
                    return J.ctx || lt(),
                    ut._autoplay = st.autoplay || !1,
                    ut._format = typeof st.format != "string" ? st.format : [st.format],
                    ut._html5 = st.html5 || !1,
                    ut._muted = st.mute || !1,
                    ut._loop = st.loop || !1,
                    ut._pool = st.pool || 5,
                    ut._preload = typeof st.preload == "boolean" || st.preload === "metadata" ? st.preload : !0,
                    ut._rate = st.rate || 1,
                    ut._sprite = st.sprite || {},
                    ut._src = typeof st.src != "string" ? st.src : [st.src],
                    ut._volume = st.volume !== void 0 ? st.volume : 1,
                    ut._xhr = {
                        method: st.xhr && st.xhr.method ? st.xhr.method : "GET",
                        headers: st.xhr && st.xhr.headers ? st.xhr.headers : null,
                        withCredentials: st.xhr && st.xhr.withCredentials ? st.xhr.withCredentials : !1
                    },
                    ut._duration = 0,
                    ut._state = "unloaded",
                    ut._sounds = [],
                    ut._endTimers = {},
                    ut._queue = [],
                    ut._playLock = !1,
                    ut._onend = st.onend ? [{
                        fn: st.onend
                    }] : [],
                    ut._onfade = st.onfade ? [{
                        fn: st.onfade
                    }] : [],
                    ut._onload = st.onload ? [{
                        fn: st.onload
                    }] : [],
                    ut._onloaderror = st.onloaderror ? [{
                        fn: st.onloaderror
                    }] : [],
                    ut._onplayerror = st.onplayerror ? [{
                        fn: st.onplayerror
                    }] : [],
                    ut._onpause = st.onpause ? [{
                        fn: st.onpause
                    }] : [],
                    ut._onplay = st.onplay ? [{
                        fn: st.onplay
                    }] : [],
                    ut._onstop = st.onstop ? [{
                        fn: st.onstop
                    }] : [],
                    ut._onmute = st.onmute ? [{
                        fn: st.onmute
                    }] : [],
                    ut._onvolume = st.onvolume ? [{
                        fn: st.onvolume
                    }] : [],
                    ut._onrate = st.onrate ? [{
                        fn: st.onrate
                    }] : [],
                    ut._onseek = st.onseek ? [{
                        fn: st.onseek
                    }] : [],
                    ut._onunlock = st.onunlock ? [{
                        fn: st.onunlock
                    }] : [],
                    ut._onresume = [],
                    ut._webAudio = J.usingWebAudio && !ut._html5,
                    typeof J.ctx < "u" && J.ctx && J.autoUnlock && J._unlockAudio(),
                    J._howls.push(ut),
                    ut._autoplay && ut._queue.push({
                        event: "play",
                        action: function() {
                            ut.play()
                        }
                    }),
                    ut._preload && ut._preload !== "none" && ut.load(),
                    ut
                },
                load: function() {
                    var st = this
                      , ut = null;
                    if (J.noAudio) {
                        st._emit("loaderror", null, "No audio support.");
                        return
                    }
                    typeof st._src == "string" && (st._src = [st._src]);
                    for (var ct = 0; ct < st._src.length; ct++) {
                        var pt, ft;
                        if (st._format && st._format[ct])
                            pt = st._format[ct];
                        else {
                            if (ft = st._src[ct],
                            typeof ft != "string") {
                                st._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                continue
                            }
                            pt = /^data:audio\/([^;,]+);/i.exec(ft),
                            pt || (pt = /\.([^.]+)$/.exec(ft.split("?", 1)[0])),
                            pt && (pt = pt[1].toLowerCase())
                        }
                        if (pt && J.codecs(pt)) {
                            ut = st._src[ct];
                            break
                        }
                    }
                    if (!ut) {
                        st._emit("loaderror", null, "No codec support for selected audio sources.");
                        return
                    }
                    return st._src = ut,
                    st._state = "loading",
                    window.location.protocol === "https:" && ut.slice(0, 5) === "http:" && (st._html5 = !0,
                    st._webAudio = !1),
                    new tt(st),
                    st._webAudio && nt(st),
                    st
                },
                play: function(st, ut) {
                    var ct = this
                      , pt = null;
                    if (typeof st == "number")
                        pt = st,
                        st = null;
                    else {
                        if (typeof st == "string" && ct._state === "loaded" && !ct._sprite[st])
                            return null;
                        if (typeof st > "u" && (st = "__default",
                        !ct._playLock)) {
                            for (var ft = 0, yt = 0; yt < ct._sounds.length; yt++)
                                ct._sounds[yt]._paused && !ct._sounds[yt]._ended && (ft++,
                                pt = ct._sounds[yt]._id);
                            ft === 1 ? st = null : pt = null
                        }
                    }
                    var ht = pt ? ct._soundById(pt) : ct._inactiveSound();
                    if (!ht)
                        return null;
                    if (pt && !st && (st = ht._sprite || "__default"),
                    ct._state !== "loaded") {
                        ht._sprite = st,
                        ht._ended = !1;
                        var gt = ht._id;
                        return ct._queue.push({
                            event: "play",
                            action: function() {
                                ct.play(gt)
                            }
                        }),
                        gt
                    }
                    if (pt && !ht._paused)
                        return ut || ct._loadQueue("play"),
                        ht._id;
                    ct._webAudio && J._autoResume();
                    var mt = Math.max(0, ht._seek > 0 ? ht._seek : ct._sprite[st][0] / 1e3)
                      , vt = Math.max(0, (ct._sprite[st][0] + ct._sprite[st][1]) / 1e3 - mt)
                      , bt = vt * 1e3 / Math.abs(ht._rate)
                      , Et = ct._sprite[st][0] / 1e3
                      , xt = (ct._sprite[st][0] + ct._sprite[st][1]) / 1e3;
                    ht._sprite = st,
                    ht._ended = !1;
                    var wt = function() {
                        ht._paused = !1,
                        ht._seek = mt,
                        ht._start = Et,
                        ht._stop = xt,
                        ht._loop = !!(ht._loop || ct._sprite[st][2])
                    };
                    if (mt >= xt) {
                        ct._ended(ht);
                        return
                    }
                    var St = ht._node;
                    if (ct._webAudio) {
                        var Pt = function() {
                            ct._playLock = !1,
                            wt(),
                            ct._refreshBuffer(ht);
                            var Ot = ht._muted || ct._muted ? 0 : ht._volume;
                            St.gain.setValueAtTime(Ot, J.ctx.currentTime),
                            ht._playStart = J.ctx.currentTime,
                            typeof St.bufferSource.start > "u" ? ht._loop ? St.bufferSource.noteGrainOn(0, mt, 86400) : St.bufferSource.noteGrainOn(0, mt, vt) : ht._loop ? St.bufferSource.start(0, mt, 86400) : St.bufferSource.start(0, mt, vt),
                            bt !== 1 / 0 && (ct._endTimers[ht._id] = setTimeout(ct._ended.bind(ct, ht), bt)),
                            ut || setTimeout(function() {
                                ct._emit("play", ht._id),
                                ct._loadQueue()
                            }, 0)
                        };
                        J.state === "running" && J.ctx.state !== "interrupted" ? Pt() : (ct._playLock = !0,
                        ct.once("resume", Pt),
                        ct._clearTimer(ht._id))
                    } else {
                        var Rt = function() {
                            St.currentTime = mt,
                            St.muted = ht._muted || ct._muted || J._muted || St.muted,
                            St.volume = ht._volume * J.volume(),
                            St.playbackRate = ht._rate;
                            try {
                                var Ot = St.play();
                                if (Ot && typeof Promise < "u" && (Ot instanceof Promise || typeof Ot.then == "function") ? (ct._playLock = !0,
                                wt(),
                                Ot.then(function() {
                                    ct._playLock = !1,
                                    St._unlocked = !0,
                                    ut ? ct._loadQueue() : ct._emit("play", ht._id)
                                }).catch(function() {
                                    ct._playLock = !1,
                                    ct._emit("playerror", ht._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                                    ht._ended = !0,
                                    ht._paused = !0
                                })) : ut || (ct._playLock = !1,
                                wt(),
                                ct._emit("play", ht._id)),
                                St.playbackRate = ht._rate,
                                St.paused) {
                                    ct._emit("playerror", ht._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                    return
                                }
                                st !== "__default" || ht._loop ? ct._endTimers[ht._id] = setTimeout(ct._ended.bind(ct, ht), bt) : (ct._endTimers[ht._id] = function() {
                                    ct._ended(ht),
                                    St.removeEventListener("ended", ct._endTimers[ht._id], !1)
                                }
                                ,
                                St.addEventListener("ended", ct._endTimers[ht._id], !1))
                            } catch (It) {
                                ct._emit("playerror", ht._id, It)
                            }
                        };
                        St.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (St.src = ct._src,
                        St.load());
                        var At = window && window.ejecta || !St.readyState && J._navigator.isCocoonJS;
                        if (St.readyState >= 3 || At)
                            Rt();
                        else {
                            ct._playLock = !0,
                            ct._state = "loading";
                            var Nt = function() {
                                ct._state = "loaded",
                                Rt(),
                                St.removeEventListener(J._canPlayEvent, Nt, !1)
                            };
                            St.addEventListener(J._canPlayEvent, Nt, !1),
                            ct._clearTimer(ht._id)
                        }
                    }
                    return ht._id
                },
                pause: function(st) {
                    var ut = this;
                    if (ut._state !== "loaded" || ut._playLock)
                        return ut._queue.push({
                            event: "pause",
                            action: function() {
                                ut.pause(st)
                            }
                        }),
                        ut;
                    for (var ct = ut._getSoundIds(st), pt = 0; pt < ct.length; pt++) {
                        ut._clearTimer(ct[pt]);
                        var ft = ut._soundById(ct[pt]);
                        if (ft && !ft._paused && (ft._seek = ut.seek(ct[pt]),
                        ft._rateSeek = 0,
                        ft._paused = !0,
                        ut._stopFade(ct[pt]),
                        ft._node))
                            if (ut._webAudio) {
                                if (!ft._node.bufferSource)
                                    continue;
                                typeof ft._node.bufferSource.stop > "u" ? ft._node.bufferSource.noteOff(0) : ft._node.bufferSource.stop(0),
                                ut._cleanBuffer(ft._node)
                            } else
                                (!isNaN(ft._node.duration) || ft._node.duration === 1 / 0) && ft._node.pause();
                        arguments[1] || ut._emit("pause", ft ? ft._id : null)
                    }
                    return ut
                },
                stop: function(st, ut) {
                    var ct = this;
                    if (ct._state !== "loaded" || ct._playLock)
                        return ct._queue.push({
                            event: "stop",
                            action: function() {
                                ct.stop(st)
                            }
                        }),
                        ct;
                    for (var pt = ct._getSoundIds(st), ft = 0; ft < pt.length; ft++) {
                        ct._clearTimer(pt[ft]);
                        var yt = ct._soundById(pt[ft]);
                        yt && (yt._seek = yt._start || 0,
                        yt._rateSeek = 0,
                        yt._paused = !0,
                        yt._ended = !0,
                        ct._stopFade(pt[ft]),
                        yt._node && (ct._webAudio ? yt._node.bufferSource && (typeof yt._node.bufferSource.stop > "u" ? yt._node.bufferSource.noteOff(0) : yt._node.bufferSource.stop(0),
                        ct._cleanBuffer(yt._node)) : (!isNaN(yt._node.duration) || yt._node.duration === 1 / 0) && (yt._node.currentTime = yt._start || 0,
                        yt._node.pause(),
                        yt._node.duration === 1 / 0 && ct._clearSound(yt._node))),
                        ut || ct._emit("stop", yt._id))
                    }
                    return ct
                },
                mute: function(st, ut) {
                    var ct = this;
                    if (ct._state !== "loaded" || ct._playLock)
                        return ct._queue.push({
                            event: "mute",
                            action: function() {
                                ct.mute(st, ut)
                            }
                        }),
                        ct;
                    if (typeof ut > "u")
                        if (typeof st == "boolean")
                            ct._muted = st;
                        else
                            return ct._muted;
                    for (var pt = ct._getSoundIds(ut), ft = 0; ft < pt.length; ft++) {
                        var yt = ct._soundById(pt[ft]);
                        yt && (yt._muted = st,
                        yt._interval && ct._stopFade(yt._id),
                        ct._webAudio && yt._node ? yt._node.gain.setValueAtTime(st ? 0 : yt._volume, J.ctx.currentTime) : yt._node && (yt._node.muted = J._muted ? !0 : st),
                        ct._emit("mute", yt._id))
                    }
                    return ct
                },
                volume: function() {
                    var st = this, ut = arguments, ct, pt;
                    if (ut.length === 0)
                        return st._volume;
                    if (ut.length === 1 || ut.length === 2 && typeof ut[1] > "u") {
                        var ft = st._getSoundIds()
                          , yt = ft.indexOf(ut[0]);
                        yt >= 0 ? pt = parseInt(ut[0], 10) : ct = parseFloat(ut[0])
                    } else
                        ut.length >= 2 && (ct = parseFloat(ut[0]),
                        pt = parseInt(ut[1], 10));
                    var ht;
                    if (typeof ct < "u" && ct >= 0 && ct <= 1) {
                        if (st._state !== "loaded" || st._playLock)
                            return st._queue.push({
                                event: "volume",
                                action: function() {
                                    st.volume.apply(st, ut)
                                }
                            }),
                            st;
                        typeof pt > "u" && (st._volume = ct),
                        pt = st._getSoundIds(pt);
                        for (var gt = 0; gt < pt.length; gt++)
                            ht = st._soundById(pt[gt]),
                            ht && (ht._volume = ct,
                            ut[2] || st._stopFade(pt[gt]),
                            st._webAudio && ht._node && !ht._muted ? ht._node.gain.setValueAtTime(ct, J.ctx.currentTime) : ht._node && !ht._muted && (ht._node.volume = ct * J.volume()),
                            st._emit("volume", ht._id))
                    } else
                        return ht = pt ? st._soundById(pt) : st._sounds[0],
                        ht ? ht._volume : 0;
                    return st
                },
                fade: function(st, ut, ct, pt) {
                    var ft = this;
                    if (ft._state !== "loaded" || ft._playLock)
                        return ft._queue.push({
                            event: "fade",
                            action: function() {
                                ft.fade(st, ut, ct, pt)
                            }
                        }),
                        ft;
                    st = Math.min(Math.max(0, parseFloat(st)), 1),
                    ut = Math.min(Math.max(0, parseFloat(ut)), 1),
                    ct = parseFloat(ct),
                    ft.volume(st, pt);
                    for (var yt = ft._getSoundIds(pt), ht = 0; ht < yt.length; ht++) {
                        var gt = ft._soundById(yt[ht]);
                        if (gt) {
                            if (pt || ft._stopFade(yt[ht]),
                            ft._webAudio && !gt._muted) {
                                var mt = J.ctx.currentTime
                                  , vt = mt + ct / 1e3;
                                gt._volume = st,
                                gt._node.gain.setValueAtTime(st, mt),
                                gt._node.gain.linearRampToValueAtTime(ut, vt)
                            }
                            ft._startFadeInterval(gt, st, ut, ct, yt[ht], typeof pt > "u")
                        }
                    }
                    return ft
                },
                _startFadeInterval: function(st, ut, ct, pt, ft, yt) {
                    var ht = this
                      , gt = ut
                      , mt = ct - ut
                      , vt = Math.abs(mt / .01)
                      , bt = Math.max(4, vt > 0 ? pt / vt : pt)
                      , Et = Date.now();
                    st._fadeTo = ct,
                    st._interval = setInterval(function() {
                        var xt = (Date.now() - Et) / pt;
                        Et = Date.now(),
                        gt += mt * xt,
                        gt = Math.round(gt * 100) / 100,
                        mt < 0 ? gt = Math.max(ct, gt) : gt = Math.min(ct, gt),
                        ht._webAudio ? st._volume = gt : ht.volume(gt, st._id, !0),
                        yt && (ht._volume = gt),
                        (ct < ut && gt <= ct || ct > ut && gt >= ct) && (clearInterval(st._interval),
                        st._interval = null,
                        st._fadeTo = null,
                        ht.volume(ct, st._id),
                        ht._emit("fade", st._id))
                    }, bt)
                },
                _stopFade: function(st) {
                    var ut = this
                      , ct = ut._soundById(st);
                    return ct && ct._interval && (ut._webAudio && ct._node.gain.cancelScheduledValues(J.ctx.currentTime),
                    clearInterval(ct._interval),
                    ct._interval = null,
                    ut.volume(ct._fadeTo, st),
                    ct._fadeTo = null,
                    ut._emit("fade", st)),
                    ut
                },
                loop: function() {
                    var st = this, ut = arguments, ct, pt, ft;
                    if (ut.length === 0)
                        return st._loop;
                    if (ut.length === 1)
                        if (typeof ut[0] == "boolean")
                            ct = ut[0],
                            st._loop = ct;
                        else
                            return ft = st._soundById(parseInt(ut[0], 10)),
                            ft ? ft._loop : !1;
                    else
                        ut.length === 2 && (ct = ut[0],
                        pt = parseInt(ut[1], 10));
                    for (var yt = st._getSoundIds(pt), ht = 0; ht < yt.length; ht++)
                        ft = st._soundById(yt[ht]),
                        ft && (ft._loop = ct,
                        st._webAudio && ft._node && ft._node.bufferSource && (ft._node.bufferSource.loop = ct,
                        ct && (ft._node.bufferSource.loopStart = ft._start || 0,
                        ft._node.bufferSource.loopEnd = ft._stop,
                        st.playing(yt[ht]) && (st.pause(yt[ht], !0),
                        st.play(yt[ht], !0)))));
                    return st
                },
                rate: function() {
                    var st = this, ut = arguments, ct, pt;
                    if (ut.length === 0)
                        pt = st._sounds[0]._id;
                    else if (ut.length === 1) {
                        var ft = st._getSoundIds()
                          , yt = ft.indexOf(ut[0]);
                        yt >= 0 ? pt = parseInt(ut[0], 10) : ct = parseFloat(ut[0])
                    } else
                        ut.length === 2 && (ct = parseFloat(ut[0]),
                        pt = parseInt(ut[1], 10));
                    var ht;
                    if (typeof ct == "number") {
                        if (st._state !== "loaded" || st._playLock)
                            return st._queue.push({
                                event: "rate",
                                action: function() {
                                    st.rate.apply(st, ut)
                                }
                            }),
                            st;
                        typeof pt > "u" && (st._rate = ct),
                        pt = st._getSoundIds(pt);
                        for (var gt = 0; gt < pt.length; gt++)
                            if (ht = st._soundById(pt[gt]),
                            ht) {
                                st.playing(pt[gt]) && (ht._rateSeek = st.seek(pt[gt]),
                                ht._playStart = st._webAudio ? J.ctx.currentTime : ht._playStart),
                                ht._rate = ct,
                                st._webAudio && ht._node && ht._node.bufferSource ? ht._node.bufferSource.playbackRate.setValueAtTime(ct, J.ctx.currentTime) : ht._node && (ht._node.playbackRate = ct);
                                var mt = st.seek(pt[gt])
                                  , vt = (st._sprite[ht._sprite][0] + st._sprite[ht._sprite][1]) / 1e3 - mt
                                  , bt = vt * 1e3 / Math.abs(ht._rate);
                                (st._endTimers[pt[gt]] || !ht._paused) && (st._clearTimer(pt[gt]),
                                st._endTimers[pt[gt]] = setTimeout(st._ended.bind(st, ht), bt)),
                                st._emit("rate", ht._id)
                            }
                    } else
                        return ht = st._soundById(pt),
                        ht ? ht._rate : st._rate;
                    return st
                },
                seek: function() {
                    var st = this, ut = arguments, ct, pt;
                    if (ut.length === 0)
                        st._sounds.length && (pt = st._sounds[0]._id);
                    else if (ut.length === 1) {
                        var ft = st._getSoundIds()
                          , yt = ft.indexOf(ut[0]);
                        yt >= 0 ? pt = parseInt(ut[0], 10) : st._sounds.length && (pt = st._sounds[0]._id,
                        ct = parseFloat(ut[0]))
                    } else
                        ut.length === 2 && (ct = parseFloat(ut[0]),
                        pt = parseInt(ut[1], 10));
                    if (typeof pt > "u")
                        return 0;
                    if (typeof ct == "number" && (st._state !== "loaded" || st._playLock))
                        return st._queue.push({
                            event: "seek",
                            action: function() {
                                st.seek.apply(st, ut)
                            }
                        }),
                        st;
                    var ht = st._soundById(pt);
                    if (ht)
                        if (typeof ct == "number" && ct >= 0) {
                            var gt = st.playing(pt);
                            gt && st.pause(pt, !0),
                            ht._seek = ct,
                            ht._ended = !1,
                            st._clearTimer(pt),
                            !st._webAudio && ht._node && !isNaN(ht._node.duration) && (ht._node.currentTime = ct);
                            var mt = function() {
                                gt && st.play(pt, !0),
                                st._emit("seek", pt)
                            };
                            if (gt && !st._webAudio) {
                                var vt = function() {
                                    st._playLock ? setTimeout(vt, 0) : mt()
                                };
                                setTimeout(vt, 0)
                            } else
                                mt()
                        } else if (st._webAudio) {
                            var bt = st.playing(pt) ? J.ctx.currentTime - ht._playStart : 0
                              , Et = ht._rateSeek ? ht._rateSeek - ht._seek : 0;
                            return ht._seek + (Et + bt * Math.abs(ht._rate))
                        } else
                            return ht._node.currentTime;
                    return st
                },
                playing: function(st) {
                    var ut = this;
                    if (typeof st == "number") {
                        var ct = ut._soundById(st);
                        return ct ? !ct._paused : !1
                    }
                    for (var pt = 0; pt < ut._sounds.length; pt++)
                        if (!ut._sounds[pt]._paused)
                            return !0;
                    return !1
                },
                duration: function(st) {
                    var ut = this
                      , ct = ut._duration
                      , pt = ut._soundById(st);
                    return pt && (ct = ut._sprite[pt._sprite][1] / 1e3),
                    ct
                },
                state: function() {
                    return this._state
                },
                unload: function() {
                    for (var st = this, ut = st._sounds, ct = 0; ct < ut.length; ct++)
                        ut[ct]._paused || st.stop(ut[ct]._id),
                        st._webAudio || (st._clearSound(ut[ct]._node),
                        ut[ct]._node.removeEventListener("error", ut[ct]._errorFn, !1),
                        ut[ct]._node.removeEventListener(J._canPlayEvent, ut[ct]._loadFn, !1),
                        ut[ct]._node.removeEventListener("ended", ut[ct]._endFn, !1),
                        J._releaseHtml5Audio(ut[ct]._node)),
                        delete ut[ct]._node,
                        st._clearTimer(ut[ct]._id);
                    var pt = J._howls.indexOf(st);
                    pt >= 0 && J._howls.splice(pt, 1);
                    var ft = !0;
                    for (ct = 0; ct < J._howls.length; ct++)
                        if (J._howls[ct]._src === st._src || st._src.indexOf(J._howls[ct]._src) >= 0) {
                            ft = !1;
                            break
                        }
                    return rt && ft && delete rt[st._src],
                    J.noAudio = !1,
                    st._state = "unloaded",
                    st._sounds = [],
                    st = null,
                    null
                },
                on: function(st, ut, ct, pt) {
                    var ft = this
                      , yt = ft["_on" + st];
                    return typeof ut == "function" && yt.push(pt ? {
                        id: ct,
                        fn: ut,
                        once: pt
                    } : {
                        id: ct,
                        fn: ut
                    }),
                    ft
                },
                off: function(st, ut, ct) {
                    var pt = this
                      , ft = pt["_on" + st]
                      , yt = 0;
                    if (typeof ut == "number" && (ct = ut,
                    ut = null),
                    ut || ct)
                        for (yt = 0; yt < ft.length; yt++) {
                            var ht = ct === ft[yt].id;
                            if (ut === ft[yt].fn && ht || !ut && ht) {
                                ft.splice(yt, 1);
                                break
                            }
                        }
                    else if (st)
                        pt["_on" + st] = [];
                    else {
                        var gt = Object.keys(pt);
                        for (yt = 0; yt < gt.length; yt++)
                            gt[yt].indexOf("_on") === 0 && Array.isArray(pt[gt[yt]]) && (pt[gt[yt]] = [])
                    }
                    return pt
                },
                once: function(st, ut, ct) {
                    var pt = this;
                    return pt.on(st, ut, ct, 1),
                    pt
                },
                _emit: function(st, ut, ct) {
                    for (var pt = this, ft = pt["_on" + st], yt = ft.length - 1; yt >= 0; yt--)
                        (!ft[yt].id || ft[yt].id === ut || st === "load") && (setTimeout(function(ht) {
                            ht.call(this, ut, ct)
                        }
                        .bind(pt, ft[yt].fn), 0),
                        ft[yt].once && pt.off(st, ft[yt].fn, ft[yt].id));
                    return pt._loadQueue(st),
                    pt
                },
                _loadQueue: function(st) {
                    var ut = this;
                    if (ut._queue.length > 0) {
                        var ct = ut._queue[0];
                        ct.event === st && (ut._queue.shift(),
                        ut._loadQueue()),
                        st || ct.action()
                    }
                    return ut
                },
                _ended: function(st) {
                    var ut = this
                      , ct = st._sprite;
                    if (!ut._webAudio && st._node && !st._node.paused && !st._node.ended && st._node.currentTime < st._stop)
                        return setTimeout(ut._ended.bind(ut, st), 100),
                        ut;
                    var pt = !!(st._loop || ut._sprite[ct][2]);
                    if (ut._emit("end", st._id),
                    !ut._webAudio && pt && ut.stop(st._id, !0).play(st._id),
                    ut._webAudio && pt) {
                        ut._emit("play", st._id),
                        st._seek = st._start || 0,
                        st._rateSeek = 0,
                        st._playStart = J.ctx.currentTime;
                        var ft = (st._stop - st._start) * 1e3 / Math.abs(st._rate);
                        ut._endTimers[st._id] = setTimeout(ut._ended.bind(ut, st), ft)
                    }
                    return ut._webAudio && !pt && (st._paused = !0,
                    st._ended = !0,
                    st._seek = st._start || 0,
                    st._rateSeek = 0,
                    ut._clearTimer(st._id),
                    ut._cleanBuffer(st._node),
                    J._autoSuspend()),
                    !ut._webAudio && !pt && ut.stop(st._id, !0),
                    ut
                },
                _clearTimer: function(st) {
                    var ut = this;
                    if (ut._endTimers[st]) {
                        if (typeof ut._endTimers[st] != "function")
                            clearTimeout(ut._endTimers[st]);
                        else {
                            var ct = ut._soundById(st);
                            ct && ct._node && ct._node.removeEventListener("ended", ut._endTimers[st], !1)
                        }
                        delete ut._endTimers[st]
                    }
                    return ut
                },
                _soundById: function(st) {
                    for (var ut = this, ct = 0; ct < ut._sounds.length; ct++)
                        if (st === ut._sounds[ct]._id)
                            return ut._sounds[ct];
                    return null
                },
                _inactiveSound: function() {
                    var st = this;
                    st._drain();
                    for (var ut = 0; ut < st._sounds.length; ut++)
                        if (st._sounds[ut]._ended)
                            return st._sounds[ut].reset();
                    return new tt(st)
                },
                _drain: function() {
                    var st = this
                      , ut = st._pool
                      , ct = 0
                      , pt = 0;
                    if (!(st._sounds.length < ut)) {
                        for (pt = 0; pt < st._sounds.length; pt++)
                            st._sounds[pt]._ended && ct++;
                        for (pt = st._sounds.length - 1; pt >= 0; pt--) {
                            if (ct <= ut)
                                return;
                            st._sounds[pt]._ended && (st._webAudio && st._sounds[pt]._node && st._sounds[pt]._node.disconnect(0),
                            st._sounds.splice(pt, 1),
                            ct--)
                        }
                    }
                },
                _getSoundIds: function(st) {
                    var ut = this;
                    if (typeof st > "u") {
                        for (var ct = [], pt = 0; pt < ut._sounds.length; pt++)
                            ct.push(ut._sounds[pt]._id);
                        return ct
                    } else
                        return [st]
                },
                _refreshBuffer: function(st) {
                    var ut = this;
                    return st._node.bufferSource = J.ctx.createBufferSource(),
                    st._node.bufferSource.buffer = rt[ut._src],
                    st._panner ? st._node.bufferSource.connect(st._panner) : st._node.bufferSource.connect(st._node),
                    st._node.bufferSource.loop = st._loop,
                    st._loop && (st._node.bufferSource.loopStart = st._start || 0,
                    st._node.bufferSource.loopEnd = st._stop || 0),
                    st._node.bufferSource.playbackRate.setValueAtTime(st._rate, J.ctx.currentTime),
                    ut
                },
                _cleanBuffer: function(st) {
                    var ut = this
                      , ct = J._navigator && J._navigator.vendor.indexOf("Apple") >= 0;
                    if (!st.bufferSource)
                        return ut;
                    if (J._scratchBuffer && st.bufferSource && (st.bufferSource.onended = null,
                    st.bufferSource.disconnect(0),
                    ct))
                        try {
                            st.bufferSource.buffer = J._scratchBuffer
                        } catch (pt) {}
                    return st.bufferSource = null,
                    ut
                },
                _clearSound: function(st) {
                    var ut = /MSIE |Trident\//.test(J._navigator && J._navigator.userAgent);
                    ut || (st.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                }
            };
            var tt = function(st) {
                this._parent = st,
                this.init()
            };
            tt.prototype = {
                init: function() {
                    var st = this
                      , ut = st._parent;
                    return st._muted = ut._muted,
                    st._loop = ut._loop,
                    st._volume = ut._volume,
                    st._rate = ut._rate,
                    st._seek = 0,
                    st._paused = !0,
                    st._ended = !0,
                    st._sprite = "__default",
                    st._id = ++J._counter,
                    ut._sounds.push(st),
                    st.create(),
                    st
                },
                create: function() {
                    var st = this
                      , ut = st._parent
                      , ct = J._muted || st._muted || st._parent._muted ? 0 : st._volume;
                    return ut._webAudio ? (st._node = typeof J.ctx.createGain > "u" ? J.ctx.createGainNode() : J.ctx.createGain(),
                    st._node.gain.setValueAtTime(ct, J.ctx.currentTime),
                    st._node.paused = !0,
                    st._node.connect(J.masterGain)) : J.noAudio || (st._node = J._obtainHtml5Audio(),
                    st._errorFn = st._errorListener.bind(st),
                    st._node.addEventListener("error", st._errorFn, !1),
                    st._loadFn = st._loadListener.bind(st),
                    st._node.addEventListener(J._canPlayEvent, st._loadFn, !1),
                    st._endFn = st._endListener.bind(st),
                    st._node.addEventListener("ended", st._endFn, !1),
                    st._node.src = ut._src,
                    st._node.preload = ut._preload === !0 ? "auto" : ut._preload,
                    st._node.volume = ct * J.volume(),
                    st._node.load()),
                    st
                },
                reset: function() {
                    var st = this
                      , ut = st._parent;
                    return st._muted = ut._muted,
                    st._loop = ut._loop,
                    st._volume = ut._volume,
                    st._rate = ut._rate,
                    st._seek = 0,
                    st._rateSeek = 0,
                    st._paused = !0,
                    st._ended = !0,
                    st._sprite = "__default",
                    st._id = ++J._counter,
                    st
                },
                _errorListener: function() {
                    var st = this;
                    st._parent._emit("loaderror", st._id, st._node.error ? st._node.error.code : 0),
                    st._node.removeEventListener("error", st._errorFn, !1)
                },
                _loadListener: function() {
                    var st = this
                      , ut = st._parent;
                    ut._duration = Math.ceil(st._node.duration * 10) / 10,
                    Object.keys(ut._sprite).length === 0 && (ut._sprite = {
                        __default: [0, ut._duration * 1e3]
                    }),
                    ut._state !== "loaded" && (ut._state = "loaded",
                    ut._emit("load"),
                    ut._loadQueue()),
                    st._node.removeEventListener(J._canPlayEvent, st._loadFn, !1)
                },
                _endListener: function() {
                    var st = this
                      , ut = st._parent;
                    ut._duration === 1 / 0 && (ut._duration = Math.ceil(st._node.duration * 10) / 10,
                    ut._sprite.__default[1] === 1 / 0 && (ut._sprite.__default[1] = ut._duration * 1e3),
                    ut._ended(st)),
                    st._node.removeEventListener("ended", st._endFn, !1)
                }
            };
            var rt = {}
              , nt = function(st) {
                var ut = st._src;
                if (rt[ut]) {
                    st._duration = rt[ut].duration,
                    at(st);
                    return
                }
                if (/^data:[^;]+;base64,/.test(ut)) {
                    for (var ct = atob(ut.split(",")[1]), pt = new Uint8Array(ct.length), ft = 0; ft < ct.length; ++ft)
                        pt[ft] = ct.charCodeAt(ft);
                    it(pt.buffer, st)
                } else {
                    var yt = new XMLHttpRequest;
                    yt.open(st._xhr.method, ut, !0),
                    yt.withCredentials = st._xhr.withCredentials,
                    yt.responseType = "arraybuffer",
                    st._xhr.headers && Object.keys(st._xhr.headers).forEach(function(ht) {
                        yt.setRequestHeader(ht, st._xhr.headers[ht])
                    }),
                    yt.onload = function() {
                        var ht = (yt.status + "")[0];
                        if (ht !== "0" && ht !== "2" && ht !== "3") {
                            st._emit("loaderror", null, "Failed loading audio file with status: " + yt.status + ".");
                            return
                        }
                        it(yt.response, st)
                    }
                    ,
                    yt.onerror = function() {
                        st._webAudio && (st._html5 = !0,
                        st._webAudio = !1,
                        st._sounds = [],
                        delete rt[ut],
                        st.load())
                    }
                    ,
                    ot(yt)
                }
            }
              , ot = function(st) {
                try {
                    st.send()
                } catch (ut) {
                    st.onerror()
                }
            }
              , it = function(st, ut) {
                var ct = function() {
                    ut._emit("loaderror", null, "Decoding audio data failed.")
                }
                  , pt = function(ft) {
                    ft && ut._sounds.length > 0 ? (rt[ut._src] = ft,
                    at(ut, ft)) : ct()
                };
                typeof Promise < "u" && J.ctx.decodeAudioData.length === 1 ? J.ctx.decodeAudioData(st).then(pt).catch(ct) : J.ctx.decodeAudioData(st, pt, ct)
            }
              , at = function(st, ut) {
                ut && !st._duration && (st._duration = ut.duration),
                Object.keys(st._sprite).length === 0 && (st._sprite = {
                    __default: [0, st._duration * 1e3]
                }),
                st._state !== "loaded" && (st._state = "loaded",
                st._emit("load"),
                st._loadQueue())
            }
              , lt = function() {
                if (J.usingWebAudio) {
                    try {
                        typeof AudioContext < "u" ? J.ctx = new AudioContext : typeof webkitAudioContext < "u" ? J.ctx = new webkitAudioContext : J.usingWebAudio = !1
                    } catch (ft) {
                        J.usingWebAudio = !1
                    }
                    J.ctx || (J.usingWebAudio = !1);
                    var st = /iP(hone|od|ad)/.test(J._navigator && J._navigator.platform)
                      , ut = J._navigator && J._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                      , ct = ut ? parseInt(ut[1], 10) : null;
                    if (st && ct && ct < 9) {
                        var pt = /safari/.test(J._navigator && J._navigator.userAgent.toLowerCase());
                        J._navigator && !pt && (J.usingWebAudio = !1)
                    }
                    J.usingWebAudio && (J.masterGain = typeof J.ctx.createGain > "u" ? J.ctx.createGainNode() : J.ctx.createGain(),
                    J.masterGain.gain.setValueAtTime(J._muted ? 0 : J._volume, J.ctx.currentTime),
                    J.masterGain.connect(J.ctx.destination)),
                    J._setup()
                }
            };
            _.Howler = J,
            _.Howl = et,
            typeof commonjsGlobal < "u" ? (commonjsGlobal.HowlerGlobal = k,
            commonjsGlobal.Howler = J,
            commonjsGlobal.Howl = et,
            commonjsGlobal.Sound = tt) : typeof window < "u" && (window.HowlerGlobal = k,
            window.Howler = J,
            window.Howl = et,
            window.Sound = tt)
        }
        )(),
        function() {
            HowlerGlobal.prototype._pos = [0, 0, 0],
            HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
            HowlerGlobal.prototype.stereo = function(J) {
                var et = this;
                if (!et.ctx || !et.ctx.listener)
                    return et;
                for (var tt = et._howls.length - 1; tt >= 0; tt--)
                    et._howls[tt].stereo(J);
                return et
            }
            ,
            HowlerGlobal.prototype.pos = function(J, et, tt) {
                var rt = this;
                if (!rt.ctx || !rt.ctx.listener)
                    return rt;
                if (et = typeof et != "number" ? rt._pos[1] : et,
                tt = typeof tt != "number" ? rt._pos[2] : tt,
                typeof J == "number")
                    rt._pos = [J, et, tt],
                    typeof rt.ctx.listener.positionX < "u" ? (rt.ctx.listener.positionX.setTargetAtTime(rt._pos[0], Howler.ctx.currentTime, .1),
                    rt.ctx.listener.positionY.setTargetAtTime(rt._pos[1], Howler.ctx.currentTime, .1),
                    rt.ctx.listener.positionZ.setTargetAtTime(rt._pos[2], Howler.ctx.currentTime, .1)) : rt.ctx.listener.setPosition(rt._pos[0], rt._pos[1], rt._pos[2]);
                else
                    return rt._pos;
                return rt
            }
            ,
            HowlerGlobal.prototype.orientation = function(J, et, tt, rt, nt, ot) {
                var it = this;
                if (!it.ctx || !it.ctx.listener)
                    return it;
                var at = it._orientation;
                if (et = typeof et != "number" ? at[1] : et,
                tt = typeof tt != "number" ? at[2] : tt,
                rt = typeof rt != "number" ? at[3] : rt,
                nt = typeof nt != "number" ? at[4] : nt,
                ot = typeof ot != "number" ? at[5] : ot,
                typeof J == "number")
                    it._orientation = [J, et, tt, rt, nt, ot],
                    typeof it.ctx.listener.forwardX < "u" ? (it.ctx.listener.forwardX.setTargetAtTime(J, Howler.ctx.currentTime, .1),
                    it.ctx.listener.forwardY.setTargetAtTime(et, Howler.ctx.currentTime, .1),
                    it.ctx.listener.forwardZ.setTargetAtTime(tt, Howler.ctx.currentTime, .1),
                    it.ctx.listener.upX.setTargetAtTime(rt, Howler.ctx.currentTime, .1),
                    it.ctx.listener.upY.setTargetAtTime(nt, Howler.ctx.currentTime, .1),
                    it.ctx.listener.upZ.setTargetAtTime(ot, Howler.ctx.currentTime, .1)) : it.ctx.listener.setOrientation(J, et, tt, rt, nt, ot);
                else
                    return at;
                return it
            }
            ,
            Howl.prototype.init = function(J) {
                return function(et) {
                    var tt = this;
                    return tt._orientation = et.orientation || [1, 0, 0],
                    tt._stereo = et.stereo || null,
                    tt._pos = et.pos || null,
                    tt._pannerAttr = {
                        coneInnerAngle: typeof et.coneInnerAngle < "u" ? et.coneInnerAngle : 360,
                        coneOuterAngle: typeof et.coneOuterAngle < "u" ? et.coneOuterAngle : 360,
                        coneOuterGain: typeof et.coneOuterGain < "u" ? et.coneOuterGain : 0,
                        distanceModel: typeof et.distanceModel < "u" ? et.distanceModel : "inverse",
                        maxDistance: typeof et.maxDistance < "u" ? et.maxDistance : 1e4,
                        panningModel: typeof et.panningModel < "u" ? et.panningModel : "HRTF",
                        refDistance: typeof et.refDistance < "u" ? et.refDistance : 1,
                        rolloffFactor: typeof et.rolloffFactor < "u" ? et.rolloffFactor : 1
                    },
                    tt._onstereo = et.onstereo ? [{
                        fn: et.onstereo
                    }] : [],
                    tt._onpos = et.onpos ? [{
                        fn: et.onpos
                    }] : [],
                    tt._onorientation = et.onorientation ? [{
                        fn: et.onorientation
                    }] : [],
                    J.call(this, et)
                }
            }(Howl.prototype.init),
            Howl.prototype.stereo = function(J, et) {
                var tt = this;
                if (!tt._webAudio)
                    return tt;
                if (tt._state !== "loaded")
                    return tt._queue.push({
                        event: "stereo",
                        action: function() {
                            tt.stereo(J, et)
                        }
                    }),
                    tt;
                var rt = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo";
                if (typeof et > "u")
                    if (typeof J == "number")
                        tt._stereo = J,
                        tt._pos = [J, 0, 0];
                    else
                        return tt._stereo;
                for (var nt = tt._getSoundIds(et), ot = 0; ot < nt.length; ot++) {
                    var it = tt._soundById(nt[ot]);
                    if (it)
                        if (typeof J == "number")
                            it._stereo = J,
                            it._pos = [J, 0, 0],
                            it._node && (it._pannerAttr.panningModel = "equalpower",
                            (!it._panner || !it._panner.pan) && k(it, rt),
                            rt === "spatial" ? typeof it._panner.positionX < "u" ? (it._panner.positionX.setValueAtTime(J, Howler.ctx.currentTime),
                            it._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                            it._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : it._panner.setPosition(J, 0, 0) : it._panner.pan.setValueAtTime(J, Howler.ctx.currentTime)),
                            tt._emit("stereo", it._id);
                        else
                            return it._stereo
                }
                return tt
            }
            ,
            Howl.prototype.pos = function(J, et, tt, rt) {
                var nt = this;
                if (!nt._webAudio)
                    return nt;
                if (nt._state !== "loaded")
                    return nt._queue.push({
                        event: "pos",
                        action: function() {
                            nt.pos(J, et, tt, rt)
                        }
                    }),
                    nt;
                if (et = typeof et != "number" ? 0 : et,
                tt = typeof tt != "number" ? -.5 : tt,
                typeof rt > "u")
                    if (typeof J == "number")
                        nt._pos = [J, et, tt];
                    else
                        return nt._pos;
                for (var ot = nt._getSoundIds(rt), it = 0; it < ot.length; it++) {
                    var at = nt._soundById(ot[it]);
                    if (at)
                        if (typeof J == "number")
                            at._pos = [J, et, tt],
                            at._node && ((!at._panner || at._panner.pan) && k(at, "spatial"),
                            typeof at._panner.positionX < "u" ? (at._panner.positionX.setValueAtTime(J, Howler.ctx.currentTime),
                            at._panner.positionY.setValueAtTime(et, Howler.ctx.currentTime),
                            at._panner.positionZ.setValueAtTime(tt, Howler.ctx.currentTime)) : at._panner.setPosition(J, et, tt)),
                            nt._emit("pos", at._id);
                        else
                            return at._pos
                }
                return nt
            }
            ,
            Howl.prototype.orientation = function(J, et, tt, rt) {
                var nt = this;
                if (!nt._webAudio)
                    return nt;
                if (nt._state !== "loaded")
                    return nt._queue.push({
                        event: "orientation",
                        action: function() {
                            nt.orientation(J, et, tt, rt)
                        }
                    }),
                    nt;
                if (et = typeof et != "number" ? nt._orientation[1] : et,
                tt = typeof tt != "number" ? nt._orientation[2] : tt,
                typeof rt > "u")
                    if (typeof J == "number")
                        nt._orientation = [J, et, tt];
                    else
                        return nt._orientation;
                for (var ot = nt._getSoundIds(rt), it = 0; it < ot.length; it++) {
                    var at = nt._soundById(ot[it]);
                    if (at)
                        if (typeof J == "number")
                            at._orientation = [J, et, tt],
                            at._node && (at._panner || (at._pos || (at._pos = nt._pos || [0, 0, -.5]),
                            k(at, "spatial")),
                            typeof at._panner.orientationX < "u" ? (at._panner.orientationX.setValueAtTime(J, Howler.ctx.currentTime),
                            at._panner.orientationY.setValueAtTime(et, Howler.ctx.currentTime),
                            at._panner.orientationZ.setValueAtTime(tt, Howler.ctx.currentTime)) : at._panner.setOrientation(J, et, tt)),
                            nt._emit("orientation", at._id);
                        else
                            return at._orientation
                }
                return nt
            }
            ,
            Howl.prototype.pannerAttr = function() {
                var J = this, et = arguments, tt, rt, nt;
                if (!J._webAudio)
                    return J;
                if (et.length === 0)
                    return J._pannerAttr;
                if (et.length === 1)
                    if (typeof et[0] == "object")
                        tt = et[0],
                        typeof rt > "u" && (tt.pannerAttr || (tt.pannerAttr = {
                            coneInnerAngle: tt.coneInnerAngle,
                            coneOuterAngle: tt.coneOuterAngle,
                            coneOuterGain: tt.coneOuterGain,
                            distanceModel: tt.distanceModel,
                            maxDistance: tt.maxDistance,
                            refDistance: tt.refDistance,
                            rolloffFactor: tt.rolloffFactor,
                            panningModel: tt.panningModel
                        }),
                        J._pannerAttr = {
                            coneInnerAngle: typeof tt.pannerAttr.coneInnerAngle < "u" ? tt.pannerAttr.coneInnerAngle : J._coneInnerAngle,
                            coneOuterAngle: typeof tt.pannerAttr.coneOuterAngle < "u" ? tt.pannerAttr.coneOuterAngle : J._coneOuterAngle,
                            coneOuterGain: typeof tt.pannerAttr.coneOuterGain < "u" ? tt.pannerAttr.coneOuterGain : J._coneOuterGain,
                            distanceModel: typeof tt.pannerAttr.distanceModel < "u" ? tt.pannerAttr.distanceModel : J._distanceModel,
                            maxDistance: typeof tt.pannerAttr.maxDistance < "u" ? tt.pannerAttr.maxDistance : J._maxDistance,
                            refDistance: typeof tt.pannerAttr.refDistance < "u" ? tt.pannerAttr.refDistance : J._refDistance,
                            rolloffFactor: typeof tt.pannerAttr.rolloffFactor < "u" ? tt.pannerAttr.rolloffFactor : J._rolloffFactor,
                            panningModel: typeof tt.pannerAttr.panningModel < "u" ? tt.pannerAttr.panningModel : J._panningModel
                        });
                    else
                        return nt = J._soundById(parseInt(et[0], 10)),
                        nt ? nt._pannerAttr : J._pannerAttr;
                else
                    et.length === 2 && (tt = et[0],
                    rt = parseInt(et[1], 10));
                for (var ot = J._getSoundIds(rt), it = 0; it < ot.length; it++)
                    if (nt = J._soundById(ot[it]),
                    nt) {
                        var at = nt._pannerAttr;
                        at = {
                            coneInnerAngle: typeof tt.coneInnerAngle < "u" ? tt.coneInnerAngle : at.coneInnerAngle,
                            coneOuterAngle: typeof tt.coneOuterAngle < "u" ? tt.coneOuterAngle : at.coneOuterAngle,
                            coneOuterGain: typeof tt.coneOuterGain < "u" ? tt.coneOuterGain : at.coneOuterGain,
                            distanceModel: typeof tt.distanceModel < "u" ? tt.distanceModel : at.distanceModel,
                            maxDistance: typeof tt.maxDistance < "u" ? tt.maxDistance : at.maxDistance,
                            refDistance: typeof tt.refDistance < "u" ? tt.refDistance : at.refDistance,
                            rolloffFactor: typeof tt.rolloffFactor < "u" ? tt.rolloffFactor : at.rolloffFactor,
                            panningModel: typeof tt.panningModel < "u" ? tt.panningModel : at.panningModel
                        };
                        var lt = nt._panner;
                        lt || (nt._pos || (nt._pos = J._pos || [0, 0, -.5]),
                        k(nt, "spatial"),
                        lt = nt._panner),
                        lt.coneInnerAngle = at.coneInnerAngle,
                        lt.coneOuterAngle = at.coneOuterAngle,
                        lt.coneOuterGain = at.coneOuterGain,
                        lt.distanceModel = at.distanceModel,
                        lt.maxDistance = at.maxDistance,
                        lt.refDistance = at.refDistance,
                        lt.rolloffFactor = at.rolloffFactor,
                        lt.panningModel = at.panningModel
                    }
                return J
            }
            ,
            Sound.prototype.init = function(J) {
                return function() {
                    var et = this
                      , tt = et._parent;
                    et._orientation = tt._orientation,
                    et._stereo = tt._stereo,
                    et._pos = tt._pos,
                    et._pannerAttr = tt._pannerAttr,
                    J.call(this),
                    et._stereo ? tt.stereo(et._stereo) : et._pos && tt.pos(et._pos[0], et._pos[1], et._pos[2], et._id)
                }
            }(Sound.prototype.init),
            Sound.prototype.reset = function(J) {
                return function() {
                    var et = this
                      , tt = et._parent;
                    return et._orientation = tt._orientation,
                    et._stereo = tt._stereo,
                    et._pos = tt._pos,
                    et._pannerAttr = tt._pannerAttr,
                    et._stereo ? tt.stereo(et._stereo) : et._pos ? tt.pos(et._pos[0], et._pos[1], et._pos[2], et._id) : et._panner && (et._panner.disconnect(0),
                    et._panner = void 0,
                    tt._refreshBuffer(et)),
                    J.call(this)
                }
            }(Sound.prototype.reset);
            var k = function(J, et) {
                et = et || "spatial",
                et === "spatial" ? (J._panner = Howler.ctx.createPanner(),
                J._panner.coneInnerAngle = J._pannerAttr.coneInnerAngle,
                J._panner.coneOuterAngle = J._pannerAttr.coneOuterAngle,
                J._panner.coneOuterGain = J._pannerAttr.coneOuterGain,
                J._panner.distanceModel = J._pannerAttr.distanceModel,
                J._panner.maxDistance = J._pannerAttr.maxDistance,
                J._panner.refDistance = J._pannerAttr.refDistance,
                J._panner.rolloffFactor = J._pannerAttr.rolloffFactor,
                J._panner.panningModel = J._pannerAttr.panningModel,
                typeof J._panner.positionX < "u" ? (J._panner.positionX.setValueAtTime(J._pos[0], Howler.ctx.currentTime),
                J._panner.positionY.setValueAtTime(J._pos[1], Howler.ctx.currentTime),
                J._panner.positionZ.setValueAtTime(J._pos[2], Howler.ctx.currentTime)) : J._panner.setPosition(J._pos[0], J._pos[1], J._pos[2]),
                typeof J._panner.orientationX < "u" ? (J._panner.orientationX.setValueAtTime(J._orientation[0], Howler.ctx.currentTime),
                J._panner.orientationY.setValueAtTime(J._orientation[1], Howler.ctx.currentTime),
                J._panner.orientationZ.setValueAtTime(J._orientation[2], Howler.ctx.currentTime)) : J._panner.setOrientation(J._orientation[0], J._orientation[1], J._orientation[2])) : (J._panner = Howler.ctx.createStereoPanner(),
                J._panner.pan.setValueAtTime(J._stereo, Howler.ctx.currentTime)),
                J._panner.connect(J._node),
                J._paused || J._parent.pause(J._id, !0).play(J._id, !0)
            }
        }()
    }(howler),
    DecimalUtils = {
        floor: _=>_.toDecimalPlaces(0, Decimal$1.ROUND_DOWN),
        round: _=>_.toDecimalPlaces(0),
        max: (..._)=>{
            let k = _[0];
            for (let J = 1; J < _.length; J++)
                _[J].greaterThan(k) && (k = _[J]);
            return k
        }
        ,
        min: (..._)=>{
            let k = _[0];
            for (let J = 1; J < _.length; J++)
                _[J].lessThan(k) && (k = _[J]);
            return k
        }
    };
    var eventemitter3 = {
        exports: {}
    };
    (function(_) {
        var k = Object.prototype.hasOwnProperty
          , J = "~";
        function et() {}
        Object.create && (et.prototype = Object.create(null),
        new et().__proto__ || (J = !1));
        function tt(it, at, lt) {
            this.fn = it,
            this.context = at,
            this.once = lt || !1
        }
        function rt(it, at, lt, st, ut) {
            if (typeof lt != "function")
                throw new TypeError("The listener must be a function");
            var ct = new tt(lt,st || it,ut)
              , pt = J ? J + at : at;
            return it._events[pt] ? it._events[pt].fn ? it._events[pt] = [it._events[pt], ct] : it._events[pt].push(ct) : (it._events[pt] = ct,
            it._eventsCount++),
            it
        }
        function nt(it, at) {
            --it._eventsCount === 0 ? it._events = new et : delete it._events[at]
        }
        function ot() {
            this._events = new et,
            this._eventsCount = 0
        }
        ot.prototype.eventNames = function() {
            var it = [], at, lt;
            if (this._eventsCount === 0)
                return it;
            for (lt in at = this._events)
                k.call(at, lt) && it.push(J ? lt.slice(1) : lt);
            return Object.getOwnPropertySymbols ? it.concat(Object.getOwnPropertySymbols(at)) : it
        }
        ,
        ot.prototype.listeners = function(it) {
            var at = J ? J + it : it
              , lt = this._events[at];
            if (!lt)
                return [];
            if (lt.fn)
                return [lt.fn];
            for (var st = 0, ut = lt.length, ct = new Array(ut); st < ut; st++)
                ct[st] = lt[st].fn;
            return ct
        }
        ,
        ot.prototype.listenerCount = function(it) {
            var at = J ? J + it : it
              , lt = this._events[at];
            return lt ? lt.fn ? 1 : lt.length : 0
        }
        ,
        ot.prototype.emit = function(it, at, lt, st, ut, ct) {
            var pt = J ? J + it : it;
            if (!this._events[pt])
                return !1;
            var ft = this._events[pt], yt = arguments.length, ht, gt;
            if (ft.fn) {
                switch (ft.once && this.removeListener(it, ft.fn, void 0, !0),
                yt) {
                case 1:
                    return ft.fn.call(ft.context),
                    !0;
                case 2:
                    return ft.fn.call(ft.context, at),
                    !0;
                case 3:
                    return ft.fn.call(ft.context, at, lt),
                    !0;
                case 4:
                    return ft.fn.call(ft.context, at, lt, st),
                    !0;
                case 5:
                    return ft.fn.call(ft.context, at, lt, st, ut),
                    !0;
                case 6:
                    return ft.fn.call(ft.context, at, lt, st, ut, ct),
                    !0
                }
                for (gt = 1,
                ht = new Array(yt - 1); gt < yt; gt++)
                    ht[gt - 1] = arguments[gt];
                ft.fn.apply(ft.context, ht)
            } else {
                var mt = ft.length, vt;
                for (gt = 0; gt < mt; gt++)
                    switch (ft[gt].once && this.removeListener(it, ft[gt].fn, void 0, !0),
                    yt) {
                    case 1:
                        ft[gt].fn.call(ft[gt].context);
                        break;
                    case 2:
                        ft[gt].fn.call(ft[gt].context, at);
                        break;
                    case 3:
                        ft[gt].fn.call(ft[gt].context, at, lt);
                        break;
                    case 4:
                        ft[gt].fn.call(ft[gt].context, at, lt, st);
                        break;
                    default:
                        if (!ht)
                            for (vt = 1,
                            ht = new Array(yt - 1); vt < yt; vt++)
                                ht[vt - 1] = arguments[vt];
                        ft[gt].fn.apply(ft[gt].context, ht)
                    }
            }
            return !0
        }
        ,
        ot.prototype.on = function(it, at, lt) {
            return rt(this, it, at, lt, !1)
        }
        ,
        ot.prototype.once = function(it, at, lt) {
            return rt(this, it, at, lt, !0)
        }
        ,
        ot.prototype.removeListener = function(it, at, lt, st) {
            var ut = J ? J + it : it;
            if (!this._events[ut])
                return this;
            if (!at)
                return nt(this, ut),
                this;
            var ct = this._events[ut];
            if (ct.fn)
                ct.fn === at && (!st || ct.once) && (!lt || ct.context === lt) && nt(this, ut);
            else {
                for (var pt = 0, ft = [], yt = ct.length; pt < yt; pt++)
                    (ct[pt].fn !== at || st && !ct[pt].once || lt && ct[pt].context !== lt) && ft.push(ct[pt]);
                ft.length ? this._events[ut] = ft.length === 1 ? ft[0] : ft : nt(this, ut)
            }
            return this
        }
        ,
        ot.prototype.removeAllListeners = function(it) {
            var at;
            return it ? (at = J ? J + it : it,
            this._events[at] && nt(this, at)) : (this._events = new et,
            this._eventsCount = 0),
            this
        }
        ,
        ot.prototype.off = ot.prototype.removeListener,
        ot.prototype.addListener = ot.prototype.on,
        ot.prefixed = J,
        ot.EventEmitter = ot,
        _.exports = ot
    }
    )(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    EventEmitter$2 = getDefaultExportFromCjs(eventemitter3Exports);
    class TimeoutError extends Error {
        constructor(k) {
            super(k),
            this.name = "TimeoutError"
        }
    }
    let AbortError$1 = class extends Error {
        constructor(_) {
            super(),
            this.name = "AbortError",
            this.message = _
        }
    }
    ;
    const getDOMException = _=>globalThis.DOMException === void 0 ? new AbortError$1(_) : new DOMException(_)
      , getAbortedReason = _=>{
        const k = _.reason === void 0 ? getDOMException("This operation was aborted.") : _.reason;
        return k instanceof Error ? k : getDOMException(k)
    }
    ;
    function pTimeout(_, k, J, et) {
        let tt;
        const rt = new Promise((nt,ot)=>{
            if (typeof k != "number" || Math.sign(k) !== 1)
                throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${k}\``);
            if (k === Number.POSITIVE_INFINITY) {
                nt(_);
                return
            }
            if (et = $t({
                customTimers: {
                    setTimeout,
                    clearTimeout
                }
            }, et),
            et.signal) {
                const {signal: it} = et;
                it.aborted && ot(getAbortedReason(it)),
                it.addEventListener("abort", ()=>{
                    ot(getAbortedReason(it))
                }
                )
            }
            tt = et.customTimers.setTimeout.call(void 0, ()=>{
                if (typeof J == "function") {
                    try {
                        nt(J())
                    } catch (lt) {
                        ot(lt)
                    }
                    return
                }
                const it = typeof J == "string" ? J : `Promise timed out after ${k} milliseconds`
                  , at = J instanceof Error ? J : new TimeoutError(it);
                typeof _.cancel == "function" && _.cancel(),
                ot(at)
            }
            , k),
            (async()=>{
                try {
                    nt(await _)
                } catch (it) {
                    ot(it)
                } finally {
                    et.customTimers.clearTimeout.call(void 0, tt)
                }
            }
            )()
        }
        );
        return rt.clear = ()=>{
            clearTimeout(tt),
            tt = void 0
        }
        ,
        rt
    }
    function lowerBound(_, k, J) {
        let et = 0
          , tt = _.length;
        for (; tt > 0; ) {
            const rt = Math.trunc(tt / 2);
            let nt = et + rt;
            J(_[nt], k) <= 0 ? (et = ++nt,
            tt -= rt + 1) : tt = rt
        }
        return et
    }
    var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(_, k, J, et) {
        if (J === "a" && !et)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof k == "function" ? _ !== k || !et : !k.has(_))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return J === "m" ? et : J === "a" ? et.call(_) : et ? et.value : k.get(_)
    }
    , _PriorityQueue_queue;
    class PriorityQueue {
        constructor() {
            _PriorityQueue_queue.set(this, [])
        }
        enqueue(k, J) {
            J = $t({
                priority: 0
            }, J);
            const et = {
                priority: J.priority,
                run: k
            };
            if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= J.priority) {
                __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(et);
                return
            }
            const tt = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), et, (rt,nt)=>nt.priority - rt.priority);
            __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(tt, 0, et)
        }
        dequeue() {
            const k = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
            return k == null ? void 0 : k.run
        }
        filter(k) {
            return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter(J=>J.priority === k.priority).map(J=>J.run)
        }
        get size() {
            return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length
        }
    }
    _PriorityQueue_queue = new WeakMap;
    var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(_, k, J, et, tt) {
        if (et === "m")
            throw new TypeError("Private method is not writable");
        if (et === "a" && !tt)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof k == "function" ? _ !== k || !tt : !k.has(_))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return et === "a" ? tt.call(_, J) : tt ? tt.value = J : k.set(_, J),
        J
    }
    , __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(_, k, J, et) {
        if (J === "a" && !et)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof k == "function" ? _ !== k || !et : !k.has(_))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return J === "m" ? et : J === "a" ? et.call(_) : et ? et.value : k.get(_)
    }
    , _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;
    class AbortError extends Error {
    }
    class PQueue extends EventEmitter$2 {
        constructor(k) {
            var J, et, tt, rt;
            if (super(),
            _PQueue_instances.add(this),
            _PQueue_carryoverConcurrencyCount.set(this, void 0),
            _PQueue_isIntervalIgnored.set(this, void 0),
            _PQueue_intervalCount.set(this, 0),
            _PQueue_intervalCap.set(this, void 0),
            _PQueue_interval.set(this, void 0),
            _PQueue_intervalEnd.set(this, 0),
            _PQueue_intervalId.set(this, void 0),
            _PQueue_timeoutId.set(this, void 0),
            _PQueue_queue.set(this, void 0),
            _PQueue_queueClass.set(this, void 0),
            _PQueue_pending.set(this, 0),
            _PQueue_concurrency.set(this, void 0),
            _PQueue_isPaused.set(this, void 0),
            _PQueue_throwOnTimeout.set(this, void 0),
            Object.defineProperty(this, "timeout", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            k = $t({
                carryoverConcurrencyCount: !1,
                intervalCap: Number.POSITIVE_INFINITY,
                interval: 0,
                concurrency: Number.POSITIVE_INFINITY,
                autoStart: !0,
                queueClass: PriorityQueue
            }, k),
            !(typeof k.intervalCap == "number" && k.intervalCap >= 1))
                throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(et = (J = k.intervalCap) === null || J === void 0 ? void 0 : J.toString()) !== null && et !== void 0 ? et : ""}\` (${typeof k.intervalCap})`);
            if (k.interval === void 0 || !(Number.isFinite(k.interval) && k.interval >= 0))
                throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(rt = (tt = k.interval) === null || tt === void 0 ? void 0 : tt.toString()) !== null && rt !== void 0 ? rt : ""}\` (${typeof k.interval})`);
            __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, k.carryoverConcurrencyCount, "f"),
            __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, k.intervalCap === Number.POSITIVE_INFINITY || k.interval === 0, "f"),
            __classPrivateFieldSet(this, _PQueue_intervalCap, k.intervalCap, "f"),
            __classPrivateFieldSet(this, _PQueue_interval, k.interval, "f"),
            __classPrivateFieldSet(this, _PQueue_queue, new k.queueClass, "f"),
            __classPrivateFieldSet(this, _PQueue_queueClass, k.queueClass, "f"),
            this.concurrency = k.concurrency,
            this.timeout = k.timeout,
            __classPrivateFieldSet(this, _PQueue_throwOnTimeout, k.throwOnTimeout === !0, "f"),
            __classPrivateFieldSet(this, _PQueue_isPaused, k.autoStart === !1, "f")
        }
        get concurrency() {
            return __classPrivateFieldGet(this, _PQueue_concurrency, "f")
        }
        set concurrency(k) {
            if (!(typeof k == "number" && k >= 1))
                throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${k}\` (${typeof k})`);
            __classPrivateFieldSet(this, _PQueue_concurrency, k, "f"),
            __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this)
        }
        async add(k, J={}) {
            return J = $t({
                timeout: this.timeout,
                throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f")
            }, J),
            new Promise((et,tt)=>{
                __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(async()=>{
                    var rt, nt, ot;
                    __classPrivateFieldSet(this, _PQueue_pending, (nt = __classPrivateFieldGet(this, _PQueue_pending, "f"),
                    nt++,
                    nt), "f"),
                    __classPrivateFieldSet(this, _PQueue_intervalCount, (ot = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"),
                    ot++,
                    ot), "f");
                    try {
                        if (!((rt = J.signal) === null || rt === void 0) && rt.aborted)
                            throw new AbortError("The task was aborted.");
                        let it = k({
                            signal: J.signal
                        });
                        J.timeout && (it = pTimeout(Promise.resolve(it), J.timeout)),
                        J.signal && (it = Promise.race([it, __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_throwOnAbort).call(this, J.signal)]));
                        const at = await it;
                        et(at),
                        this.emit("completed", at)
                    } catch (it) {
                        if (it instanceof TimeoutError && !J.throwOnTimeout) {
                            et();
                            return
                        }
                        tt(it),
                        this.emit("error", it)
                    } finally {
                        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this)
                    }
                }
                , J),
                this.emit("add"),
                __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)
            }
            )
        }
        async addAll(k, J) {
            return Promise.all(k.map(async et=>this.add(et, J)))
        }
        start() {
            return __classPrivateFieldGet(this, _PQueue_isPaused, "f") ? (__classPrivateFieldSet(this, _PQueue_isPaused, !1, "f"),
            __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this),
            this) : this
        }
        pause() {
            __classPrivateFieldSet(this, _PQueue_isPaused, !0, "f")
        }
        clear() {
            __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f")), "f")
        }
        async onEmpty() {
            __classPrivateFieldGet(this, _PQueue_queue, "f").size !== 0 && await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty")
        }
        async onSizeLessThan(k) {
            __classPrivateFieldGet(this, _PQueue_queue, "f").size < k || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", ()=>__classPrivateFieldGet(this, _PQueue_queue, "f").size < k)
        }
        async onIdle() {
            __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0 || await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle")
        }
        get size() {
            return __classPrivateFieldGet(this, _PQueue_queue, "f").size
        }
        sizeBy(k) {
            return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(k).length
        }
        get pending() {
            return __classPrivateFieldGet(this, _PQueue_pending, "f")
        }
        get isPaused() {
            return __classPrivateFieldGet(this, _PQueue_isPaused, "f")
        }
    }
    _PQueue_carryoverConcurrencyCount = new WeakMap,
    _PQueue_isIntervalIgnored = new WeakMap,
    _PQueue_intervalCount = new WeakMap,
    _PQueue_intervalCap = new WeakMap,
    _PQueue_interval = new WeakMap,
    _PQueue_intervalEnd = new WeakMap,
    _PQueue_intervalId = new WeakMap,
    _PQueue_timeoutId = new WeakMap,
    _PQueue_queue = new WeakMap,
    _PQueue_queueClass = new WeakMap,
    _PQueue_pending = new WeakMap,
    _PQueue_concurrency = new WeakMap,
    _PQueue_isPaused = new WeakMap,
    _PQueue_throwOnTimeout = new WeakMap,
    _PQueue_instances = new WeakSet,
    _PQueue_doesIntervalAllowAnother_get = function _() {
        return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f")
    }
    ,
    _PQueue_doesConcurrentAllowAnother_get = function _() {
        return __classPrivateFieldGet(this, _PQueue_pending, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f")
    }
    ,
    _PQueue_next = function _() {
        var k;
        __classPrivateFieldSet(this, _PQueue_pending, (k = __classPrivateFieldGet(this, _PQueue_pending, "f"),
        k--,
        k), "f"),
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this),
        this.emit("next")
    }
    ,
    _PQueue_onResumeInterval = function _() {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this),
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this),
        __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f")
    }
    ,
    _PQueue_isIntervalPaused_get = function _() {
        const k = Date.now();
        if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
            const J = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - k;
            if (J < 0)
                __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f");
            else
                return __classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0 && __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(()=>{
                    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this)
                }
                , J), "f"),
                !0
        }
        return !1
    }
    ,
    _PQueue_tryToStartAnother = function _() {
        if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0)
            return __classPrivateFieldGet(this, _PQueue_intervalId, "f") && clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")),
            __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f"),
            this.emit("empty"),
            __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && this.emit("idle"),
            !1;
        if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
            const k = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
            if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
                const J = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
                return J ? (this.emit("active"),
                J(),
                k && __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this),
                !0) : !1
            }
        }
        return !1
    }
    ,
    _PQueue_initializeIntervalIfNeeded = function _() {
        __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0 || (__classPrivateFieldSet(this, _PQueue_intervalId, setInterval(()=>{
            __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this)
        }
        , __classPrivateFieldGet(this, _PQueue_interval, "f")), "f"),
        __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f"))
    }
    ,
    _PQueue_onInterval = function _() {
        __classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pending, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f") && (clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f")),
        __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f")),
        __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pending, "f") : 0, "f"),
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this)
    }
    ,
    _PQueue_processQueue = function _() {
        for (; __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this); )
            ;
    }
    ,
    _PQueue_throwOnAbort = async function _(k) {
        return new Promise((J,et)=>{
            k.addEventListener("abort", ()=>{
                et(new AbortError("The task was aborted."))
            }
            , {
                once: !0
            })
        }
        )
    }
    ,
    _PQueue_onEvent = async function _(k, J) {
        return new Promise(et=>{
            const tt = ()=>{
                J && !J() || (this.off(k, tt),
                et())
            }
            ;
            this.on(k, tt)
        }
        )
    }
    ,
    useForceUpdate = function() {
        return reactExports.useReducer(_=>_ + 1, 0)[1]
    }
    ;
    class AsyncQueue {
        constructor() {
            _e(this, "list", [])
        }
        enqueue(k, J) {
            const {weights: et=0} = J || {}
              , tt = {
                weights: et,
                run: k
            }
              , rt = sortedIndexBy(this.list, tt, nt=>nt.weights);
            this.list.splice(rt, 0, tt)
        }
        dequeue() {
            var k;
            return (k = this.list.shift()) == null ? void 0 : k.run
        }
        get size() {
            return this.list.length
        }
        filter(k) {
            return this.list.map(J=>J.run)
        }
    }
    class ModalQueue extends PQueue {
        constructor() {
            super({
                queueClass: AsyncQueue,
                concurrency: 1
            })
        }
        useIdle(k=0) {
            const J = useForceUpdate()
              , et = this.pending === 0 && this.size === 0;
            return reactExports.useEffect(()=>{
                const tt = ()=>setTimeout(()=>J(), k);
                return this.on("idle", tt),
                ()=>{
                    this.off("idle", tt)
                }
            }
            , []),
            et
        }
    }
    AsyncQueue$1 = new ModalQueue;
    var wasm = null;
    try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])),{}).exports
    } catch (_) {}
    Long = function(_, k, J) {
        this.low = _ | 0,
        this.high = k | 0,
        this.unsigned = !!J
    }
    ,
    Long.prototype.__isLong__,
    Object.defineProperty(Long.prototype, "__isLong__", {
        value: !0
    });
    function isLong(_) {
        return (_ && _.__isLong__) === !0
    }
    function ctz32(_) {
        var k = Math.clz32(_ & -_);
        return _ ? 31 - k : k
    }
    Long.isLong = isLong;
    var INT_CACHE = {}
      , UINT_CACHE = {};
    function fromInt(_, k) {
        var J, et, tt;
        return k ? (_ >>>= 0,
        (tt = 0 <= _ && _ < 256) && (et = UINT_CACHE[_],
        et) ? et : (J = fromBits(_, 0, !0),
        tt && (UINT_CACHE[_] = J),
        J)) : (_ |= 0,
        (tt = -128 <= _ && _ < 128) && (et = INT_CACHE[_],
        et) ? et : (J = fromBits(_, _ < 0 ? -1 : 0, !1),
        tt && (INT_CACHE[_] = J),
        J))
    }
    Long.fromInt = fromInt;
    function fromNumber(_, k) {
        if (isNaN(_))
            return k ? UZERO : ZERO;
        if (k) {
            if (_ < 0)
                return UZERO;
            if (_ >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE
        } else {
            if (_ <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (_ + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE
        }
        return _ < 0 ? fromNumber(-_, k).neg() : fromBits(_ % TWO_PWR_32_DBL | 0, _ / TWO_PWR_32_DBL | 0, k)
    }
    Long.fromNumber = fromNumber;
    function fromBits(_, k, J) {
        return new Long(_,k,J)
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(_, k, J) {
        if (_.length === 0)
            throw Error("empty string");
        if (typeof k == "number" ? (J = k,
        k = !1) : k = !!k,
        _ === "NaN" || _ === "Infinity" || _ === "+Infinity" || _ === "-Infinity")
            return k ? UZERO : ZERO;
        if (J = J || 10,
        J < 2 || 36 < J)
            throw RangeError("radix");
        var et;
        if ((et = _.indexOf("-")) > 0)
            throw Error("interior hyphen");
        if (et === 0)
            return fromString(_.substring(1), k, J).neg();
        for (var tt = fromNumber(pow_dbl(J, 8)), rt = ZERO, nt = 0; nt < _.length; nt += 8) {
            var ot = Math.min(8, _.length - nt)
              , it = parseInt(_.substring(nt, nt + ot), J);
            if (ot < 8) {
                var at = fromNumber(pow_dbl(J, ot));
                rt = rt.mul(at).add(fromNumber(it))
            } else
                rt = rt.mul(tt),
                rt = rt.add(fromNumber(it))
        }
        return rt.unsigned = k,
        rt
    }
    Long.fromString = fromString;
    function fromValue(_, k) {
        return typeof _ == "number" ? fromNumber(_, k) : typeof _ == "string" ? fromString(_, k) : fromBits(_.low, _.high, typeof k == "boolean" ? k : _.unsigned)
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 65536
      , TWO_PWR_24_DBL = 1 << 24
      , TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL
      , TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL
      , TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2
      , TWO_PWR_24 = fromInt(TWO_PWR_24_DBL)
      , ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, !0);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, !0);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(-1, 2147483647, !1);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, -2147483648, !1);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function _() {
        return this.unsigned ? this.low >>> 0 : this.low
    }
    ,
    LongPrototype.toNumber = function _() {
        return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0)
    }
    ,
    LongPrototype.toString = function _(k) {
        if (k = k || 10,
        k < 2 || 36 < k)
            throw RangeError("radix");
        if (this.isZero())
            return "0";
        if (this.isNegative())
            if (this.eq(MIN_VALUE)) {
                var J = fromNumber(k)
                  , et = this.div(J)
                  , tt = et.mul(J).sub(this);
                return et.toString(k) + tt.toInt().toString(k)
            } else
                return "-" + this.neg().toString(k);
        for (var rt = fromNumber(pow_dbl(k, 6), this.unsigned), nt = this, ot = ""; ; ) {
            var it = nt.div(rt)
              , at = nt.sub(it.mul(rt)).toInt() >>> 0
              , lt = at.toString(k);
            if (nt = it,
            nt.isZero())
                return lt + ot;
            for (; lt.length < 6; )
                lt = "0" + lt;
            ot = "" + lt + ot
        }
    }
    ,
    LongPrototype.getHighBits = function _() {
        return this.high
    }
    ,
    LongPrototype.getHighBitsUnsigned = function _() {
        return this.high >>> 0
    }
    ,
    LongPrototype.getLowBits = function _() {
        return this.low
    }
    ,
    LongPrototype.getLowBitsUnsigned = function _() {
        return this.low >>> 0
    }
    ,
    LongPrototype.getNumBitsAbs = function _() {
        if (this.isNegative())
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        for (var k = this.high != 0 ? this.high : this.low, J = 31; J > 0 && !(k & 1 << J); J--)
            ;
        return this.high != 0 ? J + 33 : J + 1
    }
    ,
    LongPrototype.isZero = function _() {
        return this.high === 0 && this.low === 0
    }
    ,
    LongPrototype.eqz = LongPrototype.isZero,
    LongPrototype.isNegative = function _() {
        return !this.unsigned && this.high < 0
    }
    ,
    LongPrototype.isPositive = function _() {
        return this.unsigned || this.high >= 0
    }
    ,
    LongPrototype.isOdd = function _() {
        return (this.low & 1) === 1
    }
    ,
    LongPrototype.isEven = function _() {
        return (this.low & 1) === 0
    }
    ,
    LongPrototype.equals = function _(k) {
        return isLong(k) || (k = fromValue(k)),
        this.unsigned !== k.unsigned && this.high >>> 31 === 1 && k.high >>> 31 === 1 ? !1 : this.high === k.high && this.low === k.low
    }
    ,
    LongPrototype.eq = LongPrototype.equals,
    LongPrototype.notEquals = function _(k) {
        return !this.eq(k)
    }
    ,
    LongPrototype.neq = LongPrototype.notEquals,
    LongPrototype.ne = LongPrototype.notEquals,
    LongPrototype.lessThan = function _(k) {
        return this.comp(k) < 0
    }
    ,
    LongPrototype.lt = LongPrototype.lessThan,
    LongPrototype.lessThanOrEqual = function _(k) {
        return this.comp(k) <= 0
    }
    ,
    LongPrototype.lte = LongPrototype.lessThanOrEqual,
    LongPrototype.le = LongPrototype.lessThanOrEqual,
    LongPrototype.greaterThan = function _(k) {
        return this.comp(k) > 0
    }
    ,
    LongPrototype.gt = LongPrototype.greaterThan,
    LongPrototype.greaterThanOrEqual = function _(k) {
        return this.comp(k) >= 0
    }
    ,
    LongPrototype.gte = LongPrototype.greaterThanOrEqual,
    LongPrototype.ge = LongPrototype.greaterThanOrEqual,
    LongPrototype.compare = function _(k) {
        if (isLong(k) || (k = fromValue(k)),
        this.eq(k))
            return 0;
        var J = this.isNegative()
          , et = k.isNegative();
        return J && !et ? -1 : !J && et ? 1 : this.unsigned ? k.high >>> 0 > this.high >>> 0 || k.high === this.high && k.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(k).isNegative() ? -1 : 1
    }
    ,
    LongPrototype.comp = LongPrototype.compare,
    LongPrototype.negate = function _() {
        return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE)
    }
    ,
    LongPrototype.neg = LongPrototype.negate,
    LongPrototype.add = function _(k) {
        isLong(k) || (k = fromValue(k));
        var J = this.high >>> 16
          , et = this.high & 65535
          , tt = this.low >>> 16
          , rt = this.low & 65535
          , nt = k.high >>> 16
          , ot = k.high & 65535
          , it = k.low >>> 16
          , at = k.low & 65535
          , lt = 0
          , st = 0
          , ut = 0
          , ct = 0;
        return ct += rt + at,
        ut += ct >>> 16,
        ct &= 65535,
        ut += tt + it,
        st += ut >>> 16,
        ut &= 65535,
        st += et + ot,
        lt += st >>> 16,
        st &= 65535,
        lt += J + nt,
        lt &= 65535,
        fromBits(ut << 16 | ct, lt << 16 | st, this.unsigned)
    }
    ,
    LongPrototype.subtract = function _(k) {
        return isLong(k) || (k = fromValue(k)),
        this.add(k.neg())
    }
    ,
    LongPrototype.sub = LongPrototype.subtract,
    LongPrototype.multiply = function _(k) {
        if (this.isZero())
            return this;
        if (isLong(k) || (k = fromValue(k)),
        wasm) {
            var J = wasm.mul(this.low, this.high, k.low, k.high);
            return fromBits(J, wasm.get_high(), this.unsigned)
        }
        if (k.isZero())
            return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE))
            return k.isOdd() ? MIN_VALUE : ZERO;
        if (k.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative())
            return k.isNegative() ? this.neg().mul(k.neg()) : this.neg().mul(k).neg();
        if (k.isNegative())
            return this.mul(k.neg()).neg();
        if (this.lt(TWO_PWR_24) && k.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * k.toNumber(), this.unsigned);
        var et = this.high >>> 16
          , tt = this.high & 65535
          , rt = this.low >>> 16
          , nt = this.low & 65535
          , ot = k.high >>> 16
          , it = k.high & 65535
          , at = k.low >>> 16
          , lt = k.low & 65535
          , st = 0
          , ut = 0
          , ct = 0
          , pt = 0;
        return pt += nt * lt,
        ct += pt >>> 16,
        pt &= 65535,
        ct += rt * lt,
        ut += ct >>> 16,
        ct &= 65535,
        ct += nt * at,
        ut += ct >>> 16,
        ct &= 65535,
        ut += tt * lt,
        st += ut >>> 16,
        ut &= 65535,
        ut += rt * at,
        st += ut >>> 16,
        ut &= 65535,
        ut += nt * it,
        st += ut >>> 16,
        ut &= 65535,
        st += et * lt + tt * at + rt * it + nt * ot,
        st &= 65535,
        fromBits(ct << 16 | pt, st << 16 | ut, this.unsigned)
    }
    ,
    LongPrototype.mul = LongPrototype.multiply,
    LongPrototype.divide = function _(k) {
        if (isLong(k) || (k = fromValue(k)),
        k.isZero())
            throw Error("division by zero");
        if (wasm) {
            if (!this.unsigned && this.high === -2147483648 && k.low === -1 && k.high === -1)
                return this;
            var J = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, k.low, k.high);
            return fromBits(J, wasm.get_high(), this.unsigned)
        }
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var et, tt, rt;
        if (this.unsigned) {
            if (k.unsigned || (k = k.toUnsigned()),
            k.gt(this))
                return UZERO;
            if (k.gt(this.shru(1)))
                return UONE;
            rt = UZERO
        } else {
            if (this.eq(MIN_VALUE)) {
                if (k.eq(ONE) || k.eq(NEG_ONE))
                    return MIN_VALUE;
                if (k.eq(MIN_VALUE))
                    return ONE;
                var nt = this.shr(1);
                return et = nt.div(k).shl(1),
                et.eq(ZERO) ? k.isNegative() ? ONE : NEG_ONE : (tt = this.sub(k.mul(et)),
                rt = et.add(tt.div(k)),
                rt)
            } else if (k.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative())
                return k.isNegative() ? this.neg().div(k.neg()) : this.neg().div(k).neg();
            if (k.isNegative())
                return this.div(k.neg()).neg();
            rt = ZERO
        }
        for (tt = this; tt.gte(k); ) {
            et = Math.max(1, Math.floor(tt.toNumber() / k.toNumber()));
            for (var ot = Math.ceil(Math.log(et) / Math.LN2), it = ot <= 48 ? 1 : pow_dbl(2, ot - 48), at = fromNumber(et), lt = at.mul(k); lt.isNegative() || lt.gt(tt); )
                et -= it,
                at = fromNumber(et, this.unsigned),
                lt = at.mul(k);
            at.isZero() && (at = ONE),
            rt = rt.add(at),
            tt = tt.sub(lt)
        }
        return rt
    }
    ,
    LongPrototype.div = LongPrototype.divide,
    LongPrototype.modulo = function _(k) {
        if (isLong(k) || (k = fromValue(k)),
        wasm) {
            var J = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, k.low, k.high);
            return fromBits(J, wasm.get_high(), this.unsigned)
        }
        return this.sub(this.div(k).mul(k))
    }
    ,
    LongPrototype.mod = LongPrototype.modulo,
    LongPrototype.rem = LongPrototype.modulo,
    LongPrototype.not = function _() {
        return fromBits(~this.low, ~this.high, this.unsigned)
    }
    ,
    LongPrototype.countLeadingZeros = function _() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32
    }
    ,
    LongPrototype.clz = LongPrototype.countLeadingZeros,
    LongPrototype.countTrailingZeros = function _() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32
    }
    ,
    LongPrototype.ctz = LongPrototype.countTrailingZeros,
    LongPrototype.and = function _(k) {
        return isLong(k) || (k = fromValue(k)),
        fromBits(this.low & k.low, this.high & k.high, this.unsigned)
    }
    ,
    LongPrototype.or = function _(k) {
        return isLong(k) || (k = fromValue(k)),
        fromBits(this.low | k.low, this.high | k.high, this.unsigned)
    }
    ,
    LongPrototype.xor = function _(k) {
        return isLong(k) || (k = fromValue(k)),
        fromBits(this.low ^ k.low, this.high ^ k.high, this.unsigned)
    }
    ,
    LongPrototype.shiftLeft = function _(k) {
        return isLong(k) && (k = k.toInt()),
        (k &= 63) === 0 ? this : k < 32 ? fromBits(this.low << k, this.high << k | this.low >>> 32 - k, this.unsigned) : fromBits(0, this.low << k - 32, this.unsigned)
    }
    ,
    LongPrototype.shl = LongPrototype.shiftLeft,
    LongPrototype.shiftRight = function _(k) {
        return isLong(k) && (k = k.toInt()),
        (k &= 63) === 0 ? this : k < 32 ? fromBits(this.low >>> k | this.high << 32 - k, this.high >> k, this.unsigned) : fromBits(this.high >> k - 32, this.high >= 0 ? 0 : -1, this.unsigned)
    }
    ,
    LongPrototype.shr = LongPrototype.shiftRight,
    LongPrototype.shiftRightUnsigned = function _(k) {
        return isLong(k) && (k = k.toInt()),
        (k &= 63) === 0 ? this : k < 32 ? fromBits(this.low >>> k | this.high << 32 - k, this.high >>> k, this.unsigned) : k === 32 ? fromBits(this.high, 0, this.unsigned) : fromBits(this.high >>> k - 32, 0, this.unsigned)
    }
    ,
    LongPrototype.shru = LongPrototype.shiftRightUnsigned,
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned,
    LongPrototype.rotateLeft = function _(k) {
        var J;
        return isLong(k) && (k = k.toInt()),
        (k &= 63) === 0 ? this : k === 32 ? fromBits(this.high, this.low, this.unsigned) : k < 32 ? (J = 32 - k,
        fromBits(this.low << k | this.high >>> J, this.high << k | this.low >>> J, this.unsigned)) : (k -= 32,
        J = 32 - k,
        fromBits(this.high << k | this.low >>> J, this.low << k | this.high >>> J, this.unsigned))
    }
    ,
    LongPrototype.rotl = LongPrototype.rotateLeft,
    LongPrototype.rotateRight = function _(k) {
        var J;
        return isLong(k) && (k = k.toInt()),
        (k &= 63) === 0 ? this : k === 32 ? fromBits(this.high, this.low, this.unsigned) : k < 32 ? (J = 32 - k,
        fromBits(this.high << J | this.low >>> k, this.low << J | this.high >>> k, this.unsigned)) : (k -= 32,
        J = 32 - k,
        fromBits(this.low << J | this.high >>> k, this.high << J | this.low >>> k, this.unsigned))
    }
    ,
    LongPrototype.rotr = LongPrototype.rotateRight,
    LongPrototype.toSigned = function _() {
        return this.unsigned ? fromBits(this.low, this.high, !1) : this
    }
    ,
    LongPrototype.toUnsigned = function _() {
        return this.unsigned ? this : fromBits(this.low, this.high, !0)
    }
    ,
    LongPrototype.toBytes = function _(k) {
        return k ? this.toBytesLE() : this.toBytesBE()
    }
    ,
    LongPrototype.toBytesLE = function _() {
        var k = this.high
          , J = this.low;
        return [J & 255, J >>> 8 & 255, J >>> 16 & 255, J >>> 24, k & 255, k >>> 8 & 255, k >>> 16 & 255, k >>> 24]
    }
    ,
    LongPrototype.toBytesBE = function _() {
        var k = this.high
          , J = this.low;
        return [k >>> 24, k >>> 16 & 255, k >>> 8 & 255, k & 255, J >>> 24, J >>> 16 & 255, J >>> 8 & 255, J & 255]
    }
    ,
    Long.fromBytes = function _(k, J, et) {
        return et ? Long.fromBytesLE(k, J) : Long.fromBytesBE(k, J)
    }
    ,
    Long.fromBytesLE = function _(k, J) {
        return new Long(k[0] | k[1] << 8 | k[2] << 16 | k[3] << 24,k[4] | k[5] << 8 | k[6] << 16 | k[7] << 24,J)
    }
    ,
    Long.fromBytesBE = function _(k, J) {
        return new Long(k[4] << 24 | k[5] << 16 | k[6] << 8 | k[7],k[0] << 24 | k[1] << 16 | k[2] << 8 | k[3],J)
    }
    ,
    ErrorCode$1 = {
        TWOFA_ERROR: 4002,
        INSUFFICIENT_BALANCE: 5002,
        SAME_EMAIL: 5801,
        IS_MUTE: 6001,
        NEED_LOGIN: 6002,
        SESSION_ERROR: 6003,
        NEED_VERIFY: 6004,
        IS_BLOCKED: 6005,
        LOCKED_BY_KYC: 6008,
        NEED_EMAIL_AND_BASIC_KYC: 6101,
        NEED_EMAIL_AND_ADVANCED_KYC: 6102,
        NEED_PHONE_AND_BASIC_KYC: 6103,
        NEED_PHONE_AND_ADVANCED_KYC: 6104,
        NEED_EMAIL_OR_PHONE_AND_BASIC_KYC: 6105,
        NEED_EMAIL_OR_PHONE_AND_ADVANCED_KYC: 6106,
        NEED_EMAIL_AND_PHONE_AND_BASIC_KYC: 6107,
        NEED_EMAIL_AND_PHONE_AND_ADVANCED_KYC: 6108,
        NEED_BASIC_KYC: 6109,
        NEED_ADVANCED_KYC: 6110,
        FINAL_REJECT_KYC: 6111,
        IS_UPDATING: 1999
    };
    var lib$1 = {
        exports: {}
    }
      , re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
      , parts = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]
      , parseuri$2 = function _(k) {
        var J = k
          , et = k.indexOf("[")
          , tt = k.indexOf("]");
        et != -1 && tt != -1 && (k = k.substring(0, et) + k.substring(et, tt).replace(/:/g, ";") + k.substring(tt, k.length));
        for (var rt = re.exec(k || ""), nt = {}, ot = 14; ot--; )
            nt[parts[ot]] = rt[ot] || "";
        return et != -1 && tt != -1 && (nt.source = J,
        nt.host = nt.host.substring(1, nt.host.length - 1).replace(/;/g, ":"),
        nt.authority = nt.authority.replace("[", "").replace("]", "").replace(/;/g, ":"),
        nt.ipv6uri = !0),
        nt.pathNames = pathNames(nt, nt.path),
        nt.queryKey = queryKey(nt, nt.query),
        nt
    };
    function pathNames(_, k) {
        var J = /\/{2,9}/g
          , et = k.replace(J, "/").split("/");
        return (k.substr(0, 1) == "/" || k.length === 0) && et.splice(0, 1),
        k.substr(k.length - 1, 1) == "/" && et.splice(et.length - 1, 1),
        et
    }
    function queryKey(_, k) {
        var J = {};
        return k.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(et, tt, rt) {
            tt && (J[tt] = rt)
        }),
        J
    }
    var browser$3 = {
        exports: {}
    }
      , debug$8 = {
        exports: {}
    }
      , s$3 = 1e3
      , m$3 = s$3 * 60
      , h$2 = m$3 * 60
      , d$3 = h$2 * 24
      , y$3 = d$3 * 365.25
      , ms$2 = function(_, k) {
        k = k || {};
        var J = typeof _;
        if (J === "string" && _.length > 0)
            return parse$2(_);
        if (J === "number" && isNaN(_) === !1)
            return k.long ? fmtLong$2(_) : fmtShort$2(_);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
    };
    function parse$2(_) {
        if (_ = String(_),
        !(_.length > 100)) {
            var k = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (k) {
                var J = parseFloat(k[1])
                  , et = (k[2] || "ms").toLowerCase();
                switch (et) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return J * y$3;
                case "days":
                case "day":
                case "d":
                    return J * d$3;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return J * h$2;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return J * m$3;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return J * s$3;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return J;
                default:
                    return
                }
            }
        }
    }
    function fmtShort$2(_) {
        return _ >= d$3 ? Math.round(_ / d$3) + "d" : _ >= h$2 ? Math.round(_ / h$2) + "h" : _ >= m$3 ? Math.round(_ / m$3) + "m" : _ >= s$3 ? Math.round(_ / s$3) + "s" : _ + "ms"
    }
    function fmtLong$2(_) {
        return plural$2(_, d$3, "day") || plural$2(_, h$2, "hour") || plural$2(_, m$3, "minute") || plural$2(_, s$3, "second") || _ + " ms"
    }
    function plural$2(_, k, J) {
        if (!(_ < k))
            return _ < k * 1.5 ? Math.floor(_ / k) + " " + J : Math.ceil(_ / k) + " " + J + "s"
    }
    (function(_, k) {
        k = _.exports = et.debug = et.default = et,
        k.coerce = it,
        k.disable = nt,
        k.enable = rt,
        k.enabled = ot,
        k.humanize = ms$2,
        k.instances = [],
        k.names = [],
        k.skips = [],
        k.formatters = {};
        function J(at) {
            var lt = 0, st;
            for (st in at)
                lt = (lt << 5) - lt + at.charCodeAt(st),
                lt |= 0;
            return k.colors[Math.abs(lt) % k.colors.length]
        }
        function et(at) {
            var lt;
            function st() {
                if (st.enabled) {
                    var ut = st
                      , ct = +new Date
                      , pt = ct - (lt || ct);
                    ut.diff = pt,
                    ut.prev = lt,
                    ut.curr = ct,
                    lt = ct;
                    for (var ft = new Array(arguments.length), yt = 0; yt < ft.length; yt++)
                        ft[yt] = arguments[yt];
                    ft[0] = k.coerce(ft[0]),
                    typeof ft[0] != "string" && ft.unshift("%O");
                    var ht = 0;
                    ft[0] = ft[0].replace(/%([a-zA-Z%])/g, function(mt, vt) {
                        if (mt === "%%")
                            return mt;
                        ht++;
                        var bt = k.formatters[vt];
                        if (typeof bt == "function") {
                            var Et = ft[ht];
                            mt = bt.call(ut, Et),
                            ft.splice(ht, 1),
                            ht--
                        }
                        return mt
                    }),
                    k.formatArgs.call(ut, ft);
                    var gt = st.log || k.log || void 0;
                    gt.apply(ut, ft)
                }
            }
            return st.namespace = at,
            st.enabled = k.enabled(at),
            st.useColors = k.useColors(),
            st.color = J(at),
            st.destroy = tt,
            typeof k.init == "function" && k.init(st),
            k.instances.push(st),
            st
        }
        function tt() {
            var at = k.instances.indexOf(this);
            return at !== -1 ? (k.instances.splice(at, 1),
            !0) : !1
        }
        function rt(at) {
            k.save(at),
            k.names = [],
            k.skips = [];
            var lt, st = (typeof at == "string" ? at : "").split(/[\s,]+/), ut = st.length;
            for (lt = 0; lt < ut; lt++)
                st[lt] && (at = st[lt].replace(/\*/g, ".*?"),
                at[0] === "-" ? k.skips.push(new RegExp("^" + at.substr(1) + "$")) : k.names.push(new RegExp("^" + at + "$")));
            for (lt = 0; lt < k.instances.length; lt++) {
                var ct = k.instances[lt];
                ct.enabled = k.enabled(ct.namespace)
            }
        }
        function nt() {
            k.enable("")
        }
        function ot(at) {
            if (at[at.length - 1] === "*")
                return !0;
            var lt, st;
            for (lt = 0,
            st = k.skips.length; lt < st; lt++)
                if (k.skips[lt].test(at))
                    return !1;
            for (lt = 0,
            st = k.names.length; lt < st; lt++)
                if (k.names[lt].test(at))
                    return !0;
            return !1
        }
        function it(at) {
            return at instanceof Error ? at.stack || at.message : at
        }
    }
    )(debug$8, debug$8.exports);
    var debugExports$2 = debug$8.exports;
    (function(_, k) {
        k = _.exports = debugExports$2,
        k.log = tt,
        k.formatArgs = et,
        k.save = rt,
        k.load = nt,
        k.useColors = J,
        k.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : ot(),
        k.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function J() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        k.formatters.j = function(it) {
            try {
                return JSON.stringify(it)
            } catch (at) {
                return "[UnexpectedJSONParseError]: " + at.message
            }
        }
        ;
        function et(it) {
            var at = this.useColors;
            if (it[0] = (at ? "%c" : "") + this.namespace + (at ? " %c" : " ") + it[0] + (at ? "%c " : " ") + "+" + k.humanize(this.diff),
            !!at) {
                var lt = "color: " + this.color;
                it.splice(1, 0, lt, "color: inherit");
                var st = 0
                  , ut = 0;
                it[0].replace(/%[a-zA-Z%]/g, function(ct) {
                    ct !== "%%" && (st++,
                    ct === "%c" && (ut = st))
                }),
                it.splice(ut, 0, lt)
            }
        }
        function tt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }
        function rt(it) {
            try {
                it == null ? k.storage.removeItem("debug") : k.storage.debug = it
            } catch (at) {}
        }
        function nt() {
            var it;
            try {
                it = k.storage.debug
            } catch (at) {}
            return !it && typeof process < "u" && "env"in process && (it = {}.DEBUG),
            it
        }
        k.enable(nt());
        function ot() {
            try {
                return window.localStorage
            } catch (it) {}
        }
    }
    )(browser$3, browser$3.exports);
    var browserExports$2 = browser$3.exports
      , parseuri$1 = parseuri$2
      , debug$7 = browserExports$2("socket.io-client:url")
      , url_1 = url;
    function url(_, k) {
        var J = _;
        k = k || typeof location < "u" && location,
        _ == null && (_ = k.protocol + "//" + k.host),
        typeof _ == "string" && (_.charAt(0) === "/" && (_.charAt(1) === "/" ? _ = k.protocol + _ : _ = k.host + _),
        /^(https?|wss?):\/\//.test(_) || (debug$7("protocol-less url %s", _),
        typeof k < "u" ? _ = k.protocol + "//" + _ : _ = "https://" + _),
        debug$7("parse %s", _),
        J = parseuri$1(_)),
        J.port || (/^(http|ws)$/.test(J.protocol) ? J.port = "80" : /^(http|ws)s$/.test(J.protocol) && (J.port = "443")),
        J.path = J.path || "/";
        var et = J.host.indexOf(":") !== -1
          , tt = et ? "[" + J.host + "]" : J.host;
        return J.id = J.protocol + "://" + tt + ":" + J.port,
        J.href = J.protocol + "://" + tt + (k && k.port === J.port ? "" : ":" + J.port),
        J
    }
    var socket_ioParser = {}
      , browser$2 = {
        exports: {}
    }
      , debug$6 = {
        exports: {}
    }
      , s$2 = 1e3
      , m$2 = s$2 * 60
      , h$1 = m$2 * 60
      , d$2 = h$1 * 24
      , y$2 = d$2 * 365.25
      , ms$1 = function(_, k) {
        k = k || {};
        var J = typeof _;
        if (J === "string" && _.length > 0)
            return parse$1(_);
        if (J === "number" && isNaN(_) === !1)
            return k.long ? fmtLong$1(_) : fmtShort$1(_);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
    };
    function parse$1(_) {
        if (_ = String(_),
        !(_.length > 100)) {
            var k = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (k) {
                var J = parseFloat(k[1])
                  , et = (k[2] || "ms").toLowerCase();
                switch (et) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return J * y$2;
                case "days":
                case "day":
                case "d":
                    return J * d$2;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return J * h$1;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return J * m$2;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return J * s$2;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return J;
                default:
                    return
                }
            }
        }
    }
    function fmtShort$1(_) {
        return _ >= d$2 ? Math.round(_ / d$2) + "d" : _ >= h$1 ? Math.round(_ / h$1) + "h" : _ >= m$2 ? Math.round(_ / m$2) + "m" : _ >= s$2 ? Math.round(_ / s$2) + "s" : _ + "ms"
    }
    function fmtLong$1(_) {
        return plural$1(_, d$2, "day") || plural$1(_, h$1, "hour") || plural$1(_, m$2, "minute") || plural$1(_, s$2, "second") || _ + " ms"
    }
    function plural$1(_, k, J) {
        if (!(_ < k))
            return _ < k * 1.5 ? Math.floor(_ / k) + " " + J : Math.ceil(_ / k) + " " + J + "s"
    }
    (function(_, k) {
        k = _.exports = et.debug = et.default = et,
        k.coerce = it,
        k.disable = nt,
        k.enable = rt,
        k.enabled = ot,
        k.humanize = ms$1,
        k.instances = [],
        k.names = [],
        k.skips = [],
        k.formatters = {};
        function J(at) {
            var lt = 0, st;
            for (st in at)
                lt = (lt << 5) - lt + at.charCodeAt(st),
                lt |= 0;
            return k.colors[Math.abs(lt) % k.colors.length]
        }
        function et(at) {
            var lt;
            function st() {
                if (st.enabled) {
                    var ut = st
                      , ct = +new Date
                      , pt = ct - (lt || ct);
                    ut.diff = pt,
                    ut.prev = lt,
                    ut.curr = ct,
                    lt = ct;
                    for (var ft = new Array(arguments.length), yt = 0; yt < ft.length; yt++)
                        ft[yt] = arguments[yt];
                    ft[0] = k.coerce(ft[0]),
                    typeof ft[0] != "string" && ft.unshift("%O");
                    var ht = 0;
                    ft[0] = ft[0].replace(/%([a-zA-Z%])/g, function(mt, vt) {
                        if (mt === "%%")
                            return mt;
                        ht++;
                        var bt = k.formatters[vt];
                        if (typeof bt == "function") {
                            var Et = ft[ht];
                            mt = bt.call(ut, Et),
                            ft.splice(ht, 1),
                            ht--
                        }
                        return mt
                    }),
                    k.formatArgs.call(ut, ft);
                    var gt = st.log || k.log || void 0;
                    gt.apply(ut, ft)
                }
            }
            return st.namespace = at,
            st.enabled = k.enabled(at),
            st.useColors = k.useColors(),
            st.color = J(at),
            st.destroy = tt,
            typeof k.init == "function" && k.init(st),
            k.instances.push(st),
            st
        }
        function tt() {
            var at = k.instances.indexOf(this);
            return at !== -1 ? (k.instances.splice(at, 1),
            !0) : !1
        }
        function rt(at) {
            k.save(at),
            k.names = [],
            k.skips = [];
            var lt, st = (typeof at == "string" ? at : "").split(/[\s,]+/), ut = st.length;
            for (lt = 0; lt < ut; lt++)
                st[lt] && (at = st[lt].replace(/\*/g, ".*?"),
                at[0] === "-" ? k.skips.push(new RegExp("^" + at.substr(1) + "$")) : k.names.push(new RegExp("^" + at + "$")));
            for (lt = 0; lt < k.instances.length; lt++) {
                var ct = k.instances[lt];
                ct.enabled = k.enabled(ct.namespace)
            }
        }
        function nt() {
            k.enable("")
        }
        function ot(at) {
            if (at[at.length - 1] === "*")
                return !0;
            var lt, st;
            for (lt = 0,
            st = k.skips.length; lt < st; lt++)
                if (k.skips[lt].test(at))
                    return !1;
            for (lt = 0,
            st = k.names.length; lt < st; lt++)
                if (k.names[lt].test(at))
                    return !0;
            return !1
        }
        function it(at) {
            return at instanceof Error ? at.stack || at.message : at
        }
    }
    )(debug$6, debug$6.exports);
    var debugExports$1 = debug$6.exports;
    (function(_, k) {
        k = _.exports = debugExports$1,
        k.log = tt,
        k.formatArgs = et,
        k.save = rt,
        k.load = nt,
        k.useColors = J,
        k.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : ot(),
        k.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function J() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        k.formatters.j = function(it) {
            try {
                return JSON.stringify(it)
            } catch (at) {
                return "[UnexpectedJSONParseError]: " + at.message
            }
        }
        ;
        function et(it) {
            var at = this.useColors;
            if (it[0] = (at ? "%c" : "") + this.namespace + (at ? " %c" : " ") + it[0] + (at ? "%c " : " ") + "+" + k.humanize(this.diff),
            !!at) {
                var lt = "color: " + this.color;
                it.splice(1, 0, lt, "color: inherit");
                var st = 0
                  , ut = 0;
                it[0].replace(/%[a-zA-Z%]/g, function(ct) {
                    ct !== "%%" && (st++,
                    ct === "%c" && (ut = st))
                }),
                it.splice(ut, 0, lt)
            }
        }
        function tt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }
        function rt(it) {
            try {
                it == null ? k.storage.removeItem("debug") : k.storage.debug = it
            } catch (at) {}
        }
        function nt() {
            var it;
            try {
                it = k.storage.debug
            } catch (at) {}
            return !it && typeof process < "u" && "env"in process && (it = {}.DEBUG),
            it
        }
        k.enable(nt());
        function ot() {
            try {
                return window.localStorage
            } catch (it) {}
        }
    }
    )(browser$2, browser$2.exports);
    var browserExports$1 = browser$2.exports
      , componentEmitter = {
        exports: {}
    };
    (function(_) {
        _.exports = k;
        function k(et) {
            if (et)
                return J(et)
        }
        function J(et) {
            for (var tt in k.prototype)
                et[tt] = k.prototype[tt];
            return et
        }
        k.prototype.on = k.prototype.addEventListener = function(et, tt) {
            return this._callbacks = this._callbacks || {},
            (this._callbacks["$" + et] = this._callbacks["$" + et] || []).push(tt),
            this
        }
        ,
        k.prototype.once = function(et, tt) {
            function rt() {
                this.off(et, rt),
                tt.apply(this, arguments)
            }
            return rt.fn = tt,
            this.on(et, rt),
            this
        }
        ,
        k.prototype.off = k.prototype.removeListener = k.prototype.removeAllListeners = k.prototype.removeEventListener = function(et, tt) {
            if (this._callbacks = this._callbacks || {},
            arguments.length == 0)
                return this._callbacks = {},
                this;
            var rt = this._callbacks["$" + et];
            if (!rt)
                return this;
            if (arguments.length == 1)
                return delete this._callbacks["$" + et],
                this;
            for (var nt, ot = 0; ot < rt.length; ot++)
                if (nt = rt[ot],
                nt === tt || nt.fn === tt) {
                    rt.splice(ot, 1);
                    break
                }
            return rt.length === 0 && delete this._callbacks["$" + et],
            this
        }
        ,
        k.prototype.emit = function(et) {
            this._callbacks = this._callbacks || {};
            for (var tt = new Array(arguments.length - 1), rt = this._callbacks["$" + et], nt = 1; nt < arguments.length; nt++)
                tt[nt - 1] = arguments[nt];
            if (rt) {
                rt = rt.slice(0);
                for (var nt = 0, ot = rt.length; nt < ot; ++nt)
                    rt[nt].apply(this, tt)
            }
            return this
        }
        ,
        k.prototype.listeners = function(et) {
            return this._callbacks = this._callbacks || {},
            this._callbacks["$" + et] || []
        }
        ,
        k.prototype.hasListeners = function(et) {
            return !!this.listeners(et).length
        }
    }
    )(componentEmitter);
    var componentEmitterExports = componentEmitter.exports
      , binary = {}
      , toString$2 = {}.toString
      , isarray = Array.isArray || function(_) {
        return toString$2.call(_) == "[object Array]"
    }
      , isBuffer = isBuf$1
      , withNativeBuffer = typeof Buffer == "function" && typeof Buffer.isBuffer == "function"
      , withNativeArrayBuffer = typeof ArrayBuffer == "function"
      , isView = function(_) {
        return typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(_) : _.buffer instanceof ArrayBuffer
    };
    function isBuf$1(_) {
        return withNativeBuffer && Buffer.isBuffer(_) || withNativeArrayBuffer && (_ instanceof ArrayBuffer || isView(_))
    }
    var isArray$1 = isarray
      , isBuf = isBuffer
      , toString$1 = Object.prototype.toString
      , withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && toString$1.call(Blob) === "[object BlobConstructor]"
      , withNativeFile$1 = typeof File == "function" || typeof File < "u" && toString$1.call(File) === "[object FileConstructor]";
    binary.deconstructPacket = function(_) {
        var k = []
          , J = _.data
          , et = _;
        return et.data = _deconstructPacket(J, k),
        et.attachments = k.length,
        {
            packet: et,
            buffers: k
        }
    }
    ;
    function _deconstructPacket(_, k) {
        if (!_)
            return _;
        if (isBuf(_)) {
            var J = {
                _placeholder: !0,
                num: k.length
            };
            return k.push(_),
            J
        } else if (isArray$1(_)) {
            for (var et = new Array(_.length), tt = 0; tt < _.length; tt++)
                et[tt] = _deconstructPacket(_[tt], k);
            return et
        } else if (typeof _ == "object" && !(_ instanceof Date)) {
            var et = {};
            for (var rt in _)
                et[rt] = _deconstructPacket(_[rt], k);
            return et
        }
        return _
    }
    binary.reconstructPacket = function(_, k) {
        return _.data = _reconstructPacket(_.data, k),
        _.attachments = void 0,
        _
    }
    ;
    function _reconstructPacket(_, k) {
        if (!_)
            return _;
        if (_ && _._placeholder === !0) {
            var J = typeof _.num == "number" && _.num >= 0 && _.num < k.length;
            if (J)
                return k[_.num];
            throw new Error("illegal attachments")
        } else if (isArray$1(_))
            for (var et = 0; et < _.length; et++)
                _[et] = _reconstructPacket(_[et], k);
        else if (typeof _ == "object")
            for (var tt in _)
                _[tt] = _reconstructPacket(_[tt], k);
        return _
    }
    binary.removeBlobs = function(_, k) {
        function J(rt, nt, ot) {
            if (!rt)
                return rt;
            if (withNativeBlob$1 && rt instanceof Blob || withNativeFile$1 && rt instanceof File) {
                et++;
                var it = new FileReader;
                it.onload = function() {
                    ot ? ot[nt] = this.result : tt = this.result,
                    --et || k(tt)
                }
                ,
                it.readAsArrayBuffer(rt)
            } else if (isArray$1(rt))
                for (var at = 0; at < rt.length; at++)
                    J(rt[at], at, rt);
            else if (typeof rt == "object" && !isBuf(rt))
                for (var lt in rt)
                    J(rt[lt], lt, rt)
        }
        var et = 0
          , tt = _;
        J(tt),
        et || k(tt)
    }
    ,
    function(_) {
        var k = browserExports$1("socket.io-parser")
          , J = componentEmitterExports
          , et = binary
          , tt = isarray
          , rt = isBuffer;
        _.protocol = 4,
        _.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"],
        _.CONNECT = 0,
        _.DISCONNECT = 1,
        _.EVENT = 2,
        _.ACK = 3,
        _.ERROR = 4,
        _.BINARY_EVENT = 5,
        _.BINARY_ACK = 6,
        _.Encoder = nt,
        _.Decoder = st;
        function nt() {}
        var ot = _.ERROR + '"encode error"';
        nt.prototype.encode = function(yt, ht) {
            if (k("encoding packet %j", yt),
            _.BINARY_EVENT === yt.type || _.BINARY_ACK === yt.type)
                lt(yt, ht);
            else {
                var gt = it(yt);
                ht([gt])
            }
        }
        ;
        function it(yt) {
            var ht = "" + yt.type;
            if ((_.BINARY_EVENT === yt.type || _.BINARY_ACK === yt.type) && (ht += yt.attachments + "-"),
            yt.nsp && yt.nsp !== "/" && (ht += yt.nsp + ","),
            yt.id != null && (ht += yt.id),
            yt.data != null) {
                var gt = at(yt.data);
                if (gt !== !1)
                    ht += gt;
                else
                    return ot
            }
            return k("encoded %j as %s", yt, ht),
            ht
        }
        function at(yt) {
            try {
                return JSON.stringify(yt)
            } catch (ht) {
                return !1
            }
        }
        function lt(yt, ht) {
            function gt(mt) {
                var vt = et.deconstructPacket(mt)
                  , bt = it(vt.packet)
                  , Et = vt.buffers;
                Et.unshift(bt),
                ht(Et)
            }
            et.removeBlobs(yt, gt)
        }
        function st() {
            this.reconstructor = null
        }
        J(st.prototype),
        st.prototype.add = function(yt) {
            var ht;
            if (typeof yt == "string") {
                if (this.reconstructor)
                    throw new Error("got plaintext data when reconstructing a packet");
                ht = ut(yt),
                _.BINARY_EVENT === ht.type || _.BINARY_ACK === ht.type ? (this.reconstructor = new pt(ht),
                this.reconstructor.reconPack.attachments === 0 && this.emit("decoded", ht)) : this.emit("decoded", ht)
            } else if (rt(yt) || yt.base64)
                if (this.reconstructor)
                    ht = this.reconstructor.takeBinaryData(yt),
                    ht && (this.reconstructor = null,
                    this.emit("decoded", ht));
                else
                    throw new Error("got binary data when not reconstructing a packet");
            else
                throw new Error("Unknown type: " + yt)
        }
        ;
        function ut(yt) {
            var ht = 0
              , gt = {
                type: Number(yt.charAt(0))
            };
            if (_.types[gt.type] == null)
                return ft("unknown packet type " + gt.type);
            if (_.BINARY_EVENT === gt.type || _.BINARY_ACK === gt.type) {
                for (var mt = ht + 1; yt.charAt(++ht) !== "-" && ht != yt.length; )
                    ;
                var vt = yt.substring(mt, ht);
                if (vt != Number(vt) || yt.charAt(ht) !== "-")
                    throw new Error("Illegal attachments");
                gt.attachments = Number(vt)
            }
            if (yt.charAt(ht + 1) === "/") {
                for (var mt = ht + 1; ++ht; ) {
                    var bt = yt.charAt(ht);
                    if (bt === "," || ht === yt.length)
                        break
                }
                gt.nsp = yt.substring(mt, ht)
            } else
                gt.nsp = "/";
            var Et = yt.charAt(ht + 1);
            if (Et !== "" && Number(Et) == Et) {
                for (var mt = ht + 1; ++ht; ) {
                    var bt = yt.charAt(ht);
                    if (bt == null || Number(bt) != bt) {
                        --ht;
                        break
                    }
                    if (ht === yt.length)
                        break
                }
                gt.id = Number(yt.substring(mt, ht + 1))
            }
            if (yt.charAt(++ht)) {
                var xt = ct(yt.substr(ht))
                  , wt = xt !== !1 && (gt.type === _.ERROR || tt(xt));
                if (wt)
                    gt.data = xt;
                else
                    return ft("invalid payload")
            }
            return k("decoded %s as %j", yt, gt),
            gt
        }
        function ct(yt) {
            try {
                return JSON.parse(yt)
            } catch (ht) {
                return !1
            }
        }
        st.prototype.destroy = function() {
            this.reconstructor && this.reconstructor.finishedReconstruction()
        }
        ;
        function pt(yt) {
            this.reconPack = yt,
            this.buffers = []
        }
        pt.prototype.takeBinaryData = function(yt) {
            if (this.buffers.push(yt),
            this.buffers.length === this.reconPack.attachments) {
                var ht = et.reconstructPacket(this.reconPack, this.buffers);
                return this.finishedReconstruction(),
                ht
            }
            return null
        }
        ,
        pt.prototype.finishedReconstruction = function() {
            this.reconPack = null,
            this.buffers = []
        }
        ;
        function ft(yt) {
            return {
                type: _.ERROR,
                data: "parser error: " + yt
            }
        }
    }(socket_ioParser);
    var lib = {
        exports: {}
    }
      , transports$1 = {}
      , hasCors = {
        exports: {}
    };
    try {
        hasCors.exports = typeof XMLHttpRequest < "u" && "withCredentials"in new XMLHttpRequest
    } catch (_) {
        hasCors.exports = !1
    }
    var hasCorsExports = hasCors.exports
      , globalThis_browser = function() {
        return typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")()
    }()
      , hasCORS = hasCorsExports
      , globalThis$3 = globalThis_browser
      , xmlhttprequest_browser = function(_) {
        var k = _.xdomain
          , J = _.xscheme
          , et = _.enablesXDR;
        try {
            if (typeof XMLHttpRequest < "u" && (!k || hasCORS))
                return new XMLHttpRequest
        } catch (tt) {}
        try {
            if (typeof XDomainRequest < "u" && !J && et)
                return new XDomainRequest
        } catch (tt) {}
        if (!k)
            try {
                return new globalThis$3[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")
            } catch (tt) {}
    }
      , pollingXhr = {
        exports: {}
    }
      , browser$1 = {}
      , keys = Object.keys || function _(k) {
        var J = []
          , et = Object.prototype.hasOwnProperty;
        for (var tt in k)
            et.call(k, tt) && J.push(tt);
        return J
    }
      , isArray = isarray
      , toString = Object.prototype.toString
      , withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]"
      , withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]"
      , hasBinary2 = hasBinary;
    function hasBinary(_) {
        if (!_ || typeof _ != "object")
            return !1;
        if (isArray(_)) {
            for (var k = 0, J = _.length; k < J; k++)
                if (hasBinary(_[k]))
                    return !0;
            return !1
        }
        if (typeof Buffer == "function" && Buffer.isBuffer && Buffer.isBuffer(_) || typeof ArrayBuffer == "function" && _ instanceof ArrayBuffer || withNativeBlob && _ instanceof Blob || withNativeFile && _ instanceof File)
            return !0;
        if (_.toJSON && typeof _.toJSON == "function" && arguments.length === 1)
            return hasBinary(_.toJSON(), !0);
        for (var et in _)
            if (Object.prototype.hasOwnProperty.call(_, et) && hasBinary(_[et]))
                return !0;
        return !1
    }
    var arraybuffer_slice = function(_, k, J) {
        var et = _.byteLength;
        if (k = k || 0,
        J = J || et,
        _.slice)
            return _.slice(k, J);
        if (k < 0 && (k += et),
        J < 0 && (J += et),
        J > et && (J = et),
        k >= et || k >= J || et === 0)
            return new ArrayBuffer(0);
        for (var tt = new Uint8Array(_), rt = new Uint8Array(J - k), nt = k, ot = 0; nt < J; nt++,
        ot++)
            rt[ot] = tt[nt];
        return rt.buffer
    }
      , after_1 = after;
    function after(_, k, J) {
        var et = !1;
        return J = J || noop$2,
        tt.count = _,
        _ === 0 ? k() : tt;
        function tt(rt, nt) {
            if (tt.count <= 0)
                throw new Error("after called too many times");
            --tt.count,
            rt ? (et = !0,
            k(rt),
            k = J) : tt.count === 0 && !et && k(null, nt)
        }
    }
    function noop$2() {}
    var stringFromCharCode = String.fromCharCode;
    function ucs2decode(_) {
        for (var k = [], J = 0, et = _.length, tt, rt; J < et; )
            tt = _.charCodeAt(J++),
            tt >= 55296 && tt <= 56319 && J < et ? (rt = _.charCodeAt(J++),
            (rt & 64512) == 56320 ? k.push(((tt & 1023) << 10) + (rt & 1023) + 65536) : (k.push(tt),
            J--)) : k.push(tt);
        return k
    }
    function ucs2encode(_) {
        for (var k = _.length, J = -1, et, tt = ""; ++J < k; )
            et = _[J],
            et > 65535 && (et -= 65536,
            tt += stringFromCharCode(et >>> 10 & 1023 | 55296),
            et = 56320 | et & 1023),
            tt += stringFromCharCode(et);
        return tt
    }
    function checkScalarValue(_, k) {
        if (_ >= 55296 && _ <= 57343) {
            if (k)
                throw Error("Lone surrogate U+" + _.toString(16).toUpperCase() + " is not a scalar value");
            return !1
        }
        return !0
    }
    function createByte(_, k) {
        return stringFromCharCode(_ >> k & 63 | 128)
    }
    function encodeCodePoint(_, k) {
        if (!(_ & 4294967168))
            return stringFromCharCode(_);
        var J = "";
        return _ & 4294965248 ? _ & 4294901760 ? _ & 4292870144 || (J = stringFromCharCode(_ >> 18 & 7 | 240),
        J += createByte(_, 12),
        J += createByte(_, 6)) : (checkScalarValue(_, k) || (_ = 65533),
        J = stringFromCharCode(_ >> 12 & 15 | 224),
        J += createByte(_, 6)) : J = stringFromCharCode(_ >> 6 & 31 | 192),
        J += stringFromCharCode(_ & 63 | 128),
        J
    }
    function utf8encode(_, k) {
        k = k || {};
        for (var J = k.strict !== !1, et = ucs2decode(_), tt = et.length, rt = -1, nt, ot = ""; ++rt < tt; )
            nt = et[rt],
            ot += encodeCodePoint(nt, J);
        return ot
    }
    function readContinuationByte() {
        if (byteIndex >= byteCount)
            throw Error("Invalid byte index");
        var _ = byteArray[byteIndex] & 255;
        if (byteIndex++,
        (_ & 192) == 128)
            return _ & 63;
        throw Error("Invalid continuation byte")
    }
    function decodeSymbol(_) {
        var k, J, et, tt, rt;
        if (byteIndex > byteCount)
            throw Error("Invalid byte index");
        if (byteIndex == byteCount)
            return !1;
        if (k = byteArray[byteIndex] & 255,
        byteIndex++,
        !(k & 128))
            return k;
        if ((k & 224) == 192) {
            if (J = readContinuationByte(),
            rt = (k & 31) << 6 | J,
            rt >= 128)
                return rt;
            throw Error("Invalid continuation byte")
        }
        if ((k & 240) == 224) {
            if (J = readContinuationByte(),
            et = readContinuationByte(),
            rt = (k & 15) << 12 | J << 6 | et,
            rt >= 2048)
                return checkScalarValue(rt, _) ? rt : 65533;
            throw Error("Invalid continuation byte")
        }
        if ((k & 248) == 240 && (J = readContinuationByte(),
        et = readContinuationByte(),
        tt = readContinuationByte(),
        rt = (k & 7) << 18 | J << 12 | et << 6 | tt,
        rt >= 65536 && rt <= 1114111))
            return rt;
        throw Error("Invalid UTF-8 detected")
    }
    var byteArray, byteCount, byteIndex;
    function utf8decode(_, k) {
        k = k || {};
        var J = k.strict !== !1;
        byteArray = ucs2decode(_),
        byteCount = byteArray.length,
        byteIndex = 0;
        for (var et = [], tt; (tt = decodeSymbol(J)) !== !1; )
            et.push(tt);
        return ucs2encode(et)
    }
    var utf8$2 = {
        version: "2.1.2",
        encode: utf8encode,
        decode: utf8decode
    }, base64Arraybuffer = {}, hasRequiredBase64Arraybuffer;
    function requireBase64Arraybuffer() {
        return hasRequiredBase64Arraybuffer || (hasRequiredBase64Arraybuffer = 1,
        function(_) {
            base64Arraybuffer.encode = function(k) {
                var J = new Uint8Array(k), et, tt = J.length, rt = "";
                for (et = 0; et < tt; et += 3)
                    rt += _[J[et] >> 2],
                    rt += _[(J[et] & 3) << 4 | J[et + 1] >> 4],
                    rt += _[(J[et + 1] & 15) << 2 | J[et + 2] >> 6],
                    rt += _[J[et + 2] & 63];
                return tt % 3 === 2 ? rt = rt.substring(0, rt.length - 1) + "=" : tt % 3 === 1 && (rt = rt.substring(0, rt.length - 2) + "=="),
                rt
            }
            ,
            base64Arraybuffer.decode = function(k) {
                var J = k.length * .75, et = k.length, tt, rt = 0, nt, ot, it, at;
                k[k.length - 1] === "=" && (J--,
                k[k.length - 2] === "=" && J--);
                var lt = new ArrayBuffer(J)
                  , st = new Uint8Array(lt);
                for (tt = 0; tt < et; tt += 4)
                    nt = _.indexOf(k[tt]),
                    ot = _.indexOf(k[tt + 1]),
                    it = _.indexOf(k[tt + 2]),
                    at = _.indexOf(k[tt + 3]),
                    st[rt++] = nt << 2 | ot >> 4,
                    st[rt++] = (ot & 15) << 4 | it >> 2,
                    st[rt++] = (it & 3) << 6 | at & 63;
                return lt
            }
        }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),
        base64Arraybuffer
    }
    var blob, hasRequiredBlob;
    function requireBlob() {
        if (hasRequiredBlob)
            return blob;
        hasRequiredBlob = 1;
        var _ = typeof _ < "u" ? _ : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : !1
          , k = function() {
            try {
                var ot = new Blob(["hi"]);
                return ot.size === 2
            } catch (it) {
                return !1
            }
        }()
          , J = k && function() {
            try {
                var ot = new Blob([new Uint8Array([1, 2])]);
                return ot.size === 2
            } catch (it) {
                return !1
            }
        }()
          , et = _ && _.prototype.append && _.prototype.getBlob;
        function tt(ot) {
            return ot.map(function(it) {
                if (it.buffer instanceof ArrayBuffer) {
                    var at = it.buffer;
                    if (it.byteLength !== at.byteLength) {
                        var lt = new Uint8Array(it.byteLength);
                        lt.set(new Uint8Array(at,it.byteOffset,it.byteLength)),
                        at = lt.buffer
                    }
                    return at
                }
                return it
            })
        }
        function rt(ot, it) {
            it = it || {};
            var at = new _;
            return tt(ot).forEach(function(lt) {
                at.append(lt)
            }),
            it.type ? at.getBlob(it.type) : at.getBlob()
        }
        function nt(ot, it) {
            return new Blob(tt(ot),it || {})
        }
        return typeof Blob < "u" && (rt.prototype = Blob.prototype,
        nt.prototype = Blob.prototype),
        blob = function() {
            return k ? J ? Blob : nt : et ? rt : void 0
        }(),
        blob
    }
    (function(_) {
        var k = keys, J = hasBinary2, et = arraybuffer_slice, tt = after_1, rt = utf8$2, nt;
        typeof ArrayBuffer < "u" && (nt = requireBase64Arraybuffer());
        var ot = typeof navigator < "u" && /Android/i.test(navigator.userAgent)
          , it = typeof navigator < "u" && /PhantomJS/i.test(navigator.userAgent)
          , at = ot || it;
        _.protocol = 3;
        var lt = _.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
        }
          , st = k(lt)
          , ut = {
            type: "error",
            data: "parser error"
        }
          , ct = requireBlob();
        _.encodePacket = function(vt, bt, Et, xt) {
            typeof bt == "function" && (xt = bt,
            bt = !1),
            typeof Et == "function" && (xt = Et,
            Et = null);
            var wt = vt.data === void 0 ? void 0 : vt.data.buffer || vt.data;
            if (typeof ArrayBuffer < "u" && wt instanceof ArrayBuffer)
                return ft(vt, bt, xt);
            if (typeof ct < "u" && wt instanceof ct)
                return ht(vt, bt, xt);
            if (wt && wt.base64)
                return pt(vt, xt);
            var St = lt[vt.type];
            return vt.data !== void 0 && (St += Et ? rt.encode(String(vt.data), {
                strict: !1
            }) : String(vt.data)),
            xt("" + St)
        }
        ;
        function pt(vt, bt) {
            var Et = "b" + _.packets[vt.type] + vt.data.data;
            return bt(Et)
        }
        function ft(vt, bt, Et) {
            if (!bt)
                return _.encodeBase64Packet(vt, Et);
            var xt = vt.data
              , wt = new Uint8Array(xt)
              , St = new Uint8Array(1 + xt.byteLength);
            St[0] = lt[vt.type];
            for (var Pt = 0; Pt < wt.length; Pt++)
                St[Pt + 1] = wt[Pt];
            return Et(St.buffer)
        }
        function yt(vt, bt, Et) {
            if (!bt)
                return _.encodeBase64Packet(vt, Et);
            var xt = new FileReader;
            return xt.onload = function() {
                _.encodePacket({
                    type: vt.type,
                    data: xt.result
                }, bt, !0, Et)
            }
            ,
            xt.readAsArrayBuffer(vt.data)
        }
        function ht(vt, bt, Et) {
            if (!bt)
                return _.encodeBase64Packet(vt, Et);
            if (at)
                return yt(vt, bt, Et);
            var xt = new Uint8Array(1);
            xt[0] = lt[vt.type];
            var wt = new ct([xt.buffer, vt.data]);
            return Et(wt)
        }
        _.encodeBase64Packet = function(vt, bt) {
            var Et = "b" + _.packets[vt.type];
            if (typeof ct < "u" && vt.data instanceof ct) {
                var xt = new FileReader;
                return xt.onload = function() {
                    var At = xt.result.split(",")[1];
                    bt(Et + At)
                }
                ,
                xt.readAsDataURL(vt.data)
            }
            var wt;
            try {
                wt = String.fromCharCode.apply(null, new Uint8Array(vt.data))
            } catch (At) {
                for (var St = new Uint8Array(vt.data), Pt = new Array(St.length), Rt = 0; Rt < St.length; Rt++)
                    Pt[Rt] = St[Rt];
                wt = String.fromCharCode.apply(null, Pt)
            }
            return Et += btoa(wt),
            bt(Et)
        }
        ,
        _.decodePacket = function(vt, bt, Et) {
            if (vt === void 0)
                return ut;
            if (typeof vt == "string") {
                if (vt.charAt(0) === "b")
                    return _.decodeBase64Packet(vt.substr(1), bt);
                if (Et && (vt = gt(vt),
                vt === !1))
                    return ut;
                var wt = vt.charAt(0);
                return Number(wt) != wt || !st[wt] ? ut : vt.length > 1 ? {
                    type: st[wt],
                    data: vt.substring(1)
                } : {
                    type: st[wt]
                }
            }
            var xt = new Uint8Array(vt)
              , wt = xt[0]
              , St = et(vt, 1);
            return ct && bt === "blob" && (St = new ct([St])),
            {
                type: st[wt],
                data: St
            }
        }
        ;
        function gt(vt) {
            try {
                vt = rt.decode(vt, {
                    strict: !1
                })
            } catch (bt) {
                return !1
            }
            return vt
        }
        _.decodeBase64Packet = function(vt, bt) {
            var Et = st[vt.charAt(0)];
            if (!nt)
                return {
                    type: Et,
                    data: {
                        base64: !0,
                        data: vt.substr(1)
                    }
                };
            var xt = nt.decode(vt.substr(1));
            return bt === "blob" && ct && (xt = new ct([xt])),
            {
                type: Et,
                data: xt
            }
        }
        ,
        _.encodePayload = function(vt, bt, Et) {
            typeof bt == "function" && (Et = bt,
            bt = null);
            var xt = J(vt);
            if (bt && xt)
                return ct && !at ? _.encodePayloadAsBlob(vt, Et) : _.encodePayloadAsArrayBuffer(vt, Et);
            if (!vt.length)
                return Et("0:");
            function wt(Pt) {
                return Pt.length + ":" + Pt
            }
            function St(Pt, Rt) {
                _.encodePacket(Pt, xt ? bt : !1, !1, function(At) {
                    Rt(null, wt(At))
                })
            }
            mt(vt, St, function(Pt, Rt) {
                return Et(Rt.join(""))
            })
        }
        ;
        function mt(vt, bt, Et) {
            for (var xt = new Array(vt.length), wt = tt(vt.length, Et), St = function(Rt, At, Nt) {
                bt(At, function(Ot, It) {
                    xt[Rt] = It,
                    Nt(Ot, xt)
                })
            }, Pt = 0; Pt < vt.length; Pt++)
                St(Pt, vt[Pt], wt)
        }
        _.decodePayload = function(vt, bt, Et) {
            if (typeof vt != "string")
                return _.decodePayloadAsBinary(vt, bt, Et);
            typeof bt == "function" && (Et = bt,
            bt = null);
            var xt;
            if (vt === "")
                return Et(ut, 0, 1);
            for (var wt = "", St, Pt, Rt = 0, At = vt.length; Rt < At; Rt++) {
                var Nt = vt.charAt(Rt);
                if (Nt !== ":") {
                    wt += Nt;
                    continue
                }
                if (wt === "" || wt != (St = Number(wt)) || (Pt = vt.substr(Rt + 1, St),
                wt != Pt.length))
                    return Et(ut, 0, 1);
                if (Pt.length) {
                    if (xt = _.decodePacket(Pt, bt, !1),
                    ut.type === xt.type && ut.data === xt.data)
                        return Et(ut, 0, 1);
                    var Ot = Et(xt, Rt + St, At);
                    if (Ot === !1)
                        return
                }
                Rt += St,
                wt = ""
            }
            if (wt !== "")
                return Et(ut, 0, 1)
        }
        ,
        _.encodePayloadAsArrayBuffer = function(vt, bt) {
            if (!vt.length)
                return bt(new ArrayBuffer(0));
            function Et(xt, wt) {
                _.encodePacket(xt, !0, !0, function(St) {
                    return wt(null, St)
                })
            }
            mt(vt, Et, function(xt, wt) {
                var St = wt.reduce(function(At, Nt) {
                    var Ot;
                    return typeof Nt == "string" ? Ot = Nt.length : Ot = Nt.byteLength,
                    At + Ot.toString().length + Ot + 2
                }, 0)
                  , Pt = new Uint8Array(St)
                  , Rt = 0;
                return wt.forEach(function(At) {
                    var Nt = typeof At == "string"
                      , Ot = At;
                    if (Nt) {
                        for (var It = new Uint8Array(At.length), Mt = 0; Mt < At.length; Mt++)
                            It[Mt] = At.charCodeAt(Mt);
                        Ot = It.buffer
                    }
                    Nt ? Pt[Rt++] = 0 : Pt[Rt++] = 1;
                    for (var Wt = Ot.byteLength.toString(), Mt = 0; Mt < Wt.length; Mt++)
                        Pt[Rt++] = parseInt(Wt[Mt]);
                    Pt[Rt++] = 255;
                    for (var It = new Uint8Array(Ot), Mt = 0; Mt < It.length; Mt++)
                        Pt[Rt++] = It[Mt]
                }),
                bt(Pt.buffer)
            })
        }
        ,
        _.encodePayloadAsBlob = function(vt, bt) {
            function Et(xt, wt) {
                _.encodePacket(xt, !0, !0, function(St) {
                    var Pt = new Uint8Array(1);
                    if (Pt[0] = 1,
                    typeof St == "string") {
                        for (var Rt = new Uint8Array(St.length), At = 0; At < St.length; At++)
                            Rt[At] = St.charCodeAt(At);
                        St = Rt.buffer,
                        Pt[0] = 0
                    }
                    for (var Nt = St instanceof ArrayBuffer ? St.byteLength : St.size, Ot = Nt.toString(), It = new Uint8Array(Ot.length + 1), At = 0; At < Ot.length; At++)
                        It[At] = parseInt(Ot[At]);
                    if (It[Ot.length] = 255,
                    ct) {
                        var Mt = new ct([Pt.buffer, It.buffer, St]);
                        wt(null, Mt)
                    }
                })
            }
            mt(vt, Et, function(xt, wt) {
                return bt(new ct(wt))
            })
        }
        ,
        _.decodePayloadAsBinary = function(vt, bt, Et) {
            typeof bt == "function" && (Et = bt,
            bt = null);
            for (var xt = vt, wt = []; xt.byteLength > 0; ) {
                for (var St = new Uint8Array(xt), Pt = St[0] === 0, Rt = "", At = 1; St[At] !== 255; At++) {
                    if (Rt.length > 310)
                        return Et(ut, 0, 1);
                    Rt += St[At]
                }
                xt = et(xt, 2 + Rt.length),
                Rt = parseInt(Rt);
                var Nt = et(xt, 0, Rt);
                if (Pt)
                    try {
                        Nt = String.fromCharCode.apply(null, new Uint8Array(Nt))
                    } catch (Mt) {
                        var Ot = new Uint8Array(Nt);
                        Nt = "";
                        for (var At = 0; At < Ot.length; At++)
                            Nt += String.fromCharCode(Ot[At])
                    }
                wt.push(Nt),
                xt = et(xt, Rt)
            }
            var It = wt.length;
            wt.forEach(function(Mt, Wt) {
                Et(_.decodePacket(Mt, bt, !0), Wt, It)
            })
        }
    }
    )(browser$1);
    var transport, hasRequiredTransport;
    function requireTransport() {
        if (hasRequiredTransport)
            return transport;
        hasRequiredTransport = 1;
        var _ = browser$1
          , k = componentEmitterExports;
        transport = J;
        function J(et) {
            this.path = et.path,
            this.hostname = et.hostname,
            this.port = et.port,
            this.secure = et.secure,
            this.query = et.query,
            this.timestampParam = et.timestampParam,
            this.timestampRequests = et.timestampRequests,
            this.readyState = "",
            this.agent = et.agent || !1,
            this.socket = et.socket,
            this.enablesXDR = et.enablesXDR,
            this.withCredentials = et.withCredentials,
            this.pfx = et.pfx,
            this.key = et.key,
            this.passphrase = et.passphrase,
            this.cert = et.cert,
            this.ca = et.ca,
            this.ciphers = et.ciphers,
            this.rejectUnauthorized = et.rejectUnauthorized,
            this.forceNode = et.forceNode,
            this.isReactNative = et.isReactNative,
            this.extraHeaders = et.extraHeaders,
            this.localAddress = et.localAddress
        }
        return k(J.prototype),
        J.prototype.onError = function(et, tt) {
            var rt = new Error(et);
            return rt.type = "TransportError",
            rt.description = tt,
            this.emit("error", rt),
            this
        }
        ,
        J.prototype.open = function() {
            return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening",
            this.doOpen()),
            this
        }
        ,
        J.prototype.close = function() {
            return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(),
            this.onClose()),
            this
        }
        ,
        J.prototype.send = function(et) {
            if (this.readyState === "open")
                this.write(et);
            else
                throw new Error("Transport not open")
        }
        ,
        J.prototype.onOpen = function() {
            this.readyState = "open",
            this.writable = !0,
            this.emit("open")
        }
        ,
        J.prototype.onData = function(et) {
            var tt = _.decodePacket(et, this.socket.binaryType);
            this.onPacket(tt)
        }
        ,
        J.prototype.onPacket = function(et) {
            this.emit("packet", et)
        }
        ,
        J.prototype.onClose = function() {
            this.readyState = "closed",
            this.emit("close")
        }
        ,
        transport
    }
    var parseqs$3 = {};
    parseqs$3.encode = function(_) {
        var k = "";
        for (var J in _)
            _.hasOwnProperty(J) && (k.length && (k += "&"),
            k += encodeURIComponent(J) + "=" + encodeURIComponent(_[J]));
        return k
    }
    ,
    parseqs$3.decode = function(_) {
        for (var k = {}, J = _.split("&"), et = 0, tt = J.length; et < tt; et++) {
            var rt = J[et].split("=");
            k[decodeURIComponent(rt[0])] = decodeURIComponent(rt[1])
        }
        return k
    }
    ;
    var componentInherit = function(_, k) {
        var J = function() {};
        J.prototype = k.prototype,
        _.prototype = new J,
        _.prototype.constructor = _
    }, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {}, seed = 0, i$1 = 0, prev;
    function encode(_) {
        var k = "";
        do
            k = alphabet[_ % length] + k,
            _ = Math.floor(_ / length);
        while (_ > 0);
        return k
    }
    function decode(_) {
        var k = 0;
        for (i$1 = 0; i$1 < _.length; i$1++)
            k = k * length + map[_.charAt(i$1)];
        return k
    }
    function yeast$2() {
        var _ = encode(+new Date);
        return _ !== prev ? (seed = 0,
        prev = _) : _ + "." + encode(seed++)
    }
    for (; i$1 < length; i$1++)
        map[alphabet[i$1]] = i$1;
    yeast$2.encode = encode,
    yeast$2.decode = decode;
    var yeast_1 = yeast$2
      , browser = {
        exports: {}
    }
      , debug$5 = {
        exports: {}
    }
      , s$1 = 1e3
      , m$1 = s$1 * 60
      , h = m$1 * 60
      , d$1 = h * 24
      , y$1 = d$1 * 365.25
      , ms = function(_, k) {
        k = k || {};
        var J = typeof _;
        if (J === "string" && _.length > 0)
            return parse(_);
        if (J === "number" && isNaN(_) === !1)
            return k.long ? fmtLong(_) : fmtShort(_);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(_))
    };
    function parse(_) {
        if (_ = String(_),
        !(_.length > 100)) {
            var k = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(_);
            if (k) {
                var J = parseFloat(k[1])
                  , et = (k[2] || "ms").toLowerCase();
                switch (et) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                    return J * y$1;
                case "days":
                case "day":
                case "d":
                    return J * d$1;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                    return J * h;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                    return J * m$1;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                    return J * s$1;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                    return J;
                default:
                    return
                }
            }
        }
    }
    function fmtShort(_) {
        return _ >= d$1 ? Math.round(_ / d$1) + "d" : _ >= h ? Math.round(_ / h) + "h" : _ >= m$1 ? Math.round(_ / m$1) + "m" : _ >= s$1 ? Math.round(_ / s$1) + "s" : _ + "ms"
    }
    function fmtLong(_) {
        return plural(_, d$1, "day") || plural(_, h, "hour") || plural(_, m$1, "minute") || plural(_, s$1, "second") || _ + " ms"
    }
    function plural(_, k, J) {
        if (!(_ < k))
            return _ < k * 1.5 ? Math.floor(_ / k) + " " + J : Math.ceil(_ / k) + " " + J + "s"
    }
    (function(_, k) {
        k = _.exports = et.debug = et.default = et,
        k.coerce = it,
        k.disable = nt,
        k.enable = rt,
        k.enabled = ot,
        k.humanize = ms,
        k.instances = [],
        k.names = [],
        k.skips = [],
        k.formatters = {};
        function J(at) {
            var lt = 0, st;
            for (st in at)
                lt = (lt << 5) - lt + at.charCodeAt(st),
                lt |= 0;
            return k.colors[Math.abs(lt) % k.colors.length]
        }
        function et(at) {
            var lt;
            function st() {
                if (st.enabled) {
                    var ut = st
                      , ct = +new Date
                      , pt = ct - (lt || ct);
                    ut.diff = pt,
                    ut.prev = lt,
                    ut.curr = ct,
                    lt = ct;
                    for (var ft = new Array(arguments.length), yt = 0; yt < ft.length; yt++)
                        ft[yt] = arguments[yt];
                    ft[0] = k.coerce(ft[0]),
                    typeof ft[0] != "string" && ft.unshift("%O");
                    var ht = 0;
                    ft[0] = ft[0].replace(/%([a-zA-Z%])/g, function(mt, vt) {
                        if (mt === "%%")
                            return mt;
                        ht++;
                        var bt = k.formatters[vt];
                        if (typeof bt == "function") {
                            var Et = ft[ht];
                            mt = bt.call(ut, Et),
                            ft.splice(ht, 1),
                            ht--
                        }
                        return mt
                    }),
                    k.formatArgs.call(ut, ft);
                    var gt = st.log || k.log || void 0;
                    gt.apply(ut, ft)
                }
            }
            return st.namespace = at,
            st.enabled = k.enabled(at),
            st.useColors = k.useColors(),
            st.color = J(at),
            st.destroy = tt,
            typeof k.init == "function" && k.init(st),
            k.instances.push(st),
            st
        }
        function tt() {
            var at = k.instances.indexOf(this);
            return at !== -1 ? (k.instances.splice(at, 1),
            !0) : !1
        }
        function rt(at) {
            k.save(at),
            k.names = [],
            k.skips = [];
            var lt, st = (typeof at == "string" ? at : "").split(/[\s,]+/), ut = st.length;
            for (lt = 0; lt < ut; lt++)
                st[lt] && (at = st[lt].replace(/\*/g, ".*?"),
                at[0] === "-" ? k.skips.push(new RegExp("^" + at.substr(1) + "$")) : k.names.push(new RegExp("^" + at + "$")));
            for (lt = 0; lt < k.instances.length; lt++) {
                var ct = k.instances[lt];
                ct.enabled = k.enabled(ct.namespace)
            }
        }
        function nt() {
            k.enable("")
        }
        function ot(at) {
            if (at[at.length - 1] === "*")
                return !0;
            var lt, st;
            for (lt = 0,
            st = k.skips.length; lt < st; lt++)
                if (k.skips[lt].test(at))
                    return !1;
            for (lt = 0,
            st = k.names.length; lt < st; lt++)
                if (k.names[lt].test(at))
                    return !0;
            return !1
        }
        function it(at) {
            return at instanceof Error ? at.stack || at.message : at
        }
    }
    )(debug$5, debug$5.exports);
    var debugExports = debug$5.exports;
    (function(_, k) {
        k = _.exports = debugExports,
        k.log = tt,
        k.formatArgs = et,
        k.save = rt,
        k.load = nt,
        k.useColors = J,
        k.storage = typeof chrome < "u" && typeof chrome.storage < "u" ? chrome.storage.local : ot(),
        k.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function J() {
            return typeof window < "u" && window.process && window.process.type === "renderer" ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }
        k.formatters.j = function(it) {
            try {
                return JSON.stringify(it)
            } catch (at) {
                return "[UnexpectedJSONParseError]: " + at.message
            }
        }
        ;
        function et(it) {
            var at = this.useColors;
            if (it[0] = (at ? "%c" : "") + this.namespace + (at ? " %c" : " ") + it[0] + (at ? "%c " : " ") + "+" + k.humanize(this.diff),
            !!at) {
                var lt = "color: " + this.color;
                it.splice(1, 0, lt, "color: inherit");
                var st = 0
                  , ut = 0;
                it[0].replace(/%[a-zA-Z%]/g, function(ct) {
                    ct !== "%%" && (st++,
                    ct === "%c" && (ut = st))
                }),
                it.splice(ut, 0, lt)
            }
        }
        function tt() {
            return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments)
        }
        function rt(it) {
            try {
                it == null ? k.storage.removeItem("debug") : k.storage.debug = it
            } catch (at) {}
        }
        function nt() {
            var it;
            try {
                it = k.storage.debug
            } catch (at) {}
            return !it && typeof process < "u" && "env"in process && (it = {}.DEBUG),
            it
        }
        k.enable(nt());
        function ot() {
            try {
                return window.localStorage
            } catch (it) {}
        }
    }
    )(browser, browser.exports);
    var browserExports = browser.exports
      , Transport$1 = requireTransport()
      , parseqs$2 = parseqs$3
      , parser$3 = browser$1
      , inherit$3 = componentInherit
      , yeast$1 = yeast_1
      , debug$4 = browserExports("engine.io-client:polling")
      , polling$1 = Polling$2
      , hasXHR2 = function() {
        var _ = xmlhttprequest_browser
          , k = new _({
            xdomain: !1
        });
        return k.responseType != null
    }();
    function Polling$2(_) {
        var k = _ && _.forceBase64;
        (!hasXHR2 || k) && (this.supportsBinary = !1),
        Transport$1.call(this, _)
    }
    inherit$3(Polling$2, Transport$1),
    Polling$2.prototype.name = "polling",
    Polling$2.prototype.doOpen = function() {
        this.poll()
    }
    ,
    Polling$2.prototype.pause = function(_) {
        var k = this;
        this.readyState = "pausing";
        function J() {
            debug$4("paused"),
            k.readyState = "paused",
            _()
        }
        if (this.polling || !this.writable) {
            var et = 0;
            this.polling && (debug$4("we are currently polling - waiting to pause"),
            et++,
            this.once("pollComplete", function() {
                debug$4("pre-pause polling complete"),
                --et || J()
            })),
            this.writable || (debug$4("we are currently writing - waiting to pause"),
            et++,
            this.once("drain", function() {
                debug$4("pre-pause writing complete"),
                --et || J()
            }))
        } else
            J()
    }
    ,
    Polling$2.prototype.poll = function() {
        debug$4("polling"),
        this.polling = !0,
        this.doPoll(),
        this.emit("poll")
    }
    ,
    Polling$2.prototype.onData = function(_) {
        var k = this;
        debug$4("polling got data %s", _);
        var J = function(et, tt, rt) {
            if (k.readyState === "opening" && et.type === "open" && k.onOpen(),
            et.type === "close")
                return k.onClose(),
                !1;
            k.onPacket(et)
        };
        parser$3.decodePayload(_, this.socket.binaryType, J),
        this.readyState !== "closed" && (this.polling = !1,
        this.emit("pollComplete"),
        this.readyState === "open" ? this.poll() : debug$4('ignoring poll - transport state "%s"', this.readyState))
    }
    ,
    Polling$2.prototype.doClose = function() {
        var _ = this;
        function k() {
            debug$4("writing close packet"),
            _.write([{
                type: "close"
            }])
        }
        this.readyState === "open" ? (debug$4("transport open - closing"),
        k()) : (debug$4("transport not open - deferring close"),
        this.once("open", k))
    }
    ,
    Polling$2.prototype.write = function(_) {
        var k = this;
        this.writable = !1;
        var J = function() {
            k.writable = !0,
            k.emit("drain")
        };
        parser$3.encodePayload(_, this.supportsBinary, function(et) {
            k.doWrite(et, J)
        })
    }
    ,
    Polling$2.prototype.uri = function() {
        var _ = this.query || {}
          , k = this.secure ? "https" : "http"
          , J = "";
        this.timestampRequests !== !1 && (_[this.timestampParam] = yeast$1()),
        !this.supportsBinary && !_.sid && (_.b64 = 1),
        _ = parseqs$2.encode(_),
        this.port && (k === "https" && Number(this.port) !== 443 || k === "http" && Number(this.port) !== 80) && (J = ":" + this.port),
        _.length && (_ = "?" + _);
        var et = this.hostname.indexOf(":") !== -1;
        return k + "://" + (et ? "[" + this.hostname + "]" : this.hostname) + J + this.path + _
    }
    ;
    var XMLHttpRequest$2 = xmlhttprequest_browser
      , Polling$1 = polling$1
      , Emitter$2 = componentEmitterExports
      , inherit$2 = componentInherit
      , debug$3 = browserExports("engine.io-client:polling-xhr")
      , globalThis$2 = globalThis_browser;
    pollingXhr.exports = XHR$1,
    pollingXhr.exports.Request = Request$1;
    function empty$1() {}
    function XHR$1(_) {
        if (Polling$1.call(this, _),
        this.requestTimeout = _.requestTimeout,
        this.extraHeaders = _.extraHeaders,
        typeof location < "u") {
            var k = location.protocol === "https:"
              , J = location.port;
            J || (J = k ? 443 : 80),
            this.xd = typeof location < "u" && _.hostname !== location.hostname || J !== _.port,
            this.xs = _.secure !== k
        }
    }
    inherit$2(XHR$1, Polling$1),
    XHR$1.prototype.supportsBinary = !0,
    XHR$1.prototype.request = function(_) {
        return _ = _ || {},
        _.uri = this.uri(),
        _.xd = this.xd,
        _.xs = this.xs,
        _.agent = this.agent || !1,
        _.supportsBinary = this.supportsBinary,
        _.enablesXDR = this.enablesXDR,
        _.withCredentials = this.withCredentials,
        _.pfx = this.pfx,
        _.key = this.key,
        _.passphrase = this.passphrase,
        _.cert = this.cert,
        _.ca = this.ca,
        _.ciphers = this.ciphers,
        _.rejectUnauthorized = this.rejectUnauthorized,
        _.requestTimeout = this.requestTimeout,
        _.extraHeaders = this.extraHeaders,
        new Request$1(_)
    }
    ,
    XHR$1.prototype.doWrite = function(_, k) {
        var J = typeof _ != "string" && _ !== void 0
          , et = this.request({
            method: "POST",
            data: _,
            isBinary: J
        })
          , tt = this;
        et.on("success", k),
        et.on("error", function(rt) {
            tt.onError("xhr post error", rt)
        }),
        this.sendXhr = et
    }
    ,
    XHR$1.prototype.doPoll = function() {
        debug$3("xhr poll");
        var _ = this.request()
          , k = this;
        _.on("data", function(J) {
            k.onData(J)
        }),
        _.on("error", function(J) {
            k.onError("xhr poll error", J)
        }),
        this.pollXhr = _
    }
    ;
    function Request$1(_) {
        this.method = _.method || "GET",
        this.uri = _.uri,
        this.xd = !!_.xd,
        this.xs = !!_.xs,
        this.async = _.async !== !1,
        this.data = _.data !== void 0 ? _.data : null,
        this.agent = _.agent,
        this.isBinary = _.isBinary,
        this.supportsBinary = _.supportsBinary,
        this.enablesXDR = _.enablesXDR,
        this.withCredentials = _.withCredentials,
        this.requestTimeout = _.requestTimeout,
        this.pfx = _.pfx,
        this.key = _.key,
        this.passphrase = _.passphrase,
        this.cert = _.cert,
        this.ca = _.ca,
        this.ciphers = _.ciphers,
        this.rejectUnauthorized = _.rejectUnauthorized,
        this.extraHeaders = _.extraHeaders,
        this.create()
    }
    if (Emitter$2(Request$1.prototype),
    Request$1.prototype.create = function() {
        var _ = {
            agent: this.agent,
            xdomain: this.xd,
            xscheme: this.xs,
            enablesXDR: this.enablesXDR
        };
        _.pfx = this.pfx,
        _.key = this.key,
        _.passphrase = this.passphrase,
        _.cert = this.cert,
        _.ca = this.ca,
        _.ciphers = this.ciphers,
        _.rejectUnauthorized = this.rejectUnauthorized;
        var k = this.xhr = new XMLHttpRequest$2(_)
          , J = this;
        try {
            debug$3("xhr open %s: %s", this.method, this.uri),
            k.open(this.method, this.uri, this.async);
            try {
                if (this.extraHeaders) {
                    k.setDisableHeaderCheck && k.setDisableHeaderCheck(!0);
                    for (var et in this.extraHeaders)
                        this.extraHeaders.hasOwnProperty(et) && k.setRequestHeader(et, this.extraHeaders[et])
                }
            } catch (tt) {}
            if (this.method === "POST")
                try {
                    this.isBinary ? k.setRequestHeader("Content-type", "application/octet-stream") : k.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                } catch (tt) {}
            try {
                k.setRequestHeader("Accept", "*/*")
            } catch (tt) {}
            "withCredentials"in k && (k.withCredentials = this.withCredentials),
            this.requestTimeout && (k.timeout = this.requestTimeout),
            this.hasXDR() ? (k.onload = function() {
                J.onLoad()
            }
            ,
            k.onerror = function() {
                J.onError(k.responseText)
            }
            ) : k.onreadystatechange = function() {
                if (k.readyState === 2)
                    try {
                        var tt = k.getResponseHeader("Content-Type");
                        (J.supportsBinary && tt === "application/octet-stream" || tt === "application/octet-stream; charset=UTF-8") && (k.responseType = "arraybuffer")
                    } catch (rt) {}
                k.readyState === 4 && (k.status === 200 || k.status === 1223 ? J.onLoad() : setTimeout(function() {
                    J.onError(typeof k.status == "number" ? k.status : 0)
                }, 0))
            }
            ,
            debug$3("xhr data %s", this.data),
            k.send(this.data)
        } catch (tt) {
            setTimeout(function() {
                J.onError(tt)
            }, 0);
            return
        }
        typeof document < "u" && (this.index = Request$1.requestsCount++,
        Request$1.requests[this.index] = this)
    }
    ,
    Request$1.prototype.onSuccess = function() {
        this.emit("success"),
        this.cleanup()
    }
    ,
    Request$1.prototype.onData = function(_) {
        this.emit("data", _),
        this.onSuccess()
    }
    ,
    Request$1.prototype.onError = function(_) {
        this.emit("error", _),
        this.cleanup(!0)
    }
    ,
    Request$1.prototype.cleanup = function(_) {
        if (!(typeof this.xhr > "u" || this.xhr === null)) {
            if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = empty$1 : this.xhr.onreadystatechange = empty$1,
            _)
                try {
                    this.xhr.abort()
                } catch (k) {}
            typeof document < "u" && delete Request$1.requests[this.index],
            this.xhr = null
        }
    }
    ,
    Request$1.prototype.onLoad = function() {
        var _;
        try {
            var k;
            try {
                k = this.xhr.getResponseHeader("Content-Type")
            } catch (J) {}
            k === "application/octet-stream" || k === "application/octet-stream; charset=UTF-8" ? _ = this.xhr.response || this.xhr.responseText : _ = this.xhr.responseText
        } catch (J) {
            this.onError(J)
        }
        _ != null && this.onData(_)
    }
    ,
    Request$1.prototype.hasXDR = function() {
        return typeof XDomainRequest < "u" && !this.xs && this.enablesXDR
    }
    ,
    Request$1.prototype.abort = function() {
        this.cleanup()
    }
    ,
    Request$1.requestsCount = 0,
    Request$1.requests = {},
    typeof document < "u") {
        if (typeof attachEvent == "function")
            attachEvent("onunload", unloadHandler);
        else if (typeof addEventListener == "function") {
            var terminationEvent = "onpagehide"in globalThis$2 ? "pagehide" : "unload";
            addEventListener(terminationEvent, unloadHandler, !1)
        }
    }
    function unloadHandler() {
        for (var _ in Request$1.requests)
            Request$1.requests.hasOwnProperty(_) && Request$1.requests[_].abort()
    }
    var pollingXhrExports = pollingXhr.exports, Polling = polling$1, inherit$1 = componentInherit, globalThis$1 = globalThis_browser, pollingJsonp = JSONPPolling, rNewline = /\n/g, rEscapedNewline = /\\n/g, callbacks;
    function empty() {}
    function JSONPPolling(_) {
        Polling.call(this, _),
        this.query = this.query || {},
        callbacks || (callbacks = globalThis$1.___eio = globalThis$1.___eio || []),
        this.index = callbacks.length;
        var k = this;
        callbacks.push(function(J) {
            k.onData(J)
        }),
        this.query.j = this.index,
        typeof addEventListener == "function" && addEventListener("beforeunload", function() {
            k.script && (k.script.onerror = empty)
        }, !1)
    }
    inherit$1(JSONPPolling, Polling),
    JSONPPolling.prototype.supportsBinary = !1,
    JSONPPolling.prototype.doClose = function() {
        this.script && (this.script.parentNode.removeChild(this.script),
        this.script = null),
        this.form && (this.form.parentNode.removeChild(this.form),
        this.form = null,
        this.iframe = null),
        Polling.prototype.doClose.call(this)
    }
    ,
    JSONPPolling.prototype.doPoll = function() {
        var _ = this
          , k = document.createElement("script");
        this.script && (this.script.parentNode.removeChild(this.script),
        this.script = null),
        k.async = !0,
        k.src = this.uri(),
        k.onerror = function(tt) {
            _.onError("jsonp poll error", tt)
        }
        ;
        var J = document.getElementsByTagName("script")[0];
        J ? J.parentNode.insertBefore(k, J) : (document.head || document.body).appendChild(k),
        this.script = k;
        var et = typeof navigator < "u" && /gecko/i.test(navigator.userAgent);
        et && setTimeout(function() {
            var tt = document.createElement("iframe");
            document.body.appendChild(tt),
            document.body.removeChild(tt)
        }, 100)
    }
    ,
    JSONPPolling.prototype.doWrite = function(_, k) {
        var J = this;
        if (!this.form) {
            var et = document.createElement("form"), tt = document.createElement("textarea"), rt = this.iframeId = "eio_iframe_" + this.index, nt;
            et.className = "socketio",
            et.style.position = "absolute",
            et.style.top = "-1000px",
            et.style.left = "-1000px",
            et.target = rt,
            et.method = "POST",
            et.setAttribute("accept-charset", "utf-8"),
            tt.name = "d",
            et.appendChild(tt),
            document.body.appendChild(et),
            this.form = et,
            this.area = tt
        }
        this.form.action = this.uri();
        function ot() {
            it(),
            k()
        }
        function it() {
            if (J.iframe)
                try {
                    J.form.removeChild(J.iframe)
                } catch (lt) {
                    J.onError("jsonp polling iframe removal error", lt)
                }
            try {
                var at = '<iframe src="javascript:0" name="' + J.iframeId + '">';
                nt = document.createElement(at)
            } catch (lt) {
                nt = document.createElement("iframe"),
                nt.name = J.iframeId,
                nt.src = "javascript:0"
            }
            nt.id = J.iframeId,
            J.form.appendChild(nt),
            J.iframe = nt
        }
        it(),
        _ = _.replace(rEscapedNewline, `\\
`),
        this.area.value = _.replace(rNewline, "\\n");
        try {
            this.form.submit()
        } catch (at) {}
        this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
            J.iframe.readyState === "complete" && ot()
        }
        : this.iframe.onload = ot
    }
    ;
    const __viteBrowserExternal = {}
      , __viteBrowserExternal$1 = Object.assign(Object.defineProperty({
        
        default: __viteBrowserExternal
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , require$$6 = getAugmentedNamespace(__viteBrowserExternal$1);
    var Transport = requireTransport(), parser$2 = browser$1, parseqs$1 = parseqs$3, inherit = componentInherit, yeast = yeast_1, debug$2 = browserExports("engine.io-client:websocket"), BrowserWebSocket, NodeWebSocket;
    if (typeof WebSocket < "u" ? BrowserWebSocket = WebSocket : typeof self < "u" && (BrowserWebSocket = self.WebSocket || self.MozWebSocket),
    typeof window > "u")
        try {
            NodeWebSocket = require$$6
        } catch (_) {}
    var WebSocketImpl = BrowserWebSocket || NodeWebSocket
      , websocket$1 = WS;
    function WS(_) {
        var k = _ && _.forceBase64;
        k && (this.supportsBinary = !1),
        this.perMessageDeflate = _.perMessageDeflate,
        this.usingBrowserWebSocket = BrowserWebSocket && !_.forceNode,
        this.protocols = _.protocols,
        this.usingBrowserWebSocket || (WebSocketImpl = NodeWebSocket),
        Transport.call(this, _)
    }
    inherit(WS, Transport),
    WS.prototype.name = "websocket",
    WS.prototype.supportsBinary = !0,
    WS.prototype.doOpen = function() {
        if (this.check()) {
            var _ = this.uri()
              , k = this.protocols
              , J = {};
            this.isReactNative || (J.agent = this.agent,
            J.perMessageDeflate = this.perMessageDeflate,
            J.pfx = this.pfx,
            J.key = this.key,
            J.passphrase = this.passphrase,
            J.cert = this.cert,
            J.ca = this.ca,
            J.ciphers = this.ciphers,
            J.rejectUnauthorized = this.rejectUnauthorized),
            this.extraHeaders && (J.headers = this.extraHeaders),
            this.localAddress && (J.localAddress = this.localAddress);
            try {
                this.ws = this.usingBrowserWebSocket && !this.isReactNative ? k ? new WebSocketImpl(_,k) : new WebSocketImpl(_) : new WebSocketImpl(_,k,J)
            } catch (et) {
                return this.emit("error", et)
            }
            this.ws.binaryType === void 0 && (this.supportsBinary = !1),
            this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0,
            this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer",
            this.addEventListeners()
        }
    }
    ,
    WS.prototype.addEventListeners = function() {
        var _ = this;
        this.ws.onopen = function() {
            _.onOpen()
        }
        ,
        this.ws.onclose = function() {
            _.onClose()
        }
        ,
        this.ws.onmessage = function(k) {
            _.onData(k.data)
        }
        ,
        this.ws.onerror = function(k) {
            _.onError("websocket error", k)
        }
    }
    ,
    WS.prototype.write = function(_) {
        var k = this;
        this.writable = !1;
        for (var J = _.length, et = 0, tt = J; et < tt; et++)
            (function(nt) {
                parser$2.encodePacket(nt, k.supportsBinary, function(ot) {
                    if (!k.usingBrowserWebSocket) {
                        var it = {};
                        if (nt.options && (it.compress = nt.options.compress),
                        k.perMessageDeflate) {
                            var at = typeof ot == "string" ? Buffer.byteLength(ot) : ot.length;
                            at < k.perMessageDeflate.threshold && (it.compress = !1)
                        }
                    }
                    try {
                        k.usingBrowserWebSocket ? k.ws.send(ot) : k.ws.send(ot, it)
                    } catch (lt) {
                        debug$2("websocket closed before onclose event")
                    }
                    --J || rt()
                })
            }
            )(_[et]);
        function rt() {
            k.emit("flush"),
            setTimeout(function() {
                k.writable = !0,
                k.emit("drain")
            }, 0)
        }
    }
    ,
    WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this)
    }
    ,
    WS.prototype.doClose = function() {
        typeof this.ws < "u" && this.ws.close()
    }
    ,
    WS.prototype.uri = function() {
        var _ = this.query || {}
          , k = this.secure ? "wss" : "ws"
          , J = "";
        this.port && (k === "wss" && Number(this.port) !== 443 || k === "ws" && Number(this.port) !== 80) && (J = ":" + this.port),
        this.timestampRequests && (_[this.timestampParam] = yeast()),
        this.supportsBinary || (_.b64 = 1),
        _ = parseqs$1.encode(_),
        _.length && (_ = "?" + _);
        var et = this.hostname.indexOf(":") !== -1;
        return k + "://" + (et ? "[" + this.hostname + "]" : this.hostname) + J + this.path + _
    }
    ,
    WS.prototype.check = function() {
        return !!WebSocketImpl && !("__initialize"in WebSocketImpl && this.name === WS.prototype.name)
    }
    ;
    var XMLHttpRequest$1 = xmlhttprequest_browser
      , XHR = pollingXhrExports
      , JSONP = pollingJsonp
      , websocket = websocket$1;
    transports$1.polling = polling,
    transports$1.websocket = websocket;
    function polling(_) {
        var k, J = !1, et = !1, tt = _.jsonp !== !1;
        if (typeof location < "u") {
            var rt = location.protocol === "https:"
              , nt = location.port;
            nt || (nt = rt ? 443 : 80),
            J = _.hostname !== location.hostname || nt !== _.port,
            et = _.secure !== rt
        }
        if (_.xdomain = J,
        _.xscheme = et,
        k = new XMLHttpRequest$1(_),
        "open"in k && !_.forceJSONP)
            return new XHR(_);
        if (!tt)
            throw new Error("JSONP disabled");
        return new JSONP(_)
    }
    var indexOf$1 = [].indexOf
      , indexof = function(_, k) {
        if (indexOf$1)
            return _.indexOf(k);
        for (var J = 0; J < _.length; ++J)
            if (_[J] === k)
                return J;
        return -1
    }
      , transports = transports$1
      , Emitter$1 = componentEmitterExports
      , debug$1 = browserExports("engine.io-client:socket")
      , index = indexof
      , parser$1 = browser$1
      , parseuri = parseuri$2
      , parseqs = parseqs$3
      , socket$2 = Socket$1;
    function Socket$1(_, k) {
        if (!(this instanceof Socket$1))
            return new Socket$1(_,k);
        k = k || {},
        _ && typeof _ == "object" && (k = _,
        _ = null),
        _ ? (_ = parseuri(_),
        k.hostname = _.host,
        k.secure = _.protocol === "https" || _.protocol === "wss",
        k.port = _.port,
        _.query && (k.query = _.query)) : k.host && (k.hostname = parseuri(k.host).host),
        this.secure = k.secure != null ? k.secure : typeof location < "u" && location.protocol === "https:",
        k.hostname && !k.port && (k.port = this.secure ? "443" : "80"),
        this.agent = k.agent || !1,
        this.hostname = k.hostname || (typeof location < "u" ? location.hostname : "localhost"),
        this.port = k.port || (typeof location < "u" && location.port ? location.port : this.secure ? 443 : 80),
        this.query = k.query || {},
        typeof this.query == "string" && (this.query = parseqs.decode(this.query)),
        this.upgrade = k.upgrade !== !1,
        this.path = (k.path || "/engine.io").replace(/\/$/, "") + "/",
        this.forceJSONP = !!k.forceJSONP,
        this.jsonp = k.jsonp !== !1,
        this.forceBase64 = !!k.forceBase64,
        this.enablesXDR = !!k.enablesXDR,
        this.withCredentials = k.withCredentials !== !1,
        this.timestampParam = k.timestampParam || "t",
        this.timestampRequests = k.timestampRequests,
        this.transports = k.transports || ["polling", "websocket"],
        this.transportOptions = k.transportOptions || {},
        this.readyState = "",
        this.writeBuffer = [],
        this.prevBufferLen = 0,
        this.policyPort = k.policyPort || 843,
        this.rememberUpgrade = k.rememberUpgrade || !1,
        this.binaryType = null,
        this.onlyBinaryUpgrades = k.onlyBinaryUpgrades,
        this.perMessageDeflate = k.perMessageDeflate !== !1 ? k.perMessageDeflate || {} : !1,
        this.perMessageDeflate === !0 && (this.perMessageDeflate = {}),
        this.perMessageDeflate && this.perMessageDeflate.threshold == null && (this.perMessageDeflate.threshold = 1024),
        this.pfx = k.pfx || void 0,
        this.key = k.key || void 0,
        this.passphrase = k.passphrase || void 0,
        this.cert = k.cert || void 0,
        this.ca = k.ca || void 0,
        this.ciphers = k.ciphers || void 0,
        this.rejectUnauthorized = k.rejectUnauthorized === void 0 ? !0 : k.rejectUnauthorized,
        this.forceNode = !!k.forceNode,
        this.isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative",
        (typeof self > "u" || this.isReactNative) && (k.extraHeaders && Object.keys(k.extraHeaders).length > 0 && (this.extraHeaders = k.extraHeaders),
        k.localAddress && (this.localAddress = k.localAddress)),
        this.id = null,
        this.upgrades = null,
        this.pingInterval = null,
        this.pingTimeout = null,
        this.pingIntervalTimer = null,
        this.pingTimeoutTimer = null,
        this.open()
    }
    Socket$1.priorWebsocketSuccess = !1,
    Emitter$1(Socket$1.prototype),
    Socket$1.protocol = parser$1.protocol,
    Socket$1.Socket = Socket$1,
    Socket$1.Transport = requireTransport(),
    Socket$1.transports = transports$1,
    Socket$1.parser = browser$1,
    Socket$1.prototype.createTransport = function(_) {
        debug$1('creating transport "%s"', _);
        var k = clone(this.query);
        k.EIO = parser$1.protocol,
        k.transport = _;
        var J = this.transportOptions[_] || {};
        this.id && (k.sid = this.id);
        var et = new transports[_]({
            query: k,
            socket: this,
            agent: J.agent || this.agent,
            hostname: J.hostname || this.hostname,
            port: J.port || this.port,
            secure: J.secure || this.secure,
            path: J.path || this.path,
            forceJSONP: J.forceJSONP || this.forceJSONP,
            jsonp: J.jsonp || this.jsonp,
            forceBase64: J.forceBase64 || this.forceBase64,
            enablesXDR: J.enablesXDR || this.enablesXDR,
            withCredentials: J.withCredentials || this.withCredentials,
            timestampRequests: J.timestampRequests || this.timestampRequests,
            timestampParam: J.timestampParam || this.timestampParam,
            policyPort: J.policyPort || this.policyPort,
            pfx: J.pfx || this.pfx,
            key: J.key || this.key,
            passphrase: J.passphrase || this.passphrase,
            cert: J.cert || this.cert,
            ca: J.ca || this.ca,
            ciphers: J.ciphers || this.ciphers,
            rejectUnauthorized: J.rejectUnauthorized || this.rejectUnauthorized,
            perMessageDeflate: J.perMessageDeflate || this.perMessageDeflate,
            extraHeaders: J.extraHeaders || this.extraHeaders,
            forceNode: J.forceNode || this.forceNode,
            localAddress: J.localAddress || this.localAddress,
            requestTimeout: J.requestTimeout || this.requestTimeout,
            protocols: J.protocols || void 0,
            isReactNative: this.isReactNative
        });
        return et
    }
    ;
    function clone(_) {
        var k = {};
        for (var J in _)
            _.hasOwnProperty(J) && (k[J] = _[J]);
        return k
    }
    Socket$1.prototype.open = function() {
        var _;
        if (this.rememberUpgrade && Socket$1.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
            _ = "websocket";
        else if (this.transports.length === 0) {
            var k = this;
            setTimeout(function() {
                k.emit("error", "No transports available")
            }, 0);
            return
        } else
            _ = this.transports[0];
        this.readyState = "opening";
        try {
            _ = this.createTransport(_)
        } catch (J) {
            this.transports.shift(),
            this.open();
            return
        }
        _.open(),
        this.setTransport(_)
    }
    ,
    Socket$1.prototype.setTransport = function(_) {
        debug$1("setting transport %s", _.name);
        var k = this;
        this.transport && (debug$1("clearing existing transport %s", this.transport.name),
        this.transport.removeAllListeners()),
        this.transport = _,
        _.on("drain", function() {
            k.onDrain()
        }).on("packet", function(J) {
            k.onPacket(J)
        }).on("error", function(J) {
            k.onError(J)
        }).on("close", function() {
            k.onClose("transport close")
        })
    }
    ,
    Socket$1.prototype.probe = function(_) {
        debug$1('probing transport "%s"', _);
        var k = this.createTransport(_, {
            probe: 1
        })
          , J = !1
          , et = this;
        Socket$1.priorWebsocketSuccess = !1;
        function tt() {
            if (et.onlyBinaryUpgrades) {
                var st = !this.supportsBinary && et.transport.supportsBinary;
                J = J || st
            }
            J || (debug$1('probe transport "%s" opened', _),
            k.send([{
                type: "ping",
                data: "probe"
            }]),
            k.once("packet", function(ut) {
                if (!J)
                    if (ut.type === "pong" && ut.data === "probe") {
                        if (debug$1('probe transport "%s" pong', _),
                        et.upgrading = !0,
                        et.emit("upgrading", k),
                        !k)
                            return;
                        Socket$1.priorWebsocketSuccess = k.name === "websocket",
                        debug$1('pausing current transport "%s"', et.transport.name),
                        et.transport.pause(function() {
                            J || et.readyState !== "closed" && (debug$1("changing transport and sending upgrade packet"),
                            lt(),
                            et.setTransport(k),
                            k.send([{
                                type: "upgrade"
                            }]),
                            et.emit("upgrade", k),
                            k = null,
                            et.upgrading = !1,
                            et.flush())
                        })
                    } else {
                        debug$1('probe transport "%s" failed', _);
                        var ct = new Error("probe error");
                        ct.transport = k.name,
                        et.emit("upgradeError", ct)
                    }
            }))
        }
        function rt() {
            J || (J = !0,
            lt(),
            k.close(),
            k = null)
        }
        function nt(st) {
            var ut = new Error("probe error: " + st);
            ut.transport = k.name,
            rt(),
            debug$1('probe transport "%s" failed because of error: %s', _, st),
            et.emit("upgradeError", ut)
        }
        function ot() {
            nt("transport closed")
        }
        function it() {
            nt("socket closed")
        }
        function at(st) {
            k && st.name !== k.name && (debug$1('"%s" works - aborting "%s"', st.name, k.name),
            rt())
        }
        function lt() {
            k.removeListener("open", tt),
            k.removeListener("error", nt),
            k.removeListener("close", ot),
            et.removeListener("close", it),
            et.removeListener("upgrading", at)
        }
        k.once("open", tt),
        k.once("error", nt),
        k.once("close", ot),
        this.once("close", it),
        this.once("upgrading", at),
        k.open()
    }
    ,
    Socket$1.prototype.onOpen = function() {
        if (debug$1("socket open"),
        this.readyState = "open",
        Socket$1.priorWebsocketSuccess = this.transport.name === "websocket",
        this.emit("open"),
        this.flush(),
        this.readyState === "open" && this.upgrade && this.transport.pause) {
            debug$1("starting upgrade probes");
            for (var _ = 0, k = this.upgrades.length; _ < k; _++)
                this.probe(this.upgrades[_])
        }
    }
    ,
    Socket$1.prototype.onPacket = function(_) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
            switch (debug$1('socket receive: type "%s", data "%s"', _.type, _.data),
            this.emit("packet", _),
            this.emit("heartbeat"),
            _.type) {
            case "open":
                this.onHandshake(JSON.parse(_.data));
                break;
            case "pong":
                this.setPing(),
                this.emit("pong");
                break;
            case "error":
                var k = new Error("server error");
                k.code = _.data,
                this.onError(k);
                break;
            case "message":
                this.emit("data", _.data),
                this.emit("message", _.data);
                break
            }
        else
            debug$1('packet received with socket readyState "%s"', this.readyState)
    }
    ,
    Socket$1.prototype.onHandshake = function(_) {
        this.emit("handshake", _),
        this.id = _.sid,
        this.transport.query.sid = _.sid,
        this.upgrades = this.filterUpgrades(_.upgrades),
        this.pingInterval = _.pingInterval,
        this.pingTimeout = _.pingTimeout,
        this.onOpen(),
        this.readyState !== "closed" && (this.setPing(),
        this.removeListener("heartbeat", this.onHeartbeat),
        this.on("heartbeat", this.onHeartbeat))
    }
    ,
    Socket$1.prototype.onHeartbeat = function(_) {
        clearTimeout(this.pingTimeoutTimer);
        var k = this;
        k.pingTimeoutTimer = setTimeout(function() {
            k.readyState !== "closed" && k.onClose("ping timeout")
        }, _ || k.pingInterval + k.pingTimeout)
    }
    ,
    Socket$1.prototype.setPing = function() {
        var _ = this;
        clearTimeout(_.pingIntervalTimer),
        _.pingIntervalTimer = setTimeout(function() {
            debug$1("writing ping packet - expecting pong within %sms", _.pingTimeout),
            _.ping(),
            _.onHeartbeat(_.pingTimeout)
        }, _.pingInterval)
    }
    ,
    Socket$1.prototype.ping = function() {
        var _ = this;
        this.sendPacket("ping", function() {
            _.emit("ping")
        })
    }
    ,
    Socket$1.prototype.onDrain = function() {
        this.writeBuffer.splice(0, this.prevBufferLen),
        this.prevBufferLen = 0,
        this.writeBuffer.length === 0 ? this.emit("drain") : this.flush()
    }
    ,
    Socket$1.prototype.flush = function() {
        this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (debug$1("flushing %d packets in socket", this.writeBuffer.length),
        this.transport.send(this.writeBuffer),
        this.prevBufferLen = this.writeBuffer.length,
        this.emit("flush"))
    }
    ,
    Socket$1.prototype.write = Socket$1.prototype.send = function(_, k, J) {
        return this.sendPacket("message", _, k, J),
        this
    }
    ,
    Socket$1.prototype.sendPacket = function(_, k, J, et) {
        if (typeof k == "function" && (et = k,
        k = void 0),
        typeof J == "function" && (et = J,
        J = null),
        !(this.readyState === "closing" || this.readyState === "closed")) {
            J = J || {},
            J.compress = J.compress !== !1;
            var tt = {
                type: _,
                data: k,
                options: J
            };
            this.emit("packetCreate", tt),
            this.writeBuffer.push(tt),
            et && this.once("flush", et),
            this.flush()
        }
    }
    ,
    Socket$1.prototype.close = function() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.readyState = "closing";
            var _ = this;
            this.writeBuffer.length ? this.once("drain", function() {
                this.upgrading ? et() : k()
            }) : this.upgrading ? et() : k()
        }
        function k() {
            _.onClose("forced close"),
            debug$1("socket closing - telling transport to close"),
            _.transport.close()
        }
        function J() {
            _.removeListener("upgrade", J),
            _.removeListener("upgradeError", J),
            k()
        }
        function et() {
            _.once("upgrade", J),
            _.once("upgradeError", J)
        }
        return this
    }
    ,
    Socket$1.prototype.onError = function(_) {
        debug$1("socket error %j", _),
        Socket$1.priorWebsocketSuccess = !1,
        this.emit("error", _),
        this.onClose("transport error", _)
    }
    ,
    Socket$1.prototype.onClose = function(_, k) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            debug$1('socket close with reason: "%s"', _);
            var J = this;
            clearTimeout(this.pingIntervalTimer),
            clearTimeout(this.pingTimeoutTimer),
            this.transport.removeAllListeners("close"),
            this.transport.close(),
            this.transport.removeAllListeners(),
            this.readyState = "closed",
            this.id = null,
            this.emit("close", _, k),
            J.writeBuffer = [],
            J.prevBufferLen = 0
        }
    }
    ,
    Socket$1.prototype.filterUpgrades = function(_) {
        for (var k = [], J = 0, et = _.length; J < et; J++)
            ~index(this.transports, _[J]) && k.push(_[J]);
        return k
    }
    ,
    lib.exports = socket$2,
    lib.exports.parser = browser$1;
    var libExports$1 = lib.exports
      , socket$1 = {
        exports: {}
    }
      , toArray_1 = toArray;
    function toArray(_, k) {
        var J = [];
        k = k || 0;
        for (var et = k || 0; et < _.length; et++)
            J[et - k] = _[et];
        return J
    }
    var on_1 = on$1;
    function on$1(_, k, J) {
        return _.on(k, J),
        {
            destroy: function() {
                _.removeListener(k, J)
            }
        }
    }
    var slice = [].slice
      , componentBind = function(_, k) {
        if (typeof k == "string" && (k = _[k]),
        typeof k != "function")
            throw new Error("bind() requires a function");
        var J = slice.call(arguments, 2);
        return function() {
            return k.apply(_, J.concat(slice.call(arguments)))
        }
    };
    (function(_, k) {
        var J = socket_ioParser
          , et = componentEmitterExports
          , tt = toArray_1
          , rt = on_1
          , nt = componentBind
          , ot = browserExports$2("socket.io-client:socket")
          , it = parseqs$3
          , at = hasBinary2;
        _.exports = ut;
        var lt = {
            connect: 1,
            connect_error: 1,
            connect_timeout: 1,
            connecting: 1,
            disconnect: 1,
            error: 1,
            reconnect: 1,
            reconnect_attempt: 1,
            reconnect_failed: 1,
            reconnect_error: 1,
            reconnecting: 1,
            ping: 1,
            pong: 1
        }
          , st = et.prototype.emit;
        function ut(ct, pt, ft) {
            this.io = ct,
            this.nsp = pt,
            this.json = this,
            this.ids = 0,
            this.acks = {},
            this.receiveBuffer = [],
            this.sendBuffer = [],
            this.connected = !1,
            this.disconnected = !0,
            this.flags = {},
            ft && ft.query && (this.query = ft.query),
            this.io.autoConnect && this.open()
        }
        et(ut.prototype),
        ut.prototype.subEvents = function() {
            if (!this.subs) {
                var ct = this.io;
                this.subs = [rt(ct, "open", nt(this, "onopen")), rt(ct, "packet", nt(this, "onpacket")), rt(ct, "close", nt(this, "onclose"))]
            }
        }
        ,
        ut.prototype.open = ut.prototype.connect = function() {
            return this.connected ? this : (this.subEvents(),
            this.io.reconnecting || this.io.open(),
            this.io.readyState === "open" && this.onopen(),
            this.emit("connecting"),
            this)
        }
        ,
        ut.prototype.send = function() {
            var ct = tt(arguments);
            return ct.unshift("message"),
            this.emit.apply(this, ct),
            this
        }
        ,
        ut.prototype.emit = function(ct) {
            if (lt.hasOwnProperty(ct))
                return st.apply(this, arguments),
                this;
            var pt = tt(arguments)
              , ft = {
                type: (this.flags.binary !== void 0 ? this.flags.binary : at(pt)) ? J.BINARY_EVENT : J.EVENT,
                data: pt
            };
            return ft.options = {},
            ft.options.compress = !this.flags || this.flags.compress !== !1,
            typeof pt[pt.length - 1] == "function" && (ot("emitting packet with ack id %d", this.ids),
            this.acks[this.ids] = pt.pop(),
            ft.id = this.ids++),
            this.connected ? this.packet(ft) : this.sendBuffer.push(ft),
            this.flags = {},
            this
        }
        ,
        ut.prototype.packet = function(ct) {
            ct.nsp = this.nsp,
            this.io.packet(ct)
        }
        ,
        ut.prototype.onopen = function() {
            if (ot("transport is open - connecting"),
            this.nsp !== "/")
                if (this.query) {
                    var ct = typeof this.query == "object" ? it.encode(this.query) : this.query;
                    ot("sending connect packet with query %s", ct),
                    this.packet({
                        type: J.CONNECT,
                        query: ct
                    })
                } else
                    this.packet({
                        type: J.CONNECT
                    })
        }
        ,
        ut.prototype.onclose = function(ct) {
            ot("close (%s)", ct),
            this.connected = !1,
            this.disconnected = !0,
            delete this.id,
            this.emit("disconnect", ct)
        }
        ,
        ut.prototype.onpacket = function(ct) {
            var pt = ct.nsp === this.nsp
              , ft = ct.type === J.ERROR && ct.nsp === "/";
            if (!(!pt && !ft))
                switch (ct.type) {
                case J.CONNECT:
                    this.onconnect();
                    break;
                case J.EVENT:
                    this.onevent(ct);
                    break;
                case J.BINARY_EVENT:
                    this.onevent(ct);
                    break;
                case J.ACK:
                    this.onack(ct);
                    break;
                case J.BINARY_ACK:
                    this.onack(ct);
                    break;
                case J.DISCONNECT:
                    this.ondisconnect();
                    break;
                case J.ERROR:
                    this.emit("error", ct.data);
                    break
                }
        }
        ,
        ut.prototype.onevent = function(ct) {
            var pt = ct.data || [];
            ot("emitting event %j", pt),
            ct.id != null && (ot("attaching ack callback to event"),
            pt.push(this.ack(ct.id))),
            this.connected ? st.apply(this, pt) : this.receiveBuffer.push(pt)
        }
        ,
        ut.prototype.ack = function(ct) {
            var pt = this
              , ft = !1;
            return function() {
                if (!ft) {
                    ft = !0;
                    var yt = tt(arguments);
                    ot("sending ack %j", yt),
                    pt.packet({
                        type: at(yt) ? J.BINARY_ACK : J.ACK,
                        id: ct,
                        data: yt
                    })
                }
            }
        }
        ,
        ut.prototype.onack = function(ct) {
            var pt = this.acks[ct.id];
            typeof pt == "function" ? (ot("calling ack %s with %j", ct.id, ct.data),
            pt.apply(this, ct.data),
            delete this.acks[ct.id]) : ot("bad ack %s", ct.id)
        }
        ,
        ut.prototype.onconnect = function() {
            this.connected = !0,
            this.disconnected = !1,
            this.emit("connect"),
            this.emitBuffered()
        }
        ,
        ut.prototype.emitBuffered = function() {
            var ct;
            for (ct = 0; ct < this.receiveBuffer.length; ct++)
                st.apply(this, this.receiveBuffer[ct]);
            for (this.receiveBuffer = [],
            ct = 0; ct < this.sendBuffer.length; ct++)
                this.packet(this.sendBuffer[ct]);
            this.sendBuffer = []
        }
        ,
        ut.prototype.ondisconnect = function() {
            ot("server disconnect (%s)", this.nsp),
            this.destroy(),
            this.onclose("io server disconnect")
        }
        ,
        ut.prototype.destroy = function() {
            if (this.subs) {
                for (var ct = 0; ct < this.subs.length; ct++)
                    this.subs[ct].destroy();
                this.subs = null
            }
            this.io.destroy(this)
        }
        ,
        ut.prototype.close = ut.prototype.disconnect = function() {
            return this.connected && (ot("performing disconnect (%s)", this.nsp),
            this.packet({
                type: J.DISCONNECT
            })),
            this.destroy(),
            this.connected && this.onclose("io client disconnect"),
            this
        }
        ,
        ut.prototype.compress = function(ct) {
            return this.flags.compress = ct,
            this
        }
        ,
        ut.prototype.binary = function(ct) {
            return this.flags.binary = ct,
            this
        }
    }
    )(socket$1);
    var socketExports = socket$1.exports
      , backo2 = Backoff$1;
    function Backoff$1(_) {
        _ = _ || {},
        this.ms = _.min || 100,
        this.max = _.max || 1e4,
        this.factor = _.factor || 2,
        this.jitter = _.jitter > 0 && _.jitter <= 1 ? _.jitter : 0,
        this.attempts = 0
    }
    Backoff$1.prototype.duration = function() {
        var _ = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
            var k = Math.random()
              , J = Math.floor(k * this.jitter * _);
            _ = Math.floor(k * 10) & 1 ? _ + J : _ - J
        }
        return Math.min(_, this.max) | 0
    }
    ,
    Backoff$1.prototype.reset = function() {
        this.attempts = 0
    }
    ,
    Backoff$1.prototype.setMin = function(_) {
        this.ms = _
    }
    ,
    Backoff$1.prototype.setMax = function(_) {
        this.max = _
    }
    ,
    Backoff$1.prototype.setJitter = function(_) {
        this.jitter = _
    }
    ;
    var eio = libExports$1
      , Socket = socketExports
      , Emitter = componentEmitterExports
      , parser = socket_ioParser
      , on = on_1
      , bind = componentBind
      , debug = browserExports$2("socket.io-client:manager")
      , indexOf = indexof
      , Backoff = backo2
      , has = Object.prototype.hasOwnProperty
      , manager = Manager;
    function Manager(_, k) {
        if (!(this instanceof Manager))
            return new Manager(_,k);
        _ && typeof _ == "object" && (k = _,
        _ = void 0),
        k = k || {},
        k.path = k.path || "/socket.io",
        this.nsps = {},
        this.subs = [],
        this.opts = k,
        this.reconnection(k.reconnection !== !1),
        this.reconnectionAttempts(k.reconnectionAttempts || 1 / 0),
        this.reconnectionDelay(k.reconnectionDelay || 1e3),
        this.reconnectionDelayMax(k.reconnectionDelayMax || 5e3),
        this.randomizationFactor(k.randomizationFactor || .5),
        this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
        }),
        this.timeout(k.timeout == null ? 2e4 : k.timeout),
        this.readyState = "closed",
        this.uri = _,
        this.connecting = [],
        this.lastPing = null,
        this.encoding = !1,
        this.packetBuffer = [];
        var J = k.parser || parser;
        this.encoder = new J.Encoder,
        this.decoder = new J.Decoder,
        this.autoConnect = k.autoConnect !== !1,
        this.autoConnect && this.open()
    }
    Manager.prototype.emitAll = function() {
        this.emit.apply(this, arguments);
        for (var _ in this.nsps)
            has.call(this.nsps, _) && this.nsps[_].emit.apply(this.nsps[_], arguments)
    }
    ,
    Manager.prototype.updateSocketIds = function() {
        for (var _ in this.nsps)
            has.call(this.nsps, _) && (this.nsps[_].id = this.generateId(_))
    }
    ,
    Manager.prototype.generateId = function(_) {
        return (_ === "/" ? "" : _ + "#") + this.engine.id
    }
    ,
    Emitter(Manager.prototype),
    Manager.prototype.reconnection = function(_) {
        return arguments.length ? (this._reconnection = !!_,
        this) : this._reconnection
    }
    ,
    Manager.prototype.reconnectionAttempts = function(_) {
        return arguments.length ? (this._reconnectionAttempts = _,
        this) : this._reconnectionAttempts
    }
    ,
    Manager.prototype.reconnectionDelay = function(_) {
        return arguments.length ? (this._reconnectionDelay = _,
        this.backoff && this.backoff.setMin(_),
        this) : this._reconnectionDelay
    }
    ,
    Manager.prototype.randomizationFactor = function(_) {
        return arguments.length ? (this._randomizationFactor = _,
        this.backoff && this.backoff.setJitter(_),
        this) : this._randomizationFactor
    }
    ,
    Manager.prototype.reconnectionDelayMax = function(_) {
        return arguments.length ? (this._reconnectionDelayMax = _,
        this.backoff && this.backoff.setMax(_),
        this) : this._reconnectionDelayMax
    }
    ,
    Manager.prototype.timeout = function(_) {
        return arguments.length ? (this._timeout = _,
        this) : this._timeout
    }
    ,
    Manager.prototype.maybeReconnectOnOpen = function() {
        !this.reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
    }
    ,
    Manager.prototype.open = Manager.prototype.connect = function(_, k) {
        if (debug("readyState %s", this.readyState),
        ~this.readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri),
        this.engine = eio(this.uri, this.opts);
        var J = this.engine
          , et = this;
        this.readyState = "opening",
        this.skipReconnect = !1;
        var tt = on(J, "open", function() {
            et.onopen(),
            _ && _()
        })
          , rt = on(J, "error", function(it) {
            if (debug("connect_error"),
            et.cleanup(),
            et.readyState = "closed",
            et.emitAll("connect_error", it),
            _) {
                var at = new Error("Connection error");
                at.data = it,
                _(at)
            } else
                et.maybeReconnectOnOpen()
        });
        if (this._timeout !== !1) {
            var nt = this._timeout;
            debug("connect attempt will timeout after %d", nt),
            nt === 0 && tt.destroy();
            var ot = setTimeout(function() {
                debug("connect attempt timed out after %d", nt),
                tt.destroy(),
                J.close(),
                J.emit("error", "timeout"),
                et.emitAll("connect_timeout", nt)
            }, nt);
            this.subs.push({
                destroy: function() {
                    clearTimeout(ot)
                }
            })
        }
        return this.subs.push(tt),
        this.subs.push(rt),
        this
    }
    ,
    Manager.prototype.onopen = function() {
        debug("open"),
        this.cleanup(),
        this.readyState = "open",
        this.emit("open");
        var _ = this.engine;
        this.subs.push(on(_, "data", bind(this, "ondata"))),
        this.subs.push(on(_, "ping", bind(this, "onping"))),
        this.subs.push(on(_, "pong", bind(this, "onpong"))),
        this.subs.push(on(_, "error", bind(this, "onerror"))),
        this.subs.push(on(_, "close", bind(this, "onclose"))),
        this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")))
    }
    ,
    Manager.prototype.onping = function() {
        this.lastPing = new Date,
        this.emitAll("ping")
    }
    ,
    Manager.prototype.onpong = function() {
        this.emitAll("pong", new Date - this.lastPing)
    }
    ,
    Manager.prototype.ondata = function(_) {
        this.decoder.add(_)
    }
    ,
    Manager.prototype.ondecoded = function(_) {
        this.emit("packet", _)
    }
    ,
    Manager.prototype.onerror = function(_) {
        debug("error", _),
        this.emitAll("error", _)
    }
    ,
    Manager.prototype.socket = function(_, k) {
        var J = this.nsps[_];
        if (!J) {
            J = new Socket(this,_,k),
            this.nsps[_] = J;
            var et = this;
            J.on("connecting", tt),
            J.on("connect", function() {
                J.id = et.generateId(_)
            }),
            this.autoConnect && tt()
        }
        function tt() {
            ~indexOf(et.connecting, J) || et.connecting.push(J)
        }
        return J
    }
    ,
    Manager.prototype.destroy = function(_) {
        var k = indexOf(this.connecting, _);
        ~k && this.connecting.splice(k, 1),
        !this.connecting.length && this.close()
    }
    ,
    Manager.prototype.packet = function(_) {
        debug("writing packet %j", _);
        var k = this;
        _.query && _.type === 0 && (_.nsp += "?" + _.query),
        k.encoding ? k.packetBuffer.push(_) : (k.encoding = !0,
        this.encoder.encode(_, function(J) {
            for (var et = 0; et < J.length; et++)
                k.engine.write(J[et], _.options);
            k.encoding = !1,
            k.processPacketQueue()
        }))
    }
    ,
    Manager.prototype.processPacketQueue = function() {
        if (this.packetBuffer.length > 0 && !this.encoding) {
            var _ = this.packetBuffer.shift();
            this.packet(_)
        }
    }
    ,
    Manager.prototype.cleanup = function() {
        debug("cleanup");
        for (var _ = this.subs.length, k = 0; k < _; k++) {
            var J = this.subs.shift();
            J.destroy()
        }
        this.packetBuffer = [],
        this.encoding = !1,
        this.lastPing = null,
        this.decoder.destroy()
    }
    ,
    Manager.prototype.close = Manager.prototype.disconnect = function() {
        debug("disconnect"),
        this.skipReconnect = !0,
        this.reconnecting = !1,
        this.readyState === "opening" && this.cleanup(),
        this.backoff.reset(),
        this.readyState = "closed",
        this.engine && this.engine.close()
    }
    ,
    Manager.prototype.onclose = function(_) {
        debug("onclose"),
        this.cleanup(),
        this.backoff.reset(),
        this.readyState = "closed",
        this.emit("close", _),
        this._reconnection && !this.skipReconnect && this.reconnect()
    }
    ,
    Manager.prototype.reconnect = function() {
        if (this.reconnecting || this.skipReconnect)
            return this;
        var _ = this;
        if (this.backoff.attempts >= this._reconnectionAttempts)
            debug("reconnect failed"),
            this.backoff.reset(),
            this.emitAll("reconnect_failed"),
            this.reconnecting = !1;
        else {
            var k = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", k),
            this.reconnecting = !0;
            var J = setTimeout(function() {
                _.skipReconnect || (debug("attempting reconnect"),
                _.emitAll("reconnect_attempt", _.backoff.attempts),
                _.emitAll("reconnecting", _.backoff.attempts),
                !_.skipReconnect && _.open(function(et) {
                    et ? (debug("reconnect attempt error"),
                    _.reconnecting = !1,
                    _.reconnect(),
                    _.emitAll("reconnect_error", et.data)) : (debug("reconnect success"),
                    _.onreconnect())
                }))
            }, k);
            this.subs.push({
                destroy: function() {
                    clearTimeout(J)
                }
            })
        }
    }
    ,
    Manager.prototype.onreconnect = function() {
        var _ = this.backoff.attempts;
        this.reconnecting = !1,
        this.backoff.reset(),
        this.updateSocketIds(),
        this.emitAll("reconnect", _)
    }
    ,
    function(_, k) {
        var J = url_1
          , et = socket_ioParser
          , tt = manager
          , rt = browserExports$2("socket.io-client");
        _.exports = k = ot;
        var nt = k.managers = {};
        function ot(it, at) {
            typeof it == "object" && (at = it,
            it = void 0),
            at = at || {};
            var lt = J(it), st = lt.source, ut = lt.id, ct = lt.path, pt = nt[ut] && ct in nt[ut].nsps, ft = at.forceNew || at["force new connection"] || at.multiplex === !1 || pt, yt;
            return ft ? (rt("ignoring socket cache for %s", st),
            yt = tt(st, at)) : (nt[ut] || (rt("new io instance for %s", st),
            nt[ut] = tt(st, at)),
            yt = nt[ut]),
            lt.query && !at.query && (at.query = lt.query),
            yt.socket(lt.path, at)
        }
        k.protocol = et.protocol,
        k.connect = ot,
        k.Manager = manager,
        k.Socket = socketExports
    }(lib$1, lib$1.exports);
    var libExports = lib$1.exports, events = {
        exports: {}
    }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function _(k, J, et) {
        return Function.prototype.apply.call(k, J, et)
    }
    , ReflectOwnKeys;
    R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(_) {
        return Object.getOwnPropertyNames(_).concat(Object.getOwnPropertySymbols(_))
    }
    : ReflectOwnKeys = function(_) {
        return Object.getOwnPropertyNames(_)
    }
    ;
    function ProcessEmitWarning(_) {}
    var NumberIsNaN = Number.isNaN || function _(k) {
        return k !== k
    }
    ;
    function EventEmitter$1() {
        EventEmitter$1.init.call(this)
    }
    events.exports = EventEmitter$1,
    events.exports.once = once,
    EventEmitter$1.EventEmitter = EventEmitter$1,
    EventEmitter$1.prototype._events = void 0,
    EventEmitter$1.prototype._eventsCount = 0,
    EventEmitter$1.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(_) {
        if (typeof _ != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof _)
    }
    Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return defaultMaxListeners
        },
        set: function(_) {
            if (typeof _ != "number" || _ < 0 || NumberIsNaN(_))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + _ + ".");
            defaultMaxListeners = _
        }
    }),
    EventEmitter$1.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    EventEmitter$1.prototype.setMaxListeners = function _(k) {
        if (typeof k != "number" || k < 0 || NumberIsNaN(k))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + k + ".");
        return this._maxListeners = k,
        this
    }
    ;
    function _getMaxListeners(_) {
        return _._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : _._maxListeners
    }
    EventEmitter$1.prototype.getMaxListeners = function _() {
        return _getMaxListeners(this)
    }
    ,
    EventEmitter$1.prototype.emit = function _(k) {
        for (var J = [], et = 1; et < arguments.length; et++)
            J.push(arguments[et]);
        var tt = k === "error"
          , rt = this._events;
        if (rt !== void 0)
            tt = tt && rt.error === void 0;
        else if (!tt)
            return !1;
        if (tt) {
            var nt;
            if (J.length > 0 && (nt = J[0]),
            nt instanceof Error)
                throw nt;
            var ot = new Error("Unhandled error." + (nt ? " (" + nt.message + ")" : ""));
            throw ot.context = nt,
            ot
        }
        var it = rt[k];
        if (it === void 0)
            return !1;
        if (typeof it == "function")
            ReflectApply(it, this, J);
        else
            for (var at = it.length, lt = arrayClone(it, at), et = 0; et < at; ++et)
                ReflectApply(lt[et], this, J);
        return !0
    }
    ;
    function _addListener(_, k, J, et) {
        var tt, rt, nt;
        if (checkListener(J),
        rt = _._events,
        rt === void 0 ? (rt = _._events = Object.create(null),
        _._eventsCount = 0) : (rt.newListener !== void 0 && (_.emit("newListener", k, J.listener ? J.listener : J),
        rt = _._events),
        nt = rt[k]),
        nt === void 0)
            nt = rt[k] = J,
            ++_._eventsCount;
        else if (typeof nt == "function" ? nt = rt[k] = et ? [J, nt] : [nt, J] : et ? nt.unshift(J) : nt.push(J),
        tt = _getMaxListeners(_),
        tt > 0 && nt.length > tt && !nt.warned) {
            nt.warned = !0;
            var ot = new Error("Possible EventEmitter memory leak detected. " + nt.length + " " + String(k) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            ot.name = "MaxListenersExceededWarning",
            ot.emitter = _,
            ot.type = k,
            ot.count = nt.length
        }
        return _
    }
    EventEmitter$1.prototype.addListener = function _(k, J) {
        return _addListener(this, k, J, !1)
    }
    ,
    EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener,
    EventEmitter$1.prototype.prependListener = function _(k, J) {
        return _addListener(this, k, J, !0)
    }
    ;
    function onceWrapper() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function _onceWrap(_, k, J) {
        var et = {
            fired: !1,
            wrapFn: void 0,
            target: _,
            type: k,
            listener: J
        }
          , tt = onceWrapper.bind(et);
        return tt.listener = J,
        et.wrapFn = tt,
        tt
    }
    EventEmitter$1.prototype.once = function _(k, J) {
        return checkListener(J),
        this.on(k, _onceWrap(this, k, J)),
        this
    }
    ,
    EventEmitter$1.prototype.prependOnceListener = function _(k, J) {
        return checkListener(J),
        this.prependListener(k, _onceWrap(this, k, J)),
        this
    }
    ,
    EventEmitter$1.prototype.removeListener = function _(k, J) {
        var et, tt, rt, nt, ot;
        if (checkListener(J),
        tt = this._events,
        tt === void 0)
            return this;
        if (et = tt[k],
        et === void 0)
            return this;
        if (et === J || et.listener === J)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete tt[k],
            tt.removeListener && this.emit("removeListener", k, et.listener || J));
        else if (typeof et != "function") {
            for (rt = -1,
            nt = et.length - 1; nt >= 0; nt--)
                if (et[nt] === J || et[nt].listener === J) {
                    ot = et[nt].listener,
                    rt = nt;
                    break
                }
            if (rt < 0)
                return this;
            rt === 0 ? et.shift() : spliceOne(et, rt),
            et.length === 1 && (tt[k] = et[0]),
            tt.removeListener !== void 0 && this.emit("removeListener", k, ot || J)
        }
        return this
    }
    ,
    EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener,
    EventEmitter$1.prototype.removeAllListeners = function _(k) {
        var J, et, tt;
        if (et = this._events,
        et === void 0)
            return this;
        if (et.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : et[k] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete et[k]),
            this;
        if (arguments.length === 0) {
            var rt = Object.keys(et), nt;
            for (tt = 0; tt < rt.length; ++tt)
                nt = rt[tt],
                nt !== "removeListener" && this.removeAllListeners(nt);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (J = et[k],
        typeof J == "function")
            this.removeListener(k, J);
        else if (J !== void 0)
            for (tt = J.length - 1; tt >= 0; tt--)
                this.removeListener(k, J[tt]);
        return this
    }
    ;
    function _listeners(_, k, J) {
        var et = _._events;
        if (et === void 0)
            return [];
        var tt = et[k];
        return tt === void 0 ? [] : typeof tt == "function" ? J ? [tt.listener || tt] : [tt] : J ? unwrapListeners(tt) : arrayClone(tt, tt.length)
    }
    EventEmitter$1.prototype.listeners = function _(k) {
        return _listeners(this, k, !0)
    }
    ,
    EventEmitter$1.prototype.rawListeners = function _(k) {
        return _listeners(this, k, !1)
    }
    ,
    EventEmitter$1.listenerCount = function(_, k) {
        return typeof _.listenerCount == "function" ? _.listenerCount(k) : listenerCount.call(_, k)
    }
    ,
    EventEmitter$1.prototype.listenerCount = listenerCount;
    function listenerCount(_) {
        var k = this._events;
        if (k !== void 0) {
            var J = k[_];
            if (typeof J == "function")
                return 1;
            if (J !== void 0)
                return J.length
        }
        return 0
    }
    EventEmitter$1.prototype.eventNames = function _() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
    }
    ;
    function arrayClone(_, k) {
        for (var J = new Array(k), et = 0; et < k; ++et)
            J[et] = _[et];
        return J
    }
    function spliceOne(_, k) {
        for (; k + 1 < _.length; k++)
            _[k] = _[k + 1];
        _.pop()
    }
    function unwrapListeners(_) {
        for (var k = new Array(_.length), J = 0; J < k.length; ++J)
            k[J] = _[J].listener || _[J];
        return k
    }
    function once(_, k) {
        return new Promise(function(J, et) {
            function tt(nt) {
                _.removeListener(k, rt),
                et(nt)
            }
            function rt() {
                typeof _.removeListener == "function" && _.removeListener("error", tt),
                J([].slice.call(arguments))
            }
            eventTargetAgnosticAddListener(_, k, rt, {
                once: !0
            }),
            k !== "error" && addErrorHandlerIfEventEmitter(_, tt, {
                once: !0
            })
        }
        )
    }
    function addErrorHandlerIfEventEmitter(_, k, J) {
        typeof _.on == "function" && eventTargetAgnosticAddListener(_, "error", k, J)
    }
    function eventTargetAgnosticAddListener(_, k, J, et) {
        if (typeof _.on == "function")
            et.once ? _.once(k, J) : _.on(k, J);
        else if (typeof _.addEventListener == "function")
            _.addEventListener(k, function tt(rt) {
                et.once && _.removeEventListener(k, tt),
                J(rt)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof _)
    }
    var eventsExports = events.exports, indexMinimal = {}, minimal$1 = {}, longbits, hasRequiredLongbits;
    function requireLongbits() {
        if (hasRequiredLongbits)
            return longbits;
        hasRequiredLongbits = 1,
        longbits = k;
        var _ = requireMinimal();
        function k(rt, nt) {
            this.lo = rt >>> 0,
            this.hi = nt >>> 0
        }
        var J = k.zero = new k(0,0);
        J.toNumber = function() {
            return 0
        }
        ,
        J.zzEncode = J.zzDecode = function() {
            return this
        }
        ,
        J.length = function() {
            return 1
        }
        ;
        var et = k.zeroHash = "\0\0\0\0\0\0\0\0";
        k.fromNumber = function(rt) {
            if (rt === 0)
                return J;
            var nt = rt < 0;
            nt && (rt = -rt);
            var ot = rt >>> 0
              , it = (rt - ot) / 4294967296 >>> 0;
            return nt && (it = ~it >>> 0,
            ot = ~ot >>> 0,
            ++ot > 4294967295 && (ot = 0,
            ++it > 4294967295 && (it = 0))),
            new k(ot,it)
        }
        ,
        k.from = function(rt) {
            if (typeof rt == "number")
                return k.fromNumber(rt);
            if (_.isString(rt))
                if (_.Long)
                    rt = _.Long.fromString(rt);
                else
                    return k.fromNumber(parseInt(rt, 10));
            return rt.low || rt.high ? new k(rt.low >>> 0,rt.high >>> 0) : J
        }
        ,
        k.prototype.toNumber = function(rt) {
            if (!rt && this.hi >>> 31) {
                var nt = ~this.lo + 1 >>> 0
                  , ot = ~this.hi >>> 0;
                return nt || (ot = ot + 1 >>> 0),
                -(nt + ot * 4294967296)
            }
            return this.lo + this.hi * 4294967296
        }
        ,
        k.prototype.toLong = function(rt) {
            return _.Long ? new _.Long(this.lo | 0,this.hi | 0,!!rt) : {
                low: this.lo | 0,
                high: this.hi | 0,
                unsigned: !!rt
            }
        }
        ;
        var tt = String.prototype.charCodeAt;
        return k.fromHash = function(rt) {
            return rt === et ? J : new k((tt.call(rt, 0) | tt.call(rt, 1) << 8 | tt.call(rt, 2) << 16 | tt.call(rt, 3) << 24) >>> 0,(tt.call(rt, 4) | tt.call(rt, 5) << 8 | tt.call(rt, 6) << 16 | tt.call(rt, 7) << 24) >>> 0)
        }
        ,
        k.prototype.toHash = function() {
            return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
        }
        ,
        k.prototype.zzEncode = function() {
            var rt = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ rt) >>> 0,
            this.lo = (this.lo << 1 ^ rt) >>> 0,
            this
        }
        ,
        k.prototype.zzDecode = function() {
            var rt = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ rt) >>> 0,
            this.hi = (this.hi >>> 1 ^ rt) >>> 0,
            this
        }
        ,
        k.prototype.length = function() {
            var rt = this.lo
              , nt = (this.lo >>> 28 | this.hi << 4) >>> 0
              , ot = this.hi >>> 24;
            return ot === 0 ? nt === 0 ? rt < 16384 ? rt < 128 ? 1 : 2 : rt < 2097152 ? 3 : 4 : nt < 16384 ? nt < 128 ? 5 : 6 : nt < 2097152 ? 7 : 8 : ot < 128 ? 9 : 10
        }
        ,
        longbits
    }
    var hasRequiredMinimal;
    function requireMinimal() {
        return hasRequiredMinimal || (hasRequiredMinimal = 1,
        function(_) {
            var k = _;
            k.asPromise = aspromise,
            k.base64 = base64$2,
            k.EventEmitter = eventemitter,
            k.float = float,
            k.inquire = inquire_1,
            k.utf8 = utf8$5,
            k.pool = pool_1,
            k.LongBits = requireLongbits(),
            k.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node),
            k.global = k.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal,
            k.emptyArray = Object.freeze ? Object.freeze([]) : [],
            k.emptyObject = Object.freeze ? Object.freeze({}) : {},
            k.isInteger = Number.isInteger || function(tt) {
                return typeof tt == "number" && isFinite(tt) && Math.floor(tt) === tt
            }
            ,
            k.isString = function(tt) {
                return typeof tt == "string" || tt instanceof String
            }
            ,
            k.isObject = function(tt) {
                return tt && typeof tt == "object"
            }
            ,
            k.isset = k.isSet = function(tt, rt) {
                var nt = tt[rt];
                return nt != null && tt.hasOwnProperty(rt) ? typeof nt != "object" || (Array.isArray(nt) ? nt.length : Object.keys(nt).length) > 0 : !1
            }
            ,
            k.Buffer = function() {
                try {
                    var tt = k.inquire("buffer").Buffer;
                    return tt.prototype.utf8Write ? tt : null
                } catch (rt) {
                    return null
                }
            }(),
            k._Buffer_from = null,
            k._Buffer_allocUnsafe = null,
            k.newBuffer = function(tt) {
                return typeof tt == "number" ? k.Buffer ? k._Buffer_allocUnsafe(tt) : new k.Array(tt) : k.Buffer ? k._Buffer_from(tt) : typeof Uint8Array > "u" ? tt : new Uint8Array(tt)
            }
            ,
            k.Array = typeof Uint8Array < "u" ? Uint8Array : Array,
            k.Long = k.global.dcodeIO && k.global.dcodeIO.Long || k.global.Long || k.inquire("long"),
            k.key2Re = /^true|false|0|1$/,
            k.key32Re = /^-?(?:0|[1-9][0-9]*)$/,
            k.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,
            k.longToHash = function(tt) {
                return tt ? k.LongBits.from(tt).toHash() : k.LongBits.zeroHash
            }
            ,
            k.longFromHash = function(tt, rt) {
                var nt = k.LongBits.fromHash(tt);
                return k.Long ? k.Long.fromBits(nt.lo, nt.hi, rt) : nt.toNumber(!!rt)
            }
            ;
            function J(tt, rt, nt) {
                for (var ot = Object.keys(rt), it = 0; it < ot.length; ++it)
                    (tt[ot[it]] === void 0 || !nt) && (tt[ot[it]] = rt[ot[it]]);
                return tt
            }
            k.merge = J,
            k.lcFirst = function(tt) {
                return tt.charAt(0).toLowerCase() + tt.substring(1)
            }
            ;
            function et(tt) {
                function rt(nt, ot) {
                    if (!(this instanceof rt))
                        return new rt(nt,ot);
                    Object.defineProperty(this, "message", {
                        get: function() {
                            return nt
                        }
                    }),
                    Error.captureStackTrace ? Error.captureStackTrace(this, rt) : Object.defineProperty(this, "stack", {
                        value: new Error().stack || ""
                    }),
                    ot && J(this, ot)
                }
                return (rt.prototype = Object.create(Error.prototype)).constructor = rt,
                Object.defineProperty(rt.prototype, "name", {
                    get: function() {
                        return tt
                    }
                }),
                rt.prototype.toString = function() {
                    return this.name + ": " + this.message
                }
                ,
                rt
            }
            k.newError = et,
            k.ProtocolError = et("ProtocolError"),
            k.oneOfGetter = function(tt) {
                for (var rt = {}, nt = 0; nt < tt.length; ++nt)
                    rt[tt[nt]] = 1;
                return function() {
                    for (var ot = Object.keys(this), it = ot.length - 1; it > -1; --it)
                        if (rt[ot[it]] === 1 && this[ot[it]] !== void 0 && this[ot[it]] !== null)
                            return ot[it]
                }
            }
            ,
            k.oneOfSetter = function(tt) {
                return function(rt) {
                    for (var nt = 0; nt < tt.length; ++nt)
                        tt[nt] !== rt && delete this[tt[nt]]
                }
            }
            ,
            k.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: !0
            },
            k._configure = function() {
                var tt = k.Buffer;
                if (!tt) {
                    k._Buffer_from = k._Buffer_allocUnsafe = null;
                    return
                }
                k._Buffer_from = tt.from !== Uint8Array.from && tt.from || function(rt, nt) {
                    return new tt(rt,nt)
                }
                ,
                k._Buffer_allocUnsafe = tt.allocUnsafe || function(rt) {
                    return new tt(rt)
                }
            }
        }(minimal$1)),
        minimal$1
    }
    var writer = Writer$1, util$4 = requireMinimal(), BufferWriter$1, LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
    function Op(_, k, J) {
        this.fn = _,
        this.len = k,
        this.next = void 0,
        this.val = J
    }
    function noop$1() {}
    function State$1(_) {
        this.head = _.head,
        this.tail = _.tail,
        this.len = _.len,
        this.next = _.states
    }
    function Writer$1() {
        this.len = 0,
        this.head = new Op(noop$1,0,0),
        this.tail = this.head,
        this.states = null
    }
    var create$1 = function _() {
        return util$4.Buffer ? function() {
            return (Writer$1.create = function() {
                return new BufferWriter$1
            }
            )()
        }
        : function() {
            return new Writer$1
        }
    };
    Writer$1.create = create$1(),
    Writer$1.alloc = function _(k) {
        return new util$4.Array(k)
    }
    ,
    util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)),
    Writer$1.prototype._push = function _(k, J, et) {
        return this.tail = this.tail.next = new Op(k,J,et),
        this.len += J,
        this
    }
    ;
    function writeByte(_, k, J) {
        k[J] = _ & 255
    }
    function writeVarint32(_, k, J) {
        for (; _ > 127; )
            k[J++] = _ & 127 | 128,
            _ >>>= 7;
        k[J] = _
    }
    function VarintOp(_, k) {
        this.len = _,
        this.next = void 0,
        this.val = k
    }
    VarintOp.prototype = Object.create(Op.prototype),
    VarintOp.prototype.fn = writeVarint32,
    Writer$1.prototype.uint32 = function _(k) {
        return this.len += (this.tail = this.tail.next = new VarintOp((k = k >>> 0) < 128 ? 1 : k < 16384 ? 2 : k < 2097152 ? 3 : k < 268435456 ? 4 : 5,k)).len,
        this
    }
    ,
    Writer$1.prototype.int32 = function _(k) {
        return k < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(k)) : this.uint32(k)
    }
    ,
    Writer$1.prototype.sint32 = function _(k) {
        return this.uint32((k << 1 ^ k >> 31) >>> 0)
    }
    ;
    function writeVarint64(_, k, J) {
        for (; _.hi; )
            k[J++] = _.lo & 127 | 128,
            _.lo = (_.lo >>> 7 | _.hi << 25) >>> 0,
            _.hi >>>= 7;
        for (; _.lo > 127; )
            k[J++] = _.lo & 127 | 128,
            _.lo = _.lo >>> 7;
        k[J++] = _.lo
    }
    Writer$1.prototype.uint64 = function _(k) {
        var J = LongBits$1.from(k);
        return this._push(writeVarint64, J.length(), J)
    }
    ,
    Writer$1.prototype.int64 = Writer$1.prototype.uint64,
    Writer$1.prototype.sint64 = function _(k) {
        var J = LongBits$1.from(k).zzEncode();
        return this._push(writeVarint64, J.length(), J)
    }
    ,
    Writer$1.prototype.bool = function _(k) {
        return this._push(writeByte, 1, k ? 1 : 0)
    }
    ;
    function writeFixed32(_, k, J) {
        k[J] = _ & 255,
        k[J + 1] = _ >>> 8 & 255,
        k[J + 2] = _ >>> 16 & 255,
        k[J + 3] = _ >>> 24
    }
    Writer$1.prototype.fixed32 = function _(k) {
        return this._push(writeFixed32, 4, k >>> 0)
    }
    ,
    Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32,
    Writer$1.prototype.fixed64 = function _(k) {
        var J = LongBits$1.from(k);
        return this._push(writeFixed32, 4, J.lo)._push(writeFixed32, 4, J.hi)
    }
    ,
    Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64,
    Writer$1.prototype.float = function _(k) {
        return this._push(util$4.float.writeFloatLE, 4, k)
    }
    ,
    Writer$1.prototype.double = function _(k) {
        return this._push(util$4.float.writeDoubleLE, 8, k)
    }
    ;
    var writeBytes = util$4.Array.prototype.set ? function _(k, J, et) {
        J.set(k, et)
    }
    : function _(k, J, et) {
        for (var tt = 0; tt < k.length; ++tt)
            J[et + tt] = k[tt]
    }
    ;
    Writer$1.prototype.bytes = function _(k) {
        var J = k.length >>> 0;
        if (!J)
            return this._push(writeByte, 1, 0);
        if (util$4.isString(k)) {
            var et = Writer$1.alloc(J = base64.length(k));
            base64.decode(k, et, 0),
            k = et
        }
        return this.uint32(J)._push(writeBytes, J, k)
    }
    ,
    Writer$1.prototype.string = function _(k) {
        var J = utf8$1.length(k);
        return J ? this.uint32(J)._push(utf8$1.write, J, k) : this._push(writeByte, 1, 0)
    }
    ,
    Writer$1.prototype.fork = function _() {
        return this.states = new State$1(this),
        this.head = this.tail = new Op(noop$1,0,0),
        this.len = 0,
        this
    }
    ,
    Writer$1.prototype.reset = function _() {
        return this.states ? (this.head = this.states.head,
        this.tail = this.states.tail,
        this.len = this.states.len,
        this.states = this.states.next) : (this.head = this.tail = new Op(noop$1,0,0),
        this.len = 0),
        this
    }
    ,
    Writer$1.prototype.ldelim = function _() {
        var k = this.head
          , J = this.tail
          , et = this.len;
        return this.reset().uint32(et),
        et && (this.tail.next = k.next,
        this.tail = J,
        this.len += et),
        this
    }
    ,
    Writer$1.prototype.finish = function _() {
        for (var k = this.head.next, J = this.constructor.alloc(this.len), et = 0; k; )
            k.fn(k.val, J, et),
            et += k.len,
            k = k.next;
        return J
    }
    ,
    Writer$1._configure = function(_) {
        BufferWriter$1 = _,
        Writer$1.create = create$1(),
        BufferWriter$1._configure()
    }
    ;
    var writer_buffer = BufferWriter
      , Writer = writer;
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util$3 = requireMinimal();
    function BufferWriter() {
        Writer.call(this)
    }
    BufferWriter._configure = function() {
        BufferWriter.alloc = util$3._Buffer_allocUnsafe,
        BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function(_, k, J) {
            k.set(_, J)
        }
        : function(_, k, J) {
            if (_.copy)
                _.copy(k, J, 0, _.length);
            else
                for (var et = 0; et < _.length; )
                    k[J++] = _[et++]
        }
    }
    ,
    BufferWriter.prototype.bytes = function _(k) {
        util$3.isString(k) && (k = util$3._Buffer_from(k, "base64"));
        var J = k.length >>> 0;
        return this.uint32(J),
        J && this._push(BufferWriter.writeBytesBuffer, J, k),
        this
    }
    ;
    function writeStringBuffer(_, k, J) {
        _.length < 40 ? util$3.utf8.write(_, k, J) : k.utf8Write ? k.utf8Write(_, J) : k.write(_, J)
    }
    BufferWriter.prototype.string = function _(k) {
        var J = util$3.Buffer.byteLength(k);
        return this.uint32(J),
        J && this._push(writeStringBuffer, J, k),
        this
    }
    ,
    BufferWriter._configure();
    var reader = Reader$1, util$2 = requireMinimal(), BufferReader$1, LongBits = util$2.LongBits, utf8 = util$2.utf8;
    function indexOutOfRange(_, k) {
        return RangeError("index out of range: " + _.pos + " + " + (k || 1) + " > " + _.len)
    }
    function Reader$1(_) {
        this.buf = _,
        this.pos = 0,
        this.len = _.length
    }
    var create_array = typeof Uint8Array < "u" ? function _(k) {
        if (k instanceof Uint8Array || Array.isArray(k))
            return new Reader$1(k);
        throw Error("illegal buffer")
    }
    : function _(k) {
        if (Array.isArray(k))
            return new Reader$1(k);
        throw Error("illegal buffer")
    }
      , create = function _() {
        return util$2.Buffer ? function(k) {
            return (Reader$1.create = function(J) {
                return util$2.Buffer.isBuffer(J) ? new BufferReader$1(J) : create_array(J)
            }
            )(k)
        }
        : create_array
    };
    Reader$1.create = create(),
    Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice,
    Reader$1.prototype.uint32 = function _() {
        var k = 4294967295;
        return function() {
            if (k = (this.buf[this.pos] & 127) >>> 0,
            this.buf[this.pos++] < 128 || (k = (k | (this.buf[this.pos] & 127) << 7) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 127) << 14) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 127) << 21) >>> 0,
            this.buf[this.pos++] < 128) || (k = (k | (this.buf[this.pos] & 15) << 28) >>> 0,
            this.buf[this.pos++] < 128))
                return k;
            if ((this.pos += 5) > this.len)
                throw this.pos = this.len,
                indexOutOfRange(this, 10);
            return k
        }
    }(),
    Reader$1.prototype.int32 = function _() {
        return this.uint32() | 0
    }
    ,
    Reader$1.prototype.sint32 = function _() {
        var k = this.uint32();
        return k >>> 1 ^ -(k & 1) | 0
    }
    ;
    function readLongVarint() {
        var _ = new LongBits(0,0)
          , k = 0;
        if (this.len - this.pos > 4) {
            for (; k < 4; ++k)
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << k * 7) >>> 0,
                this.buf[this.pos++] < 128)
                    return _;
            if (_.lo = (_.lo | (this.buf[this.pos] & 127) << 28) >>> 0,
            _.hi = (_.hi | (this.buf[this.pos] & 127) >> 4) >>> 0,
            this.buf[this.pos++] < 128)
                return _;
            k = 0
        } else {
            for (; k < 3; ++k) {
                if (this.pos >= this.len)
                    throw indexOutOfRange(this);
                if (_.lo = (_.lo | (this.buf[this.pos] & 127) << k * 7) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
            }
            return _.lo = (_.lo | (this.buf[this.pos++] & 127) << k * 7) >>> 0,
            _
        }
        if (this.len - this.pos > 4) {
            for (; k < 5; ++k)
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << k * 7 + 3) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
        } else
            for (; k < 5; ++k) {
                if (this.pos >= this.len)
                    throw indexOutOfRange(this);
                if (_.hi = (_.hi | (this.buf[this.pos] & 127) << k * 7 + 3) >>> 0,
                this.buf[this.pos++] < 128)
                    return _
            }
        throw Error("invalid varint encoding")
    }
    Reader$1.prototype.bool = function _() {
        return this.uint32() !== 0
    }
    ;
    function readFixed32_end(_, k) {
        return (_[k - 4] | _[k - 3] << 8 | _[k - 2] << 16 | _[k - 1] << 24) >>> 0
    }
    Reader$1.prototype.fixed32 = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4)
    }
    ,
    Reader$1.prototype.sfixed32 = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0
    }
    ;
    function readFixed64() {
        if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4),readFixed32_end(this.buf, this.pos += 4))
    }
    Reader$1.prototype.float = function _() {
        if (this.pos + 4 > this.len)
            throw indexOutOfRange(this, 4);
        var k = util$2.float.readFloatLE(this.buf, this.pos);
        return this.pos += 4,
        k
    }
    ,
    Reader$1.prototype.double = function _() {
        if (this.pos + 8 > this.len)
            throw indexOutOfRange(this, 4);
        var k = util$2.float.readDoubleLE(this.buf, this.pos);
        return this.pos += 8,
        k
    }
    ,
    Reader$1.prototype.bytes = function _() {
        var k = this.uint32()
          , J = this.pos
          , et = this.pos + k;
        if (et > this.len)
            throw indexOutOfRange(this, k);
        return this.pos += k,
        Array.isArray(this.buf) ? this.buf.slice(J, et) : J === et ? new this.buf.constructor(0) : this._slice.call(this.buf, J, et)
    }
    ,
    Reader$1.prototype.string = function _() {
        var k = this.bytes();
        return utf8.read(k, 0, k.length)
    }
    ,
    Reader$1.prototype.skip = function _(k) {
        if (typeof k == "number") {
            if (this.pos + k > this.len)
                throw indexOutOfRange(this, k);
            this.pos += k
        } else
            do
                if (this.pos >= this.len)
                    throw indexOutOfRange(this);
            while (this.buf[this.pos++] & 128);
        return this
    }
    ,
    Reader$1.prototype.skipType = function(_) {
        switch (_) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            for (; (_ = this.uint32() & 7) !== 4; )
                this.skipType(_);
            break;
        case 5:
            this.skip(4);
            break;
        default:
            throw Error("invalid wire type " + _ + " at offset " + this.pos)
        }
        return this
    }
    ,
    Reader$1._configure = function(_) {
        BufferReader$1 = _,
        Reader$1.create = create(),
        BufferReader$1._configure();
        var k = util$2.Long ? "toLong" : "toNumber";
        util$2.merge(Reader$1.prototype, {
            int64: function() {
                return readLongVarint.call(this)[k](!1)
            },
            uint64: function() {
                return readLongVarint.call(this)[k](!0)
            },
            sint64: function() {
                return readLongVarint.call(this).zzDecode()[k](!1)
            },
            fixed64: function() {
                return readFixed64.call(this)[k](!0)
            },
            sfixed64: function() {
                return readFixed64.call(this)[k](!1)
            }
        })
    }
    ;
    var reader_buffer = BufferReader
      , Reader = reader;
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util$1 = requireMinimal();
    function BufferReader(_) {
        Reader.call(this, _)
    }
    BufferReader._configure = function() {
        util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice)
    }
    ,
    BufferReader.prototype.string = function _() {
        var k = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + k, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + k, this.len))
    }
    ,
    BufferReader._configure();
    var rpc = {}
      , service = Service
      , util = requireMinimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(_, k, J) {
        if (typeof _ != "function")
            throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this),
        this.rpcImpl = _,
        this.requestDelimited = !!k,
        this.responseDelimited = !!J
    }
    Service.prototype.rpcCall = function _(k, J, et, tt, rt) {
        if (!tt)
            throw TypeError("request must be specified");
        var nt = this;
        if (!rt)
            return util.asPromise(_, nt, k, J, et, tt);
        if (!nt.rpcImpl) {
            setTimeout(function() {
                rt(Error("already ended"))
            }, 0);
            return
        }
        try {
            return nt.rpcImpl(k, J[nt.requestDelimited ? "encodeDelimited" : "encode"](tt).finish(), function(ot, it) {
                if (ot)
                    return nt.emit("error", ot, k),
                    rt(ot);
                if (it === null) {
                    nt.end(!0);
                    return
                }
                if (!(it instanceof et))
                    try {
                        it = et[nt.responseDelimited ? "decodeDelimited" : "decode"](it)
                    } catch (at) {
                        return nt.emit("error", at, k),
                        rt(at)
                    }
                return nt.emit("data", it, k),
                rt(null, it)
            })
        } catch (ot) {
            nt.emit("error", ot, k),
            setTimeout(function() {
                rt(ot)
            }, 0);
            return
        }
    }
    ,
    Service.prototype.end = function _(k) {
        return this.rpcImpl && (k || this.rpcImpl(null, null, null),
        this.rpcImpl = null,
        this.emit("end").off()),
        this
    }
    ,
    function(_) {
        var k = _;
        k.Service = service
    }(rpc);
    var roots = {};
    (function(_) {
        var k = _;
        k.build = "minimal",
        k.Writer = writer,
        k.BufferWriter = writer_buffer,
        k.Reader = reader,
        k.BufferReader = reader_buffer,
        k.util = requireMinimal(),
        k.rpc = rpc,
        k.roots = roots,
        k.configure = J;
        function J() {
            k.util._configure(),
            k.Writer._configure(k.BufferWriter),
            k.Reader._configure(k.BufferReader)
        }
        J()
    }
    )(indexMinimal);
    var minimal = indexMinimal;
    const d = getDefaultExportFromCjs(minimal);
    var D = Object.defineProperty
      , S = (_,k,J)=>k in _ ? D(_, k, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: J
    }) : _[k] = J
      , a$1 = (_,k,J)=>(S(_, typeof k != "symbol" ? k + "" : k, J),
    J);
    const w = new TextEncoder
      , p = new TextDecoder;
    class $ {
        encode(k, J) {
            let et, tt, rt;
            k.type === 2 ? (et = k.data[0],
            tt = k.data[1]) : (et = "",
            tt = new ArrayBuffer(0)),
            rt = k.id === void 0 ? -1 : k.id;
            let nt = {
                type: k.type,
                namespace: k.nsp,
                event: et,
                data: tt,
                ackId: rt
            };
            return J([E(nt)])
        }
    }
    class x extends eventsExports.EventEmitter {
        add(k) {
            let J = j(k);
            J.type === 5 && (J.type = 2),
            J.type === 6 && (J.type = 3);
            let et = {
                type: J.type,
                data: J.type === 3 ? [J.data] : [J.event, J.data],
                nsp: J.namespace,
                id: J.ackId
            };
            this.emit("decoded", et)
        }
        destroy() {}
    }
    function E(_) {
        let k, J, et = _.type, tt = [];
        if (_.ackId !== -1) {
            et += 128,
            tt.push(Uint8Array.of(et));
            let rt = new Uint8Array(4);
            new DataView(rt.buffer).setUint32(0, _.ackId),
            tt.push(rt)
        } else
            tt.push(Uint8Array.of(et));
        return J = w.encode(_.namespace),
        tt.push(Uint8Array.of(J.length)),
        tt.push(J),
        k = w.encode(_.event),
        tt.push(Uint8Array.of(k.length)),
        tt.push(k),
        tt.push(new Uint8Array(_.data)),
        O(Uint8Array, ...tt).buffer
    }
    function j(_) {
        let k = 0, J, et = -1, tt, rt, nt, ot;
        const it = new DataView(_,0);
        return J = it.getUint8(k),
        k++,
        J >= 128 && (J %= 128,
        et = it.getUint32(k),
        k += 4),
        ot = it.getUint8(k),
        k++,
        tt = new Uint8Array(_,k,ot),
        k += ot,
        ot = it.getUint8(k),
        k++,
        rt = new Uint8Array(_,k,ot),
        k += ot,
        nt = _.slice(k),
        {
            type: J,
            data: nt,
            namespace: p.decode(tt),
            event: p.decode(rt),
            ackId: et
        }
    }
    const O = (_,...k)=>{
        let J = 0;
        for (let rt of k)
            J += rt.length;
        let et = new _(J)
          , tt = 0;
        for (let rt of k)
            et.set(rt, tt),
            tt += rt.length;
        return et
    }
      , v = Object.assign(Object.defineProperty({
        
        Decoder: x,
        Encoder: $,
        concatenate: O
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , y = d.Reader
      , C = d.Writer
      , q = d.util
      , g = d.roots.default || (d.roots.default = {})
      , B = g.ResultObj = (()=>{
        function _(k) {
            if (k)
                for (let J = Object.keys(k), et = 0; et < J.length; ++et)
                    k[J[et]] != null && (this[J[et]] = k[J[et]])
        }
        return _.prototype.code = 0,
        _.prototype.msg = "",
        _.prototype.data = q.newBuffer([]),
        _.encode = function(k, J) {
            return J || (J = C.create()),
            k.code != null && Object.hasOwnProperty.call(k, "code") && J.uint32(8).sint32(k.code),
            k.msg != null && Object.hasOwnProperty.call(k, "msg") && J.uint32(18).string(k.msg),
            k.data != null && Object.hasOwnProperty.call(k, "data") && J.uint32(26).bytes(k.data),
            J
        }
        ,
        _.decode = function(k, J) {
            k instanceof y || (k = y.create(k));
            let et = J === void 0 ? k.len : k.pos + J
              , tt = new g.ResultObj;
            for (; k.pos < et; ) {
                let rt = k.uint32();
                switch (rt >>> 3) {
                case 1:
                    tt.code = k.sint32();
                    break;
                case 2:
                    tt.msg = k.string();
                    break;
                case 3:
                    tt.data = k.bytes();
                    break;
                default:
                    k.skipType(rt & 7);
                    break
                }
            }
            return tt
        }
        ,
        _
    }
    )()
      , T = ()=>__vitePreload(()=>import("./chunk-b3c3490f.js"), []).then(_=>_.default)
      , V = typeof window > "u"
      , f = class mn extends libExports.Manager {
        constructor({uris: k}, J=mn.socketOptions) {
            super(k[0].socket, J),
            a$1(this, "afterRequest", []),
            a$1(this, "uris"),
            a$1(this, "isConnecting", !1),
            a$1(this, "enableSocketConnect", ()=>{}
            ),
            a$1(this, "waitSocketConnect", new Promise(et=>this.enableSocketConnect = et)),
            a$1(this, "socketRequestBind", et=>(tt,rt)=>new Promise((nt,ot)=>{
                const it = setTimeout(()=>ot(new Error(`${et.nsp}/${tt}:Socket time out`)), 2e4);
                et.emit(tt, rt, this.decodeBind(at=>{
                    clearTimeout(it);
                    try {
                        for (let lt = 0, st = this.afterRequest.length; lt < st; lt++)
                            this.afterRequest[lt](at);
                        at.code === 0 ? nt(at.data) : ot(new P(at.msg,at.code))
                    } catch (lt) {
                        ot(lt)
                    }
                }
                , B))
            }
            )),
            this.uris = k
        }
        open(k) {
            V || this.isConnecting || ~this.readyState.indexOf("open") || (this.isConnecting = !0,
            this.openWithSign().finally(()=>{
                super.open(k),
                this.isConnecting = !1
            }
            ))
        }
        async openWithSign() {
            const {sign: k, uri: J, source: et} = await this.getSignData();
            await this.waitSocketConnect,
            this.opts.query = {
                p: k,
                t: et
            },
            this.uri = J.socket
        }
        async testSocketRoute(k, J="") {
            const {socket: et, test: tt=et} = k
              , rt = `${tt}/test/${J ? "?p=" + J : ""}`
              , nt = await fetch(rt, {
                credentials: "include"
            }).then(ot=>ot.text());
            return {
                uri: k,
                sign: nt
            }
        }
        async getSignData() {
            const {t1: k, t2: J} = await T()
              , et = window.navigator.userAgent.trim()
              , tt = k(et);
            let {uri: rt, sign: nt} = await Promise.race(this.uris.map(ot=>this.testSocketRoute(ot, tt)));
            return {
                sign: J(nt, et),
                uri: rt,
                source: nt
            }
        }
        addAfterRequest(k) {
            this.afterRequest.push(k)
        }
        decode(k="utf8") {
            return J=>{
                let et;
                if (k === "utf8")
                    et = b.decode(J);
                else if (k === "json")
                    et = JSON.parse(b.decode(J));
                else if (k === "int8")
                    et = new DataView(J).getUint8(0);
                else if (k === "int32")
                    et = new DataView(J).getUint32(0);
                else if (k === "int64") {
                    let tt = new DataView(J);
                    et = new Long(tt.getUint32(4),tt.getUint32(0)).toNumber()
                } else
                    et = k.decode(new Uint8Array(J));
                return et
            }
        }
        encode(k="utf8") {
            return J=>{
                if (k === "utf8")
                    return U.encode(J);
                if (k === "json")
                    return U.encode(JSON.stringify(J));
                if (k === "int8")
                    return Uint8Array.of(J);
                if (k === "int32") {
                    let et = new Uint8Array(4);
                    return new DataView(et.buffer).setUint32(0, J),
                    et
                } else if (k === "int64") {
                    let et = Long.fromNumber(J)
                      , tt = new Uint8Array(8)
                      , rt = new DataView(tt.buffer);
                    return rt.setUint32(0, et.high),
                    rt.setUint32(4, et.low),
                    tt
                } else
                    return k.encode(new k(J)).finish()
            }
        }
        decodeBind(k, J="utf8") {
            const et = this.decode(J);
            return tt=>k(et(tt))
        }
    }
    ;
    a$1(f, "socketOptions", {
        timeout: 2e4,
        reconnectionDelayMax: 1e4,
        transports: ["websocket"],
        autoConnect: !1,
        parser: v,
        query: {}
    });
    let m = f;
    const U = new TextEncoder
      , b = new TextDecoder;
    class P extends Error {
        constructor(k, J=0) {
            super(k),
            a$1(this, "code"),
            this.code = J
        }
    }
    F = ()=>__vitePreload(()=>import("./chunk-b3c3490f.js"), []).then(_=>_.default);
    function getHttp() {
        const _ = axios$1.create({
            baseURL: "/api"
        });
        return _.interceptors.request.use(k=>(k.cache && (k.baseURL = "/cache",
        delete k.cache),
        k.headers = k.headers || {},
        k), k=>Promise.reject(String(k) + ":REQ!")),
        _.interceptors.response.use(k=>{
            let J = k.data;
            return J.code === 0 ? J.data : Promise.reject(new HttpResponseError(J.msg,J.code,J))
        }
        , k=>k && k.response ? Promise.reject(new ErrorWithTip("Oops\uFF01We lost your network, Please have a check\uFF01",k.response.status + k.config.url)) : Promise.reject(new ErrorWithTip("Network error!"))),
        _
    }
    http = globalThis.__http || getHttp(),
    ErrorWithTip = class extends Error {
        constructor(_, k) {
            super(_),
            _e(this, "tip"),
            this.tip = k
        }
    }
    ,
    HttpResponseError = class extends Error {
        constructor(_, k, J) {
            super(_),
            this.code = k,
            this.response = J
        }
    }
    ,
    socket = new m({
        uris: getSocketUri()
    }),
    userSocket = socket.socket("/user"),
    supportSocket = socket.socket("/game-support");
    function getSocketUri() {
         var _ = 'bc.game';
        if (isSSR)
            return [{
                socket: ""
            }];
        if (location.hostname === "dogcrash.game")
            return [{
                socket: `https://socketv2.${_}`,
                test: `https://socket2v2.${_}`
            }];
        {
           
            return [{
                socket: `https://socketv2.${_}`
            }, {
                socket: `https://socket2v2.${_}`
            }]
        }
    }
    addUserReceiptEvent = function(_, k) {
        const J = socket.decodeBind(et=>{
            msgReceipt(et) || k(et)
        }
        , "json");
        return userSocket.on(_, J),
        ()=>userSocket.off(_, J)
    }
    ;
    const msgDict = new Set;
    function msgReceipt({msgId: _}) {
        return _ ? msgDict.has(_) ? !0 : (http.post("/account/userNotification/received/", {
            msgId: _
        }),
        msgDict.add(_),
        !1) : !1
    }
    const {useProxy: useProxy$9, proxy: proxy$9} = valtio
      , Context = React.createContext(void 0);
    usePageContext = function() {
        return reactExports.useContext(Context)
    }
    ,
    usePageProps = function() {
        return reactExports.useContext(Context).pageProps.suspensed
    }
    ,
    useSetSearch = function() {
        const {urlParsed: _} = usePageContext();
        return reactExports.useCallback(k=>{
            const J = $t($t({}, _.search), k)
              , et = new URLSearchParams(J);
            et.forEach((rt,nt)=>!rt && et.delete(nt));
            const tt = et.toString();
            return `${_.pathname}${tt ? "?" + tt : ""}`
        }
        , [_])
    }
    ,
    useNavigate = function() {
        return app.unsafeNavigate
    }
    ;
    const baseUrl = "/".replace(/\/$/, "");
    function getI18nPath(_, k) {
        if (_.startsWith("/") && !_.startsWith("//")) {
            const J = k === "en" ? "" : `/${k}`;
            return `${baseUrl}${J}${_}`
        }
        return _
    }
    useLocation = function() {
        const {urlParsed: {pathname: _, hash: k, searchOriginal: J}} = usePageContext();
        return reactExports.useMemo(()=>({
            pathname: _,
            search: J || "",
            hash: k
        }), [_, k, J])
    }
    ;
    let pageContextRef = null;
    function onPageContextChange(_) {
        pageContextRef !== _ && (pageContextRef = _,
        app.emit("page_context", _))
    }
    subscribePageContext = function(_) {
        return app.on("page_context", _),
        pageContextRef && _(pageContextRef),
        ()=>{
            app.off("page_context", _)
        }
    }
    ;
    const globalState = proxy$9({
        mobile: !1,
        darken: !localStorage.getItem("isBrighten")
    });
    function useGlobalState() {
        return useProxy$9(globalState)
    }
    useIsDarken = function() {
        return useGlobalState().darken
    }
    ,
    useToggleDarken = function() {
        return _=>{
            globalState.darken = _
        }
    }
    ,
    useIsMobile = function() {
        return useGlobalState().mobile
    }
    ;
    const consoleLogger = {
        type: "logger",
        log(_) {
            this.output("log", _)
        },
        warn(_) {
            this.output("warn", _)
        },
        error(_) {
            this.output("error", _)
        },
        output(_, k) {
            console && console[_]
        }
    };
    class Logger {
        constructor(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.init(k, J)
        }
        init(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.prefix = J.prefix || "i18next:",
            this.logger = k || consoleLogger,
            this.options = J,
            this.debug = J.debug
        }
        log() {
            for (var k = arguments.length, J = new Array(k), et = 0; et < k; et++)
                J[et] = arguments[et];
            return this.forward(J, "log", "", !0)
        }
        warn() {
            for (var k = arguments.length, J = new Array(k), et = 0; et < k; et++)
                J[et] = arguments[et];
            return this.forward(J, "warn", "", !0)
        }
        error() {
            for (var k = arguments.length, J = new Array(k), et = 0; et < k; et++)
                J[et] = arguments[et];
            return this.forward(J, "error", "")
        }
        deprecate() {
            for (var k = arguments.length, J = new Array(k), et = 0; et < k; et++)
                J[et] = arguments[et];
            return this.forward(J, "warn", "WARNING DEPRECATED: ", !0)
        }
        forward(k, J, et, tt) {
            return tt && !this.debug ? null : (typeof k[0] == "string" && (k[0] = `${et}${this.prefix} ${k[0]}`),
            this.logger[J](k))
        }
        create(k) {
            return new Logger(this.logger,$t({
                prefix: `${this.prefix}:${k}:`
            }, this.options))
        }
        clone(k) {
            return k = k || this.options,
            k.prefix = k.prefix || this.prefix,
            new Logger(this.logger,k)
        }
    }
    var baseLogger = new Logger;
    class EventEmitter {
        constructor() {
            this.observers = {}
        }
        on(k, J) {
            return k.split(" ").forEach(et=>{
                this.observers[et] || (this.observers[et] = new Map);
                const tt = this.observers[et].get(J) || 0;
                this.observers[et].set(J, tt + 1)
            }
            ),
            this
        }
        off(k, J) {
            if (this.observers[k]) {
                if (!J) {
                    delete this.observers[k];
                    return
                }
                this.observers[k].delete(J)
            }
        }
        emit(k) {
            for (var J = arguments.length, et = new Array(J > 1 ? J - 1 : 0), tt = 1; tt < J; tt++)
                et[tt - 1] = arguments[tt];
            this.observers[k] && Array.from(this.observers[k].entries()).forEach(rt=>{
                let[nt,ot] = rt;
                for (let it = 0; it < ot; it++)
                    nt(...et)
            }
            ),
            this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(rt=>{
                let[nt,ot] = rt;
                for (let it = 0; it < ot; it++)
                    nt.apply(nt, [k, ...et])
            }
            )
        }
    }
    function defer() {
        let _, k;
        const J = new Promise((et,tt)=>{
            _ = et,
            k = tt
        }
        );
        return J.resolve = _,
        J.reject = k,
        J
    }
    function makeString(_) {
        return _ == null ? "" : "" + _
    }
    function copy(_, k, J) {
        _.forEach(et=>{
            k[et] && (J[et] = k[et])
        }
        )
    }
    const lastOfPathSeparatorRegExp = /###/g;
    function getLastOfPath(_, k, J) {
        function et(ot) {
            return ot && ot.indexOf("###") > -1 ? ot.replace(lastOfPathSeparatorRegExp, ".") : ot
        }
        function tt() {
            return !_ || typeof _ == "string"
        }
        const rt = typeof k != "string" ? k : k.split(".");
        let nt = 0;
        for (; nt < rt.length - 1; ) {
            if (tt())
                return {};
            const ot = et(rt[nt]);
            !_[ot] && J && (_[ot] = new J),
            Object.prototype.hasOwnProperty.call(_, ot) ? _ = _[ot] : _ = {},
            ++nt
        }
        return tt() ? {} : {
            obj: _,
            k: et(rt[nt])
        }
    }
    function setPath(_, k, J) {
        const {obj: et, k: tt} = getLastOfPath(_, k, Object);
        if (et !== void 0 || k.length === 1) {
            et[tt] = J;
            return
        }
        let rt = k[k.length - 1]
          , nt = k.slice(0, k.length - 1)
          , ot = getLastOfPath(_, nt, Object);
        for (; ot.obj === void 0 && nt.length; )
            rt = `${nt[nt.length - 1]}.${rt}`,
            nt = nt.slice(0, nt.length - 1),
            ot = getLastOfPath(_, nt, Object),
            ot && ot.obj && typeof ot.obj[`${ot.k}.${rt}`] < "u" && (ot.obj = void 0);
        ot.obj[`${ot.k}.${rt}`] = J
    }
    function pushPath(_, k, J, et) {
        const {obj: tt, k: rt} = getLastOfPath(_, k, Object);
        tt[rt] = tt[rt] || [],
        et && (tt[rt] = tt[rt].concat(J)),
        et || tt[rt].push(J)
    }
    function getPath(_, k) {
        const {obj: J, k: et} = getLastOfPath(_, k);
        if (J)
            return J[et]
    }
    function getPathWithDefaults(_, k, J) {
        const et = getPath(_, J);
        return et !== void 0 ? et : getPath(k, J)
    }
    function deepExtend(_, k, J) {
        for (const et in k)
            et !== "__proto__" && et !== "constructor" && (et in _ ? typeof _[et] == "string" || _[et]instanceof String || typeof k[et] == "string" || k[et]instanceof String ? J && (_[et] = k[et]) : deepExtend(_[et], k[et], J) : _[et] = k[et]);
        return _
    }
    function regexEscape(_) {
        return _.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
    }
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;"
    };
    function escape(_) {
        return typeof _ == "string" ? _.replace(/[&<>"'\/]/g, k=>_entityMap[k]) : _
    }
    class RegExpCache {
        constructor(k) {
            this.capacity = k,
            this.regExpMap = new Map,
            this.regExpQueue = []
        }
        getRegExp(k) {
            const J = this.regExpMap.get(k);
            if (J !== void 0)
                return J;
            const et = new RegExp(k);
            return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()),
            this.regExpMap.set(k, et),
            this.regExpQueue.push(k),
            et
        }
    }
    const chars = [" ", ",", "?", "!", ";"]
      , looksLikeObjectPathRegExpCache = new RegExpCache(20);
    function looksLikeObjectPath(_, k, J) {
        k = k || "",
        J = J || "";
        const et = chars.filter(nt=>k.indexOf(nt) < 0 && J.indexOf(nt) < 0);
        if (et.length === 0)
            return !0;
        const tt = looksLikeObjectPathRegExpCache.getRegExp(`(${et.map(nt=>nt === "?" ? "\\?" : nt).join("|")})`);
        let rt = !tt.test(_);
        if (!rt) {
            const nt = _.indexOf(J);
            nt > 0 && !tt.test(_.substring(0, nt)) && (rt = !0)
        }
        return rt
    }
    function deepFind(_, k) {
        let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
        if (!_)
            return;
        if (_[k])
            return _[k];
        const et = k.split(J);
        let tt = _;
        for (let rt = 0; rt < et.length; ) {
            if (!tt || typeof tt != "object")
                return;
            let nt, ot = "";
            for (let it = rt; it < et.length; ++it)
                if (it !== rt && (ot += J),
                ot += et[it],
                nt = tt[ot],
                nt !== void 0) {
                    if (["string", "number", "boolean"].indexOf(typeof nt) > -1 && it < et.length - 1)
                        continue;
                    rt += it - rt + 1;
                    break
                }
            tt = nt
        }
        return tt
    }
    function getCleanedCode(_) {
        return _ && _.indexOf("_") > 0 ? _.replace("_", "-") : _
    }
    class ResourceStore extends EventEmitter {
        constructor(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                ns: ["translation"],
                defaultNS: "translation"
            };
            super(),
            this.data = k || {},
            this.options = J,
            this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
            this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
        }
        addNamespaces(k) {
            this.options.ns.indexOf(k) < 0 && this.options.ns.push(k)
        }
        removeNamespaces(k) {
            const J = this.options.ns.indexOf(k);
            J > -1 && this.options.ns.splice(J, 1)
        }
        getResource(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            const rt = tt.keySeparator !== void 0 ? tt.keySeparator : this.options.keySeparator
              , nt = tt.ignoreJSONStructure !== void 0 ? tt.ignoreJSONStructure : this.options.ignoreJSONStructure;
            let ot;
            k.indexOf(".") > -1 ? ot = k.split(".") : (ot = [k, J],
            et && (Array.isArray(et) ? ot.push(...et) : typeof et == "string" && rt ? ot.push(...et.split(rt)) : ot.push(et)));
            const it = getPath(this.data, ot);
            return !it && !J && !et && k.indexOf(".") > -1 && (k = ot[0],
            J = ot[1],
            et = ot.slice(2).join(".")),
            it || !nt || typeof et != "string" ? it : deepFind(this.data && this.data[k] && this.data[k][J], et, rt)
        }
        addResource(k, J, et, tt) {
            let rt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
                silent: !1
            };
            const nt = rt.keySeparator !== void 0 ? rt.keySeparator : this.options.keySeparator;
            let ot = [k, J];
            et && (ot = ot.concat(nt ? et.split(nt) : et)),
            k.indexOf(".") > -1 && (ot = k.split("."),
            tt = J,
            J = ot[1]),
            this.addNamespaces(J),
            setPath(this.data, ot, tt),
            rt.silent || this.emit("added", k, J, et, tt)
        }
        addResources(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
                silent: !1
            };
            for (const rt in et)
                (typeof et[rt] == "string" || Object.prototype.toString.apply(et[rt]) === "[object Array]") && this.addResource(k, J, rt, et[rt], {
                    silent: !0
                });
            tt.silent || this.emit("added", k, J, et)
        }
        addResourceBundle(k, J, et, tt, rt) {
            let nt = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
                silent: !1,
                skipCopy: !1
            }
              , ot = [k, J];
            k.indexOf(".") > -1 && (ot = k.split("."),
            tt = et,
            et = J,
            J = ot[1]),
            this.addNamespaces(J);
            let it = getPath(this.data, ot) || {};
            nt.skipCopy || (et = JSON.parse(JSON.stringify(et))),
            tt ? deepExtend(it, et, rt) : it = $t($t({}, it), et),
            setPath(this.data, ot, it),
            nt.silent || this.emit("added", k, J, et)
        }
        removeResourceBundle(k, J) {
            this.hasResourceBundle(k, J) && delete this.data[k][J],
            this.removeNamespaces(J),
            this.emit("removed", k, J)
        }
        hasResourceBundle(k, J) {
            return this.getResource(k, J) !== void 0
        }
        getResourceBundle(k, J) {
            return J || (J = this.options.defaultNS),
            this.options.compatibilityAPI === "v1" ? $t({}, this.getResource(k, J)) : this.getResource(k, J)
        }
        getDataByLanguage(k) {
            return this.data[k]
        }
        hasLanguageSomeTranslations(k) {
            const J = this.getDataByLanguage(k);
            return !!(J && Object.keys(J) || []).find(et=>J[et] && Object.keys(J[et]).length > 0)
        }
        toJSON() {
            return this.data
        }
    }
    var postProcessor = {
        processors: {},
        addPostProcessor(_) {
            this.processors[_.name] = _
        },
        handle(_, k, J, et, tt) {
            return _.forEach(rt=>{
                this.processors[rt] && (k = this.processors[rt].process(k, J, et, tt))
            }
            ),
            k
        }
    };
    const checkedLoadedFor = {};
    class Translator extends EventEmitter {
        constructor(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super(),
            copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], k, this),
            this.options = J,
            this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
            this.logger = baseLogger.create("translator")
        }
        changeLanguage(k) {
            k && (this.language = k)
        }
        exists(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            };
            if (k == null)
                return !1;
            const et = this.resolve(k, J);
            return et && et.res !== void 0
        }
        extractFromKey(k, J) {
            let et = J.nsSeparator !== void 0 ? J.nsSeparator : this.options.nsSeparator;
            et === void 0 && (et = ":");
            const tt = J.keySeparator !== void 0 ? J.keySeparator : this.options.keySeparator;
            let rt = J.ns || this.options.defaultNS || [];
            const nt = et && k.indexOf(et) > -1
              , ot = !this.options.userDefinedKeySeparator && !J.keySeparator && !this.options.userDefinedNsSeparator && !J.nsSeparator && !looksLikeObjectPath(k, et, tt);
            if (nt && !ot) {
                const it = k.match(this.interpolator.nestingRegexp);
                if (it && it.length > 0)
                    return {
                        key: k,
                        namespaces: rt
                    };
                const at = k.split(et);
                (et !== tt || et === tt && this.options.ns.indexOf(at[0]) > -1) && (rt = at.shift()),
                k = at.join(tt)
            }
            return typeof rt == "string" && (rt = [rt]),
            {
                key: k,
                namespaces: rt
            }
        }
        translate(k, J, et) {
            if (typeof J != "object" && this.options.overloadTranslationOptionHandler && (J = this.options.overloadTranslationOptionHandler(arguments)),
            typeof J == "object" && (J = $t({}, J)),
            J || (J = {}),
            k == null)
                return "";
            Array.isArray(k) || (k = [String(k)]);
            const tt = J.returnDetails !== void 0 ? J.returnDetails : this.options.returnDetails
              , rt = J.keySeparator !== void 0 ? J.keySeparator : this.options.keySeparator
              , {key: nt, namespaces: ot} = this.extractFromKey(k[k.length - 1], J)
              , it = ot[ot.length - 1]
              , at = J.lng || this.language
              , lt = J.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (at && at.toLowerCase() === "cimode") {
                if (lt) {
                    const mt = J.nsSeparator || this.options.nsSeparator;
                    return tt ? {
                        res: `${it}${mt}${nt}`,
                        usedKey: nt,
                        exactUsedKey: nt,
                        usedLng: at,
                        usedNS: it,
                        usedParams: this.getUsedParamsDetails(J)
                    } : `${it}${mt}${nt}`
                }
                return tt ? {
                    res: nt,
                    usedKey: nt,
                    exactUsedKey: nt,
                    usedLng: at,
                    usedNS: it,
                    usedParams: this.getUsedParamsDetails(J)
                } : nt
            }
            const st = this.resolve(k, J);
            let ut = st && st.res;
            const ct = st && st.usedKey || nt
              , pt = st && st.exactUsedKey || nt
              , ft = Object.prototype.toString.apply(ut)
              , yt = ["[object Number]", "[object Function]", "[object RegExp]"]
              , ht = J.joinArrays !== void 0 ? J.joinArrays : this.options.joinArrays
              , gt = !this.i18nFormat || this.i18nFormat.handleAsObject;
            if (gt && ut && typeof ut != "string" && typeof ut != "boolean" && typeof ut != "number" && yt.indexOf(ft) < 0 && !(typeof ht == "string" && ft === "[object Array]")) {
                if (!J.returnObjects && !this.options.returnObjects) {
                    this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                    const mt = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ct, ut, _t($t({}, J), {
                        ns: ot
                    })) : `key '${nt} (${this.language})' returned an object instead of string.`;
                    return tt ? (st.res = mt,
                    st.usedParams = this.getUsedParamsDetails(J),
                    st) : mt
                }
                if (rt) {
                    const mt = ft === "[object Array]"
                      , vt = mt ? [] : {}
                      , bt = mt ? pt : ct;
                    for (const Et in ut)
                        if (Object.prototype.hasOwnProperty.call(ut, Et)) {
                            const xt = `${bt}${rt}${Et}`;
                            vt[Et] = this.translate(xt, _t($t({}, J), {
                                joinArrays: !1,
                                ns: ot
                            })),
                            vt[Et] === xt && (vt[Et] = ut[Et])
                        }
                    ut = vt
                }
            } else if (gt && typeof ht == "string" && ft === "[object Array]")
                ut = ut.join(ht),
                ut && (ut = this.extendTranslation(ut, k, J, et));
            else {
                let mt = !1
                  , vt = !1;
                const bt = J.count !== void 0 && typeof J.count != "string"
                  , Et = Translator.hasDefaultValue(J)
                  , xt = bt ? this.pluralResolver.getSuffix(at, J.count, J) : ""
                  , wt = J.ordinal && bt ? this.pluralResolver.getSuffix(at, J.count, {
                    ordinal: !1
                }) : ""
                  , St = bt && !J.ordinal && J.count === 0 && this.pluralResolver.shouldUseIntlApi()
                  , Pt = St && J[`defaultValue${this.options.pluralSeparator}zero`] || J[`defaultValue${xt}`] || J[`defaultValue${wt}`] || J.defaultValue;
                !this.isValidLookup(ut) && Et && (mt = !0,
                ut = Pt),
                this.isValidLookup(ut) || (vt = !0,
                ut = nt);
                const Rt = (J.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && vt ? void 0 : ut
                  , At = Et && Pt !== ut && this.options.updateMissing;
                if (vt || mt || At) {
                    if (this.logger.log(At ? "updateKey" : "missingKey", at, it, nt, At ? Pt : ut),
                    rt) {
                        const Mt = this.resolve(nt, _t($t({}, J), {
                            keySeparator: !1
                        }));
                        Mt && Mt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                    }
                    let Nt = [];
                    const Ot = this.languageUtils.getFallbackCodes(this.options.fallbackLng, J.lng || this.language);
                    if (this.options.saveMissingTo === "fallback" && Ot && Ot[0])
                        for (let Mt = 0; Mt < Ot.length; Mt++)
                            Nt.push(Ot[Mt]);
                    else
                        this.options.saveMissingTo === "all" ? Nt = this.languageUtils.toResolveHierarchy(J.lng || this.language) : Nt.push(J.lng || this.language);
                    const It = (Mt,Wt,jt)=>{
                        const Bt = Et && jt !== ut ? jt : Rt;
                        this.options.missingKeyHandler ? this.options.missingKeyHandler(Mt, it, Wt, Bt, At, J) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(Mt, it, Wt, Bt, At, J),
                        this.emit("missingKey", Mt, it, Wt, ut)
                    }
                    ;
                    this.options.saveMissing && (this.options.saveMissingPlurals && bt ? Nt.forEach(Mt=>{
                        const Wt = this.pluralResolver.getSuffixes(Mt, J);
                        St && J[`defaultValue${this.options.pluralSeparator}zero`] && Wt.indexOf(`${this.options.pluralSeparator}zero`) < 0 && Wt.push(`${this.options.pluralSeparator}zero`),
                        Wt.forEach(jt=>{
                            It([Mt], nt + jt, J[`defaultValue${jt}`] || Pt)
                        }
                        )
                    }
                    ) : It(Nt, nt, Pt))
                }
                ut = this.extendTranslation(ut, k, J, st, et),
                vt && ut === nt && this.options.appendNamespaceToMissingKey && (ut = `${it}:${nt}`),
                (vt || mt) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? ut = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${it}:${nt}` : nt, mt ? ut : void 0) : ut = this.options.parseMissingKeyHandler(ut))
            }
            return tt ? (st.res = ut,
            st.usedParams = this.getUsedParamsDetails(J),
            st) : ut
        }
        extendTranslation(k, J, et, tt, rt) {
            var nt = this;
            if (this.i18nFormat && this.i18nFormat.parse)
                k = this.i18nFormat.parse(k, $t($t({}, this.options.interpolation.defaultVariables), et), et.lng || this.language || tt.usedLng, tt.usedNS, tt.usedKey, {
                    resolved: tt
                });
            else if (!et.skipInterpolation) {
                et.interpolation && this.interpolator.init(_t($t({}, et), {
                    interpolation: $t($t({}, this.options.interpolation), et.interpolation)
                }));
                const at = typeof k == "string" && (et && et.interpolation && et.interpolation.skipOnVariables !== void 0 ? et.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
                let lt;
                if (at) {
                    const ut = k.match(this.interpolator.nestingRegexp);
                    lt = ut && ut.length
                }
                let st = et.replace && typeof et.replace != "string" ? et.replace : et;
                if (this.options.interpolation.defaultVariables && (st = $t($t({}, this.options.interpolation.defaultVariables), st)),
                k = this.interpolator.interpolate(k, st, et.lng || this.language, et),
                at) {
                    const ut = k.match(this.interpolator.nestingRegexp)
                      , ct = ut && ut.length;
                    lt < ct && (et.nest = !1)
                }
                !et.lng && this.options.compatibilityAPI !== "v1" && tt && tt.res && (et.lng = tt.usedLng),
                et.nest !== !1 && (k = this.interpolator.nest(k, function() {
                    for (var ut = arguments.length, ct = new Array(ut), pt = 0; pt < ut; pt++)
                        ct[pt] = arguments[pt];
                    return rt && rt[0] === ct[0] && !et.context ? (nt.logger.warn(`It seems you are nesting recursively key: ${ct[0]} in key: ${J[0]}`),
                    null) : nt.translate(...ct, J)
                }, et)),
                et.interpolation && this.interpolator.reset()
            }
            const ot = et.postProcess || this.options.postProcess
              , it = typeof ot == "string" ? [ot] : ot;
            return k != null && it && it.length && et.applyPostProcessor !== !1 && (k = postProcessor.handle(it, k, J, this.options && this.options.postProcessPassResolved ? $t({
                i18nResolved: _t($t({}, tt), {
                    usedParams: this.getUsedParamsDetails(et)
                })
            }, et) : et, this)),
            k
        }
        resolve(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, et, tt, rt, nt, ot;
            return typeof k == "string" && (k = [k]),
            k.forEach(it=>{
                if (this.isValidLookup(et))
                    return;
                const at = this.extractFromKey(it, J)
                  , lt = at.key;
                tt = lt;
                let st = at.namespaces;
                this.options.fallbackNS && (st = st.concat(this.options.fallbackNS));
                const ut = J.count !== void 0 && typeof J.count != "string"
                  , ct = ut && !J.ordinal && J.count === 0 && this.pluralResolver.shouldUseIntlApi()
                  , pt = J.context !== void 0 && (typeof J.context == "string" || typeof J.context == "number") && J.context !== ""
                  , ft = J.lngs ? J.lngs : this.languageUtils.toResolveHierarchy(J.lng || this.language, J.fallbackLng);
                st.forEach(yt=>{
                    this.isValidLookup(et) || (ot = yt,
                    !checkedLoadedFor[`${ft[0]}-${yt}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(ot) && (checkedLoadedFor[`${ft[0]}-${yt}`] = !0,
                    this.logger.warn(`key "${tt}" for languages "${ft.join(", ")}" won't get resolved as namespace "${ot}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                    ft.forEach(ht=>{
                        if (this.isValidLookup(et))
                            return;
                        nt = ht;
                        const gt = [lt];
                        if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                            this.i18nFormat.addLookupKeys(gt, lt, ht, yt, J);
                        else {
                            let vt;
                            ut && (vt = this.pluralResolver.getSuffix(ht, J.count, J));
                            const bt = `${this.options.pluralSeparator}zero`
                              , Et = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                            if (ut && (gt.push(lt + vt),
                            J.ordinal && vt.indexOf(Et) === 0 && gt.push(lt + vt.replace(Et, this.options.pluralSeparator)),
                            ct && gt.push(lt + bt)),
                            pt) {
                                const xt = `${lt}${this.options.contextSeparator}${J.context}`;
                                gt.push(xt),
                                ut && (gt.push(xt + vt),
                                J.ordinal && vt.indexOf(Et) === 0 && gt.push(xt + vt.replace(Et, this.options.pluralSeparator)),
                                ct && gt.push(xt + bt))
                            }
                        }
                        let mt;
                        for (; mt = gt.pop(); )
                            this.isValidLookup(et) || (rt = mt,
                            et = this.getResource(ht, yt, mt, J))
                    }
                    ))
                }
                )
            }
            ),
            {
                res: et,
                usedKey: tt,
                exactUsedKey: rt,
                usedLng: nt,
                usedNS: ot
            }
        }
        isValidLookup(k) {
            return k !== void 0 && !(!this.options.returnNull && k === null) && !(!this.options.returnEmptyString && k === "")
        }
        getResource(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(k, J, et, tt) : this.resourceStore.getResource(k, J, et, tt)
        }
        getUsedParamsDetails() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const J = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"]
              , et = k.replace && typeof k.replace != "string";
            let tt = et ? k.replace : k;
            if (et && typeof k.count < "u" && (tt.count = k.count),
            this.options.interpolation.defaultVariables && (tt = $t($t({}, this.options.interpolation.defaultVariables), tt)),
            !et) {
                tt = $t({}, tt);
                for (const rt of J)
                    delete tt[rt]
            }
            return tt
        }
        static hasDefaultValue(k) {
            const J = "defaultValue";
            for (const et in k)
                if (Object.prototype.hasOwnProperty.call(k, et) && J === et.substring(0, J.length) && k[et] !== void 0)
                    return !0;
            return !1
        }
    }
    function capitalize(_) {
        return _.charAt(0).toUpperCase() + _.slice(1)
    }
    class LanguageUtil {
        constructor(k) {
            this.options = k,
            this.supportedLngs = this.options.supportedLngs || !1,
            this.logger = baseLogger.create("languageUtils")
        }
        getScriptPartFromCode(k) {
            if (k = getCleanedCode(k),
            !k || k.indexOf("-") < 0)
                return null;
            const J = k.split("-");
            return J.length === 2 || (J.pop(),
            J[J.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(J.join("-"))
        }
        getLanguagePartFromCode(k) {
            if (k = getCleanedCode(k),
            !k || k.indexOf("-") < 0)
                return k;
            const J = k.split("-");
            return this.formatLanguageCode(J[0])
        }
        formatLanguageCode(k) {
            if (typeof k == "string" && k.indexOf("-") > -1) {
                const J = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
                let et = k.split("-");
                return this.options.lowerCaseLng ? et = et.map(tt=>tt.toLowerCase()) : et.length === 2 ? (et[0] = et[0].toLowerCase(),
                et[1] = et[1].toUpperCase(),
                J.indexOf(et[1].toLowerCase()) > -1 && (et[1] = capitalize(et[1].toLowerCase()))) : et.length === 3 && (et[0] = et[0].toLowerCase(),
                et[1].length === 2 && (et[1] = et[1].toUpperCase()),
                et[0] !== "sgn" && et[2].length === 2 && (et[2] = et[2].toUpperCase()),
                J.indexOf(et[1].toLowerCase()) > -1 && (et[1] = capitalize(et[1].toLowerCase())),
                J.indexOf(et[2].toLowerCase()) > -1 && (et[2] = capitalize(et[2].toLowerCase()))),
                et.join("-")
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? k.toLowerCase() : k
        }
        isSupportedCode(k) {
            return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (k = this.getLanguagePartFromCode(k)),
            !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(k) > -1
        }
        getBestMatchFromCodes(k) {
            if (!k)
                return null;
            let J;
            return k.forEach(et=>{
                if (J)
                    return;
                const tt = this.formatLanguageCode(et);
                (!this.options.supportedLngs || this.isSupportedCode(tt)) && (J = tt)
            }
            ),
            !J && this.options.supportedLngs && k.forEach(et=>{
                if (J)
                    return;
                const tt = this.getLanguagePartFromCode(et);
                if (this.isSupportedCode(tt))
                    return J = tt;
                J = this.options.supportedLngs.find(rt=>{
                    if (rt === tt || !(rt.indexOf("-") < 0 && tt.indexOf("-") < 0) && (rt.indexOf("-") > 0 && tt.indexOf("-") < 0 && rt.substring(0, rt.indexOf("-")) === tt || rt.indexOf(tt) === 0 && tt.length > 1))
                        return rt
                }
                )
            }
            ),
            J || (J = this.getFallbackCodes(this.options.fallbackLng)[0]),
            J
        }
        getFallbackCodes(k, J) {
            if (!k)
                return [];
            if (typeof k == "function" && (k = k(J)),
            typeof k == "string" && (k = [k]),
            Object.prototype.toString.apply(k) === "[object Array]")
                return k;
            if (!J)
                return k.default || [];
            let et = k[J];
            return et || (et = k[this.getScriptPartFromCode(J)]),
            et || (et = k[this.formatLanguageCode(J)]),
            et || (et = k[this.getLanguagePartFromCode(J)]),
            et || (et = k.default),
            et || []
        }
        toResolveHierarchy(k, J) {
            const et = this.getFallbackCodes(J || this.options.fallbackLng || [], k)
              , tt = []
              , rt = nt=>{
                nt && (this.isSupportedCode(nt) ? tt.push(nt) : this.logger.warn(`rejecting language code not found in supportedLngs: ${nt}`))
            }
            ;
            return typeof k == "string" && (k.indexOf("-") > -1 || k.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && rt(this.formatLanguageCode(k)),
            this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && rt(this.getScriptPartFromCode(k)),
            this.options.load !== "currentOnly" && rt(this.getLanguagePartFromCode(k))) : typeof k == "string" && rt(this.formatLanguageCode(k)),
            et.forEach(nt=>{
                tt.indexOf(nt) < 0 && rt(this.formatLanguageCode(nt))
            }
            ),
            tt
        }
    }
    let sets = [{
        lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
        nr: [1, 2],
        fc: 1
    }, {
        lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
        nr: [1, 2],
        fc: 2
    }, {
        lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
        nr: [1],
        fc: 3
    }, {
        lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
        nr: [1, 2, 5],
        fc: 4
    }, {
        lngs: ["ar"],
        nr: [0, 1, 2, 3, 11, 100],
        fc: 5
    }, {
        lngs: ["cs", "sk"],
        nr: [1, 2, 5],
        fc: 6
    }, {
        lngs: ["csb", "pl"],
        nr: [1, 2, 5],
        fc: 7
    }, {
        lngs: ["cy"],
        nr: [1, 2, 3, 8],
        fc: 8
    }, {
        lngs: ["fr"],
        nr: [1, 2],
        fc: 9
    }, {
        lngs: ["ga"],
        nr: [1, 2, 3, 7, 11],
        fc: 10
    }, {
        lngs: ["gd"],
        nr: [1, 2, 3, 20],
        fc: 11
    }, {
        lngs: ["is"],
        nr: [1, 2],
        fc: 12
    }, {
        lngs: ["jv"],
        nr: [0, 1],
        fc: 13
    }, {
        lngs: ["kw"],
        nr: [1, 2, 3, 4],
        fc: 14
    }, {
        lngs: ["lt"],
        nr: [1, 2, 10],
        fc: 15
    }, {
        lngs: ["lv"],
        nr: [1, 2, 0],
        fc: 16
    }, {
        lngs: ["mk"],
        nr: [1, 2],
        fc: 17
    }, {
        lngs: ["mnk"],
        nr: [0, 1, 2],
        fc: 18
    }, {
        lngs: ["mt"],
        nr: [1, 2, 11, 20],
        fc: 19
    }, {
        lngs: ["or"],
        nr: [2, 1],
        fc: 2
    }, {
        lngs: ["ro"],
        nr: [1, 2, 20],
        fc: 20
    }, {
        lngs: ["sl"],
        nr: [5, 1, 2, 3],
        fc: 21
    }, {
        lngs: ["he", "iw"],
        nr: [1, 2, 20, 21],
        fc: 22
    }]
      , _rulesPluralsTypes = {
        1: function(_) {
            return +(_ > 1)
        },
        2: function(_) {
            return +(_ != 1)
        },
        3: function(_) {
            return 0
        },
        4: function(_) {
            return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ % 10 >= 2 && _ % 10 <= 4 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
        },
        5: function(_) {
            return _ == 0 ? 0 : _ == 1 ? 1 : _ == 2 ? 2 : _ % 100 >= 3 && _ % 100 <= 10 ? 3 : _ % 100 >= 11 ? 4 : 5
        },
        6: function(_) {
            return _ == 1 ? 0 : _ >= 2 && _ <= 4 ? 1 : 2
        },
        7: function(_) {
            return _ == 1 ? 0 : _ % 10 >= 2 && _ % 10 <= 4 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
        },
        8: function(_) {
            return _ == 1 ? 0 : _ == 2 ? 1 : _ != 8 && _ != 11 ? 2 : 3
        },
        9: function(_) {
            return +(_ >= 2)
        },
        10: function(_) {
            return _ == 1 ? 0 : _ == 2 ? 1 : _ < 7 ? 2 : _ < 11 ? 3 : 4
        },
        11: function(_) {
            return _ == 1 || _ == 11 ? 0 : _ == 2 || _ == 12 ? 1 : _ > 2 && _ < 20 ? 2 : 3
        },
        12: function(_) {
            return +(_ % 10 != 1 || _ % 100 == 11)
        },
        13: function(_) {
            return +(_ !== 0)
        },
        14: function(_) {
            return _ == 1 ? 0 : _ == 2 ? 1 : _ == 3 ? 2 : 3
        },
        15: function(_) {
            return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ % 10 >= 2 && (_ % 100 < 10 || _ % 100 >= 20) ? 1 : 2
        },
        16: function(_) {
            return _ % 10 == 1 && _ % 100 != 11 ? 0 : _ !== 0 ? 1 : 2
        },
        17: function(_) {
            return _ == 1 || _ % 10 == 1 && _ % 100 != 11 ? 0 : 1
        },
        18: function(_) {
            return _ == 0 ? 0 : _ == 1 ? 1 : 2
        },
        19: function(_) {
            return _ == 1 ? 0 : _ == 0 || _ % 100 > 1 && _ % 100 < 11 ? 1 : _ % 100 > 10 && _ % 100 < 20 ? 2 : 3
        },
        20: function(_) {
            return _ == 1 ? 0 : _ == 0 || _ % 100 > 0 && _ % 100 < 20 ? 1 : 2
        },
        21: function(_) {
            return _ % 100 == 1 ? 1 : _ % 100 == 2 ? 2 : _ % 100 == 3 || _ % 100 == 4 ? 3 : 0
        },
        22: function(_) {
            return _ == 1 ? 0 : _ == 2 ? 1 : (_ < 0 || _ > 10) && _ % 10 == 0 ? 2 : 3
        }
    };
    const nonIntlVersions = ["v1", "v2", "v3"]
      , intlVersions = ["v4"]
      , suffixesOrder = {
        zero: 0,
        one: 1,
        two: 2,
        few: 3,
        many: 4,
        other: 5
    };
    function createRules() {
        const _ = {};
        return sets.forEach(k=>{
            k.lngs.forEach(J=>{
                _[J] = {
                    numbers: k.nr,
                    plurals: _rulesPluralsTypes[k.fc]
                }
            }
            )
        }
        ),
        _
    }
    class PluralResolver {
        constructor(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this.languageUtils = k,
            this.options = J,
            this.logger = baseLogger.create("pluralResolver"),
            (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3",
            this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
            this.rules = createRules()
        }
        addRule(k, J) {
            this.rules[k] = J
        }
        getRule(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (this.shouldUseIntlApi())
                try {
                    return new Intl.PluralRules(getCleanedCode(k === "dev" ? "en" : k),{
                        type: J.ordinal ? "ordinal" : "cardinal"
                    })
                } catch (et) {
                    return
                }
            return this.rules[k] || this.rules[this.languageUtils.getLanguagePartFromCode(k)]
        }
        needsPlural(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const et = this.getRule(k, J);
            return this.shouldUseIntlApi() ? et && et.resolvedOptions().pluralCategories.length > 1 : et && et.numbers.length > 1
        }
        getPluralFormsOfKey(k, J) {
            let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.getSuffixes(k, et).map(tt=>`${J}${tt}`)
        }
        getSuffixes(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            const et = this.getRule(k, J);
            return et ? this.shouldUseIntlApi() ? et.resolvedOptions().pluralCategories.sort((tt,rt)=>suffixesOrder[tt] - suffixesOrder[rt]).map(tt=>`${this.options.prepend}${J.ordinal ? `ordinal${this.options.prepend}` : ""}${tt}`) : et.numbers.map(tt=>this.getSuffix(k, tt, J)) : []
        }
        getSuffix(k, J) {
            let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            const tt = this.getRule(k, et);
            return tt ? this.shouldUseIntlApi() ? `${this.options.prepend}${et.ordinal ? `ordinal${this.options.prepend}` : ""}${tt.select(J)}` : this.getSuffixRetroCompatible(tt, J) : (this.logger.warn(`no plural rule found for: ${k}`),
            "")
        }
        getSuffixRetroCompatible(k, J) {
            const et = k.noAbs ? k.plurals(J) : k.plurals(Math.abs(J));
            let tt = k.numbers[et];
            this.options.simplifyPluralSuffix && k.numbers.length === 2 && k.numbers[0] === 1 && (tt === 2 ? tt = "plural" : tt === 1 && (tt = ""));
            const rt = ()=>this.options.prepend && tt.toString() ? this.options.prepend + tt.toString() : tt.toString();
            return this.options.compatibilityJSON === "v1" ? tt === 1 ? "" : typeof tt == "number" ? `_plural_${tt.toString()}` : rt() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && k.numbers.length === 2 && k.numbers[0] === 1 ? rt() : this.options.prepend && et.toString() ? this.options.prepend + et.toString() : et.toString()
        }
        shouldUseIntlApi() {
            return !nonIntlVersions.includes(this.options.compatibilityJSON)
        }
    }
    function deepFindWithDefaults(_, k, J) {
        let et = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "."
          , tt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0
          , rt = getPathWithDefaults(_, k, J);
        return !rt && tt && typeof J == "string" && (rt = deepFind(_, J, et),
        rt === void 0 && (rt = deepFind(k, J, et))),
        rt
    }
    class Interpolator {
        constructor() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.logger = baseLogger.create("interpolator"),
            this.options = k,
            this.format = k.interpolation && k.interpolation.format || (J=>J),
            this.init(k)
        }
        init() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            k.interpolation || (k.interpolation = {
                escapeValue: !0
            });
            const J = k.interpolation;
            this.escape = J.escape !== void 0 ? J.escape : escape,
            this.escapeValue = J.escapeValue !== void 0 ? J.escapeValue : !0,
            this.useRawValueToEscape = J.useRawValueToEscape !== void 0 ? J.useRawValueToEscape : !1,
            this.prefix = J.prefix ? regexEscape(J.prefix) : J.prefixEscaped || "{{",
            this.suffix = J.suffix ? regexEscape(J.suffix) : J.suffixEscaped || "}}",
            this.formatSeparator = J.formatSeparator ? J.formatSeparator : J.formatSeparator || ",",
            this.unescapePrefix = J.unescapeSuffix ? "" : J.unescapePrefix || "-",
            this.unescapeSuffix = this.unescapePrefix ? "" : J.unescapeSuffix || "",
            this.nestingPrefix = J.nestingPrefix ? regexEscape(J.nestingPrefix) : J.nestingPrefixEscaped || regexEscape("$t("),
            this.nestingSuffix = J.nestingSuffix ? regexEscape(J.nestingSuffix) : J.nestingSuffixEscaped || regexEscape(")"),
            this.nestingOptionsSeparator = J.nestingOptionsSeparator ? J.nestingOptionsSeparator : J.nestingOptionsSeparator || ",",
            this.maxReplaces = J.maxReplaces ? J.maxReplaces : 1e3,
            this.alwaysFormat = J.alwaysFormat !== void 0 ? J.alwaysFormat : !1,
            this.resetRegExp()
        }
        reset() {
            this.options && this.init(this.options)
        }
        resetRegExp() {
            const k = (J,et)=>J && J.source === et ? (J.lastIndex = 0,
            J) : new RegExp(et,"g");
            this.regexp = k(this.regexp, `${this.prefix}(.+?)${this.suffix}`),
            this.regexpUnescape = k(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),
            this.nestingRegexp = k(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
        }
        interpolate(k, J, et, tt) {
            let rt, nt, ot;
            const it = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
            function at(ct) {
                return ct.replace(/\$/g, "$$$$")
            }
            const lt = ct=>{
                if (ct.indexOf(this.formatSeparator) < 0) {
                    const ht = deepFindWithDefaults(J, it, ct, this.options.keySeparator, this.options.ignoreJSONStructure);
                    return this.alwaysFormat ? this.format(ht, void 0, et, _t($t($t({}, tt), J), {
                        interpolationkey: ct
                    })) : ht
                }
                const pt = ct.split(this.formatSeparator)
                  , ft = pt.shift().trim()
                  , yt = pt.join(this.formatSeparator).trim();
                return this.format(deepFindWithDefaults(J, it, ft, this.options.keySeparator, this.options.ignoreJSONStructure), yt, et, _t($t($t({}, tt), J), {
                    interpolationkey: ft
                }))
            }
            ;
            this.resetRegExp();
            const st = tt && tt.missingInterpolationHandler || this.options.missingInterpolationHandler
              , ut = tt && tt.interpolation && tt.interpolation.skipOnVariables !== void 0 ? tt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
            return [{
                regex: this.regexpUnescape,
                safeValue: ct=>at(ct)
            }, {
                regex: this.regexp,
                safeValue: ct=>this.escapeValue ? at(this.escape(ct)) : at(ct)
            }].forEach(ct=>{
                for (ot = 0; rt = ct.regex.exec(k); ) {
                    const pt = rt[1].trim();
                    if (nt = lt(pt),
                    nt === void 0)
                        if (typeof st == "function") {
                            const yt = st(k, rt, tt);
                            nt = typeof yt == "string" ? yt : ""
                        } else if (tt && Object.prototype.hasOwnProperty.call(tt, pt))
                            nt = "";
                        else if (ut) {
                            nt = rt[0];
                            continue
                        } else
                            this.logger.warn(`missed to pass in variable ${pt} for interpolating ${k}`),
                            nt = "";
                    else
                        typeof nt != "string" && !this.useRawValueToEscape && (nt = makeString(nt));
                    const ft = ct.safeValue(nt);
                    if (k = k.replace(rt[0], ft),
                    ut ? (ct.regex.lastIndex += nt.length,
                    ct.regex.lastIndex -= rt[0].length) : ct.regex.lastIndex = 0,
                    ot++,
                    ot >= this.maxReplaces)
                        break
                }
            }
            ),
            k
        }
        nest(k, J) {
            let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, tt, rt, nt;
            function ot(it, at) {
                const lt = this.nestingOptionsSeparator;
                if (it.indexOf(lt) < 0)
                    return it;
                const st = it.split(new RegExp(`${lt}[ ]*{`));
                let ut = `{${st[1]}`;
                it = st[0],
                ut = this.interpolate(ut, nt);
                const ct = ut.match(/'/g)
                  , pt = ut.match(/"/g);
                (ct && ct.length % 2 === 0 && !pt || pt.length % 2 !== 0) && (ut = ut.replace(/'/g, '"'));
                try {
                    nt = JSON.parse(ut),
                    at && (nt = $t($t({}, at), nt))
                } catch (ft) {
                    return this.logger.warn(`failed parsing options string in nesting for key ${it}`, ft),
                    `${it}${lt}${ut}`
                }
                return delete nt.defaultValue,
                it
            }
            for (; tt = this.nestingRegexp.exec(k); ) {
                let it = [];
                nt = $t({}, et),
                nt = nt.replace && typeof nt.replace != "string" ? nt.replace : nt,
                nt.applyPostProcessor = !1,
                delete nt.defaultValue;
                let at = !1;
                if (tt[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(tt[1])) {
                    const lt = tt[1].split(this.formatSeparator).map(st=>st.trim());
                    tt[1] = lt.shift(),
                    it = lt,
                    at = !0
                }
                if (rt = J(ot.call(this, tt[1].trim(), nt), nt),
                rt && tt[0] === k && typeof rt != "string")
                    return rt;
                typeof rt != "string" && (rt = makeString(rt)),
                rt || (this.logger.warn(`missed to resolve ${tt[1]} for nesting ${k}`),
                rt = ""),
                at && (rt = it.reduce((lt,st)=>this.format(lt, st, et.lng, _t($t({}, et), {
                    interpolationkey: tt[1].trim()
                })), rt.trim())),
                k = k.replace(tt[0], rt),
                this.regexp.lastIndex = 0
            }
            return k
        }
    }
    function parseFormatStr(_) {
        let k = _.toLowerCase().trim();
        const J = {};
        if (_.indexOf("(") > -1) {
            const et = _.split("(");
            k = et[0].toLowerCase().trim();
            const tt = et[1].substring(0, et[1].length - 1);
            k === "currency" && tt.indexOf(":") < 0 ? J.currency || (J.currency = tt.trim()) : k === "relativetime" && tt.indexOf(":") < 0 ? J.range || (J.range = tt.trim()) : tt.split(";").forEach(rt=>{
                if (!rt)
                    return;
                const [nt,...ot] = rt.split(":")
                  , it = ot.join(":").trim().replace(/^'+|'+$/g, "");
                J[nt.trim()] || (J[nt.trim()] = it),
                it === "false" && (J[nt.trim()] = !1),
                it === "true" && (J[nt.trim()] = !0),
                isNaN(it) || (J[nt.trim()] = parseInt(it, 10))
            }
            )
        }
        return {
            formatName: k,
            formatOptions: J
        }
    }
    function createCachedFormatter(_) {
        const k = {};
        return function(J, et, tt) {
            const rt = et + JSON.stringify(tt);
            let nt = k[rt];
            return nt || (nt = _(getCleanedCode(et), tt),
            k[rt] = nt),
            nt(J)
        }
    }
    class Formatter {
        constructor() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.logger = baseLogger.create("formatter"),
            this.options = k,
            this.formats = {
                number: createCachedFormatter((J,et)=>{
                    const tt = new Intl.NumberFormat(J,$t({}, et));
                    return rt=>tt.format(rt)
                }
                ),
                currency: createCachedFormatter((J,et)=>{
                    const tt = new Intl.NumberFormat(J,_t($t({}, et), {
                        style: "currency"
                    }));
                    return rt=>tt.format(rt)
                }
                ),
                datetime: createCachedFormatter((J,et)=>{
                    const tt = new Intl.DateTimeFormat(J,$t({}, et));
                    return rt=>tt.format(rt)
                }
                ),
                relativetime: createCachedFormatter((J,et)=>{
                    const tt = new Intl.RelativeTimeFormat(J,$t({}, et));
                    return rt=>tt.format(rt, et.range || "day")
                }
                ),
                list: createCachedFormatter((J,et)=>{
                    const tt = new Intl.ListFormat(J,$t({}, et));
                    return rt=>tt.format(rt)
                }
                )
            },
            this.init(k)
        }
        init(k) {
            const J = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                interpolation: {}
            }).interpolation;
            this.formatSeparator = J.formatSeparator ? J.formatSeparator : J.formatSeparator || ","
        }
        add(k, J) {
            this.formats[k.toLowerCase().trim()] = J
        }
        addCached(k, J) {
            this.formats[k.toLowerCase().trim()] = createCachedFormatter(J)
        }
        format(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return J.split(this.formatSeparator).reduce((rt,nt)=>{
                const {formatName: ot, formatOptions: it} = parseFormatStr(nt);
                if (this.formats[ot]) {
                    let at = rt;
                    try {
                        const lt = tt && tt.formatParams && tt.formatParams[tt.interpolationkey] || {}
                          , st = lt.locale || lt.lng || tt.locale || tt.lng || et;
                        at = this.formats[ot](rt, st, $t($t($t({}, it), tt), lt))
                    } catch (lt) {
                        this.logger.warn(lt)
                    }
                    return at
                } else
                    this.logger.warn(`there was no format function for ${ot}`);
                return rt
            }
            , k)
        }
    }
    function removePending(_, k) {
        _.pending[k] !== void 0 && (delete _.pending[k],
        _.pendingCount--)
    }
    class Connector extends EventEmitter {
        constructor(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            super(),
            this.backend = k,
            this.store = J,
            this.services = et,
            this.languageUtils = et.languageUtils,
            this.options = tt,
            this.logger = baseLogger.create("backendConnector"),
            this.waitingReads = [],
            this.maxParallelReads = tt.maxParallelReads || 10,
            this.readingCalls = 0,
            this.maxRetries = tt.maxRetries >= 0 ? tt.maxRetries : 5,
            this.retryTimeout = tt.retryTimeout >= 1 ? tt.retryTimeout : 350,
            this.state = {},
            this.queue = [],
            this.backend && this.backend.init && this.backend.init(et, tt.backend, tt)
        }
        queueLoad(k, J, et, tt) {
            const rt = {}
              , nt = {}
              , ot = {}
              , it = {};
            return k.forEach(at=>{
                let lt = !0;
                J.forEach(st=>{
                    const ut = `${at}|${st}`;
                    !et.reload && this.store.hasResourceBundle(at, st) ? this.state[ut] = 2 : this.state[ut] < 0 || (this.state[ut] === 1 ? nt[ut] === void 0 && (nt[ut] = !0) : (this.state[ut] = 1,
                    lt = !1,
                    nt[ut] === void 0 && (nt[ut] = !0),
                    rt[ut] === void 0 && (rt[ut] = !0),
                    it[st] === void 0 && (it[st] = !0)))
                }
                ),
                lt || (ot[at] = !0)
            }
            ),
            (Object.keys(rt).length || Object.keys(nt).length) && this.queue.push({
                pending: nt,
                pendingCount: Object.keys(nt).length,
                loaded: {},
                errors: [],
                callback: tt
            }),
            {
                toLoad: Object.keys(rt),
                pending: Object.keys(nt),
                toLoadLanguages: Object.keys(ot),
                toLoadNamespaces: Object.keys(it)
            }
        }
        loaded(k, J, et) {
            const tt = k.split("|")
              , rt = tt[0]
              , nt = tt[1];
            J && this.emit("failedLoading", rt, nt, J),
            et && this.store.addResourceBundle(rt, nt, et, void 0, void 0, {
                skipCopy: !0
            }),
            this.state[k] = J ? -1 : 2;
            const ot = {};
            this.queue.forEach(it=>{
                pushPath(it.loaded, [rt], nt),
                removePending(it, k),
                J && it.errors.push(J),
                it.pendingCount === 0 && !it.done && (Object.keys(it.loaded).forEach(at=>{
                    ot[at] || (ot[at] = {});
                    const lt = it.loaded[at];
                    lt.length && lt.forEach(st=>{
                        ot[at][st] === void 0 && (ot[at][st] = !0)
                    }
                    )
                }
                ),
                it.done = !0,
                it.errors.length ? it.callback(it.errors) : it.callback())
            }
            ),
            this.emit("loaded", ot),
            this.queue = this.queue.filter(it=>!it.done)
        }
        read(k, J, et) {
            let tt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
              , rt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout
              , nt = arguments.length > 5 ? arguments[5] : void 0;
            if (!k.length)
                return nt(null, {});
            if (this.readingCalls >= this.maxParallelReads) {
                this.waitingReads.push({
                    lng: k,
                    ns: J,
                    fcName: et,
                    tried: tt,
                    wait: rt,
                    callback: nt
                });
                return
            }
            this.readingCalls++;
            const ot = (at,lt)=>{
                if (this.readingCalls--,
                this.waitingReads.length > 0) {
                    const st = this.waitingReads.shift();
                    this.read(st.lng, st.ns, st.fcName, st.tried, st.wait, st.callback)
                }
                if (at && lt && tt < this.maxRetries) {
                    setTimeout(()=>{
                        this.read.call(this, k, J, et, tt + 1, rt * 2, nt)
                    }
                    , rt);
                    return
                }
                nt(at, lt)
            }
              , it = this.backend[et].bind(this.backend);
            if (it.length === 2) {
                try {
                    const at = it(k, J);
                    at && typeof at.then == "function" ? at.then(lt=>ot(null, lt)).catch(ot) : ot(null, at)
                } catch (at) {
                    ot(at)
                }
                return
            }
            return it(k, J, ot)
        }
        prepareLoading(k, J) {
            let et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
              , tt = arguments.length > 3 ? arguments[3] : void 0;
            if (!this.backend)
                return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
                tt && tt();
            typeof k == "string" && (k = this.languageUtils.toResolveHierarchy(k)),
            typeof J == "string" && (J = [J]);
            const rt = this.queueLoad(k, J, et, tt);
            if (!rt.toLoad.length)
                return rt.pending.length || tt(),
                null;
            rt.toLoad.forEach(nt=>{
                this.loadOne(nt)
            }
            )
        }
        load(k, J, et) {
            this.prepareLoading(k, J, {}, et)
        }
        reload(k, J, et) {
            this.prepareLoading(k, J, {
                reload: !0
            }, et)
        }
        loadOne(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            const et = k.split("|")
              , tt = et[0]
              , rt = et[1];
            this.read(tt, rt, "read", void 0, void 0, (nt,ot)=>{
                nt && this.logger.warn(`${J}loading namespace ${rt} for language ${tt} failed`, nt),
                !nt && ot && this.logger.log(`${J}loaded namespace ${rt} for language ${tt}`, ot),
                this.loaded(k, nt, ot)
            }
            )
        }
        saveMissing(k, J, et, tt, rt) {
            let nt = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}
              , ot = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ()=>{}
            ;
            if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(J)) {
                this.logger.warn(`did not save key "${et}" as the namespace "${J}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
                return
            }
            if (!(et == null || et === "")) {
                if (this.backend && this.backend.create) {
                    const it = _t($t({}, nt), {
                        isUpdate: rt
                    })
                      , at = this.backend.create.bind(this.backend);
                    if (at.length < 6)
                        try {
                            let lt;
                            at.length === 5 ? lt = at(k, J, et, tt, it) : lt = at(k, J, et, tt),
                            lt && typeof lt.then == "function" ? lt.then(st=>ot(null, st)).catch(ot) : ot(null, lt)
                        } catch (lt) {
                            ot(lt)
                        }
                    else
                        at(k, J, et, tt, ot, it)
                }
                !k || !k[0] || this.store.addResource(k[0], J, et, tt)
            }
        }
    }
    function get() {
        return {
            debug: !1,
            initImmediate: !0,
            ns: ["translation"],
            defaultNS: ["translation"],
            fallbackLng: ["dev"],
            fallbackNS: !1,
            supportedLngs: !1,
            nonExplicitSupportedLngs: !1,
            load: "all",
            preload: !1,
            simplifyPluralSuffix: !0,
            keySeparator: ".",
            nsSeparator: ":",
            pluralSeparator: "_",
            contextSeparator: "_",
            partialBundledLanguages: !1,
            saveMissing: !1,
            updateMissing: !1,
            saveMissingTo: "fallback",
            saveMissingPlurals: !0,
            missingKeyHandler: !1,
            missingInterpolationHandler: !1,
            postProcess: !1,
            postProcessPassResolved: !1,
            returnNull: !1,
            returnEmptyString: !0,
            returnObjects: !1,
            joinArrays: !1,
            returnedObjectHandler: !1,
            parseMissingKeyHandler: !1,
            appendNamespaceToMissingKey: !1,
            appendNamespaceToCIMode: !1,
            overloadTranslationOptionHandler: function(_) {
                let k = {};
                if (typeof _[1] == "object" && (k = _[1]),
                typeof _[1] == "string" && (k.defaultValue = _[1]),
                typeof _[2] == "string" && (k.tDescription = _[2]),
                typeof _[2] == "object" || typeof _[3] == "object") {
                    const J = _[3] || _[2];
                    Object.keys(J).forEach(et=>{
                        k[et] = J[et]
                    }
                    )
                }
                return k
            },
            interpolation: {
                escapeValue: !0,
                format: _=>_,
                prefix: "{{",
                suffix: "}}",
                formatSeparator: ",",
                unescapePrefix: "-",
                nestingPrefix: "$t(",
                nestingSuffix: ")",
                nestingOptionsSeparator: ",",
                maxReplaces: 1e3,
                skipOnVariables: !0
            }
        }
    }
    function transformOptions(_) {
        return typeof _.ns == "string" && (_.ns = [_.ns]),
        typeof _.fallbackLng == "string" && (_.fallbackLng = [_.fallbackLng]),
        typeof _.fallbackNS == "string" && (_.fallbackNS = [_.fallbackNS]),
        _.supportedLngs && _.supportedLngs.indexOf("cimode") < 0 && (_.supportedLngs = _.supportedLngs.concat(["cimode"])),
        _
    }
    function noop() {}
    function bindMemberFunctions(_) {
        Object.getOwnPropertyNames(Object.getPrototypeOf(_)).forEach(k=>{
            typeof _[k] == "function" && (_[k] = _[k].bind(_))
        }
        )
    }
    class I18n extends EventEmitter {
        constructor() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , J = arguments.length > 1 ? arguments[1] : void 0;
            if (super(),
            this.options = transformOptions(k),
            this.services = {},
            this.logger = baseLogger,
            this.modules = {
                external: []
            },
            bindMemberFunctions(this),
            J && !this.isInitialized && !k.isClone) {
                if (!this.options.initImmediate)
                    return this.init(k, J),
                    this;
                setTimeout(()=>{
                    this.init(k, J)
                }
                , 0)
            }
        }
        init() {
            var k = this;
            let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , et = arguments.length > 1 ? arguments[1] : void 0;
            this.isInitializing = !0,
            typeof J == "function" && (et = J,
            J = {}),
            !J.defaultNS && J.defaultNS !== !1 && J.ns && (typeof J.ns == "string" ? J.defaultNS = J.ns : J.ns.indexOf("translation") < 0 && (J.defaultNS = J.ns[0]));
            const tt = get();
            this.options = $t($t($t({}, tt), this.options), transformOptions(J)),
            this.options.compatibilityAPI !== "v1" && (this.options.interpolation = $t($t({}, tt.interpolation), this.options.interpolation)),
            J.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = J.keySeparator),
            J.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = J.nsSeparator);
            function rt(it) {
                return it ? typeof it == "function" ? new it : it : null
            }
            if (!this.options.isClone) {
                this.modules.logger ? baseLogger.init(rt(this.modules.logger), this.options) : baseLogger.init(null, this.options);
                let it;
                this.modules.formatter ? it = this.modules.formatter : typeof Intl < "u" && (it = Formatter);
                const at = new LanguageUtil(this.options);
                this.store = new ResourceStore(this.options.resources,this.options);
                const lt = this.services;
                lt.logger = baseLogger,
                lt.resourceStore = this.store,
                lt.languageUtils = at,
                lt.pluralResolver = new PluralResolver(at,{
                    prepend: this.options.pluralSeparator,
                    compatibilityJSON: this.options.compatibilityJSON,
                    simplifyPluralSuffix: this.options.simplifyPluralSuffix
                }),
                it && (!this.options.interpolation.format || this.options.interpolation.format === tt.interpolation.format) && (lt.formatter = rt(it),
                lt.formatter.init(lt, this.options),
                this.options.interpolation.format = lt.formatter.format.bind(lt.formatter)),
                lt.interpolator = new Interpolator(this.options),
                lt.utils = {
                    hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
                },
                lt.backendConnector = new Connector(rt(this.modules.backend),lt.resourceStore,lt,this.options),
                lt.backendConnector.on("*", function(st) {
                    for (var ut = arguments.length, ct = new Array(ut > 1 ? ut - 1 : 0), pt = 1; pt < ut; pt++)
                        ct[pt - 1] = arguments[pt];
                    k.emit(st, ...ct)
                }),
                this.modules.languageDetector && (lt.languageDetector = rt(this.modules.languageDetector),
                lt.languageDetector.init && lt.languageDetector.init(lt, this.options.detection, this.options)),
                this.modules.i18nFormat && (lt.i18nFormat = rt(this.modules.i18nFormat),
                lt.i18nFormat.init && lt.i18nFormat.init(this)),
                this.translator = new Translator(this.services,this.options),
                this.translator.on("*", function(st) {
                    for (var ut = arguments.length, ct = new Array(ut > 1 ? ut - 1 : 0), pt = 1; pt < ut; pt++)
                        ct[pt - 1] = arguments[pt];
                    k.emit(st, ...ct)
                }),
                this.modules.external.forEach(st=>{
                    st.init && st.init(this)
                }
                )
            }
            if (this.format = this.options.interpolation.format,
            et || (et = noop),
            this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
                const it = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
                it.length > 0 && it[0] !== "dev" && (this.options.lng = it[0])
            }
            !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"),
            ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(it=>{
                this[it] = function() {
                    return k.store[it](...arguments)
                }
            }
            ),
            ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(it=>{
                this[it] = function() {
                    return k.store[it](...arguments),
                    k
                }
            }
            );
            const nt = defer()
              , ot = ()=>{
                const it = (at,lt)=>{
                    this.isInitializing = !1,
                    this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"),
                    this.isInitialized = !0,
                    this.options.isClone || this.logger.log("initialized", this.options),
                    this.emit("initialized", this.options),
                    nt.resolve(lt),
                    et(at, lt)
                }
                ;
                if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
                    return it(null, this.t.bind(this));
                this.changeLanguage(this.options.lng, it)
            }
            ;
            return this.options.resources || !this.options.initImmediate ? ot() : setTimeout(ot, 0),
            nt
        }
        loadResources(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
            const et = typeof k == "string" ? k : this.language;
            if (typeof k == "function" && (J = k),
            !this.options.resources || this.options.partialBundledLanguages) {
                if (et && et.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
                    return J();
                const tt = []
                  , rt = nt=>{
                    !nt || nt === "cimode" || this.services.languageUtils.toResolveHierarchy(nt).forEach(ot=>{
                        ot !== "cimode" && tt.indexOf(ot) < 0 && tt.push(ot)
                    }
                    )
                }
                ;
                et ? rt(et) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(nt=>rt(nt)),
                this.options.preload && this.options.preload.forEach(nt=>rt(nt)),
                this.services.backendConnector.load(tt, this.options.ns, nt=>{
                    !nt && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language),
                    J(nt)
                }
                )
            } else
                J(null)
        }
        reloadResources(k, J, et) {
            const tt = defer();
            return k || (k = this.languages),
            J || (J = this.options.ns),
            et || (et = noop),
            this.services.backendConnector.reload(k, J, rt=>{
                tt.resolve(),
                et(rt)
            }
            ),
            tt
        }
        use(k) {
            if (!k)
                throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
            if (!k.type)
                throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
            return k.type === "backend" && (this.modules.backend = k),
            (k.type === "logger" || k.log && k.warn && k.error) && (this.modules.logger = k),
            k.type === "languageDetector" && (this.modules.languageDetector = k),
            k.type === "i18nFormat" && (this.modules.i18nFormat = k),
            k.type === "postProcessor" && postProcessor.addPostProcessor(k),
            k.type === "formatter" && (this.modules.formatter = k),
            k.type === "3rdParty" && this.modules.external.push(k),
            this
        }
        setResolvedLanguage(k) {
            if (!(!k || !this.languages) && !(["cimode", "dev"].indexOf(k) > -1))
                for (let J = 0; J < this.languages.length; J++) {
                    const et = this.languages[J];
                    if (!(["cimode", "dev"].indexOf(et) > -1) && this.store.hasLanguageSomeTranslations(et)) {
                        this.resolvedLanguage = et;
                        break
                    }
                }
        }
        changeLanguage(k, J) {
            var et = this;
            this.isLanguageChangingTo = k;
            const tt = defer();
            this.emit("languageChanging", k);
            const rt = it=>{
                this.language = it,
                this.languages = this.services.languageUtils.toResolveHierarchy(it),
                this.resolvedLanguage = void 0,
                this.setResolvedLanguage(it)
            }
              , nt = (it,at)=>{
                at ? (rt(at),
                this.translator.changeLanguage(at),
                this.isLanguageChangingTo = void 0,
                this.emit("languageChanged", at),
                this.logger.log("languageChanged", at)) : this.isLanguageChangingTo = void 0,
                tt.resolve(function() {
                    return et.t(...arguments)
                }),
                J && J(it, function() {
                    return et.t(...arguments)
                })
            }
              , ot = it=>{
                !k && !it && this.services.languageDetector && (it = []);
                const at = typeof it == "string" ? it : this.services.languageUtils.getBestMatchFromCodes(it);
                at && (this.language || rt(at),
                this.translator.language || this.translator.changeLanguage(at),
                this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(at)),
                this.loadResources(at, lt=>{
                    nt(lt, at)
                }
                )
            }
            ;
            return !k && this.services.languageDetector && !this.services.languageDetector.async ? ot(this.services.languageDetector.detect()) : !k && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(ot) : this.services.languageDetector.detect(ot) : ot(k),
            tt
        }
        getFixedT(k, J, et) {
            var tt = this;
            const rt = function(nt, ot) {
                let it;
                if (typeof ot != "object") {
                    for (var at = arguments.length, lt = new Array(at > 2 ? at - 2 : 0), st = 2; st < at; st++)
                        lt[st - 2] = arguments[st];
                    it = tt.options.overloadTranslationOptionHandler([nt, ot].concat(lt))
                } else
                    it = $t({}, ot);
                it.lng = it.lng || rt.lng,
                it.lngs = it.lngs || rt.lngs,
                it.ns = it.ns || rt.ns,
                it.keyPrefix = it.keyPrefix || et || rt.keyPrefix;
                const ut = tt.options.keySeparator || ".";
                let ct;
                return it.keyPrefix && Array.isArray(nt) ? ct = nt.map(pt=>`${it.keyPrefix}${ut}${pt}`) : ct = it.keyPrefix ? `${it.keyPrefix}${ut}${nt}` : nt,
                tt.t(ct, it)
            };
            return typeof k == "string" ? rt.lng = k : rt.lngs = k,
            rt.ns = J,
            rt.keyPrefix = et,
            rt
        }
        t() {
            return this.translator && this.translator.translate(...arguments)
        }
        exists() {
            return this.translator && this.translator.exists(...arguments)
        }
        setDefaultNamespace(k) {
            this.options.defaultNS = k
        }
        hasLoadedNamespace(k) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this.isInitialized)
                return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
                !1;
            if (!this.languages || !this.languages.length)
                return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
                !1;
            const et = J.lng || this.resolvedLanguage || this.languages[0]
              , tt = this.options ? this.options.fallbackLng : !1
              , rt = this.languages[this.languages.length - 1];
            if (et.toLowerCase() === "cimode")
                return !0;
            const nt = (ot,it)=>{
                const at = this.services.backendConnector.state[`${ot}|${it}`];
                return at === -1 || at === 2
            }
            ;
            if (J.precheck) {
                const ot = J.precheck(this, nt);
                if (ot !== void 0)
                    return ot
            }
            return !!(this.hasResourceBundle(et, k) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || nt(et, k) && (!tt || nt(rt, k)))
        }
        loadNamespaces(k, J) {
            const et = defer();
            return this.options.ns ? (typeof k == "string" && (k = [k]),
            k.forEach(tt=>{
                this.options.ns.indexOf(tt) < 0 && this.options.ns.push(tt)
            }
            ),
            this.loadResources(tt=>{
                et.resolve(),
                J && J(tt)
            }
            ),
            et) : (J && J(),
            Promise.resolve())
        }
        loadLanguages(k, J) {
            const et = defer();
            typeof k == "string" && (k = [k]);
            const tt = this.options.preload || []
              , rt = k.filter(nt=>tt.indexOf(nt) < 0);
            return rt.length ? (this.options.preload = tt.concat(rt),
            this.loadResources(nt=>{
                et.resolve(),
                J && J(nt)
            }
            ),
            et) : (J && J(),
            Promise.resolve())
        }
        dir(k) {
            if (k || (k = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
            !k)
                return "rtl";
            const J = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"]
              , et = this.services && this.services.languageUtils || new LanguageUtil(get());
            return J.indexOf(et.getLanguagePartFromCode(k)) > -1 || k.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
        }
        static createInstance() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , J = arguments.length > 1 ? arguments[1] : void 0;
            return new I18n(k,J)
        }
        cloneInstance() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
              , J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
            const et = k.forkResourceStore;
            et && delete k.forkResourceStore;
            const tt = _t($t($t({}, this.options), k), {
                isClone: !0
            })
              , rt = new I18n(tt);
            return (k.debug !== void 0 || k.prefix !== void 0) && (rt.logger = rt.logger.clone(k)),
            ["store", "services", "language"].forEach(nt=>{
                rt[nt] = this[nt]
            }
            ),
            rt.services = $t({}, this.services),
            rt.services.utils = {
                hasLoadedNamespace: rt.hasLoadedNamespace.bind(rt)
            },
            et && (rt.store = new ResourceStore(this.store.data,tt),
            rt.services.resourceStore = rt.store),
            rt.translator = new Translator(rt.services,tt),
            rt.translator.on("*", function(nt) {
                for (var ot = arguments.length, it = new Array(ot > 1 ? ot - 1 : 0), at = 1; at < ot; at++)
                    it[at - 1] = arguments[at];
                rt.emit(nt, ...it)
            }),
            rt.init(tt, J),
            rt.translator.options = tt,
            rt.translator.backendConnector.services.utils = {
                hasLoadedNamespace: rt.hasLoadedNamespace.bind(rt)
            },
            rt
        }
        toJSON() {
            return {
                options: this.options,
                store: this.store,
                language: this.language,
                languages: this.languages,
                resolvedLanguage: this.resolvedLanguage
            }
        }
    }
    instance = I18n.createInstance(),
    instance.createInstance = I18n.createInstance,
    instance.createInstance,
    instance.dir,
    instance.init,
    instance.loadResources,
    instance.reloadResources,
    instance.use,
    instance.changeLanguage,
    instance.getFixedT,
    instance.t,
    instance.exists,
    instance.setDefaultNamespace,
    instance.hasLoadedNamespace,
    instance.loadNamespaces,
    instance.loadLanguages,
    State = class {
        constructor(_) {
            _e(this, "state"),
            this.state = _
        }
        setState(_) {
            Object.assign(this.state, _)
        }
    }
    ;
    const {useProxy: useProxy$8, proxy: proxy$8, subscribeKey: subscribeKey$1} = valtio
      , defaultChatRoomPermission = {
        blockable: !1,
        deleteable: !1,
        vipable: !1,
        blockLevel: 0
    };
    class AccountStore extends State {
        constructor(k) {
            super(k),
            _e(this, "initData"),
            _e(this, "isInited", !1),
            this.initData = this.syncData(),
            this.initData.then(()=>this.isInited = !0),
            userSocket.on("xp_change", socket.decodeBind(J=>{
                const {vipLevel: et, currXP: tt, levelEndXP: rt, levelStartXP: nt} = J;
                Object.assign(this.state, {
                    vipLevel: et,
                    currXP: tt,
                    levelEndXP: rt,
                    levelStartXP: nt
                })
            }
            , "json")),
            subscribeKey$1(this.state, "login", J=>{
                J && userSocket.emit("user-login")
            }
            ),
            isSSR || setInterval(()=>this.syncData(), 3e5)
        }
        waitLogin() {
            return new Promise(k=>{
                if (this.state.login)
                    return k();
                const J = subscribeKey$1(this.state, "login", et=>{
                    et && (k(),
                    J())
                }
                )
            }
            )
        }
        async syncData() {
            const k = await http.get("/account/get/");
            return k.chatRoomPermission = k.chatRoomPermission || $t({}, defaultChatRoomPermission),
            Object.assign(this.state, k),
            this.state
        }
    }
    accountStore = new AccountStore(proxy$8({
        name: "",
        userId: 0,
        uniqueUid: 0,
        uid: 0,
        createTime: 0,
        kyc: 1,
        gameable: !0,
        login: !1,
        email: "",
        loginSource: "",
        open: 0,
        bonusCurrencyName: "",
        avatarUpdateTime: Date.now(),
        vipLevel: 0,
        currXP: 0,
        levelEndXP: 0,
        levelStartXP: 0,
        safePwd: !1,
        google2StepAuth: !1,
        hasPhone: !1,
        chatRoomPermission: defaultChatRoomPermission,
        emailVerified: !1,
        channel: "",
        currentInvitationCode: "",
        areaCode: "UNKOWN",
        showable: !0,
        areaAlert: !1,
        acceptPromotion: !0,
        passwordExist: !1,
        invitationUrl: ""
    })),
    useAccount = function() {
        return useProxy$8(accountStore.state)
    }
    ;
    async function getSetting() {
        const _ = await http.get("/account/setting/ns_user/get/");
        if (_)
            try {
                const k = JSON.parse(_);
                return preWalletData && !preWalletData.find(J=>J.currencyName === k.currencyName) && (k.currencyName = preWalletData[0].currencyName),
                k
            } catch (k) {
                return null
            }
        else
            return null
    }
    let preWalletData = null;
    async function getWallet() {
        const _ = await http.get("/user/amount/");
        return preWalletData = _,
        _
    }
    const {useProxy: useProxy$7, proxy: proxy$7, subscribe: subscribe$1} = valtio;
    class SettingStore extends State {
        constructor(k) {
            super(k),
            _e(this, "initData"),
            this.initData = this.sync(),
            this.initData.then(()=>{
                subscribe$1(this.state, ()=>this.save())
            }
            )
        }
        async sync() {
            if (await accountStore.initData,
            !accountStore.state.login)
                return accountStore.waitLogin().then(()=>this.sync()),
                this.state;
            const k = await getSetting();
            return k ? this.setState(k) : this.save(),
            this.state
        }
        async save() {
            if (await accountStore.initData,
            !!accountStore.state.login)
                return http.post("/account/setting/ns_user/reset/", this.state)
        }
    }
    settingStore = new SettingStore(proxy$7({
        currencyFullName: !1,
        localeCurrencyName: "USD",
        enableLocaleCurrency: !1,
        currencyName: "BTC",
        hideSmallCurrency: !1,
        lastFiatCurrency: "",
        lastCryptoCurrency: "",
        lastNftCurrency: "",
        soundEffectEnable: !0,
        lang: ""
    })),
    useSetting = function() {
        return useProxy$7(settingStore.state)
    }
    ;
    var jsxRuntime = {
        exports: {}
    }, reactJsxRuntime_production_min = {}, hasRequiredReactJsxRuntime_production_min;
    function requireReactJsxRuntime_production_min() {
        if (hasRequiredReactJsxRuntime_production_min)
            return reactJsxRuntime_production_min;
        hasRequiredReactJsxRuntime_production_min = 1;
        var _ = React
          , k = Symbol.for("react.element")
          , J = Symbol.for("react.fragment")
          , et = Object.prototype.hasOwnProperty
          , tt = _.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
          , rt = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };
        function nt(ot, it, at) {
            var lt, st = {}, ut = null, ct = null;
            at !== void 0 && (ut = "" + at),
            it.key !== void 0 && (ut = "" + it.key),
            it.ref !== void 0 && (ct = it.ref);
            for (lt in it)
                et.call(it, lt) && !rt.hasOwnProperty(lt) && (st[lt] = it[lt]);
            if (ot && ot.defaultProps)
                for (lt in it = ot.defaultProps,
                it)
                    st[lt] === void 0 && (st[lt] = it[lt]);
            return {
                $$typeof: k,
                type: ot,
                key: ut,
                ref: ct,
                props: st,
                _owner: tt.current
            }
        }
        return reactJsxRuntime_production_min.Fragment = J,
        reactJsxRuntime_production_min.jsx = nt,
        reactJsxRuntime_production_min.jsxs = nt,
        reactJsxRuntime_production_min
    }
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
    var jsxRuntimeExports = jsxRuntime.exports;
    function _extends$1() {
        return _extends$1 = Object.assign ? Object.assign.bind() : function(_) {
            for (var k = 1; k < arguments.length; k++) {
                var J = arguments[k];
                for (var et in J)
                    Object.prototype.hasOwnProperty.call(J, et) && (_[et] = J[et])
            }
            return _
        }
        ,
        _extends$1.apply(this, arguments)
    }
    var voidElements = {
        area: !0,
        base: !0,
        br: !0,
        col: !0,
        embed: !0,
        hr: !0,
        img: !0,
        input: !0,
        link: !0,
        meta: !0,
        param: !0,
        source: !0,
        track: !0,
        wbr: !0
    };
    const e = getDefaultExportFromCjs(voidElements);
    var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    function n(_) {
        var k = {
            type: "tag",
            name: "",
            voidElement: !1,
            attrs: {},
            children: []
        }
          , J = _.match(/<\/?([^\s]+?)[/\s>]/);
        if (J && (k.name = J[1],
        (e[J[1]] || _.charAt(_.length - 2) === "/") && (k.voidElement = !0),
        k.name.startsWith("!--"))) {
            var et = _.indexOf("-->");
            return {
                type: "comment",
                comment: et !== -1 ? _.slice(4, et) : ""
            }
        }
        for (var tt = new RegExp(t), rt = null; (rt = tt.exec(_)) !== null; )
            if (rt[0].trim())
                if (rt[1]) {
                    var nt = rt[1].trim()
                      , ot = [nt, ""];
                    nt.indexOf("=") > -1 && (ot = nt.split("=")),
                    k.attrs[ot[0]] = ot[1],
                    tt.lastIndex--
                } else
                    rt[2] && (k.attrs[rt[2]] = rt[3].trim().substring(1, rt[3].length - 1));
        return k
    }
    var r = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g
      , i = /^\s*$/
      , s = Object.create(null);
    function a(_, k) {
        switch (k.type) {
        case "text":
            return _ + k.content;
        case "tag":
            return _ += "<" + k.name + (k.attrs ? function(J) {
                var et = [];
                for (var tt in J)
                    et.push(tt + '="' + J[tt] + '"');
                return et.length ? " " + et.join(" ") : ""
            }(k.attrs) : "") + (k.voidElement ? "/>" : ">"),
            k.voidElement ? _ : _ + k.children.reduce(a, "") + "</" + k.name + ">";
        case "comment":
            return _ + "<!--" + k.comment + "-->"
        }
    }
    var c = {
        parse: function(_, k) {
            k || (k = {}),
            k.components || (k.components = s);
            var J, et = [], tt = [], rt = -1, nt = !1;
            if (_.indexOf("<") !== 0) {
                var ot = _.indexOf("<");
                et.push({
                    type: "text",
                    content: ot === -1 ? _ : _.substring(0, ot)
                })
            }
            return _.replace(r, function(it, at) {
                if (nt) {
                    if (it !== "</" + J.name + ">")
                        return;
                    nt = !1
                }
                var lt, st = it.charAt(1) !== "/", ut = it.startsWith("<!--"), ct = at + it.length, pt = _.charAt(ct);
                if (ut) {
                    var ft = n(it);
                    return rt < 0 ? (et.push(ft),
                    et) : ((lt = tt[rt]).children.push(ft),
                    et)
                }
                if (st && (rt++,
                (J = n(it)).type === "tag" && k.components[J.name] && (J.type = "component",
                nt = !0),
                J.voidElement || nt || !pt || pt === "<" || J.children.push({
                    type: "text",
                    content: _.slice(ct, _.indexOf("<", ct))
                }),
                rt === 0 && et.push(J),
                (lt = tt[rt - 1]) && lt.children.push(J),
                tt[rt] = J),
                (!st || J.voidElement) && (rt > -1 && (J.voidElement || J.name === it.slice(2, -1)) && (rt--,
                J = rt === -1 ? et : tt[rt]),
                !nt && pt !== "<" && pt)) {
                    lt = rt === -1 ? et : tt[rt].children;
                    var yt = _.indexOf("<", ct)
                      , ht = _.slice(ct, yt === -1 ? void 0 : yt);
                    i.test(ht) && (ht = " "),
                    (yt > -1 && rt + lt.length >= 0 || ht !== " ") && lt.push({
                        type: "text",
                        content: ht
                    })
                }
            }),
            et
        },
        stringify: function(_) {
            return _.reduce(function(k, J) {
                return k + a("", J)
            }, "")
        }
    };
    function warn() {
        if (console && console.warn) {
            for (var _ = arguments.length, k = new Array(_), J = 0; J < _; J++)
                k[J] = arguments[J];
            typeof k[0] == "string" && (k[0] = `react-i18next:: ${k[0]}`)
        }
    }
    const alreadyWarned = {};
    function warnOnce() {
        for (var _ = arguments.length, k = new Array(_), J = 0; J < _; J++)
            k[J] = arguments[J];
        typeof k[0] == "string" && alreadyWarned[k[0]] || (typeof k[0] == "string" && (alreadyWarned[k[0]] = new Date),
        warn(...k))
    }
    const loadedClb = (_,k)=>()=>{
        if (_.isInitialized)
            k();
        else {
            const J = ()=>{
                setTimeout(()=>{
                    _.off("initialized", J)
                }
                , 0),
                k()
            }
            ;
            _.on("initialized", J)
        }
    }
    ;
    function loadNamespaces(_, k, J) {
        _.loadNamespaces(k, loadedClb(_, J))
    }
    function loadLanguages(_, k, J, et) {
        typeof J == "string" && (J = [J]),
        J.forEach(tt=>{
            _.options.ns.indexOf(tt) < 0 && _.options.ns.push(tt)
        }
        ),
        _.loadLanguages(k, loadedClb(_, et))
    }
    function oldI18nextHasLoadedNamespace(_, k) {
        let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const et = k.languages[0]
          , tt = k.options ? k.options.fallbackLng : !1
          , rt = k.languages[k.languages.length - 1];
        if (et.toLowerCase() === "cimode")
            return !0;
        const nt = (ot,it)=>{
            const at = k.services.backendConnector.state[`${ot}|${it}`];
            return at === -1 || at === 2
        }
        ;
        return J.bindI18n && J.bindI18n.indexOf("languageChanging") > -1 && k.services.backendConnector.backend && k.isLanguageChangingTo && !nt(k.isLanguageChangingTo, _) ? !1 : !!(k.hasResourceBundle(et, _) || !k.services.backendConnector.backend || k.options.resources && !k.options.partialBundledLanguages || nt(et, _) && (!tt || nt(rt, _)))
    }
    function hasLoadedNamespace(_, k) {
        let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return !k.languages || !k.languages.length ? (warnOnce("i18n.languages were undefined or empty", k.languages),
        !0) : k.options.ignoreJSONStructure !== void 0 ? k.hasLoadedNamespace(_, {
            lng: J.lng,
            precheck: (et,tt)=>{
                if (J.bindI18n && J.bindI18n.indexOf("languageChanging") > -1 && et.services.backendConnector.backend && et.isLanguageChangingTo && !tt(et.isLanguageChangingTo, _))
                    return !1
            }
        }) : oldI18nextHasLoadedNamespace(_, k, J)
    }
    const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
      , htmlEntities = {
        "&amp;": "&",
        "&#38;": "&",
        "&lt;": "<",
        "&#60;": "<",
        "&gt;": ">",
        "&#62;": ">",
        "&apos;": "'",
        "&#39;": "'",
        "&quot;": '"',
        "&#34;": '"',
        "&nbsp;": " ",
        "&#160;": " ",
        "&copy;": "\xA9",
        "&#169;": "\xA9",
        "&reg;": "\xAE",
        "&#174;": "\xAE",
        "&hellip;": "\u2026",
        "&#8230;": "\u2026",
        "&#x2F;": "/",
        "&#47;": "/"
    }
      , unescapeHtmlEntity = _=>htmlEntities[_]
      , unescape$1 = _=>_.replace(matchHtmlEntity, unescapeHtmlEntity);
    let defaultOptions = {
        bindI18n: "languageChanged",
        bindI18nStore: "",
        transEmptyNodeValue: "",
        transSupportBasicHtmlNodes: !0,
        transWrapTextNodes: "",
        transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
        useSuspense: !0,
        unescape: unescape$1
    };
    function setDefaults() {
        let _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        defaultOptions = $t($t({}, defaultOptions), _)
    }
    function getDefaults() {
        return defaultOptions
    }
    let i18nInstance;
    function setI18n(_) {
        i18nInstance = _
    }
    function getI18n() {
        return i18nInstance
    }
    function hasChildren(_, k) {
        if (!_)
            return !1;
        const J = _.props ? _.props.children : _.children;
        return k ? J.length > 0 : !!J
    }
    function getChildren(_) {
        if (!_)
            return [];
        const k = _.props ? _.props.children : _.children;
        return _.props && _.props.i18nIsDynamicList ? getAsArray(k) : k
    }
    function hasValidReactChildren(_) {
        return Object.prototype.toString.call(_) !== "[object Array]" ? !1 : _.every(k=>reactExports.isValidElement(k))
    }
    function getAsArray(_) {
        return Array.isArray(_) ? _ : [_]
    }
    function mergeProps(_, k) {
        const J = $t({}, k);
        return J.props = Object.assign(_.props, k.props),
        J
    }
    function nodesToString(_, k) {
        if (!_)
            return "";
        let J = "";
        const et = getAsArray(_)
          , tt = k.transSupportBasicHtmlNodes && k.transKeepBasicHtmlNodesFor ? k.transKeepBasicHtmlNodesFor : [];
        return et.forEach((rt,nt)=>{
            if (typeof rt == "string")
                J += `${rt}`;
            else if (reactExports.isValidElement(rt)) {
                const it = Object.keys(rt.props).length
                  , at = tt.indexOf(rt.type) > -1
                  , lt = rt.props.children;
                if (!lt && at && it === 0)
                    J += `<${rt.type}/>`;
                else if (!lt && (!at || it !== 0))
                    J += `<${nt}></${nt}>`;
                else if (rt.props.i18nIsDynamicList)
                    J += `<${nt}></${nt}>`;
                else if (at && it === 1 && typeof lt == "string")
                    J += `<${rt.type}>${lt}</${rt.type}>`;
                else {
                    const st = nodesToString(lt, k);
                    J += `<${nt}>${st}</${nt}>`
                }
            } else if (rt === null)
                warn("Trans: the passed in value is invalid - seems you passed in a null child.");
            else if (typeof rt == "object") {
                const ot = rt
                  , {format: it} = ot
                  , at = Kt(ot, ["format"])
                  , lt = Object.keys(at);
                if (lt.length === 1) {
                    const st = it ? `${lt[0]}, ${it}` : lt[0];
                    J += `{{${st}}}`
                } else
                    warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", rt)
            } else
                warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", rt)
        }
        ),
        J
    }
    function renderNodes(_, k, J, et, tt, rt) {
        if (k === "")
            return [];
        const nt = et.transKeepBasicHtmlNodesFor || []
          , ot = k && new RegExp(nt.map(yt=>`<${yt}`).join("|")).test(k);
        if (!_ && !ot && !rt)
            return [k];
        const it = {};
        function at(yt) {
            getAsArray(yt).forEach(ht=>{
                typeof ht != "string" && (hasChildren(ht) ? at(getChildren(ht)) : typeof ht == "object" && !reactExports.isValidElement(ht) && Object.assign(it, ht))
            }
            )
        }
        at(_);
        const lt = c.parse(`<0>${k}</0>`)
          , st = $t($t({}, it), tt);
        function ut(yt, ht, gt) {
            const mt = getChildren(yt)
              , vt = pt(mt, ht.children, gt);
            return hasValidReactChildren(mt) && vt.length === 0 || yt.props && yt.props.i18nIsDynamicList ? mt : vt
        }
        function ct(yt, ht, gt, mt, vt) {
            yt.dummy ? (yt.children = ht,
            gt.push(reactExports.cloneElement(yt, {
                key: mt
            }, vt ? void 0 : ht))) : gt.push(...reactExports.Children.map([yt], bt=>{
                const Et = $t({}, bt.props);
                return delete Et.i18nIsDynamicList,
                React.createElement(bt.type, _extends$1({}, Et, {
                    key: mt,
                    ref: bt.ref
                }, vt ? {} : {
                    children: ht
                }))
            }
            ))
        }
        function pt(yt, ht, gt) {
            const mt = getAsArray(yt);
            return getAsArray(ht).reduce((vt,bt,Et)=>{
                const xt = bt.children && bt.children[0] && bt.children[0].content && J.services.interpolator.interpolate(bt.children[0].content, st, J.language);
                if (bt.type === "tag") {
                    let wt = mt[parseInt(bt.name, 10)];
                    gt.length === 1 && !wt && (wt = gt[0][bt.name]),
                    wt || (wt = {});
                    const St = Object.keys(bt.attrs).length !== 0 ? mergeProps({
                        props: bt.attrs
                    }, wt) : wt
                      , Pt = reactExports.isValidElement(St)
                      , Rt = Pt && hasChildren(bt, !0) && !bt.voidElement
                      , At = ot && typeof St == "object" && St.dummy && !Pt
                      , Nt = typeof _ == "object" && _ !== null && Object.hasOwnProperty.call(_, bt.name);
                    if (typeof St == "string") {
                        const Ot = J.services.interpolator.interpolate(St, st, J.language);
                        vt.push(Ot)
                    } else if (hasChildren(St) || Rt) {
                        const Ot = ut(St, bt, gt);
                        ct(St, Ot, vt, Et)
                    } else if (At) {
                        const Ot = pt(mt, bt.children, gt);
                        ct(St, Ot, vt, Et)
                    } else if (Number.isNaN(parseFloat(bt.name)))
                        if (Nt) {
                            const Ot = ut(St, bt, gt);
                            ct(St, Ot, vt, Et, bt.voidElement)
                        } else if (et.transSupportBasicHtmlNodes && nt.indexOf(bt.name) > -1)
                            if (bt.voidElement)
                                vt.push(reactExports.createElement(bt.name, {
                                    key: `${bt.name}-${Et}`
                                }));
                            else {
                                const Ot = pt(mt, bt.children, gt);
                                vt.push(reactExports.createElement(bt.name, {
                                    key: `${bt.name}-${Et}`
                                }, Ot))
                            }
                        else if (bt.voidElement)
                            vt.push(`<${bt.name} />`);
                        else {
                            const Ot = pt(mt, bt.children, gt);
                            vt.push(`<${bt.name}>${Ot}</${bt.name}>`)
                        }
                    else if (typeof St == "object" && !Pt) {
                        const Ot = bt.children[0] ? xt : null;
                        Ot && vt.push(Ot)
                    } else
                        ct(St, xt, vt, Et, bt.children.length !== 1 || !xt)
                } else if (bt.type === "text") {
                    const wt = et.transWrapTextNodes
                      , St = rt ? et.unescape(J.services.interpolator.interpolate(bt.content, st, J.language)) : J.services.interpolator.interpolate(bt.content, st, J.language);
                    wt ? vt.push(reactExports.createElement(wt, {
                        key: `${bt.name}-${Et}`
                    }, St)) : vt.push(St)
                }
                return vt
            }
            , [])
        }
        const ft = pt([{
            dummy: !0,
            children: _ || []
        }], lt, getAsArray(_ || []));
        return getChildren(ft[0])
    }
    function Trans$2(_) {
        let At = _
          , {children: k, count: J, parent: et, i18nKey: tt, context: rt, tOptions: nt={}, values: ot, defaults: it, components: at, ns: lt, i18n: st, t: ut, shouldUnescape: ct} = At
          , pt = Kt(At, ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"]);
        const ft = st || getI18n();
        if (!ft)
            return warnOnce("You will need to pass in an i18next instance by using i18nextReactModule"),
            k;
        const yt = ut || ft.t.bind(ft) || (Nt=>Nt);
        rt && (nt.context = rt);
        const ht = $t($t({}, getDefaults()), ft.options && ft.options.react);
        let gt = lt || yt.ns || ft.options && ft.options.defaultNS;
        gt = typeof gt == "string" ? [gt] : gt || ["translation"];
        const mt = nodesToString(k, ht)
          , vt = it || mt || ht.transEmptyNodeValue || tt
          , {hashTransKey: bt} = ht
          , Et = tt || (bt ? bt(mt || vt) : mt || vt);
        ft.options && ft.options.interpolation && ft.options.interpolation.defaultVariables && (ot = ot && Object.keys(ot).length > 0 ? $t($t({}, ot), ft.options.interpolation.defaultVariables) : $t({}, ft.options.interpolation.defaultVariables));
        const xt = ot ? nt.interpolation : {
            interpolation: _t($t({}, nt.interpolation), {
                prefix: "#$?",
                suffix: "?$#"
            })
        }
          , wt = _t($t($t(_t($t({}, nt), {
            count: J
        }), ot), xt), {
            defaultValue: vt,
            ns: gt
        })
          , St = Et ? yt(Et, wt) : vt;
        at && Object.keys(at).forEach(Nt=>{
            const Ot = at[Nt];
            if (typeof Ot.type == "function" || !Ot.props || !Ot.props.children || St.indexOf(`${Nt}/>`) < 0 && St.indexOf(`${Nt} />`) < 0)
                return;
            function It() {
                return React.createElement(React.Fragment, null, Ot)
            }
            at[Nt] = React.createElement(It, null)
        }
        );
        const Pt = renderNodes(at || k, St, ft, ht, wt, ct)
          , Rt = et !== void 0 ? et : ht.defaultTransParent;
        return Rt ? reactExports.createElement(Rt, pt, Pt) : Pt
    }
    const initReactI18next = {
        type: "3rdParty",
        init(_) {
            setDefaults(_.options.react),
            setI18n(_)
        }
    }
      , I18nContext = reactExports.createContext();
    class ReportNamespaces {
        constructor() {
            this.usedNamespaces = {}
        }
        addUsedNamespaces(k) {
            k.forEach(J=>{
                this.usedNamespaces[J] || (this.usedNamespaces[J] = !0)
            }
            )
        }
        getUsedNamespaces() {
            return Object.keys(this.usedNamespaces)
        }
    }
    function Trans$1(_) {
        let mt = _
          , {children: k, count: J, parent: et, i18nKey: tt, context: rt, tOptions: nt={}, values: ot, defaults: it, components: at, ns: lt, i18n: st, t: ut, shouldUnescape: ct} = mt
          , pt = Kt(mt, ["children", "count", "parent", "i18nKey", "context", "tOptions", "values", "defaults", "components", "ns", "i18n", "t", "shouldUnescape"]);
        const {i18n: ft, defaultNS: yt} = reactExports.useContext(I18nContext) || {}
          , ht = st || ft || getI18n()
          , gt = ut || ht && ht.t.bind(ht);
        return Trans$2($t({
            children: k,
            count: J,
            parent: et,
            i18nKey: tt,
            context: rt,
            tOptions: nt,
            values: ot,
            defaults: it,
            components: at,
            ns: lt || gt && gt.ns || yt || ht && ht.options && ht.options.defaultNS,
            i18n: ht,
            t: ut,
            shouldUnescape: ct
        }, pt))
    }
    const usePrevious$1 = (_,k)=>{
        const J = reactExports.useRef();
        return reactExports.useEffect(()=>{
            J.current = k ? J.current : _
        }
        , [_, k]),
        J.current
    }
    ;
    function useTranslation$1(_) {
        let k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {i18n: J} = k
          , {i18n: et, defaultNS: tt} = reactExports.useContext(I18nContext) || {}
          , rt = J || et || getI18n();
        if (rt && !rt.reportNamespaces && (rt.reportNamespaces = new ReportNamespaces),
        !rt) {
            warnOnce("You will need to pass in an i18next instance by using initReactI18next");
            const mt = (bt,Et)=>typeof Et == "string" ? Et : Et && typeof Et == "object" && typeof Et.defaultValue == "string" ? Et.defaultValue : Array.isArray(bt) ? bt[bt.length - 1] : bt
              , vt = [mt, {}, !1];
            return vt.t = mt,
            vt.i18n = {},
            vt.ready = !1,
            vt
        }
        rt.options.react && rt.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
        const nt = $t($t($t({}, getDefaults()), rt.options.react), k)
          , {useSuspense: ot, keyPrefix: it} = nt;
        let at = _ || tt || rt.options && rt.options.defaultNS;
        at = typeof at == "string" ? [at] : at || ["translation"],
        rt.reportNamespaces.addUsedNamespaces && rt.reportNamespaces.addUsedNamespaces(at);
        const lt = (rt.isInitialized || rt.initializedStoreOnce) && at.every(mt=>hasLoadedNamespace(mt, rt, nt));
        function st() {
            return rt.getFixedT(k.lng || null, nt.nsMode === "fallback" ? at : at[0], it)
        }
        const [ut,ct] = reactExports.useState(st);
        let pt = at.join();
        k.lng && (pt = `${k.lng}${pt}`);
        const ft = usePrevious$1(pt)
          , yt = reactExports.useRef(!0);
        reactExports.useEffect(()=>{
            const {bindI18n: mt, bindI18nStore: vt} = nt;
            yt.current = !0,
            !lt && !ot && (k.lng ? loadLanguages(rt, k.lng, at, ()=>{
                yt.current && ct(st)
            }
            ) : loadNamespaces(rt, at, ()=>{
                yt.current && ct(st)
            }
            )),
            lt && ft && ft !== pt && yt.current && ct(st);
            function bt() {
                yt.current && ct(st)
            }
            return mt && rt && rt.on(mt, bt),
            vt && rt && rt.store.on(vt, bt),
            ()=>{
                yt.current = !1,
                mt && rt && mt.split(" ").forEach(Et=>rt.off(Et, bt)),
                vt && rt && vt.split(" ").forEach(Et=>rt.store.off(Et, bt))
            }
        }
        , [rt, pt]);
        const ht = reactExports.useRef(!0);
        reactExports.useEffect(()=>{
            yt.current && !ht.current && ct(st),
            ht.current = !1
        }
        , [rt, it]);
        const gt = [ut, rt, lt];
        if (gt.t = ut,
        gt.i18n = rt,
        gt.ready = lt,
        lt || !lt && !ot)
            return gt;
        throw new Promise(mt=>{
            k.lng ? loadLanguages(rt, k.lng, at, ()=>mt()) : loadNamespaces(rt, at, ()=>mt())
        }
        )
    }
    let Ctx;
    Ctx = reactExports.createContext(null),
    langsLocaleToISO6391 = {
        "en-US": "en",
        "vi-VN": "vi",
        "id-ID": "id",
        "ja-JP": "ja",
        "ko-KR": "ko",
        "fr-FR": "fr",
        "es-ES": "es",
        "fil-PH": "tl",
        "ar-SA": "ar",
        "hi-IN": "hi",
        "tr-TR": "tr",
        "fa-IR": "fa",
        "pt-BR": "pt",
        "ru-RU": "ru",
        "de-DE": "de",
        "th-TH": "th",
        "fi-FI": "fi",
        "pl-PL": "pl",
        "it-IT": "it",
        "my-MM": "my",
        "ur-PK": "ur",
        "uk-UA": "uk",
        "ms-MY": "ms",
        "bn-BD": "bn",
        "mr-IN": "mr",
        "ta-IN": "ta",
        "te-IN": "te",
        "en-IN": "en-IN"
    },
    parseI18Locales = function(_) {
        return Object.entries(_).reduce((k,[J,et])=>{
            const tt = J.split("/").find(nt=>nt !== "front-end" && nt.includes("-")) || "en-US"
              , rt = langsLocaleToISO6391[tt] || tt.split("-")[0];
            return k[rt] = et,
            k
        }
        , {})
    }
    ;
    const addI18nLocales = memoize$1((_,k)=>{
        const J = parseI18Locales(_);
        return instance.options.backend.sources[k] = J,
        J
    }
    );
    createI18nT = function(_, k) {
        const J = (...et)=>k(_(...et));
        return J.$TFunctionBrand = _.$TFunctionBrand,
        J
    }
    ,
    I18nProvider = React.memo(({children: _, locales: k, namespace: J})=>{
        const et = reactExports.useMemo(()=>({
            namespace: J,
            locales: addI18nLocales(k, J)
        }), [J, k]);
        return jsxRuntimeExports.jsx(Ctx.Provider, {
            value: et,
            children: _
        })
    }
    ),
    instance.use({
        type: "backend",
        options: {},
        init(_, k={}, J={}) {
            this.options = k
        },
        read(_, k, J) {
            const et = this.options.sources[k]
              , tt = et && et[_] ? et[_]() : {};
            tt instanceof Promise ? tt.then(rt=>J(null, rt)) : J(null, tt)
        }
    }).use(initReactI18next);
    function getLang(_) {
        const k = localStorage.getItem("lang");
        if (k)
            if (k !== _) {
                const J = matchLang(k);
                return localStorage.setItem("lang", J),
                J || k
            } else
                return _;
        else if (navigator.language) {
            let J = _ !== "en" ? _ : navigator.language;
            J = J.replace("fil", "tl");
            const et = matchLang(J);
            return localStorage.setItem("lang", et),
            et
        } else
            return localStorage.setItem("navigatornolang", "lang"),
            _
    }
    function matchLang(_) {
        const k = instance.options.defaultNS
          , J = instance.options.backend.sources[k]
          , et = Object.keys(J);
        return et.find(tt=>tt === _ || new RegExp(`${tt}-.*`).test(_)) || et[0]
    }
    function useNamespace() {
        const _ = reactExports.useContext(Ctx);
        if (_)
            return _.namespace
    }
    useTranslation = isSSR ? function _(k) {
        const J = useNamespace()
          , {lang: et} = usePageContext();
        return useTranslation$1(k || J, {
            lng: et
        })
    }
    : function _(k) {
        const J = useNamespace();
        return useTranslation$1(k || J)
    }
    ,
    Trans = isSSR ? _=>{
        const k = useNamespace()
          , {lang: J} = usePageContext();
        return jsxRuntimeExports.jsx(Trans$1, _t($t({}, _), {
            ns: k,
            tOptions: {
                lng: J
            }
        }))
    }
    : _=>{
        const k = useNamespace();
        return jsxRuntimeExports.jsx(Trans$1, _t($t({}, _), {
            ns: k
        }))
    }
    ;
    class App extends EventEmitter$2 {
        constructor() {
            super(),
            _e(this, "rootEm", 16),
            _e(this, "rootNodes", []),
            _e(this, "dialogNodes", []),
            _e(this, "hashRouter", null),
            _e(this, "socket", null),
            _e(this, "history_navigate", ()=>{}
            ),
            _e(this, "unsafeNavigate", (...k)=>{
                this.history_navigate(...k)
            }
            ),
            this.on("inject_dialog", k=>this.dialogNodes.push(...k)),
            this.on("inject_rootNode", k=>this.rootNodes.push(k))
        }
        assets(k) {
            let J = `/modules/assets${k.startsWith("/") ? k : "/" + k}`;
            return k.startsWith("/logo/") && env.host === "87.com" && (J = J.replace("/logo/", "/logo87/")),
            J
        }
        createPath(k, J="") {
            return J = J && J + ".",
            `${window.location.protocol}//${J}distributedresourcestorage.com${k}`
        }
        isMobile() {
            return globalThis.innerWidth <= env.MAX_DESIGN_WIDTH
        }
        enableRem(k, J) {
            const et = throttle$1(()=>{
                const tt = globalThis.innerWidth;
                let rt;
                tt <= J ? rt = tt / k : rt = 1,
                this.rootEm = 16 * rt;
                const nt = document.documentElement.style;
                nt.fontSize = this.rootEm + "px"
            }
            , 500, {
                leading: !0
            });
            globalThis.addEventListener("resize", et),
            et()
        }
        relativePx(k) {
            return this.remScale(k) * this.rootEm
        }
        remScale(k) {
            return k / 16
        }
        promisify(k) {
            return (...J)=>new Promise(et=>{
                this.emit(k, ...J, tt=>et(tt))
            }
            )
        }
    }
    app = new App,
    env = {
        isSSR,
        localCurrencys: []
    };
    function SyncI18n() {
        const {urlOriginal: _, lang: k} = usePageContext()
          , J = useNavigate();
        return reactExports.useEffect(()=>{
            const et = getLang(k);
            et !== k && J(_, {
                lang: et
            })
        }
        , [k]),
        useIsomorphicEffect(()=>{
            instance.changeLanguage(k)
        }
        , [k]),
        null
    }
    useChangeLang = function() {
        const {urlOriginal: _, lang: k} = usePageContext()
          , J = useNavigate();
        return et=>{
            k !== et && (localStorage.setItem("lang", et),
            settingStore.setState({
                lang: et
            }),
            J(_, {
                lang: et
            }))
        }
    }
    ,
    useMountedState = function() {
        const _ = reactExports.useRef(!1)
          , k = reactExports.useCallback(()=>_.current, []);
        return useIsomorphicEffect(()=>(_.current = !0,
        ()=>{
            _.current = !1
        }
        ), []),
        k
    }
    ,
    useSetState = function(_) {
        const [k,J] = reactExports.useState(_)
          , et = useMountedState()
          , tt = reactExports.useCallback(rt=>{
            et() && J(nt=>{
                const ot = rt instanceof Function ? rt(nt) : rt;
                return Object.keys(ot).findIndex(it=>nt[it] !== ot[it]) != -1 ? Object.assign({}, nt, ot) : nt
            }
            )
        }
        , [J]);
        return [k, tt]
    }
    ;
    function cx$1(..._) {
        return _.filter(Boolean).join(" ")
    }
    function Loading({className: _, size: k=0, stroke: J="#3BC117"}) {
        const et = k > 0 ? {
            height: k,
            maxHeight: k
        } : void 0;
        return jsxRuntimeExports.jsx("div", {
            className: cx$1(ellipsisStyle, "loading", _),
            children: jsxRuntimeExports.jsxs("svg", {
                viewBox: "0 0 84 24",
                fill: J,
                style: et,
                children: [jsxRuntimeExports.jsx("circle", {
                    cx: "18",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "18",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "42",
                    cy: "12",
                    r: "6"
                }), jsxRuntimeExports.jsx("circle", {
                    cx: "66",
                    cy: "12",
                    r: "6"
                })]
            })
        })
    }
    let ellipsisStyle, assetsDict;
    Loading$1 = React.memo(Loading),
    ellipsisStyle = "e9sva",
    assetsDict = {
        empty: ["common/empty.png", "common/empty_w.png"],
        notfound: ["common/notfound.png", "common/notfound_w.png"],
        offline: ["common/offline.png", "common/offline_w.png"],
        privacy: ["common/privacy.png", "common/privacy_w.png"],
        ban: ["common/ban.png", "common/ban_w.png"]
    };
    function getAssets$1(_, k) {
        return app.assets(assetsDict[_][k ? 0 : 1])
    }
    let style$3, initState;
    Empty = React.memo(function({className: _="", type: k="empty", children: J, hideMsg: et=!1}) {
        const tt = useIsDarken()
          , rt = instance.options.defaultNS
          , nt = {
            empty: instance.t("Oops! There is no data yet!", {
                ns: rt
            }),
            notfound: instance.t("Uh Oh! The page you're looking for cannot be found!", {
                ns: rt
            }),
            offline: instance.t("Oops! No internet connection!", {
                ns: rt
            }),
            privacy: instance.t("This user has privacy mode enabled!", {
                ns: rt
            }),
            ban: ""
        }
          , ot = J || !et && nt[k];
        return jsxRuntimeExports.jsxs("div", {
            className: `empty ${style$3} ${_}`,
            children: [jsxRuntimeExports.jsx("img", {
                src: getAssets$1(k, tt)
            }), ot && jsxRuntimeExports.jsx("div", {
                className: "msg",
                children: ot
            })]
        })
    }),
    style$3 = "sowd61n",
    initState = {
        error: null,
        data: null
    },
    useAsyncFn = function(_, k=[], J=initState) {
        const et = reactExports.useRef(0)
          , [tt,rt] = useSetState(J)
          , nt = useMountedState()
          , ot = reactExports.useCallback((...it)=>{
            const at = ++et.current;
            return rt(initState),
            _(...it).then(lt=>{
                nt() && et.current == at && rt({
                    data: lt
                })
            }
            ).catch(lt=>{
                if (nt() && et.current == at && rt({
                    error: lt
                }),
                lt instanceof Error)
                    throw lt
            }
            )
        }
        , k);
        return {
            state: tt,
            fetch: ot
        }
    }
    ,
    useAsync = function(_, k=[]) {
        const {state: J, fetch: et} = useAsyncFn(_, k, initState);
        return reactExports.useEffect(()=>{
            et()
        }
        , [et]),
        J
    }
    ,
    useAsyncNode = function(_, k=[], {loadingNode: J=jsxRuntimeExports.jsx(Loading$1, {}), errorNode: et=jsxRuntimeExports.jsx(Empty, {})}={}) {
        const {data: tt, error: rt} = useAsync(_, k);
        return rt ? et : tt || J
    }
    ,
    useIsFirstRender = function() {
        const _ = reactExports.useRef(!0);
        return reactExports.useEffect(()=>{
            _.current = !1
        }
        , []),
        _.current
    }
    ,
    useIntersection = function(_, k) {
        const [J,et] = reactExports.useState(!1);
        return reactExports.useEffect(()=>{
            if (_.current) {
                const tt = _.current
                  , rt = intersectionObserver(tt, et, k);
                return ()=>{
                    rt.unobserve(tt)
                }
            }
        }
        , [_.current]),
        J
    }
    ,
    useInView = function(_) {
        const k = reactExports.useRef(null)
          , J = useIntersection(k, _);
        return {
            ref: k,
            inView: J
        }
    }
    ,
    useOnClickOutside = function(_, k=[], J=[], et=!1) {
        const tt = reactExports.useRef(null);
        return reactExports.useEffect(()=>{
            const rt = k.concat(tt)
              , nt = ot=>{
                rt.find(it=>!it.current || it.current.contains(ot.target)) || _(ot)
            }
            ;
            return et ? (document.addEventListener("mousedown", nt),
            document.addEventListener("touchstart", nt),
            ()=>{
                document.removeEventListener("mousedown", nt),
                document.removeEventListener("touchstart", nt)
            }
            ) : (document.addEventListener("click", nt, !0),
            ()=>{
                document.removeEventListener("click", nt, !0)
            }
            )
        }
        , J),
        tt
    }
    ,
    usePrevious = function(_) {
        const k = reactExports.useRef();
        return reactExports.useEffect(()=>{
            k.current = _
        }
        ),
        k.current
    }
    ,
    useWindowSize = function() {
        const [_,k] = reactExports.useState({
            width: globalThis.innerWidth,
            height: globalThis.innerHeight
        })
          , J = reactExports.useMemo(()=>throttle$1(()=>k({
            width: globalThis.innerWidth,
            height: globalThis.innerHeight
        }), 200), []);
        return reactExports.useEffect(()=>(globalThis.addEventListener("resize", J),
        ()=>globalThis.removeEventListener("resize", J)), []),
        _
    }
    ,
    useResize = function(_, k=0) {
        const J = useMountedState()
          , et = reactExports.useRef({
            width: 0,
            height: 0,
            el: null,
            fn: _
        });
        et.current.fn = reactExports.useMemo(()=>k > 0 ? throttle$1(nt=>J() && _(nt), k) : _, [_, k]);
        const tt = reactExports.useCallback(({width: nt, height: ot})=>{
            const it = et.current;
            (ot != it.height || nt != it.width) && (Object.assign(it, {
                width: nt,
                height: ot
            }),
            J() && it.fn({
                width: nt,
                height: ot
            }))
        }
        , [])
          , rt = reactExports.useRef(null);
        return useIsomorphicEffect(()=>{
            const nt = et.current
              , ot = rt.current;
            ot && nt.el !== ot && (nt.el && SRObserver.remove(nt.el),
            nt.el = ot,
            tt({
                width: ot.clientWidth,
                height: ot.clientHeight
            }),
            SRObserver.add(ot, tt))
        }
        ),
        reactExports.useEffect(()=>()=>{
            const nt = et.current.el;
            nt && SRObserver.remove(nt)
        }
        , []),
        rt
    }
    ,
    useHover = function(_=!1) {
        const k = reactExports.useRef(null)
          , [J,et] = reactExports.useState(!1);
        return useIsomorphicEffect(()=>{
            if (k.current) {
                const tt = ()=>et(!0)
                  , rt = ()=>et(!1)
                  , nt = k.current;
                if (isSupportTouch) {
                    if (!_)
                        return nt.addEventListener("touchstart", tt),
                        nt.addEventListener("touchend", rt),
                        nt.addEventListener("touchcancel", rt),
                        ()=>{
                            nt.removeEventListener("touchstart", tt),
                            nt.removeEventListener("touchend", rt),
                            nt.removeEventListener("touchcancel", rt)
                        }
                } else
                    return nt.addEventListener("mouseenter", tt),
                    nt.addEventListener("mouseleave", rt),
                    ()=>{
                        nt.removeEventListener("mouseenter", tt),
                        nt.removeEventListener("mouseleave", rt)
                    }
            }
        }
        , []),
        {
            isHover: J,
            ref: k
        }
    }
    ,
    useAutoRemove = function(_=2e3) {
        const [k,J] = reactExports.useState(null);
        return reactExports.useEffect(()=>{
            if (k) {
                const et = setTimeout(()=>J(null), _);
                return ()=>{
                    clearTimeout(et)
                }
            }
        }
        , [k, _]),
        [k, J]
    }
    ,
    useAnimatedFrames = function({config: _, image: k, fps: J=60, options: et={}}) {
        const tt = reactExports.useRef(null)
          , rt = _.frames[0].sourceSize
          , nt = {
            width: rt.w,
            height: rt.h
        }
          , ot = reactExports.useMemo(()=>_.frames.map(at=>{
            const {frame: lt, spriteSourceSize: st} = at;
            return {
                width: `${lt.w}px`,
                height: `${lt.h}px`,
                left: `${st.x}px`,
                top: `${st.y}px`,
                backgroundPosition: `${-lt.x}px ${-lt.y}px`
            }
        }
        ), [_])
          , it = reactExports.useMemo(()=>{
            const at = {
                idx: 0,
                frames: ot
            };
            return gsapWithCSS.to(at, Object.assign(et, {
                idx: at.frames.length - 1,
                duration: at.frames.length / J,
                ease: Linear.easeNone,
                onUpdate() {
                    tt.current && Object.assign(tt.current.style, at.frames[Math.round(at.idx)])
                }
            }))
        }
        , [_, J]);
        return useIsomorphicEffect(()=>(it.progress(0),
        ()=>{
            gsapWithCSS.killTweensOf(it)
        }
        ), [it]),
        [reactExports.useMemo(()=>jsxRuntimeExports.jsx("div", {
            className: `${wrapStyle$3} animatedframes`,
            style: nt,
            children: jsxRuntimeExports.jsx("div", {
                className: "frame",
                ref: tt,
                style: $t({
                    backgroundImage: `url(${k})`
                }, ot[0])
            })
        }), []), it]
    }
    ;
    const wrapStyle$3 = "w183p1ml";
    function _toConsumableArray(_) {
        if (Array.isArray(_)) {
            for (var k = 0, J = Array(_.length); k < _.length; k++)
                J[k] = _[k];
            return J
        } else
            return Array.from(_)
    }
    var hasPassiveEvents = !1;
    if (typeof window < "u") {
        var passiveTestOptions = {
            get passive() {
                hasPassiveEvents = !0
            }
        };
        window.addEventListener("testPassive", null, passiveTestOptions),
        window.removeEventListener("testPassive", null, passiveTestOptions)
    }
    var isIosDevice = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1)
      , locks = []
      , documentListenerAdded = !1
      , initialClientY = -1
      , previousBodyOverflowSetting = void 0
      , previousBodyPaddingRight = void 0
      , allowTouchMove = function _(k) {
        return locks.some(function(J) {
            return !!(J.options.allowTouchMove && J.options.allowTouchMove(k))
        })
    }
      , preventDefault = function _(k) {
        var J = k || window.event;
        return allowTouchMove(J.target) || J.touches.length > 1 ? !0 : (J.preventDefault && J.preventDefault(),
        !1)
    }
      , setOverflowHidden = function _(k) {
        if (previousBodyPaddingRight === void 0) {
            var J = !!k && k.reserveScrollBarGap === !0
              , et = window.innerWidth - document.documentElement.clientWidth;
            J && et > 0 && (previousBodyPaddingRight = document.body.style.paddingRight,
            document.body.style.paddingRight = et + "px")
        }
        previousBodyOverflowSetting === void 0 && (previousBodyOverflowSetting = document.body.style.overflow,
        document.body.style.overflow = "hidden")
    }
      , restoreOverflowSetting = function _() {
        previousBodyPaddingRight !== void 0 && (document.body.style.paddingRight = previousBodyPaddingRight,
        previousBodyPaddingRight = void 0),
        previousBodyOverflowSetting !== void 0 && (document.body.style.overflow = previousBodyOverflowSetting,
        previousBodyOverflowSetting = void 0)
    }
      , isTargetElementTotallyScrolled = function _(k) {
        return k ? k.scrollHeight - k.scrollTop <= k.clientHeight : !1
    }
      , handleScroll = function _(k, J) {
        var et = k.targetTouches[0].clientY - initialClientY;
        return allowTouchMove(k.target) ? !1 : J && J.scrollTop === 0 && et > 0 || isTargetElementTotallyScrolled(J) && et < 0 ? preventDefault(k) : (k.stopPropagation(),
        !0)
    }
      , disableBodyScroll = function _(k, J) {
        if (k && !locks.some(function(tt) {
            return tt.targetElement === k
        })) {
            var et = {
                targetElement: k,
                options: J || {}
            };
            locks = [].concat(_toConsumableArray(locks), [et]),
            isIosDevice ? (k.ontouchstart = function(tt) {
                tt.targetTouches.length === 1 && (initialClientY = tt.targetTouches[0].clientY)
            }
            ,
            k.ontouchmove = function(tt) {
                tt.targetTouches.length === 1 && handleScroll(tt, k)
            }
            ,
            documentListenerAdded || (document.addEventListener("touchmove", preventDefault, hasPassiveEvents ? {
                passive: !1
            } : void 0),
            documentListenerAdded = !0)) : setOverflowHidden(J)
        }
    }
      , enableBodyScroll = function _(k) {
        k && (locks = locks.filter(function(J) {
            return J.targetElement !== k
        }),
        isIosDevice ? (k.ontouchstart = null,
        k.ontouchmove = null,
        documentListenerAdded && locks.length === 0 && (document.removeEventListener("touchmove", preventDefault, hasPassiveEvents ? {
            passive: !1
        } : void 0),
        documentListenerAdded = !1)) : locks.length || restoreOverflowSetting())
    };
    useDisableBodyScroll = function(_) {
        const k = reactExports.useRef(!1);
        useIsomorphicEffect(()=>{
            const J = _ && _.current;
            if (J && !k.current)
                return k.current = !0,
                disableBodyScroll(J),
                ()=>{
                    k.current = !1,
                    enableBodyScroll(J)
                }
        }
        )
    }
    ,
    useDisableParentScroll = function(_) {
        reactExports.useEffect(()=>{
            const k = _ && _.current;
            if (k) {
                const J = et=>{
                    (et.deltaY > 0 && k.scrollTop === k.scrollHeight - k.offsetHeight || k.scrollTop === 0 && et.deltaY < 0) && et.preventDefault()
                }
                ;
                return k.addEventListener("wheel", J),
                ()=>{
                    k.removeEventListener("wheel", J)
                }
            }
        }
        , [_])
    }
    ,
    useMergeRefs = function(..._) {
        return reactExports.useCallback(k=>{
            _.forEach(J=>{
                typeof J == "function" ? J(k) : J != null && (J.current = k)
            }
            )
        }
        , _)
    }
    ,
    useDelayHover = function(_) {
        const k = reactExports.useRef(null)
          , [J,et] = reactExports.useState(!1);
        return reactExports.useEffect(()=>{
            const tt = k.current;
            if (!tt)
                return;
            let rt = 0;
            const nt = it=>{
                rt = window.setTimeout(()=>et(!0), _)
            }
              , ot = it=>{
                clearTimeout(rt),
                et(!1)
            }
            ;
            return tt.addEventListener("pointerenter", nt),
            tt.addEventListener("pointerleave", ot),
            ()=>{
                tt.removeEventListener("pointerenter", nt),
                tt.removeEventListener("pointerleave", ot)
            }
        }
        , [k.current, _]),
        {
            ref: k,
            isHover: J
        }
    }
    ;
    const isLocaleReg = /^\//;
    useLinkIntercept = function() {
        const _ = useNavigate();
        return reactExports.useCallback(k=>{
            let J = k.target;
            for (; J; ) {
                if (J.tagName === "A") {
                    const et = J.getAttribute("href")
                      , tt = !J.hasAttribute("data-ignore-intercept");
                    isLocaleReg.test(et) && tt && (k.preventDefault(),
                    _(et));
                    break
                }
                J = J.parentElement === k.currentTarget ? null : J.parentElement
            }
        }
        , [_])
    }
    ,
    useRootClassName = isSSR ? function(_) {
        const k = reactExports.useRef()
          , J = usePageContext();
        if (!_ || !J.rootClassName)
            return;
        const et = k.current;
        et && et !== _ && J.rootClassName.delete(_),
        J.rootClassName.add(_),
        k.current = _
    }
    : function(_, k="root") {
        reactExports.useLayoutEffect(()=>{
            if (_) {
                const J = document.getElementById(k).classList;
                return J.add(_),
                ()=>{
                    J.remove(_)
                }
            }
        }
        , [_])
    }
    ,
    useSmoothList = function(ot) {
        var it = ot
          , {data: _, className: k, renderItem: J, ref: et, style: tt, loop: rt=0} = it
          , nt = Kt(it, ["data", "className", "renderItem", "ref", "style", "loop"]);
        const at = useForceUpdate()
          , lt = reactExports.useRef(null)
          , st = useMergeRefs(lt, et)
          , ut = reactExports.useRef({
            index: 0,
            prevEnable: !1,
            nextEnable: !0
        }).current;
        useIsomorphicEffect(()=>{
            const ht = lt.current;
            if (!ht || ht.children.length === 0)
                return;
            const gt = ht.children[ut.index];
            gt ? ht.scrollTo({
                left: gt.offsetLeft,
                behavior: "smooth"
            }) : ct(0)
        }
        , [ut.index]);
        const ct = reactExports.useCallback(ht=>{
            ht != ut.index && (ut.index = ht,
            at())
        }
        , [])
          , pt = reactExports.useCallback(ht=>{
            const gt = lt.current;
            if (!gt)
                return 0;
            const {clientWidth: mt, scrollWidth: vt} = gt
              , bt = [...gt.children];
            if (bt.length <= 0)
                return 0;
            const Et = Math.min(Math.max(ht, 0), vt - mt);
            return Math.max(bt.findIndex(xt=>Math.abs(xt.offsetLeft - Et) < xt.clientWidth), 0)
        }
        , [])
          , ft = reactExports.useCallback((ht,gt=!1)=>{
            const mt = lt.current;
            if (!mt)
                return;
            const {scrollLeft: vt, clientWidth: bt, scrollWidth: Et} = mt;
            let xt = vt + bt * ht;
            const wt = pt(xt);
            gt && ut.index == wt ? ht > 0 ? ct(0) : ct(pt(Et)) : ct(wt)
        }
        , [])
          , [yt] = reactExports.useState(()=>debounce(()=>{
            const ht = lt.current;
            if (!ht || ht.children.length === 0)
                return;
            const gt = ht.children[0]
              , mt = ht.children[ht.children.length - 1]
              , {scrollLeft: vt, scrollWidth: bt, clientWidth: Et} = ht
              , xt = vt - (bt - Et) < -mt.clientWidth * .5
              , wt = vt > gt.clientWidth * .5;
            ct(pt(ht.scrollLeft)),
            (xt !== ut.nextEnable || wt !== ut.prevEnable) && (Object.assign(ut, {
                nextEnable: xt,
                prevEnable: wt
            }),
            at())
        }
        , 100));
        return reactExports.useEffect(()=>{
            if (rt > 0) {
                const ht = setInterval(()=>{
                    ft(1, !0)
                }
                , rt);
                return ()=>{
                    clearInterval(ht)
                }
            }
        }
        , [rt]),
        reactExports.useEffect(()=>yt(), []),
        $t({
            scrollNode: reactExports.useMemo(()=>jsxRuntimeExports.jsx("div", _t($t({
                ref: st,
                className: cx$1(styleName, k),
                style: tt
            }, nt), {
                onScroll: yt,
                children: _.map((ht,gt)=>J(ht, gt))
            })), [_, k, tt]),
            slide: ft
        }, ut)
    }
    ;
    let styleName, LayoutSizeContext;
    styleName = "s138s2zu",
    LayoutSizeContext = reactExports.createContext(globalThis.innerWidth),
    LayoutSizeProvider = reactExports.memo(({children: _, root: k, rootRef: J})=>{
        const [et,tt] = reactExports.useState(globalThis.innerWidth);
        return useIsomorphicEffect(()=>{
            const rt = J ? J.current : k;
            if (rt)
                return SRObserver.add(rt, throttle$1(({width: nt})=>tt(nt), 500)),
                ()=>SRObserver.remove(rt)
        }
        , [k, J]),
        jsxRuntimeExports.jsx(LayoutSizeContext.Provider, {
            value: et,
            children: _
        })
    }
    ),
    useLayoutSize = function() {
        return reactExports.useContext(LayoutSizeContext)
    }
    ,
    SuspenseData = class {
        constructor(_) {
            _e(this, "result", null),
            _e(this, "promise"),
            _.then(k=>{
                this.result = k
            }
            , k=>{
                this.result = k
            }
            ),
            this.promise = _
        }
        read() {
            if (this.result) {
                if (this.result instanceof Error)
                    throw this.result;
                return this.result
            } else
                throw this.promise
        }
    }
    ,
    SuspenseSource = class {
        constructor(_) {
            _e(this, "source"),
            _e(this, "suspensed"),
            this.source = _,
            this.suspensed = Object.entries(_).reduce((k,[J,et])=>(k[J] = new SuspenseData(et),
            k), {})
        }
        async flat() {
            const _ = Object.entries(this.suspensed).map(([J,et])=>[J, et])
              , k = _.map(([,J])=>J.promise);
            return await Promise.all(k),
            _.reduce((J,[et,tt])=>(J[et] = tt.read(),
            J), {})
        }
        static fromStaticObject(_) {
            return new SuspenseSource(Object.entries(_).reduce((k,[J,et])=>(k[J] = Promise.resolve(et),
            k), {}))
        }
    }
    ;
    let svgWrap, ActiveContext;
    Icon = React.memo(function _(tt) {
        var rt = tt
          , {name: k, className: J} = rt
          , et = Kt(rt, ["name", "className"]);
        const {assets: nt} = usePageContext();
        return jsxRuntimeExports.jsx("svg", _t($t({
            className: cx$1(svgWrap, "icon", J)
        }, et), {
            children: jsxRuntimeExports.jsx("use", {
                xlinkHref: `${nt.icon}#icon_${k}`
            })
        }))
    }),
    svgWrap = "s1ff97qc",
    ActiveContext = React.createContext(!0),
    Active = class extends React.PureComponent {
        constructor(_) {
            super(_),
            this.state = {
                active: !0
            }
        }
        render() {
            return jsxRuntimeExports.jsx(ActiveContext.Provider, {
                value: this.state.active,
                children: this.props.children
            })
        }
    }
    ,
    ActiveProvider = React.memo(function _({children: k, value: J}) {
        const et = useIsActive();
        return jsxRuntimeExports.jsx(ActiveContext.Provider, {
            value: et && J,
            children: k
        })
    }),
    useIsActive = function() {
        return reactExports.useContext(ActiveContext)
    }
    ,
    useActiveMemo = function(_) {
        const k = useIsActive()
          , J = reactExports.useRef(_);
        return reactExports.useMemo(()=>k ? (J.current = _,
        _) : J.current, [k, _])
    }
    ;
    class PortalManager extends EventEmitter$2 {
        constructor() {
            super(),
            _e(this, "cache", new Map)
        }
        delNode(k, J) {
            const et = this.getCache(k)
              , tt = et.indexOf(J);
            tt != -1 && (et.splice(tt, 1),
            this.emit(k, et))
        }
        sendNode(k, J) {
            const et = this.getCache(k);
            et.push(J),
            this.emit(k, et)
        }
        getCache(k) {
            let J = this.cache.get(k);
            return J || (J = [],
            this.cache.set(k, J)),
            J
        }
    }
    const PortalContext = reactExports.createContext(new PortalManager);
    usePortalContext = function() {
        return reactExports.useContext(PortalContext)
    }
    ,
    usePortalList = function(_) {
        const k = usePortalContext()
          , [J,et] = reactExports.useState([]);
        return reactExports.useEffect(()=>{
            const tt = rt=>{
                et(rt.concat())
            }
            ;
            return tt(k.getCache(_)),
            k.on(_, tt),
            ()=>{
                k.off(_, tt)
            }
        }
        , []),
        J
    }
    ;
    const PortalReceive = React.memo(function _({id: k}) {
        const J = usePortalList(k)
          , et = reactExports.useMemo(()=>J.sort((tt,rt)=>{
            const nt = tt.props.sort || 0;
            return (rt.props.sort || 0) - nt
        }
        ), [J]);
        return reactExports.createElement(reactExports.Fragment, null, ...et)
    })
      , ProtalSend = React.memo(function _({id: k, children: J}) {
        const et = usePortalContext();
        return reactExports.useEffect(()=>(et.sendNode(k, J),
        ()=>et.delNode(k, J)), [J]),
        null
    });
    function PortalBase({id: _, children: k}) {
        return k ? jsxRuntimeExports.jsx(ProtalSend, {
            id: _,
            children: k
        }) : jsxRuntimeExports.jsx(PortalReceive, {
            id: _
        })
    }
    const targetMap = new Map;
    function useCtx(_) {
        return reactExports.useMemo(()=>{
            let k = targetMap.get(_);
            if (!k) {
                const J = {
                    ref: null,
                    sets: new Set,
                    setRef: et=>{
                        J.ref = et,
                        J.sets.forEach(tt=>tt(et))
                    }
                    ,
                    destroy() {
                        J.sets.size == 0 && J.ref === null && targetMap.delete(_)
                    }
                };
                k = J,
                targetMap.set(_, k)
            }
            return k
        }
        , [_])
    }
    function Target(J) {
        var et = J
          , {id: _} = et
          , k = Kt(et, ["id"]);
        const tt = useCtx(_)
          , rt = reactExports.useRef(null);
        return reactExports.useEffect(()=>(tt.setRef(rt.current),
        ()=>{
            tt.setRef(null),
            tt.destroy()
        }
        ), [tt]),
        jsxRuntimeExports.jsx("div", _t($t({
            id: _
        }, k), {
            ref: rt
        }))
    }
    function Source({id: _, children: k}) {
        const J = useCtx(_)
          , [et,tt] = reactExports.useState(J.ref);
        return reactExports.useEffect(()=>(J.sets.add(tt),
        ()=>{
            J.sets.delete(tt),
            J.destroy()
        }
        ), [J]),
        et ? reactDomExports.createPortal(k, et) : null
    }
    Portal = PortalBase,
    Portal.Target = React.memo(Target),
    Portal.Source = React.memo(Source);
    let springPower1, OverlayerContext;
    springPower1 = {
        type: "spring",
        damping: 80,
        stiffness: 900
    },
    Overlayer = React.memo(function(rt) {
        var nt = rt
          , {children: _, visible: k, transparent: J=!1, className: et} = nt
          , tt = Kt(nt, ["children", "visible", "transparent", "className"]);
        const ot = reactExports.useRef(null);
        useDisableBodyScroll(k && ot);
        const it = reactExports.useMemo(()=>J ? [void 0, void 0] : [{
            backgroundColor: "#0000"
        }, {
            backgroundColor: "#000a"
        }], [J]);
        return jsxRuntimeExports.jsx(OverlayerContext.Provider, {
            value: !0,
            children: jsxRuntimeExports.jsx(AnimatePresence, {
                children: k && jsxRuntimeExports.jsxs(motion.div, _t($t({
                    ref: ot,
                    className: cx$1(wrapStyle$2, et)
                }, tt), {
                    animate: it[1],
                    initial: it[0],
                    exit: it[0],
                    transition: springPower1,
                    children: [jsxRuntimeExports.jsx(Portal, {
                        id: "overlayer"
                    }), _]
                }))
            })
        })
    }),
    OverlayerContext = React.createContext(!1),
    useInOverlayer = function() {
        return reactExports.useContext(OverlayerContext)
    }
    ;
    let wrapStyle$2, ScrollViewCom, viewStyle;
    wrapStyle$2 = "wdcb8sn",
    ScrollViewCom = React.forwardRef(function _(ot, nt) {
        var it = ot
          , {children: k, className: J="", bodyLock: et=!1, hideBar: tt=!1} = it
          , rt = Kt(it, ["children", "className", "bodyLock", "hideBar"]);
        const at = reactExports.useRef(null)
          , lt = reactExports.useRef(0)
          , st = useIsActive()
          , ut = useMergeRefs(nt, at)
          , ct = useInOverlayer();
        return useDisableBodyScroll((et || ct) && at),
        useIsomorphicEffect(()=>{
            at.current && (st ? at.current.scrollTop = lt.current : lt.current = at.current.scrollTop)
        }
        , [st]),
        jsxRuntimeExports.jsx(motion.div, _t($t({
            ref: ut,
            className: cx$1("ui-scrollview", tt && " hide-bar", J)
        }, rt), {
            children: k
        }))
    }),
    ScrollView = React.memo(ScrollViewCom),
    ToggleView = React.memo(function _({visible: k=!0, className: J="", minHeight: et=0, children: tt, style: rt}) {
        return jsxRuntimeExports.jsx(motion.div, {
            style: rt,
            initial: {
                height: k ? "auto" : et
            },
            animate: {
                height: k ? "auto" : et
            },
            transition: springPower1,
            className: cx$1(viewStyle, J),
            children: tt
        })
    }),
    viewStyle = "v1qcofba",
    Countdown$1 = React.memo(function _({endTime: k, children: J, onEnd: et}) {
        const [tt,rt] = reactExports.useState(Date.now())
          , nt = reactExports.useRef(k);
        k !== nt.current && rt(Date.now()),
        nt.current = k,
        reactExports.useEffect(()=>{
            if (tt < k) {
                const at = setTimeout(()=>rt(Date.now()), 1e3);
                return ()=>clearTimeout(at)
            } else
                et && et()
        }
        , [tt, k]);
        let ot = (k - tt) / 1e3, it;
        return ot > 0 ? it = {
            days: Math.floor(ot / 86400),
            hours: Math.floor(ot / 3600 % 24),
            minutes: Math.floor(ot / 60 % 60),
            seconds: Math.floor(ot % 60)
        } : it = {
            days: 0,
            hours: 0,
            minutes: 0,
            seconds: 0
        },
        jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: J(it)
        })
    });
    function cx(..._) {
        return _.filter(Boolean).join(" ")
    }
    memoize(_=>murmurhash3_32_gc(_).toString(36));
    function memoize(_, k) {
        if (typeof _ != "function" || k != null && typeof k != "function")
            throw new TypeError(FUNC_ERROR_TEXT);
        var J = function() {
            var et = arguments
              , tt = k ? k.apply(this, et) : et[0]
              , rt = J.cache;
            if (rt.has(tt))
                return rt.get(tt);
            var nt = _.apply(this, et);
            return J.cache = rt.set(tt, nt) || rt,
            nt
        };
        return J.cache = new Map,
        J
    }
    function murmurhash3_32_gc(_, k) {
        var J, et, tt, rt, nt, ot, it, at;
        for (J = _.length & 3,
        et = _.length - J,
        tt = k,
        nt = 3432918353,
        ot = 461845907,
        at = 0; at < et; )
            it = _.charCodeAt(at) & 255 | (_.charCodeAt(++at) & 255) << 8 | (_.charCodeAt(++at) & 255) << 16 | (_.charCodeAt(++at) & 255) << 24,
            ++at,
            it = (it & 65535) * nt + (((it >>> 16) * nt & 65535) << 16) & 4294967295,
            it = it << 15 | it >>> 17,
            it = (it & 65535) * ot + (((it >>> 16) * ot & 65535) << 16) & 4294967295,
            tt ^= it,
            tt = tt << 13 | tt >>> 19,
            rt = (tt & 65535) * 5 + (((tt >>> 16) * 5 & 65535) << 16) & 4294967295,
            tt = (rt & 65535) + 27492 + (((rt >>> 16) + 58964 & 65535) << 16);
        switch (it = 0,
        J) {
        case 3:
            it ^= (_.charCodeAt(at + 2) & 255) << 16;
        case 2:
            it ^= (_.charCodeAt(at + 1) & 255) << 8;
        case 1:
            it ^= _.charCodeAt(at) & 255,
            it = (it & 65535) * nt + (((it >>> 16) * nt & 65535) << 16) & 4294967295,
            it = it << 15 | it >>> 17,
            it = (it & 65535) * ot + (((it >>> 16) * ot & 65535) << 16) & 4294967295,
            tt ^= it
        }
        return tt ^= _.length,
        tt ^= tt >>> 16,
        tt = (tt & 65535) * 2246822507 + (((tt >>> 16) * 2246822507 & 65535) << 16) & 4294967295,
        tt ^= tt >>> 13,
        tt = (tt & 65535) * 3266489909 + (((tt >>> 16) * 3266489909 & 65535) << 16) & 4294967295,
        tt ^= tt >>> 16,
        tt >>> 0
    }
    function CircleCountdownInner({endTime: _, startTime: k, onComplete: J, className: et}) {
        const tt = useAnimationControls()
          , rt = async nt=>tt.start({
            pathLength: 0,
            transition: {
                duration: nt / 1e3,
                ease: "linear"
            }
        });
        return reactExports.useEffect(()=>{
            const nt = _ - k;
            let ot = !1;
            return nt > 0 && (tt.set({
                pathLength: 1
            }),
            rt(nt).then(it=>{
                ot || J && J()
            }
            )),
            ()=>{
                ot = !0
            }
        }
        , [_, k]),
        jsxRuntimeExports.jsx("svg", {
            className: cx(style$2, et),
            viewBox: "25 25 50 50",
            children: jsxRuntimeExports.jsx(motion.circle, {
                animate: tt,
                cx: "50",
                cy: "50",
                r: "20",
                fill: "none",
                strokeWidth: "8",
                strokeLinecap: "round"
            })
        })
    }
    let style$2, textStyle, ButtonFoward;
    CircleCountdown = React.memo(function _({endTime: k, startTime: J=Date.now(), onComplete: et, className: tt}) {
        return jsxRuntimeExports.jsx(CircleCountdownInner, {
            endTime: k,
            startTime: J,
            onComplete: et,
            className: tt
        })
    }),
    style$2 = "s13v8tlr",
    Text = React.memo(function(tt) {
        var rt = tt
          , {children: _, align: k="center", className: J} = rt
          , et = Kt(rt, ["children", "align", "className"]);
        const nt = reactExports.useRef(null);
        return reactExports.useEffect(()=>{
            const ot = nt.current;
            if (ot && ot.parentElement) {
                ot.style.transform = "";
                const it = Math.min(ot.parentElement.clientWidth / ot.clientWidth, 1);
                ot.style.transform = `scale(${it})`
            }
        }
        , [_]),
        jsxRuntimeExports.jsx("div", _t($t({
            className: cx$1(textStyle, J, `${textStyle}-${k}`)
        }, et), {
            children: jsxRuntimeExports.jsx("span", {
                ref: nt,
                children: _
            })
        }))
    }),
    textStyle = "tlqf8r7",
    ButtonFoward = React.forwardRef(function _(st, lt) {
        var ut = st
          , {type: k, loading: J=!1, disabled: et=!1, className: tt="", size: rt="normal", children: nt, loadingNode: ot=jsxRuntimeExports.jsx(Loading$1, {
            stroke: "#fff"
        }), onClick: it} = ut
          , at = Kt(ut, ["type", "loading", "disabled", "className", "size", "children", "loadingNode", "onClick"]);
        const ct = useMountedState()
          , [pt,ft] = reactExports.useState(!1)
          , yt = gt=>{
            if (it) {
                const mt = it(gt);
                if (mt instanceof Promise) {
                    ft(!0);
                    const vt = ()=>{
                        ct() && ft(!1)
                    }
                    ;
                    mt.then(vt, vt)
                }
            }
        }
        ;
        J = J || pt,
        J && (et = J);
        const ht = cx$1("ui-button", `button-${rt}`, k && `s-${k}`, tt, J && "is-loading");
        return jsxRuntimeExports.jsx(motion.button, _t($t({
            className: ht,
            ref: lt,
            disabled: et,
            onClick: yt
        }, at), {
            children: jsxRuntimeExports.jsx("div", {
                className: "button-inner",
                children: J ? ot : nt
            })
        }))
    }),
    Button2 = React.memo(ButtonFoward),
    ButtonGroup = function(J) {
        var et = J
          , {className: _} = et
          , k = Kt(et, ["className"]);
        return jsxRuntimeExports.jsx("div", $t({
            className: cx$1("button-group", _)
        }, k))
    }
    ;
    let style$1, NUM_SCALE;
    Badge = React.memo(function({num: _, className: k=""}) {
        return _ == 0 ? null : jsxRuntimeExports.jsx("div", {
            className: `badge ${style$1} ${k}`,
            children: Math.min(_, 99)
        })
    }),
    style$1 = "s1rp7ii5",
    NUM_SCALE = 1e8,
    AnimatedNumber = React.memo(function _({children: k, className: J, format: et=tt=>String(tt)}) {
        const tt = reactExports.useRef({
            num: 0
        })
          , rt = reactExports.useRef(null);
        return reactExports.useEffect(()=>(gsapWithCSS.to(tt.current, {
            num: k * NUM_SCALE,
            duration: 1,
            onUpdate() {
                rt.current && (rt.current.innerText = et(tt.current.num / NUM_SCALE))
            }
        }),
        ()=>gsapWithCSS.killTweensOf(tt.current)), [k]),
        jsxRuntimeExports.jsx("span", {
            className: J,
            ref: rt
        })
    }),
    WithOutSsr = ({children: _})=>{
        const [k,J] = reactExports.useState(!0);
        return useIsomorphicEffect(()=>J(!1), []),
        k ? null : _
    }
    ,
    Link = React.memo(React.forwardRef(function _(nt, rt) {
        var ot = nt
          , {href: k, onClick: J, replace: et=!1} = ot
          , tt = Kt(ot, ["href", "onClick", "replace"]);
        const {urlOriginal: it, lang: at, Page: lt} = usePageContext()
          , st = useNavigate()
          , ut = reactExports.useMemo(()=>k && getI18nPath(k, at), [k, at])
          , ct = reactExports.useMemo(()=>k && (!lt || k.startsWith("#/") || k.startsWith("/#/") || et) ? wrapLinkClick(pt=>{
            st(k, {
                replace: !0
            }),
            pt.stopPropagation(),
            pt.preventDefault()
        }
        , J) : J, [k, J, et]);
        return jsxRuntimeExports.jsx("a", _t($t({
            ref: rt,
            href: ut || void 0,
            "keep-scroll-position": "true",
            onClick: ct
        }, tt), {
            className: cx(tt.className, it === k && "is-active")
        }))
    }));
    function wrapLinkClick(_, k) {
        return J=>{
            _(J),
            k && k(J)
        }
    }
    let contentWrap, tagReg, tagRegSub;
    Content = React.memo(function _({content: k}) {
        const J = formateContent(k);
        let et;
        if (J.length > 1) {
            const tt = J[0].args[0] || 0
              , rt = J[0].args[1] || "";
            et = jsxRuntimeExports.jsxs("div", {
                className: contentWrap,
                children: [jsxRuntimeExports.jsxs(Link, {
                    href: `#/user/profile/${tt}`,
                    children: ["@", rt]
                }), jsxRuntimeExports.jsx("span", {
                    className: "content-msg",
                    style: {
                        whiteSpace: "pre-line"
                    },
                    children: unescape$2(J[1])
                })]
            })
        } else
            et = jsxRuntimeExports.jsx("span", {
                className: "content-msg",
                style: {
                    whiteSpace: "pre-line"
                },
                children: unescape$2(J[0])
            });
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [et, " "]
        })
    }),
    contentWrap = "cghm3iz",
    tagReg = /(\[\w+=.+?\])/,
    tagRegSub = /(\[(\w+=.+?)\])/,
    formateContent = function(_) {
        let k = [];
        return unescape$2(_).split(tagReg).forEach(J=>{
            if (J === "")
                return;
            let et = J.match(tagRegSub);
            if (et) {
                let[tt,rt] = et[2].split("=")
                  , nt = rt.split(",")
                  , ot = {
                    type: tt,
                    args: nt
                };
                k.push(ot)
            } else
                k.push(J)
        }
        ),
        k
    }
    ;
    const UIContext = React.createContext({
        onError(_) {}
    })
      , UIProvider = UIContext.Provider;
    ErrorBoundary = class extends React.PureComponent {
        static getDerivedStateFromError(_) {
            return {
                error: _
            }
        }
        constructor(_) {
            super(_),
            this.state = {
                error: null
            }
        }
        componentDidUpdate(_, k) {
            _.children !== this.props.children && this.setState({
                error: null
            })
        }
        componentDidCatch(_, k) {
            this.context.onError(_)
        }
        render() {
            return this.state.error ? this.props.errorComponent ? jsxRuntimeExports.jsx(this.props.errorComponent, {
                msg: String(this.state.error)
            }) : jsxRuntimeExports.jsx("div", {
                className: `error ${errorStyle}`,
                children: String(this.state.error)
            }) : this.props.children
        }
    }
    ,
    _e(ErrorBoundary, "contextType", UIContext);
    const errorStyle = "env4u6q";
    Confirm = function(ot) {
        var it = ot
          , {className: _, onConfirm: k, cancelText: J, confirmText: et, hasCancel: tt=!1, children: rt} = it
          , nt = Kt(it, ["className", "onConfirm", "cancelText", "confirmText", "hasCancel", "children"]);
        const {t: at} = useTranslation(instance.options.defaultNS);
        return J = J || at("Cancel"),
        et = et || at("Confirm"),
        jsxRuntimeExports.jsxs("div", _t($t({
            className: cx$1(style, _)
        }, nt), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "message",
                children: rt
            }), jsxRuntimeExports.jsxs("div", {
                className: "btns",
                children: [tt && jsxRuntimeExports.jsx(Button2, {
                    type: "gray",
                    className: "cancle",
                    onClick: ()=>k(!1),
                    children: J
                }), jsxRuntimeExports.jsx(Button2, {
                    type: "conic",
                    className: "light",
                    onClick: ()=>k(!0),
                    children: et
                })]
            })]
        }))
    }
    ;
    const style = "s1qim8vk"
      , {useProxy: useProxy$6, proxy: proxy$6, ref: ref$3} = valtio;
    let ckey$2 = 0, popList;
    popList = proxy$6([]),
    pop = {
        popList,
        push(_, k={
            closeable: !0
        }) {
            return k.closeable === void 0 && (k.closeable = !0),
            new Promise(J=>{
                const et = ref$3({
                    node: _,
                    key: ckey$2++,
                    resolve: J,
                    config: k
                });
                popList.push(et)
            }
            )
        },
        back(_) {
            const k = popList.pop();
            k && k.resolve(_)
        },
        close() {
            popList.forEach(_=>_.resolve(null)),
            popList.splice(0, popList.length)
        },
        confirm(_, k={}) {
            return new Promise(J=>{
                const et = once$1(tt=>{
                    pop.back(),
                    J(tt)
                }
                );
                pop.push(jsxRuntimeExports.jsx(Confirm, _t($t({
                    onConfirm: et,
                    hasCancel: !0
                }, k), {
                    children: _
                })), {
                    closeable: !1
                }).then(()=>et(!1))
            }
            )
        },
        alert(_, k={}) {
            return pop.push(jsxRuntimeExports.jsx(Confirm, _t($t({
                onConfirm: pop.back
            }, k), {
                children: _
            })), {
                closeable: !1
            })
        },
        prompt(_) {
            return new Promise(k=>{
                let J;
                const et = rt=>J = rt
                  , tt = once$1(rt=>{
                    k(rt ? J : null),
                    pop.back()
                }
                );
                pop.push(jsxRuntimeExports.jsx(Confirm, {
                    onConfirm: tt,
                    hasCancel: !0,
                    children: jsxRuntimeExports.jsx(_, {
                        onChange: et
                    })
                }), {
                    closeable: !1
                }).then(()=>tt(!1))
            }
            )
        }
    },
    usePop = function() {
        return pop
    }
    ;
    function usePopList() {
        return useProxy$6(popList)
    }
    let aneFrom, aneFromWithHidden, aneEnter, PopProvider, PopWrap, PopContent, popStyle, useProxy$5, proxy$5, ref$2;
    aneFrom = {
        scale: .5,
        opacity: 0,
        visibility: "visible"
    },
    aneFromWithHidden = _t($t({}, aneFrom), {
        transitionEnd: {
            visibility: "hidden"
        }
    }),
    aneEnter = {
        scale: 1,
        opacity: 1,
        visibility: "visible"
    },
    PopProvider = React.memo(()=>{
        const _ = usePopList().length > 0;
        return jsxRuntimeExports.jsx(Overlayer, {
            className: "ui-pop-overlayer",
            visible: _,
            children: jsxRuntimeExports.jsx(PopWrap, {})
        })
    }
    ),
    PopWrap = React.memo(()=>{
        const _ = usePopList()
          , k = _.slice(-1)[0];
        return jsxRuntimeExports.jsx(AnimatePresence, {
            children: _.map((J,et)=>jsxRuntimeExports.jsx(PopContent, {
                active: J === k,
                children: J
            }, J.key))
        })
    }
    ),
    PopContent = React.memo(({active: _, children: k})=>{
        const J = reactExports.useCallback(et=>{
            et.target === et.currentTarget && k.config.closeable && pop.back()
        }
        , []);
        return jsxRuntimeExports.jsx(ActiveProvider, {
            value: _,
            children: jsxRuntimeExports.jsx(motion.div, {
                className: popStyle,
                animate: _ ? aneEnter : aneFromWithHidden,
                initial: aneFrom,
                exit: aneFrom,
                onClick: J,
                children: jsxRuntimeExports.jsx(ErrorBoundary, {
                    children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                        fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                        children: k.node
                    })
                })
            })
        })
    }
    ),
    Pop = React.memo(({closeable: _, className: k, id: J, title: et, children: tt})=>jsxRuntimeExports.jsxs("div", {
        className: `pop ${k || ""}`,
        id: J || "",
        children: [et && jsxRuntimeExports.jsx("div", {
            className: "pop-title",
            children: et
        }), _ && jsxRuntimeExports.jsx("button", {
            onClick: pop.back,
            className: "pop-close",
            children: jsxRuntimeExports.jsx(Icon, {
                name: "Close"
            })
        }), tt]
    })),
    popStyle = "pfrl3ez",
    {useProxy: useProxy$5, proxy: proxy$5, ref: ref$2} = valtio;
    let ckey$1 = 0;
    const ignoredErrorCodes = [6002, 6005, 6008, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111];
    let notifyList = proxy$5([]);
    const ntf = {
        notifyList,
        push(_, tt={}) {
            var rt = tt
              , {onClose: k, onClick: J} = rt
              , et = Kt(rt, ["onClose", "onClick"]);
            if (!_)
                return;
            if (_ instanceof Error) {
                if (!_.message || _ instanceof HttpResponseError && ignoredErrorCodes.indexOf(_.code) !== -1)
                    return;
                for (let lt of notifyList) {
                    const st = lt.props.message;
                    if (st instanceof Error && st.message === _.message)
                        return
                }
            }
            const nt = ckey$1++
              , ot = {
                props: Object.assign(et, {
                    message: _,
                    onClick: ()=>{
                        ntf.remove(nt),
                        J && J()
                    }
                    ,
                    onClose: ()=>{
                        ntf.remove(nt),
                        k && k()
                    }
                }),
                key: nt
            }
              , it = ref$2(ot)
              , at = getPushFlag(notifyList, it);
            return at >= 0 && notifyList.splice(at, 1),
            notifyList.push(it),
            ot
        },
        remove(_) {
            const k = notifyList.findIndex(J=>J.key === _);
            k !== -1 && notifyList.splice(k, 1)
        }
    };
    function getPushFlag(_, k) {
        let J = -1;
        const et = k.props.className;
        return et && et !== "" ? J = _.findIndex(tt=>!!tt.props.className) : J = _.findIndex(tt=>!tt.props.className || tt.props.className === ""),
        J
    }
    useNotify = function() {
        return ntf
    }
    ;
    function useNotifyList() {
        return useProxy$5(notifyList)
    }
    let supportNotifycation, NotifyProvider, heightAuto, height0, NotifyWrap;
    notify = ntf.push,
    supportNotifycation = "Notification"in globalThis,
    NotifyProvider = React.memo(({value: _=ntf, className: k})=>ReactDOM.createPortal(jsxRuntimeExports.jsx(NotifyWrap, {
        className: k
    }), document.body)),
    heightAuto = {
        height: "auto"
    },
    height0 = {
        height: 0
    },
    NotifyWrap = React.memo(({className: _})=>{
        let k = useNotifyList().concat();
        const J = useIsMobile();
        return J && k.reverse(),
        jsxRuntimeExports.jsx("div", {
            className: cx$1(notifyWrapStyle, _, J && "is-reverse"),
            children: jsxRuntimeExports.jsx(AnimatePresence, {
                children: k.map(et=>jsxRuntimeExports.jsx(motion.div, {
                    animate: heightAuto,
                    initial: height0,
                    exit: height0,
                    className: "notify-item",
                    children: jsxRuntimeExports.jsx(ErrorBoundary, {
                        children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                            fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                            children: jsxRuntimeExports.jsx(Notify, $t({}, et.props))
                        })
                    })
                }, et.key))
            })
        })
    }
    );
    function useShowSystemNotify() {
        const {t: _} = useTranslation(instance.options.defaultNS);
        function k() {
            return new Promise(J=>{
                ntf.push(jsxRuntimeExports.jsxs("div", {
                    className: notifyConfirmStyle,
                    children: [jsxRuntimeExports.jsx("div", {
                        children: _("We'd like to send you notifications for the latest news and updates.")
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "actions",
                        children: [jsxRuntimeExports.jsx("button", {
                            className: "later",
                            children: _("Cancel")
                        }), jsxRuntimeExports.jsx(Button2, {
                            onClick: ()=>J(Notification.requestPermission()),
                            type: "conic",
                            size: "small",
                            children: _("Allow")
                        })]
                    })]
                }), {
                    duration: 0,
                    title: _("Authorization Notifications")
                })
            }
            )
        }
        return async function(J, et) {
            if (Notification.permission === "default" && await k(),
            Notification.permission === "denied")
                throw new Error("No permission!");
            return new Notification(J,et)
        }
    }
    const Notify = React.memo(reactExports.forwardRef(function _({title: k, message: J, duration: et=5e3, icon: tt, onClick: rt, onClose: nt, system: ot=!1, className: it}, at) {
        const lt = reactExports.useRef(null)
          , st = reactExports.useRef(null)
          , ut = useShowSystemNotify();
        J instanceof Error && (J = J.message),
        typeof J == "string" && (J = unescape(J));
        const ct = et > 0;
        return reactExports.useEffect(()=>{
            const pt = lt.current;
            if (supportNotifycation && ot && pt) {
                let ft = pt.innerText, yt, ht;
                typeof tt == "string" && (ht = tt),
                st.current && (yt = ft,
                ft = st.current.innerText),
                ut(ft, {
                    icon: ht,
                    body: yt
                }).then(gt=>{
                    gt.onclick = rt,
                    gt.onclose = nt
                }
                ).catch(()=>{}
                )
            }
        }
        , []),
        jsxRuntimeExports.jsx("div", {
            className: cx$1("notify-ins", it),
            onClick: rt,
            ref: at,
            children: jsxRuntimeExports.jsxs("div", {
                className: "notify-wrap",
                children: [jsxRuntimeExports.jsx(AnimatePresence, {
                    children: ct ? jsxRuntimeExports.jsx(Countdown, {
                        duration: et,
                        onComplete: nt
                    }) : jsxRuntimeExports.jsx("button", {
                        className: "notify-close",
                        onClick: pt=>{
                            pt.stopPropagation(),
                            nt()
                        }
                        ,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: "Close"
                        })
                    })
                }), tt && jsxRuntimeExports.jsx("div", {
                    className: `notify-icon${k ? "" : " is-small"}`,
                    children: typeof tt == "string" ? jsxRuntimeExports.jsx("img", {
                        className: "notify-icon-img",
                        src: tt
                    }) : tt
                }), jsxRuntimeExports.jsxs("div", {
                    className: "notify-content",
                    children: [k && jsxRuntimeExports.jsx("div", {
                        ref: st,
                        className: "notify-title",
                        children: k
                    }), jsxRuntimeExports.jsx("div", {
                        ref: lt,
                        className: "notify-message",
                        children: J
                    })]
                })]
            })
        })
    }));
    function Countdown({duration: _, onComplete: k}) {
        return useIsomorphicEffect(()=>{
            setTimeout(k, _ + 150)
        }
        , [_]),
        jsxRuntimeExports.jsx("button", {
            className: "notify-close",
            onClick: J=>{
                J.stopPropagation(),
                k()
            }
            ,
            children: jsxRuntimeExports.jsx(Icon, {
                name: "Close"
            })
        })
    }
    let notifyWrapStyle, notifyConfirmStyle, iconStyle, useProxy$4, proxy$4, ref$1;
    notifyWrapStyle = "nfnfs0b",
    notifyConfirmStyle = "n1n0wcth",
    CloseIcon = React.memo(function _({className: k, onClick: J}) {
        return jsxRuntimeExports.jsx("button", {
            className: cx$1("close-icon", iconStyle, k),
            onClick: ()=>{
                J && J()
            }
            ,
            children: jsxRuntimeExports.jsx(Icon, {
                name: "Close"
            })
        })
    }),
    iconStyle = "i1gm0mn8",
    {useProxy: useProxy$4, proxy: proxy$4, ref: ref$1} = valtio;
    let ckey = 0;
    const keyMap = new WeakMap
      , dialogList = proxy$4([]);
    function getKey(_) {
        if (typeof _ == "string")
            return Date.now();
        {
            let k = keyMap.get(_);
            return k !== void 0 ? k : (ckey++,
            keyMap.set(_, ckey),
            ckey)
        }
    }
    dialog = {
        dialogList,
        push(_, k={}) {
            let J = dialogList.findIndex(tt=>tt.modal.type == _.type), et;
            if (J != -1) {
                const tt = dialogList.splice(J, 1)[0];
                Object.assign(tt.config, k),
                et = _t($t({}, tt), {
                    modal: _
                })
            } else
                et = {
                    modal: _,
                    config: k,
                    key: getKey(_.type)
                };
            dialogList.push(ref$1(et))
        },
        back(_) {
            dialogList.length != 0 && dialogList.pop()
        },
        close() {
            dialogList.length !== 0 && dialogList.splice(0, dialogList.length)
        },
        replace(_, k={}) {
            let J = dialogList.findIndex(tt=>tt.modal.type == _.type), et;
            if (J != -1) {
                J !== dialogList.length - 1 && dialogList.pop();
                const tt = dialogList.splice(J, 1)[0];
                Object.assign(tt.config, k),
                et = _t($t({}, tt), {
                    modal: _
                })
            } else
                dialogList.pop(),
                et = {
                    modal: _,
                    config: k,
                    key: getKey(_.type)
                };
            dialogList.push(ref$1(et))
        }
    };
    function useDialogList() {
        return useProxy$4(dialogList)
    }
    const DialogProvider = React.memo(()=>{
        const _ = useDialogList().length > 0
          , k = useIsMobile()
          , J = useForceUpdate()
          , et = reactExports.useRef({
            width: 200,
            height: 200
        }).current
          , {width: tt, height: rt} = et
          , nt = reactExports.useCallback(lt=>{
            (et.width !== lt.width || et.height !== lt.height) && (Object.assign(et, lt),
            J())
        }
        , [])
          , ot = reactExports.useMemo(()=>k ? [{
            x: 0
        }, {
            x: "100%"
        }] : [{
            scale: 1,
            opacity: 1
        }, {
            scale: .8,
            opacity: 0
        }], [k])
          , it = reactExports.useMemo(()=>{
            if (!k)
                return {
                    width: tt,
                    height: rt,
                    marginTop: -rt / 2,
                    marginLeft: -tt / 2
                }
        }
        , [k, tt, rt])
          , at = reactExports.useCallback(lt=>{
            lt.target === lt.currentTarget && dialog.back()
        }
        , []);
        return jsxRuntimeExports.jsx(Overlayer, {
            className: "ui-dialog-overlayer",
            visible: _,
            transparent: k,
            onClick: at,
            children: jsxRuntimeExports.jsx(DialogWrapSizeContext.Provider, {
                value: nt,
                children: jsxRuntimeExports.jsx(motion.div, {
                    style: it,
                    animate: ot[0],
                    initial: ot[1],
                    exit: ot[1],
                    transition: springPower1,
                    className: cx$1("ui-dialog-wrap", et.parentClassName),
                    children: jsxRuntimeExports.jsx(DialogList, {})
                })
            })
        })
    }
    )
      , DialogHead = React.memo(_=>{
        const k = useDialog()
          , J = reactExports.useContext(IndexContext)
          , {title: et="", back: tt=J > 0, closeable: rt} = _
          , nt = reactExports.useCallback(()=>k.back(), []);
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [tt && jsxRuntimeExports.jsx("button", {
                onClick: nt,
                className: "dialog-back",
                children: jsxRuntimeExports.jsx(Icon, {
                    name: "Arrow"
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: cx$1("dialog-head", tt && "has-back", rt && "has-close"),
                children: [et !== "" && jsxRuntimeExports.jsx("div", {
                    className: "dialog-title",
                    children: et
                }, et), _.children]
            })]
        })
    }
    )
      , DialogList = React.memo(()=>{
        const _ = useDialogList().concat()
          , k = reactExports.useRef(_)
          , J = _.length == 0 ? k.current : _;
        return k.current = _,
        jsxRuntimeExports.jsx(AnimatePresence, {
            children: J.map((et,tt)=>jsxRuntimeExports.jsx(ActiveProvider, {
                value: tt === J.length - 1,
                children: jsxRuntimeExports.jsx(IndexContext.Provider, {
                    value: tt,
                    children: jsxRuntimeExports.jsx(ErrorBoundary, {
                        errorComponent: ErrorView,
                        children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                            fallback: jsxRuntimeExports.jsx(Dialog, {
                                className: "ui-dialog-loading",
                                closeable: !1,
                                children: jsxRuntimeExports.jsx(Loading$1, {})
                            }),
                            children: et.modal
                        })
                    })
                })
            }, et.key))
        })
    }
    )
      , DialogWrapSizeContext = React.createContext(null)
      , IndexContext = React.createContext(0)
      , DialogInjectContext = React.createContext(null);
    function useInFirstDialog() {
        return !!reactExports.useContext(DialogWrapSizeContext) && !reactExports.useContext(DialogInjectContext)
    }
    let ErrorView, initial, animate, animateUnActive, exit;
    ErrorView = React.memo(({msg: _})=>jsxRuntimeExports.jsx(Dialog, {
        title: "Error",
        children: jsxRuntimeExports.jsx(Empty, {
            type: "offline",
            children: _
        })
    })),
    DialogHeader = React.memo(function _({children: k}) {
        const J = useIsActive()
          , et = reactExports.useContext(DialogInjectContext);
        return useIsomorphicEffect(()=>{
            if (J && et)
                return et(k),
                ()=>{
                    et(null)
                }
        }
        , [J, k]),
        null
    }),
    initial = {
        x: "100%",
        visibility: "visible"
    },
    animate = {
        x: "0%",
        scale: 1,
        opacity: 1,
        visibility: "visible",
        transitionEnd: {
            visibility: "visible"
        }
    },
    animateUnActive = {
        x: "-10%",
        transitionEnd: {
            visibility: "hidden"
        }
    },
    exit = {
        x: "100%",
        visibility: "visible"
    },
    Dialog = React.memo(({children: _, className: k, title: J, back: et, closeable: tt=!0, parentClassName: rt, headChildren: nt, elRef: ot})=>{
        const it = useIsActive()
          , at = reactExports.useRef(it)
          , lt = useIsMobile()
          , st = reactExports.useContext(IndexContext);
        at.current = it;
        const ut = reactExports.useContext(DialogWrapSizeContext)
          , [ct,pt] = reactExports.useState(null)
          , ft = reactExports.useRef(null)
          , yt = useMergeRefs(ot, ft)
          , ht = reactExports.useCallback(()=>{
            const mt = at.current
              , vt = ft.current;
            if (mt && vt) {
                const {clientWidth: bt, clientHeight: Et} = vt;
                ut({
                    width: bt,
                    height: Et,
                    parentClassName: rt
                })
            }
        }
        , [rt]);
        useIsomorphicEffect(ht),
        useIsomorphicEffect(()=>{
            const mt = throttle$1(ht, 200);
            return window.addEventListener("resize", mt),
            ()=>window.removeEventListener("resize", mt)
        }
        , [rt]);
        const gt = reactExports.useMemo(()=>!lt && st === 0 ? [animate, animate] : [initial, animate], [lt, st]);
        return jsxRuntimeExports.jsx(DialogInjectContext.Provider, {
            value: pt,
            children: jsxRuntimeExports.jsxs(motion.div, {
                ref: yt,
                className: cx$1("ui-dialog", k),
                initial: gt[0],
                animate: it ? gt[1] : animateUnActive,
                exit,
                transition: springPower1,
                children: [J && jsxRuntimeExports.jsx(DialogHead, {
                    title: J,
                    back: et,
                    closeable: tt,
                    children: ct || nt
                }), tt && jsxRuntimeExports.jsx(CloseIcon, {
                    className: "dialog-close",
                    onClick: dialog.close
                }), jsxRuntimeExports.jsx(reactExports.Suspense, {
                    fallback: jsxRuntimeExports.jsx(Loading$1, {}),
                    children: _
                })]
            })
        })
    }
    ),
    useDialog = ()=>dialog;
    function useHashRouter() {
        const [_] = reactExports.useState(()=>{
            const k = parseDefaultHooks(app.dialogNodes)
              , J = createHashRouter([{
                element: jsxRuntimeExports.jsx(Layout, {}),
                children: [...k.map(et=>{
                    var tt;
                    return et.path = (tt = et.path) == null ? void 0 : tt.replace(/^#/, ""),
                    et
                }
                ), {
                    path: "*",
                    element: null
                }]
            }]);
            return unsafeRouter = J,
            J
        }
        );
        return _
    }
    let unsafeRouter = null;
    const unsafeHashNavigate = _=>{
        unsafeRouter == null || unsafeRouter.navigate(_, {
            replace: !0
        })
    }
    ;
    function Layout() {
        return jsxRuntimeExports.jsxs(ErrorBoundary, {
            errorComponent: ()=>"HashRouter error!",
            children: [jsxRuntimeExports.jsx(DialogProvider, {}), jsxRuntimeExports.jsx(AutoClear, {}), jsxRuntimeExports.jsx(Outlet, {})]
        })
    }
    function AutoClear() {
        const _ = useDialogList().length
          , k = reactExports.useRef(_);
        return reactExports.useEffect(()=>{
            _ === 0 && k.current !== 0 && (unsafeRouter == null || unsafeRouter.navigate("/"),
            history.replaceState({}, "", location.href.replace(/#.*/, ""))),
            k.current = _
        }
        , [_]),
        null
    }
    const createDialogType = memoize$1(_=>function({children: k}) {
        return k
    }
    )
      , DialogPopHook = React.memo(function _({children: k}) {
        const J = useDialog()
          , et = reactExports.useContext(RouteContext)
          , tt = createDialogType(k.type)
          , rt = jsxRuntimeExports.jsx(tt, {
            children: jsxRuntimeExports.jsx(RouteContext.Provider, {
                value: et,
                children: k
            })
        });
        return reactExports.useEffect(()=>{
            J.push(rt)
        }
        ),
        null
    })
      , AuthHook = React.memo(({children: _, isAuth: k})=>{
        const J = useNavigate()
          , {login: et} = useAccount()
          , tt = k && !et;
        return reactExports.useEffect(()=>{
            tt && J("#/login")
        }
        , [tt]),
        tt ? null : _
    }
    );
    function parseDefaultHooks(_) {
        return _.map(k=>(k.path = k.path.replace(/^#/, ""),
        k.isDialog && (k.isHook = !0,
        k.element = jsxRuntimeExports.jsx(DialogPopHook, {
            children: k.element
        })),
        typeof k.isAuth == "boolean" && (k.element = jsxRuntimeExports.jsx(AuthHook, {
            isAuth: k.isAuth,
            children: k.element
        })),
        k.element = jsxRuntimeExports.jsx(reactExports.Suspense, {
            fallback: null,
            children: k.element
        }),
        k))
    }
    AppProvider = function({children: _, pageContext: k, onError: J}) {
        const et = reactExports.useRef(k);
        et.current = k,
        app.unsafeNavigate = reactExports.useCallback((rt,nt)=>{
            const ot = et.current
              , {lang: it=ot.lang, replace: at=!1} = nt || {};
            rt.startsWith("#") || (it !== ot.lang || rt !== ot.urlOriginal) && app.history_navigate(getI18nPath(rt, it), {
                replace: at,
                lang: it
            });
            const lt = rt.split("#")[1];
            lt && unsafeHashNavigate(lt)
        }
        , []);
        const tt = reactExports.useMemo(()=>({
            onError: J || (()=>{}
            )
        }), [J]);
        return useMobileResize(k),
        onPageContextChange(k),
        jsxRuntimeExports.jsx(Context.Provider, {
            value: k,
            children: jsxRuntimeExports.jsxs(UIProvider, {
                value: tt,
                children: [jsxRuntimeExports.jsx(SyncI18n, {}), jsxRuntimeExports.jsxs(WithOutSsr, {
                    children: [jsxRuntimeExports.jsx(PopProvider, {}), jsxRuntimeExports.jsx(NotifyProvider, {}), jsxRuntimeExports.jsx(RootNodes, {}), jsxRuntimeExports.jsx(HashRouterProvider, {})]
                }), _]
            })
        })
    }
    ;
    function useDarkenSync() {
        const _ = useIsDarken();
        reactExports.useEffect(()=>{
            _ ? (localStorage.removeItem("isBrighten"),
            document.body.classList.add("darken", "dark")) : (localStorage.setItem("isBrighten", "true"),
            document.body.classList.remove("darken", "dark"))
        }
        , [_])
    }
    function useMobileResize(_) {
        const k = isSSR && _.mobile ? 1 / 0 : env.MAX_DESIGN_WIDTH
          , J = useGlobalState()
          , et = ()=>globalThis.innerWidth <= k
          , tt = et();
        useIsomorphicEffect(()=>{
            const rt = throttle$1(()=>J.mobile = et(), 500, {
                leading: !0
            });
            return globalThis.addEventListener("resize", rt),
            ()=>{
                globalThis.removeEventListener("resize", rt)
            }
        }
        , [k]),
        J.mobile !== tt && (J.mobile = tt)
    }
    const RootNodes = React.memo(function _() {
        const k = reactExports.useMemo(()=>{
            const J = app.rootNodes.map(et=>jsxRuntimeExports.jsx(ErrorBoundary, {
                errorComponent: RootErrorCom,
                children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                    fallback: null,
                    children: et
                })
            }));
            return React.createElement(reactExports.Fragment, {}, ...J)
        }
        , []);
        return useDarkenSync(),
        k
    });
    function RootErrorCom({msg: _}) {
        return null
    }
    const HashRouterProvider = React.memo(function _() {
        const k = useHashRouter();
        return app.hashRouter = k,
        jsxRuntimeExports.jsx(RouterProvider, {
            router: k
        })
    });
    function calibrationXY(_, k, J, et, tt) {
        const rt = k - tt[1];
        let nt = _ > J ? J : _ < 0 ? 0 : _
          , ot = rt > et ? et : rt < 0 ? 0 : rt;
        return nt + tt[0] > J && (nt = J - tt[0]),
        ot + tt[1] > et && (ot = et - tt[1]),
        {
            x: nt,
            y: ot
        }
    }
    let getBounds, wrapStyle$1;
    getBounds = (_,k,J,et,tt)=>({
        left: -_,
        right: J - _ - tt[0],
        top: -k,
        bottom: et - k - tt[1]
    }),
    DragDialog = React.memo(function({visible: _, children: k, title: J, onClose: et, className: tt="", x: rt=0, y: nt=0}) {
        const {width: ot, height: it} = useWindowSize()
          , at = reactExports.useRef(null)
          , [lt,st] = reactExports.useState([0, 0])
          , ut = useAnimation()
          , ct = useDragControls();
        if (reactExports.useEffect(()=>{
            const yt = at.current;
            !_ || !yt || st([yt.clientWidth, yt.clientHeight])
        }
        , [_]),
        !_)
            return null;
        const pt = calibrationXY(rt, nt, ot, it, lt)
          , ft = getBounds(pt.x, pt.y, ot, it, lt);
        return ReactDOM.createPortal(jsxRuntimeExports.jsxs(motion.div, {
            ref: at,
            className: cx$1("dragpop", wrapStyle$1, tt),
            style: {
                left: pt.x,
                top: pt.y
            },
            animate: ut,
            drag: !0,
            dragMomentum: !1,
            dragConstraints: ft,
            dragControls: ct,
            dragListener: !1,
            children: [jsxRuntimeExports.jsx("div", {
                className: "dragpop-title",
                onPointerDown: yt=>{
                    ct.start(yt)
                }
                ,
                children: J
            }), et && jsxRuntimeExports.jsx("button", {
                className: "dragpop-close hover",
                onClick: et,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: "Close"
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "dragpop-content",
                children: jsxRuntimeExports.jsx(ErrorBoundary, {
                    children: k
                })
            })]
        }), document.body)
    }),
    wrapStyle$1 = "wx5m421";
    function defaultChildren({active: _, option: k}) {
        return jsxRuntimeExports.jsxs("div", {
            className: `radio-item${_ ? " is-active" : ""}`,
            children: [jsxRuntimeExports.jsx("div", {
                className: "circle"
            }), jsxRuntimeExports.jsx("div", {
                children: k.label
            })]
        })
    }
    RadioBase = React.memo(function _({value: k, options: J, onChange: et, disabled: tt, children: rt=defaultChildren}) {
        const nt = ot=>{
            !tt && ot != k && et(ot)
        }
        ;
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: J.map((ot,it)=>React.cloneElement(rt({
                option: ot,
                active: ot.value == k
            }), {
                key: it,
                onClick: ()=>nt(ot.value)
            }))
        })
    }),
    Radio = React.memo(function _(tt) {
        var rt = tt
          , {disabled: k, className: J=""} = rt
          , et = Kt(rt, ["disabled", "className"]);
        return jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-radio", J, k && "is-disabled"),
            children: jsxRuntimeExports.jsx(RadioBase, _t($t({}, et), {
                disabled: k
            }))
        })
    });
    function Tabs(J) {
        var et = J
          , {type: _="circle"} = et
          , k = Kt(et, ["type"]);
        return _ === "circle" ? jsxRuntimeExports.jsx(TabStyle1, $t({}, k)) : _ === "line" ? jsxRuntimeExports.jsx(TabStyle2, $t({}, k)) : jsxRuntimeExports.jsx(NoStyle, $t({}, k))
    }
    function TabStyle1(ot) {
        var it = ot
          , {className: _, tabs: k, value: J, onChange: et, children: tt, disabled: rt=!1} = it
          , nt = Kt(it, ["className", "tabs", "value", "onChange", "children", "disabled"]);
        const at = k[J].value
          , lt = useIsFirstRender();
        return jsxRuntimeExports.jsxs("div", _t($t({
            className: cx$1("ui-tabs", "tabs-circle", _)
        }, nt), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "tabs-scroll",
                children: jsxRuntimeExports.jsx("div", {
                    className: "tabs-navs",
                    children: k.map((st,ut)=>jsxRuntimeExports.jsx("button", {
                        className: cx$1("tabs-nav", ut === J && "is-active", st.disabled && "tabs-nav-disabled"),
                        onClick: !rt && !st.disabled ? ()=>et(ut) : void 0,
                        children: st.label
                    }, ut))
                })
            }), at && jsxRuntimeExports.jsx(TabView, {
                component: at,
                immediate: lt
            }, J), tt]
        }))
    }
    function TabStyle2(ot) {
        var it = ot
          , {className: _, tabs: k, value: J, onChange: et, children: tt, disabled: rt=!1} = it
          , nt = Kt(it, ["className", "tabs", "value", "onChange", "children", "disabled"]);
        const at = k[J].value
          , lt = useIsFirstRender();
        return jsxRuntimeExports.jsxs("div", _t($t({
            className: cx$1("ui-tabs", "tabs-line", _)
        }, nt), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "tabs-navs",
                children: k.map((st,ut)=>jsxRuntimeExports.jsx("button", {
                    className: `tabs-nav${ut === J ? " is-active" : ""}`,
                    onClick: rt ? void 0 : ()=>et(ut),
                    children: st.label
                }, ut))
            }), at && jsxRuntimeExports.jsx(TabView, {
                component: at,
                immediate: lt
            }, J), tt]
        }))
    }
    function NoStyle(J) {
        var et = J
          , {className: _} = et
          , k = Kt(et, ["className"]);
        return null
    }
    function TabView({component: _, immediate: k=!1}) {
        const J = _;
        return jsxRuntimeExports.jsx(motion.div, {
            animate: springConfig$1.to,
            initial: k ? springConfig$1.to : springConfig$1.from,
            transition: springPower1,
            className: "tabs-view",
            children: jsxRuntimeExports.jsx(J, {})
        })
    }
    let springConfig$1;
    springConfig$1 = {
        from: {
            y: 30
        },
        to: {
            y: 0
        }
    },
    Tabs$1 = React.memo(Tabs);
    function Switch({value: _, onChange: k, className: J="", type: et}) {
        return et === "checkbox" ? jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-checkbox", J),
            onClick: ()=>k && k(!_),
            children: _ && jsxRuntimeExports.jsx(Icon, {
                name: "Check",
                className: "dot"
            })
        }) : jsxRuntimeExports.jsx("div", {
            className: cx$1("ui-switch", _ && "open", J),
            onClick: ()=>k && k(!_),
            children: jsxRuntimeExports.jsx("div", {
                className: "dot"
            })
        })
    }
    Switch$1 = React.memo(Switch),
    Input = function(_) {
        const k = reactExports.useRef(null)
          , wt = _
          , {label: J, after: et, onChange: tt, validates: rt, className: nt, type: ot="text", size: it, children: at, focus: lt, bold: st, onFocus: ut, onBlur: ct, onKeyUp: pt, onEnter: ft} = wt
          , yt = Kt(wt, ["label", "after", "onChange", "validates", "className", "type", "size", "children", "focus", "bold", "onFocus", "onBlur", "onKeyUp", "onEnter"])
          , [ht,gt] = reactExports.useState(!1)
          , mt = reactExports.useCallback(St=>{
            tt && tt(St.target.value)
        }
        , [tt]);
        reactExports.useEffect(()=>{
            lt && setTimeout(()=>{
                var St;
                (St = k.current) == null || St.focus()
            }
            , 300)
        }
        , []);
        const vt = reactExports.useMemo(()=>{
            if (rt)
                for (let St of rt) {
                    const Pt = St(String(_.value));
                    if (Pt)
                        return Pt
                }
            else
                return !1
        }
        , [_.value, rt])
          , bt = reactExports.useCallback(St=>{
            gt(!1),
            ct && ct(St)
        }
        , [ct])
          , Et = reactExports.useCallback(St=>{
            gt(!_.readOnly),
            ut && ut(St)
        }
        , [ct, _.readOnly])
          , xt = reactExports.useCallback(St=>{
            ft && St.key === "Enter" && ft(),
            pt && pt(St)
        }
        , [ft]);
        return jsxRuntimeExports.jsx(InputWrap, {
            className: classList(nt, !!vt && "is-error"),
            label: J,
            size: it,
            disabled: _.disabled,
            after: et,
            bold: st,
            children: jsxRuntimeExports.jsxs("div", {
                className: classList("input-control", ht && "is-focus"),
                children: [jsxRuntimeExports.jsx("input", $t({
                    type: ot,
                    ref: k,
                    onChange: mt,
                    onFocus: Et,
                    onBlur: bt,
                    onKeyUp: ft || pt ? xt : void 0
                }, yt)), at, vt && jsxRuntimeExports.jsx("div", {
                    className: "input-validate",
                    children: vt
                })]
            })
        })
    }
    ,
    InputWrap = React.memo(function _({size: k, disabled: J, className: et, label: tt, after: rt, children: nt, bold: ot}) {
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-input", k, et, J && "is-disabled", ot && "is-bold"),
            children: [tt && jsxRuntimeExports.jsx("div", {
                className: "input-label",
                children: tt
            }), nt, rt && jsxRuntimeExports.jsx("div", {
                className: "input-after",
                children: rt
            })]
        })
    }),
    InputNumber = React.memo(function _(k) {
        let ht = k
          , {value: J, onChange: et, min: tt=-1 / 0, max: rt=1 / 0, precision: nt, isInt: ot=nt == 0, formatter: it} = ht
          , at = Kt(ht, ["value", "onChange", "min", "max", "precision", "isInt", "formatter"]);
        rt = Math.max(tt, rt);
        const lt = reactExports.useCallback(gt=>it ? it(gt) : precisional(gt, nt), [it, nt])
          , [st,ut] = reactExports.useState(()=>lt(J));
        useIsomorphicEffect(()=>ct(J), [J, tt, rt]);
        const ct = gt=>{
            gt < tt ? gt = tt : gt > rt && (gt = rt),
            ut(lt(J)),
            gt !== J && et(gt)
        }
          , pt = gt=>{
            let mt = parseFloat(st);
            isNaN(mt) && (mt = J),
            ct(mt),
            at.onBlur && at.onBlur(gt)
        }
          , ft = gt=>{
            !k.disabled && !k.readOnly && (st === "0" || st === "\u221E") && ut(""),
            at.onFocus && at.onFocus(gt)
        }
          , yt = reactExports.useCallback(gt=>{
            gt !== "" && !(ot ? /^-?(?:\d+)$/ : /^-?(?:\d+)?(\.)?(\d+)*$/).test(gt) || ut(gt)
        }
        , []);
        return jsxRuntimeExports.jsx(Input, _t($t({}, at), {
            value: st,
            onChange: yt,
            onFocus: ft,
            onBlur: pt
        }))
    });
    function precisional(_, k) {
        const J = new Decimal$1(_);
        let et = "";
        return J.lt(1e-6) ? et = k ? J.toFixed(k) : J.toString() : et = k ? J.todp(k).toNumber() + "" : J.toNumber() + "",
        et
    }
    let passwordStyle;
    InputPassword = reactExports.memo(function _(tt) {
        var rt = tt
          , {autoSee: k=!1, className: J} = rt
          , et = Kt(rt, ["autoSee", "className"]);
        const [nt,ot] = reactExports.useState(k || !1);
        return jsxRuntimeExports.jsx(Input, _t($t({
            className: cx$1(passwordStyle, J),
            type: nt ? "text" : "password",
            autoComplete: "off"
        }, et), {
            children: jsxRuntimeExports.jsx(Icon, {
                onClick: ()=>ot(!nt),
                name: nt ? "Hide" : "View"
            })
        }))
    }),
    passwordStyle = "pjkqlcx",
    Slider = reactExports.memo(function _({min: k=0, max: J=100, value: et, step: tt=0, vertical: rt=!1, onChange: nt, className: ot="", noDebounce: it=!1, onDragValue: at}) {
        const [lt,st] = reactExports.useState(void 0)
          , ut = reactExports.useRef(null)
          , ct = reactExports.useRef(et)
          , pt = reactExports.useRef({
            x: 0,
            y: 0
        })
          , ft = reactExports.useRef([])
          , yt = reactExports.useMemo(()=>debounce(wt=>{
            st(void 0),
            nt && nt(wt)
        }
        , 200), [nt])
          , ht = reactExports.useCallback(wt=>{
            it ? nt && nt(wt) : (st(wt),
            yt(wt)),
            at && at(wt)
        }
        , [nt, yt, at, it])
          , gt = reactExports.useCallback(wt=>{
            if (wt.target.tagName.toLowerCase() == "button")
                return;
            const [St,Pt,Rt,At,Nt,Ot,It,Mt] = calcDivPosition(ut.current)
              , {clientX: Wt, clientY: jt} = wt;
            let Bt = rt ? 1 - (jt - Pt - Nt) / (At - Nt - It) : (Wt - St - Mt) / (Rt - Mt - Ot);
            Bt = Bt < 0 ? 0 : Bt > 1 ? 1 : Bt;
            const Ut = k + Bt * (J - k);
            ht(formatValueWithStep(Ut, tt, J))
        }
        , [rt, k, J, tt, ht])
          , mt = reactExports.useCallback(()=>{
            ct.current = et,
            ft.current = calcDivPosition(ut.current)
        }
        , [et])
          , vt = reactExports.useCallback((wt,St)=>{
            const {x: Pt, y: Rt} = St.offset;
            if (Pt === pt.current.x && Rt === pt.current.y)
                return;
            pt.current = St.offset;
            const [,,At,Nt,Ot,It,Mt,Wt] = ft.current;
            let jt = rt ? -Rt / (Nt - Ot - Mt) : Pt / (At - Wt - It)
              , Bt = ct.current + jt * (J - k);
            Bt >= J ? Bt = J : Bt <= k && (Bt = k),
            ht(formatValueWithStep(Bt, tt, J))
        }
        , [rt, J, k, tt])
          , bt = reactExports.useMemo(()=>{
            const wt = ((lt === void 0 ? et : lt) - k) / (J - k);
            return wt < 0 ? 0 : wt > 1 ? 1 : wt
        }
        , [it, et, lt, J, k])
          , [Et,xt] = reactExports.useMemo(()=>rt ? ["scaleY", "translateY"] : ["scaleX", "translateX"], [rt]);
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-slider", rt && "slider-vertical", ot),
            ref: ut,
            onClick: gt,
            children: [jsxRuntimeExports.jsx("div", {
                style: {
                    transform: `${Et}(${bt})`
                },
                className: "slider-after"
            }), jsxRuntimeExports.jsx("div", {
                style: {
                    transform: `${xt}(${(rt ? 1 - bt : bt) * 100}%)`
                },
                className: "slider-handler-wrap",
                children: jsxRuntimeExports.jsx(motion.button, {
                    className: "slider-handler",
                    drag: rt ? "y" : "x",
                    dragMomentum: !1,
                    dragConstraints: ut,
                    dragDirectionLock: !0,
                    dragElastic: 0,
                    animate: !1,
                    onDragStart: mt,
                    onDrag: vt
                })
            }), jsxRuntimeExports.jsx("div", {
                className: "slider-before"
            })]
        })
    });
    function formatValueWithStep(_, k, J) {
        if (k === 0)
            return _;
        let et = new Decimal$1(_).sub(new Decimal$1(_).modulo(k)).toNumber();
        return new Decimal$1(_).modulo(k).div(k).gte(.5) && (et += k),
        et > J ? J : et
    }
    function calcDivPosition(_) {
        const {clientWidth: k, clientHeight: J} = _
          , {x: et, y: tt} = _.getBoundingClientRect()
          , rt = getComputedStyle(_)
          , nt = parseInt(rt.paddingLeft)
          , ot = parseInt(rt.paddingRight)
          , it = parseInt(rt.paddingTop)
          , at = parseInt(rt.paddingBottom);
        return [et, tt, k, J, it, ot, at, nt]
    }
    let MaxHeightTextarea, textareaStyle, springConfig;
    Textarea = React.memo(React.forwardRef(function _(pt, ct) {
        var ft = pt
          , {className: k, label: J, size: et, disabled: tt, after: rt, children: nt, maxHeight: ot, onChange: it, focus: at, onBlur: lt, onFocus: st} = ft
          , ut = Kt(ft, ["className", "label", "size", "disabled", "after", "children", "maxHeight", "onChange", "focus", "onBlur", "onFocus"]);
        const [yt,ht] = reactExports.useState(!1)
          , gt = reactExports.useRef(null)
          , mt = reactExports.useCallback(Et=>{
            it && it(Et.target.value)
        }
        , [it]);
        reactExports.useEffect(()=>{
            if (at && setTimeout(()=>{
                var Et;
                (Et = gt.current) == null || Et.focus()
            }
            , 300),
            ct)
                return typeof ct == "function" ? (ct(gt.current),
                ()=>ct(null)) : (ct.current = gt.current,
                ()=>ct.current = null)
        }
        , []);
        const vt = reactExports.useCallback(Et=>{
            ht(!1),
            lt && lt(Et)
        }
        , [lt])
          , bt = reactExports.useCallback(Et=>{
            ht(!ut.readOnly),
            st && st(Et)
        }
        , [lt, ut.readOnly]);
        return jsxRuntimeExports.jsx(InputWrap, {
            className: cx$1(textareaStyle, k),
            label: J,
            size: et,
            disabled: tt,
            after: rt,
            children: jsxRuntimeExports.jsxs("div", {
                className: classList("input-control", yt && "is-focus"),
                children: [ot === void 0 ? jsxRuntimeExports.jsx("textarea", $t({
                    ref: gt,
                    onChange: mt,
                    onBlur: vt,
                    onFocus: bt
                }, ut)) : jsxRuntimeExports.jsx(MaxHeightTextarea, $t({
                    ref: gt,
                    onChange: mt,
                    maxHeight: ot,
                    onBlur: vt,
                    onFocus: bt
                }, ut)), nt]
            })
        })
    })),
    MaxHeightTextarea = React.memo(React.forwardRef(function _(k, J) {
        const ot = k
          , {maxHeight: et} = ot
          , tt = Kt(ot, ["maxHeight"])
          , rt = reactExports.useRef(null)
          , nt = reactExports.useCallback(it=>{
            rt.current = it,
            J && (typeof J == "function" ? J(it) : J.current = it)
        }
        , []);
        return useIsomorphicEffect(()=>{
            const it = rt.current;
            et && (it.style.height = "",
            it.style.height = Math.min(it.scrollHeight, et) + "px")
        }
        , [tt.value]),
        jsxRuntimeExports.jsx("textarea", $t({
            ref: nt
        }, tt))
    })),
    textareaStyle = "tpnb05b",
    springConfig = {
        from: {
            y: -10,
            opacity: 0
        },
        enter: {
            y: 0,
            opacity: 1
        }
    };
    function Select(_) {
        const {value: k, options: J, onChange: et, disabled: tt, top: rt=!1, className: nt, popNode: ot, filter: it, searchNoResult: at, disableHover: lt=!0, renderLabel: st=defaultLabel, renderOption: ut=defaultOption, getKey: ct} = _
          , [pt,ft] = reactExports.useState("")
          , yt = it ? J.filter(St=>it(St, pt)) : J
          , ht = J.find(St=>St.value == k)
          , gt = useIsMobile()
          , [mt,vt] = reactExports.useState(!1)
          , bt = reactExports.useRef(null)
          , Et = useOnClickOutside(()=>vt(!1))
          , xt = St=>{
            et(St),
            vt(!1)
        }
        ;
        let wt = ()=>vt(!mt);
        return jsxRuntimeExports.jsxs("div", {
            ref: Et,
            className: cx$1("ui-select", nt, mt && "is-open", tt && "is-disabled"),
            children: [jsxRuntimeExports.jsxs("div", {
                className: "select-trigger",
                onClick: wt,
                children: [ht && st(ht), jsxRuntimeExports.jsx("div", {
                    className: "arrow " + (rt ? "top" : ""),
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: "Arrow"
                    })
                })]
            }), jsxRuntimeExports.jsx(AnimatePresence, {
                children: mt && jsxRuntimeExports.jsxs(motion.div, {
                    className: "select-options-wrap",
                    animate: springConfig.enter,
                    initial: springConfig.from,
                    exit: springConfig.from,
                    transition: springPower1,
                    style: rt ? topStyle : bottomStyle,
                    children: [ot, it && jsxRuntimeExports.jsx(Input, {
                        autoComplete: "off",
                        focus: !0,
                        className: "search-input",
                        value: pt,
                        onChange: ft,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: "Search"
                        })
                    }), jsxRuntimeExports.jsx(ScrollView, {
                        ref: bt,
                        bodyLock: gt,
                        className: "select-options " + ("len-" + J.length),
                        children: yt.length <= 0 ? at : yt.map(St=>jsxRuntimeExports.jsx("div", {
                            onClick: ()=>!St.disabled && xt(St.value),
                            className: ["select-option", St.value == (ht == null ? void 0 : ht.value) && "active", St.disabled && "disabled"].filter(Boolean).join(" "),
                            children: ut(St)
                        }, ct ? ct(St) : St.label))
                    })]
                })
            })]
        })
    }
    let defaultLabel, defaultOption, topStyle, bottomStyle;
    defaultLabel = _=>_.label,
    defaultOption = _=>_.label,
    Select$1 = React.memo(Select),
    topStyle = {
        bottom: "100%"
    },
    bottomStyle = {
        top: "100%"
    };
    function SelectBaseFunc(nt) {
        var ot = nt
          , {options: _, keydownRef: k, onSelect: J, itemKey: et, children: tt=defaultRenderOptions} = ot
          , rt = Kt(ot, ["options", "keydownRef", "onSelect", "itemKey", "children"]);
        const it = reactExports.useRef({
            idx: 0,
            options: _,
            elRef: reactExports.useRef(null),
            itemRef: reactExports.useRef(null)
        })
          , at = useIsMobile();
        it.current.options !== _ && (it.current.idx = 0,
        it.current.options = _);
        const lt = useForceUpdate();
        reactExports.useEffect(()=>{
            if (k)
                return k.current = ut=>{
                    const {idx: ct, options: pt} = it.current;
                    return ut == 38 ? (it.current.idx = validLen(ct - 1, pt.length),
                    lt(),
                    !0) : ut == 40 ? (it.current.idx = validLen(ct + 1, pt.length),
                    lt(),
                    !0) : (ut == 13 || ut == 9) && pt[ct] ? (J(pt[ct]),
                    !0) : !1
                }
                ,
                ()=>{
                    k.current = null
                }
        }
        ),
        useIsomorphicEffect(()=>{
            const ut = it.current.elRef.current
              , ct = it.current.itemRef.current;
            if (!ct || !ut)
                return;
            const pt = ct.offsetHeight
              , ft = it.current.idx * pt;
            ut.scrollTop = Math.max(Math.min(ft, ut.scrollTop), pt + ft - ut.offsetHeight)
        }
        ),
        useIsomorphicEffect(()=>{
            if (at)
                return disableBodyScroll(it.current.elRef.current),
                ()=>enableBodyScroll(it.current.elRef.current)
        }
        , [at]);
        const st = _.map((ut,ct)=>{
            const pt = it.current.idx == ct
              , ft = tt({
                isSelected: pt,
                option: ut
            })
              , yt = ft.props.className || ""
              , ht = {
                onClick() {
                    J(ut)
                },
                key: et ? ut[et] : ct,
                className: pt ? `${yt} is-selected` : yt
            };
            return ct == 0 && (ht.ref = it.current.itemRef),
            React.cloneElement(ft, ht)
        }
        );
        return jsxRuntimeExports.jsx("div", _t($t({
            ref: it.current.elRef
        }, rt), {
            children: st
        }))
    }
    SelectBase = React.memo(SelectBaseFunc);
    function defaultRenderOptions({isSelected: _, option: k}) {
        return jsxRuntimeExports.jsx("div", {
            className: "item",
            children: String(k)
        })
    }
    function validLen(_, k) {
        return _ < k && (_ += k),
        _ % k
    }
    let LimitRange;
    Table = React.memo(React.forwardRef(function({hover: _=!0, stripe: k, className: J="", children: et}, tt) {
        return jsxRuntimeExports.jsx("table", {
            className: cx$1("ui-table", J, _ && "is-hover", k && "is-stripe"),
            ref: tt,
            children: et
        })
    })),
    LimitRange = [{
        value: 10,
        label: "10"
    }, {
        value: 20,
        label: "20"
    }, {
        value: 30,
        label: "30"
    }, {
        value: 40,
        label: "40"
    }, {
        value: 50,
        label: "50"
    }],
    Pagination = React.memo(function _(k) {
        const {t: J} = useTranslation(instance.options.defaultNS)
          , {page: et, onChange: tt, total: rt, limit: nt=20, onChangeLimit: ot, bound: it=2, className: at="", type: lt="pageConic"} = k
          , st = Math.ceil(rt / nt)
          , ut = getPages(et, st, it);
        return jsxRuntimeExports.jsxs("div", {
            className: cx$1("ui-pagination", at),
            children: [ot && jsxRuntimeExports.jsx(Select$1, {
                top: !0,
                value: nt,
                options: LimitRange,
                onChange: ot
            }), jsxRuntimeExports.jsxs("div", {
                className: "total",
                children: [J("Total"), " ", st]
            }), jsxRuntimeExports.jsx("div", {
                className: cx$1("pages-box", "pages-wrap"),
                children: ut.map(ct=>jsxRuntimeExports.jsx("button", {
                    className: ct == et ? "active" : "",
                    onClick: ()=>tt(ct),
                    disabled: ct == et,
                    children: ct
                }, ct))
            }), jsxRuntimeExports.jsxs("div", {
                className: cx$1("pages-box", "page-pn", lt),
                children: [jsxRuntimeExports.jsx("button", {
                    disabled: et === 1,
                    className: et === 1 ? "disabled previous-btn" : "previous-btn",
                    onClick: ()=>tt(et - 1),
                    children: jsxRuntimeExports.jsx(Icon, {
                        className: "prev",
                        name: "Arrow"
                    })
                }), jsxRuntimeExports.jsx("button", {
                    disabled: et >= st,
                    className: et >= st ? "disabled next-page" : "next-page",
                    onClick: ()=>tt(et + 1),
                    children: jsxRuntimeExports.jsx(Icon, {
                        className: "next",
                        name: "Arrow"
                    })
                })]
            })]
        })
    });
    function getPages(_, k, J) {
        let et = [_];
        for (let tt = 1; tt < J + 1; tt++)
            _ - tt >= 1 && et.unshift(_ - tt),
            _ + tt <= k && et.push(_ + tt);
        return et
    }
    Tooltip = React.memo(({title: _, delay: k=1e3, forceWrap: J=!1, children: et})=>{
        const [tt,rt] = reactExports.useState(null)
          , nt = reactExports.useRef(0)
          , ot = lt=>{
            const st = lt.currentTarget.getBoundingClientRect();
            nt.current = window.setTimeout(()=>rt(st), k)
        }
          , it = ()=>{
            window.clearTimeout(nt.current),
            rt(null)
        }
        ;
        reactExports.useEffect(()=>()=>{
            window.clearTimeout(nt.current)
        }
        , []);
        let at;
        return isSupportTouch ? at = {
            onTouchStart: ot,
            onTouchEnd: it,
            onTouchCancel: it
        } : at = {
            onMouseEnter: ot,
            onMouseLeave: it
        },
        jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [bindTriggerElement(et, at), tt && _ && jsxRuntimeExports.jsx(TooltipBase, {
                forceWrap: J,
                rect: tt,
                children: _
            })]
        })
    }
    );
    function bindTriggerElement(_, k) {
        let J = null;
        return React.Children.map(_, et=>!J && React.isValidElement(et) ? (J = React.cloneElement(et, k),
        J) : et)
    }
    let tipsStyle;
    TooltipBase = reactExports.memo(({padding: _=5, rect: k, forceWrap: J, children: et})=>{
        const tt = reactExports.useRef(null);
        return useIsomorphicEffect(()=>{
            const rt = tt.current;
            if (rt) {
                let nt = {
                    x: k.x + k.width * .5,
                    y: k.y + k.height * .5
                }
                  , ot = {
                    x: rt.offsetWidth * .5 + _,
                    y: rt.offsetHeight * .5 + _
                }
                  , it = Math.max(ot.x, Math.min(window.innerWidth - ot.x, nt.x))
                  , at = k.y - ot.y;
                k.y < ot.y * 2 && (at = k.y + k.height + ot.y),
                rt.style.left = `${it}px`,
                rt.style.top = `${at}px`
            }
        }
        , []),
        ReactDOM.createPortal(jsxRuntimeExports.jsx("div", {
            className: cx$1(tipsStyle, J && "force-wrap"),
            ref: tt,
            children: et
        }), document.body)
    }
    ),
    tipsStyle = "tt7l7b4",
    Carousel$1 = React.memo(function _({value: k, onChange: J, duration: et=0, className: tt="", drag: rt=!0, style: nt, children: ot}) {
        const it = reactExports.useRef(null)
          , [at,lt] = useDimensions()
          , st = reactExports.Children.toArray(ot)
          , ut = st.length
          , ct = reactExports.useMemo(()=>st.map((mt,vt)=>-vt * lt), [lt, st])
          , pt = mt=>(mt + st.length * 1e8) % st.length
          , ft = pt(k)
          , yt = useAnimationControls();
        useIsomorphicEffect(()=>{
            if (ut > 0) {
                const mt = pt(k);
                mt != k ? J(mt) : yt.start({
                    x: ct[k]
                })
            }
        }
        , [k, ut]);
        const ht = lt * (st.length - 1);
        function gt(mt, vt) {
            const bt = it.current;
            if (!bt)
                return null;
            const Et = bt.getBoundingClientRect()
              , xt = vt.offset.x + vt.velocity.x
              , wt = xt > 0 ? 1 : -1
              , St = Math.min(Math.abs(xt), lt * .9) * wt
              , Pt = Et.x + St
              , Rt = ct.reduce((Nt,Ot)=>Math.abs(Ot - Pt) < Math.abs(Nt - Pt) ? Ot : Nt, 0)
              , At = ct.indexOf(Rt);
            J(At),
            yt.start({
                x: Rt
            })
        }
        return jsxRuntimeExports.jsx("div", {
            ref: at,
            className: classList("carousel", carouselStyle, tt, rt && "drag-enable"),
            style: nt,
            children: jsxRuntimeExports.jsx(motion.div, {
                ref: it,
                className: "carousel-list",
                animate: yt,
                drag: "x",
                style: {
                    width: lt * st.length
                },
                dragConstraints: {
                    left: -ht,
                    right: 0
                },
                onDragEnd: gt,
                transition: springPower1,
                children: st.map((mt,vt)=>jsxRuntimeExports.jsx(ActiveProvider, {
                    value: ft === vt,
                    children: jsxRuntimeExports.jsx(motion.div, {
                        className: "carousel-item",
                        children: mt
                    })
                }, vt))
            })
        })
    });
    function useDimensions() {
        const _ = reactExports.useRef(null)
          , [k,J] = reactExports.useState(0);
        return useIsomorphicEffect(()=>{
            const et = _.current;
            et && J(et.clientWidth)
        }
        ),
        [_, k]
    }
    const carouselStyle = "c1ve37vw";
    function UpdateInView({children: _}) {
        const {ref: k, inView: J} = useInView()
          , et = reactExports.useRef();
        return (!et.current || J) && (et.current = React.cloneElement(_, {
            ref: k
        })),
        et.current
    }
    UpdateInView$1 = React.memo(UpdateInView),
    lazyLoad = function(_, k=jsxRuntimeExports.jsx(Loading$1, {})) {
        let J = null
          , et = null;
        const tt = rt=>{
            rt.match && rt.match.params && (rt = rt.match.params);
            const nt = useMountedState()
              , ot = useForceUpdate()
              , it = useInFirstDialog()
              , at = ()=>nt() && ot();
            return reactExports.useEffect(()=>{
                J || Promise.all([tt.preload(), delay(500)]).then(at).catch(lt=>{
                    et = new Error("Script not found!")
                }
                )
            }
            ),
            et ? jsxRuntimeExports.jsx(Empty, {
                type: "offline"
            }) : J ? jsxRuntimeExports.jsx(J, $t({}, rt)) : it ? jsxRuntimeExports.jsx(Dialog, {
                className: "ui-dialog-loading",
                closeable: !1,
                children: k
            }) : k
        }
        ;
        return tt.preload = async()=>(J || (J = (await _()).default),
        J),
        tt
    }
    ,
    pickLazyFunction = function(_, k) {
        return async(...J)=>{
            const et = (await _())[k];
            return et instanceof Function ? et(...J) : et
        }
    }
    ,
    pickLazyComponent = function(_, k) {
        return lazyLoad(async(...J)=>({
            default: (await _())[k]
        }))
    }
    ;
    let wrapStyle, codeStyle, cache;
    FileSelect = reactExports.memo(function _({onChange: k, className: J="", children: et, multiple: tt, disabled: rt, typeCheck: nt=/\.(gif|jpg|jpeg|png|bmp|GIF|JPG|PNG)$/}) {
        const ot = reactExports.useRef(null)
          , it = at=>{
            if (!at.target.files || at.target.files.length == 0)
                return;
            const lt = at.target.files;
            for (let st = 0; st < lt.length; st++)
                if (!nt.test(lt[st].name))
                    return notify(new Error("File type is not supported"));
            k(lt),
            at.target.value = ""
        }
        ;
        return jsxRuntimeExports.jsxs("button", {
            className: cx$1("upload", wrapStyle, J),
            children: [et, jsxRuntimeExports.jsx("input", {
                type: "file",
                onChange: it,
                ref: ot,
                multiple: tt,
                disabled: rt
            })]
        })
    }),
    wrapStyle = "w1tpi5js",
    CodeSegment = React.memo(function({children: _, style: k, className: J=""}) {
        return jsxRuntimeExports.jsx("div", {
            className: cx$1("code-area", codeStyle, J),
            style: k,
            children: jsxRuntimeExports.jsx("pre", {
                children: _
            })
        })
    }),
    codeStyle = "c1xwx83c",
    LazyImage = React.memo(function _(ot) {
        var it = ot
          , {src: k, lazy: J, loading: et, className: tt, children: rt} = it
          , nt = Kt(it, ["src", "lazy", "loading", "className", "children"]);
        const at = reactExports.useRef(null)
          , {state: lt, fetch: st} = useAsyncFn(()=>loadImage(k), [k]);
        return reactExports.useEffect(()=>{
            const ut = at.current;
            if (ut && k) {
                const ct = ()=>SIObserver.remove(ut);
                return SIObserver.add(ut, pt=>{
                    pt && st().then(ct)
                }
                ),
                ct
            }
        }
        , [k]),
        tt = classList("lazy-img", tt),
        lt.data ? jsxRuntimeExports.jsxs("div", _t($t({
            className: tt,
            ref: at
        }, nt), {
            children: [jsxRuntimeExports.jsx("img", {
                src: lt.data,
                alt: ""
            }), rt]
        })) : jsxRuntimeExports.jsxs("div", _t($t({
            className: tt,
            ref: at
        }, nt), {
            children: [et, rt]
        }))
    }),
    Image$1 = React.memo(function _(rt) {
        var nt = rt
          , {src: k, lazy: J, fallback: et} = nt
          , tt = Kt(nt, ["src", "lazy", "fallback"]);
        const ot = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="
          , [it,at] = useLazyImg(k, et || ot, ot)
          , [lt,st] = reactExports.useState(ot);
        return useIsomorphicEffect(()=>{
            st(J ? at : k)
        }
        , [at, J]),
        jsxRuntimeExports.jsx("img", $t({
            ref: J ? it : void 0,
            src: lt
        }, tt))
    }),
    cache = new Set;
    function useLazyImg(_, k, J) {
        const et = reactExports.useRef(null)
          , [tt,rt] = useLoadImage(k, J)
          , [nt,ot] = useLoadImage(_, tt)
          , it = _ === nt;
        return reactExports.useEffect(()=>{
            const at = et.current;
            if (!it && at && _) {
                rt();
                const lt = ()=>{
                    SIObserver.remove(at)
                }
                ;
                return SIObserver.add(at, st=>{
                    st && ot().then(lt)
                }
                ),
                lt
            }
        }
        , [et, _]),
        it ? [void 0, nt] : [et, tt]
    }
    function useLoadImage(_, k) {
        const J = cache.has(_)
          , {state: et, fetch: tt} = useAsyncFn(()=>{
            const rt = loadImage(_);
            return rt.then(()=>cache.add(_)),
            rt
        }
        , [_]);
        return J || et.data ? [_, ()=>Promise.resolve()] : [k, tt]
    }
    let defaultArgs;
    defaultArgs = `auto=format&dpr=${isSSR ? 1 : globalThis.devicePixelRatio}`,
    Imgix = React.memo(function _(ot) {
        var it = ot
          , {src: k, args: J, fallback: et, lazy: tt=!0, fillbackArgs: rt="w=100&auto=format&cs=tinysrgb&blur=100"} = it
          , nt = Kt(it, ["src", "args", "fallback", "lazy", "fillbackArgs"]);
        const at = [defaultArgs];
        return J && at.push(J),
        jsxRuntimeExports.jsx(Image$1, _t($t({
            src: `${k}?${at.join("&")}`
        }, nt), {
            lazy: tt,
            fallback: et || `${k}?${rt}`
        }))
    }),
    DialogTable = function(J) {
        var et = J
          , {className: _} = et
          , k = Kt(et, ["className"]);
        return jsxRuntimeExports.jsx("table", $t({
            className: cx$1(tableStyle, _)
        }, k))
    }
    ;
    const tableStyle = "t1aku4jw"
      , loadLottie = ()=>__vitePreload(()=>import("./chunk-76d3d72c.js"), ["assets/chunk-76d3d72c.js", "assets/chunk-cf010ec4.js", "assets/chunk-73e80d68.js"]).then(_=>_.l);
    let lottie = null;
    async function getInstance() {
        return lottie || (lottie = (await loadLottie()).default),
        lottie
    }
    Lottie = class extends React.PureComponent {
        constructor(_) {
            super(_),
            _e(this, "containerRef", React.createRef()),
            _e(this, "instance", null)
        }
        componentDidMount() {
            const _ = this.containerRef.current
              , {loop: k=!1, autoplay: J, path: et} = this.props;
            _ && (this.instance = getInstance().then(tt=>tt.loadAnimation({
                container: _,
                renderer: "svg",
                loop: k,
                autoplay: J,
                path: et
            })).catch(tt=>null),
            this.syncProps())
        }
        componentDidUpdate() {
            this.syncProps()
        }
        componentWillUnmount() {
            var _;
            (_ = this.instance) == null || _.then(k=>k.destroy())
        }
        async runInstance(_) {
            this.instance && _(await this.instance)
        }
        play(_) {
            this.runInstance(k=>{
                typeof _ > "u" && (_ = k.currentFrame),
                k.goToAndPlay(_, !0)
            }
            )
        }
        stop(_) {
            this.runInstance(k=>{
                typeof _ > "u" && (_ = k.currentFrame),
                k.goToAndStop(_, !0)
            }
            )
        }
        addEventListener(_, k) {
            this.runInstance(J=>J.addEventListener(_, k))
        }
        removeEventListener(_, k) {
            this.runInstance(J=>J.removeEventListener(_, k))
        }
        syncProps() {
            const {speed: _=1} = this.props;
            this.runInstance(k=>{
                k.setSpeed(_)
            }
            )
        }
        render() {
            let tt = this.props
              , {loop: _, path: k, autoplay: J} = tt
              , et = Kt(tt, ["loop", "path", "autoplay"]);
            return jsxRuntimeExports.jsx("div", _t($t({}, et), {
                ref: this.containerRef
            }))
        }
    }
    ;
    const loadQRCode = ()=>__vitePreload(()=>import("./chunk-21db0a97.js").then(_=>_.b), []);
    let qrcodeCache = null;
    function useLoadQrcode() {
        const [_,k] = reactExports.useState(qrcodeCache);
        return useIsomorphicEffect(()=>{
            qrcodeCache || loadQRCode().then(J=>{
                qrcodeCache = J.default,
                k(qrcodeCache)
            }
            )
        }
        , [_]),
        _
    }
    useQrcode = function({url: _, qrimg: k, className: J, options: et={
        margin: 4,
        width: 200
    }}) {
        const tt = useLoadQrcode()
          , [rt,nt] = reactExports.useState(k != null ? k : "");
        return reactExports.useEffect(()=>{
            !rt && tt && tt.toDataURL(_, {
                margin: et.margin,
                width: app.relativePx(et.width),
                errorCorrectionLevel: "L"
            }, function(ot, it) {
                nt(ot ? emptyPng : it)
            })
        }
        , [tt, _, rt]),
        {
            qrnode: reactExports.useMemo(()=>jsxRuntimeExports.jsx("div", {
                className: classList("qrcode-wrap", J),
                children: rt ? jsxRuntimeExports.jsx("img", {
                    alt: "qrcode",
                    src: rt
                }) : jsxRuntimeExports.jsx(Loading$1, {})
            }), [rt]),
            img: rt
        }
    }
    ;
    function _extends() {
        return _extends = Object.assign || function(_) {
            for (var k = 1; k < arguments.length; k++) {
                var J = arguments[k];
                for (var et in J)
                    Object.prototype.hasOwnProperty.call(J, et) && (_[et] = J[et])
            }
            return _
        }
        ,
        _extends.apply(this, arguments)
    }
    function _objectWithoutPropertiesLoose(_, k) {
        if (_ == null)
            return {};
        var J = {}, et = Object.keys(_), tt, rt;
        for (rt = 0; rt < et.length; rt++)
            tt = et[rt],
            !(k.indexOf(tt) >= 0) && (J[tt] = _[tt]);
        return J
    }
    var props = ["bottom", "height", "left", "right", "top", "width"], rectChanged = function _(k, J) {
        return k === void 0 && (k = {}),
        J === void 0 && (J = {}),
        props.some(function(et) {
            return k[et] !== J[et]
        })
    }, observedNodes = new Map, rafId, run = function _() {
        var k = [];
        observedNodes.forEach(function(J, et) {
            var tt = et.getBoundingClientRect();
            rectChanged(tt, J.rect) && (J.rect = tt,
            k.push(J))
        }),
        k.forEach(function(J) {
            J.callbacks.forEach(function(et) {
                return et(J.rect)
            })
        }),
        rafId = window.requestAnimationFrame(_)
    };
    function observeRect(_, k) {
        return {
            observe: function() {
                var J = observedNodes.size === 0;
                observedNodes.has(_) ? observedNodes.get(_).callbacks.push(k) : observedNodes.set(_, {
                    rect: void 0,
                    hasRectChanged: !1,
                    callbacks: [k]
                }),
                J && run()
            },
            unobserve: function() {
                var J = observedNodes.get(_);
                if (J) {
                    var et = J.callbacks.indexOf(k);
                    et >= 0 && J.callbacks.splice(et, 1),
                    J.callbacks.length || observedNodes.delete(_),
                    observedNodes.size || cancelAnimationFrame(rafId)
                }
            }
        }
    }
    var useIsomorphicLayoutEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
    function useRect(_, k) {
        k === void 0 && (k = {
            width: 0,
            height: 0
        });
        var J = React.useState(_.current)
          , et = J[0]
          , tt = J[1]
          , rt = React.useReducer(rectReducer, k)
          , nt = rt[0]
          , ot = rt[1]
          , it = React.useRef(!1);
        return useIsomorphicLayoutEffect(function() {
            _.current !== et && tt(_.current)
        }),
        useIsomorphicLayoutEffect(function() {
            if (et && !it.current) {
                it.current = !0;
                var at = et.getBoundingClientRect();
                ot({
                    rect: at
                })
            }
        }, [et]),
        React.useEffect(function() {
            if (et) {
                var at = observeRect(et, function(lt) {
                    ot({
                        rect: lt
                    })
                });
                return at.observe(),
                function() {
                    at.unobserve()
                }
            }
        }, [et]),
        nt
    }
    function rectReducer(_, k) {
        var J = k.rect;
        return _.height !== J.height || _.width !== J.width ? J : _
    }
    var defaultEstimateSize = function _() {
        return 50
    }
      , defaultKeyExtractor = function _(k) {
        return k
    }
      , defaultMeasureSize = function _(k, J) {
        var et = J ? "offsetWidth" : "offsetHeight";
        return k[et]
    }
      , defaultRangeExtractor = function _(k) {
        for (var J = Math.max(k.start - k.overscan, 0), et = Math.min(k.end + k.overscan, k.size - 1), tt = [], rt = J; rt <= et; rt++)
            tt.push(rt);
        return tt
    }
      , useElementScroll = function _(k) {
        var J = k.parentRef
          , et = k.horizontal
          , tt = k.useObserver
          , rt = k.initialRect
          , nt = et ? "scrollLeft" : "scrollTop"
          , ot = React.useState(0)
          , it = ot[0]
          , at = ot[1]
          , lt = React.useState(J.current)
          , st = lt[0]
          , ut = lt[1];
        useIsomorphicLayoutEffect(function() {
            ut(J.current)
        }),
        useIsomorphicLayoutEffect(function() {
            if (!st) {
                at(0);
                return
            }
            var gt = function() {
                at(st[nt])
            };
            return gt(),
            st.addEventListener("scroll", gt, {
                capture: !1,
                passive: !0
            }),
            function() {
                st.removeEventListener("scroll", gt)
            }
        }, [st, nt]);
        var ct = React.useCallback(function(gt) {
            J.current && (J.current[nt] = gt)
        }, [J, nt])
          , pt = tt || useRect
          , ft = et ? "width" : "height"
          , yt = pt(J, rt)
          , ht = yt[ft];
        return {
            outerSize: ht,
            scrollOffset: it,
            scrollToFn: ct
        }
    }
      , useWindowRect = function _(k, J) {
        J === void 0 && (J = {
            width: 0,
            height: 0
        });
        var et = React.useState(J)
          , tt = et[0]
          , rt = et[1]
          , nt = React.useState(k.current)
          , ot = nt[0]
          , it = nt[1];
        return useIsomorphicLayoutEffect(function() {
            it(k.current)
        }),
        useIsomorphicLayoutEffect(function() {
            if (!ot)
                return;
            function at() {
                var lt = {
                    width: ot.innerWidth,
                    height: ot.innerHeight
                };
                rt(function(st) {
                    return st.height !== lt.height || st.width !== lt.width ? lt : st
                })
            }
            return at(),
            ot.addEventListener("resize", at),
            function() {
                ot.removeEventListener("resize", at)
            }
        }, [ot]),
        tt
    }
      , useWindowScroll = function _(k) {
        var J = k.windowRef
          , et = k.parentRef
          , tt = k.horizontal
          , rt = k.useWindowObserver
          , nt = k.initialRect
          , ot = React.useState(0)
          , it = ot[0]
          , at = ot[1]
          , lt = React.useState(J.current)
          , st = lt[0]
          , ut = lt[1]
          , ct = React.useRef(0)
          , pt = tt ? "left" : "top"
          , ft = tt ? "scrollX" : "scrollY";
        useIsomorphicLayoutEffect(function() {
            ut(J.current)
        }),
        useIsomorphicLayoutEffect(function() {
            if (!st) {
                ct.current = 0,
                at(0);
                return
            }
            et.current && (ct.current = st[ft] + et.current.getBoundingClientRect()[pt]);
            var bt = function() {
                var Et = st[ft] - ct.current;
                at(Et)
            };
            return bt(),
            st.addEventListener("scroll", bt, {
                capture: !1,
                passive: !0
            }),
            function() {
                st.removeEventListener("scroll", bt)
            }
        }, [st, ft, pt, et]);
        var yt = React.useCallback(function(bt, Et) {
            if (J.current) {
                var xt, wt = ["ToIndex", "SizeChanged"].includes(Et) ? ct.current : 0;
                J.current.scrollTo((xt = {},
                xt[pt] = bt + wt,
                xt))
            }
        }, [J, pt])
          , ht = rt || useWindowRect
          , gt = tt ? "width" : "height"
          , mt = ht(J, nt)
          , vt = mt[gt];
        return {
            outerSize: vt,
            scrollOffset: it,
            scrollToFn: yt
        }
    }
      , useDefaultScroll = function _(k) {
        var J = k.parentRef
          , et = k.windowRef
          , tt = et !== void 0
          , rt = React.useRef(null)
          , nt = useElementScroll(_extends(_extends({}, k), {}, {
            parentRef: tt ? rt : J
        }))
          , ot = useWindowScroll(_extends(_extends({}, k), {}, {
            windowRef: tt ? et : rt
        }));
        return tt ? ot : nt
    };
    function useVirtual(_) {
        var k, J = _.size, et = J === void 0 ? 0 : J, tt = _.estimateSize, rt = tt === void 0 ? defaultEstimateSize : tt, nt = _.overscan, ot = nt === void 0 ? 1 : nt, it = _.paddingStart, at = it === void 0 ? 0 : it, lt = _.paddingEnd, st = lt === void 0 ? 0 : lt, ut = _.parentRef, ct = _.windowRef, pt = _.horizontal, ft = _.scrollToFn, yt = _.useObserver, ht = _.useWindowObserver, gt = _.initialRect, mt = _.keyExtractor, vt = mt === void 0 ? defaultKeyExtractor : mt, bt = _.measureSize, Et = bt === void 0 ? defaultMeasureSize : bt, xt = _.rangeExtractor, wt = xt === void 0 ? defaultRangeExtractor : xt, St = _.useScroll, Pt = St === void 0 ? useDefaultScroll : St, Rt = React.useRef({
            scrollOffset: 0,
            measurements: []
        }), At = Pt({
            windowRef: ct,
            parentRef: ut,
            horizontal: pt,
            useObserver: yt,
            useWindowObserver: ht,
            initialRect: gt
        }), Nt = At.outerSize, Ot = At.scrollOffset, It = At.scrollToFn, Mt = React.useRef(Ot);
        Rt.current.scrollOffset !== Ot && (Mt.current = Ot),
        Rt.current.outerSize = Nt,
        Rt.current.scrollOffset = Ot;
        var Wt = React.useCallback(function(ur, ar) {
            var or = ft || function(Tr) {
                return It(Tr, ar)
            }
            ;
            or(ur, It)
        }, [ft, It])
          , jt = React.useState({})
          , Bt = jt[0]
          , Ut = jt[1]
          , Xt = React.useCallback(function() {
            return Ut({})
        }, [])
          , Yt = React.useRef([])
          , Gt = React.useMemo(function() {
            var ur = Yt.current.length > 0 ? Math.min.apply(Math, Yt.current) : 0;
            Yt.current = [];
            for (var ar = Rt.current.measurements.slice(0, ur), or = ur; or < et; or++) {
                var Tr = vt(or)
                  , br = Bt[Tr]
                  , Sr = ar[or - 1] ? ar[or - 1].end : at
                  , $r = typeof br == "number" ? br : rt(or)
                  , Rr = Sr + $r;
                ar[or] = {
                    index: or,
                    start: Sr,
                    size: $r,
                    end: Rr,
                    key: Tr
                }
            }
            return ar
        }, [rt, Bt, at, et, vt])
          , er = (((k = Gt[et - 1]) == null ? void 0 : k.end) || 0) + st;
        Rt.current.measurements = Gt,
        Rt.current.totalSize = er;
        var lr = calculateRange(Rt.current)
          , sr = lr.start
          , fr = lr.end
          , Er = React.useMemo(function() {
            return wt({
                start: sr,
                end: fr,
                overscan: ot,
                size: Gt.length
            })
        }, [sr, fr, ot, Gt.length, wt])
          , mr = React.useRef(Et);
        mr.current = Et;
        var wr = React.useMemo(function() {
            for (var ur = [], ar = function(br, Sr) {
                var $r = Er[br]
                  , Rr = Gt[$r]
                  , gr = _extends(_extends({}, Rr), {}, {
                    measureRef: function(Mr) {
                        if (Mr) {
                            var Cr = mr.current(Mr, pt);
                            if (Cr !== gr.size) {
                                var Ar = Rt.current.scrollOffset;
                                if (gr.start < Ar) {
                                    var _r = Cr - gr.size;
                                    Mt.current += _r,
                                    It(Mt.current, "SizeChanged")
                                }
                                Yt.current.push($r),
                                Ut(function(Wr) {
                                    var Dr;
                                    return _extends(_extends({}, Wr), {}, (Dr = {},
                                    Dr[gr.key] = Cr,
                                    Dr))
                                })
                            }
                        }
                    }
                });
                ur.push(gr)
            }, or = 0, Tr = Er.length; or < Tr; or++)
                ar(or);
            return ur
        }, [Er, It, pt, Gt])
          , Pr = React.useRef(!1);
        useIsomorphicLayoutEffect(function() {
            Pr.current && Ut({}),
            Pr.current = !0
        }, [rt]);
        var nr = React.useCallback(function(ur, ar, or) {
            var Tr = ar === void 0 ? {} : ar
              , br = Tr.align
              , Sr = br === void 0 ? "start" : br;
            or === void 0 && (or = "ToOffset");
            var $r = Rt.current
              , Rr = $r.scrollOffset
              , gr = $r.outerSize;
            Sr === "auto" && (ur <= Rr ? Sr = "start" : ur >= Rr + gr ? Sr = "end" : Sr = "start"),
            Sr === "start" ? Wt(ur, or) : Sr === "end" ? Wt(ur - gr, or) : Sr === "center" && Wt(ur - gr / 2, or)
        }, [Wt])
          , pr = React.useCallback(function(ur, ar) {
            var or = ar === void 0 ? {} : ar
              , Tr = or.align
              , br = Tr === void 0 ? "auto" : Tr
              , Sr = _objectWithoutPropertiesLoose(or, ["align"])
              , $r = Rt.current
              , Rr = $r.measurements
              , gr = $r.scrollOffset
              , Mr = $r.outerSize
              , Cr = Rr[Math.max(0, Math.min(ur, et - 1))];
            if (Cr) {
                if (br === "auto")
                    if (Cr.end >= gr + Mr)
                        br = "end";
                    else if (Cr.start <= gr)
                        br = "start";
                    else
                        return;
                var Ar = br === "center" ? Cr.start + Cr.size / 2 : br === "end" ? Cr.end : Cr.start;
                nr(Ar, _extends({
                    align: br
                }, Sr), "ToIndex")
            }
        }, [nr, et])
          , Or = React.useCallback(function() {
            for (var ur = arguments.length, ar = new Array(ur), or = 0; or < ur; or++)
                ar[or] = arguments[or];
            pr.apply(void 0, ar),
            requestAnimationFrame(function() {
                pr.apply(void 0, ar)
            })
        }, [pr]);
        return {
            virtualItems: wr,
            totalSize: er,
            scrollToOffset: nr,
            scrollToIndex: Or,
            measure: Xt
        }
    }
    var findNearestBinarySearch = function _(k, J, et, tt) {
        for (; k <= J; ) {
            var rt = (k + J) / 2 | 0
              , nt = et(rt);
            if (nt < tt)
                k = rt + 1;
            else if (nt > tt)
                J = rt - 1;
            else
                return rt
        }
        return k > 0 ? k - 1 : 0
    };
    function calculateRange(_) {
        for (var k = _.measurements, J = _.outerSize, et = _.scrollOffset, tt = k.length - 1, rt = function(it) {
            return k[it].start
        }, nt = findNearestBinarySearch(0, tt, rt, et), ot = nt; ot < tt && k[ot].end < et + J; )
            ot++;
        return {
            start: nt,
            end: ot
        }
    }
    function FlatList(_, k) {
        const gt = _
          , {data: J, overscan: et=2, estimateSize: tt, paddingStart: rt, paddingEnd: nt, windowScroll: ot, renderItem: it, keyExtractor: at, children: lt, onRangeChange: st, virtualRef: ut} = gt
          , ct = Kt(gt, ["data", "overscan", "estimateSize", "paddingStart", "paddingEnd", "windowScroll", "renderItem", "keyExtractor", "children", "onRangeChange", "virtualRef"])
          , pt = reactExports.useRef(null)
          , ft = useMergeRefs(pt, k)
          , yt = useVirtual({
            size: J.length,
            parentRef: pt,
            overscan: et,
            estimateSize: tt,
            paddingStart: rt,
            paddingEnd: nt,
            keyExtractor: at,
            useObserver,
            rangeExtractor: useBatchRange(st)
        });
        ut && (ut.current = {
            scrollToIndex: yt.scrollToIndex,
            scrollToOffset: yt.scrollToOffset
        });
        const ht = usePool(yt.virtualItems, J, it, tt);
        return reactExports.useMemo(()=>{
            if (ot) {
                const mt = ct
                  , {className: vt} = mt
                  , bt = Kt(mt, ["className"]);
                return jsxRuntimeExports.jsxs(motion.div, _t($t({
                    className: cx$1(flatContainerStyle, vt)
                }, bt), {
                    style: {
                        height: yt.totalSize
                    },
                    children: [lt, ht]
                }))
            }
            return jsxRuntimeExports.jsx(ScrollView, _t($t({}, ct), {
                ref: ft,
                children: jsxRuntimeExports.jsxs("div", {
                    className: flatContainerStyle,
                    style: {
                        height: yt.totalSize
                    },
                    children: [lt, ht]
                })
            }))
        }
        , [yt.totalSize, ht, ot, _])
    }
    let VirtualItemWrap;
    FlatList$1 = React.memo(React.forwardRef(FlatList)),
    VirtualItemWrap = React.memo(function _({start: k, children: J, used: et, estimateSize: tt}) {
        const rt = {
            transform: `translateY(${k}px)`
        };
        return et || (rt.display = "none"),
        jsxRuntimeExports.jsx(ActiveProvider, {
            value: et,
            children: jsxRuntimeExports.jsx("div", {
                className: "flat-item",
                style: rt,
                ref: tt,
                children: J
            })
        })
    }, (_,k)=>!(_.start !== k.start || _.used !== k.used));
    function useBatchRange(_) {
        const k = reactExports.useRef({
            start: 0,
            end: -1,
            indexs: []
        });
        return reactExports.useCallback(J=>{
            const et = k.current
              , tt = Math.max(J.start - J.overscan, 0)
              , rt = Math.max(Math.min(J.end + J.overscan, J.size - 1), tt);
            if (tt < et.start || rt > et.end || tt === rt) {
                const nt = Math.max(J.start - J.overscan * 2, 0)
                  , ot = Math.max(Math.min(J.end + J.overscan * 2, J.size - 1), nt)
                  , it = [];
                for (let at = nt; at <= ot; at++)
                    it.push(at);
                et.start = nt,
                et.end = ot,
                et.indexs = it
            }
            return _ && setTimeout(()=>_(J.start, J.end), 0),
            et.indexs
        }
        , [])
    }
    function usePool(_, k, J, et) {
        const tt = reactExports.useRef(k)
          , [rt] = reactExports.useState(()=>({
            usedPool: new Set,
            pool: new Array,
            unUsedPool: new Map
        }));
        return tt.current !== k && (rt.usedPool = new Set,
        rt.pool = new Array,
        rt.unUsedPool = new Map,
        tt.current = k),
        reactExports.useMemo(()=>{
            const nt = _.reduce((ot,it)=>ot.set(it.index, it), new Map);
            return rt.pool.forEach(ot=>{
                const it = ot.item.index;
                if (ot.used) {
                    const at = nt.get(it);
                    (!at || at.size !== ot.item.size || at.start !== ot.item.start) && (ot.used = !1,
                    rt.usedPool.delete(it),
                    rt.unUsedPool.get(ot.element.type).push(ot))
                }
            }
            ),
            _.forEach(ot=>{
                const it = ot.index
                  , at = rt.usedPool.has(it)
                  , lt = k[ot.index];
                if (!at && lt) {
                    const st = J(lt);
                    let ut = rt.unUsedPool.get(st.type);
                    ut || (ut = [],
                    rt.unUsedPool.set(st.type, ut));
                    let ct = ut.pop();
                    ct || (ct = {
                        index: rt.pool.length,
                        used: !0,
                        item: ot,
                        element: st
                    },
                    rt.pool.push(ct)),
                    ct.used = !0,
                    ct.item = ot,
                    ct.element = st,
                    rt.usedPool.add(it)
                }
            }
            ),
            rt.pool.map(({index: ot, item: it, used: at, element: lt})=>jsxRuntimeExports.jsx(VirtualItemWrap, {
                start: it.start,
                children: lt,
                used: at,
                estimateSize: et ? void 0 : it.measureRef
            }, ot))
        }
        , [_, k, J])
    }
    function useObserver(_) {
        const [k,J] = reactExports.useState({
            height: 0,
            width: 0
        });
        return useIsomorphicEffect(()=>{
            const et = _.current;
            et && J({
                width: et.clientWidth,
                height: et.clientHeight
            })
        }
        , [_]),
        k
    }
    const flatContainerStyle = "fzzoavm"
      , baseArrowStyle = {
        position: "absolute",
        width: "50px",
        height: "50px",
        backgroundColor: "rgba(0,0,0,0.5)",
        top: "50%",
        transform: "translateY(-50%)",
        borderRadius: "50%",
        color: "#fff",
        fontSize: "20px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "pointer"
    }
      , Arrow = ({left: _=!1, children: k, onClick: J})=>jsxRuntimeExports.jsx("div", {
        onClick: J,
        style: _t($t({}, baseArrowStyle), {
            left: _ ? "20px" : "initial",
            right: _ ? "initial" : "10px"
        }),
        children: k
    })
      , dotWrapStyle = {
        position: "absolute",
        bottom: "10px",
        left: "50%",
        transform: "translateX(-50%)"
    }
      , dotItemStyle = {
        width: "20px",
        height: "20px",
        borderRadius: "50%",
        margin: "0 10px",
        display: "inline-block",
        cursor: "pointer"
    }
      , Dots = ({length: _, activeIndex: k, setActiveIndex: J})=>jsxRuntimeExports.jsx("div", {
        style: dotWrapStyle,
        children: new Array(_).fill("").map((et,tt)=>jsxRuntimeExports.jsx("span", {
            onClick: ()=>J(tt),
            style: _t($t({}, dotItemStyle), {
                background: tt === k ? "#000" : "#999",
                transform: `scale(${tt === k ? 1.3 : 1})`
            })
        }, tt))
    });
    function useContainer() {
        const _ = reactExports.useRef(null);
        return reactExports.useEffect(()=>{
            var k;
            const J = ((k = _.current) == null ? void 0 : k.getElementsByTagName("*")) || [];
            for (const et of J)
                et.setAttribute("draggable", "false")
        }
        , [_.current]),
        _
    }
    const containerStyle = "c1mxe6k6"
      , transition = {
        type: "spring",
        stiffness: 50
    }
      , Carousel = reactExports.forwardRef(({children: _, renderArrowLeft: k, renderArrowRight: J, renderDots: et, autoPlay: tt=!0, interval: rt=2e3, loop: nt=!0, direction: ot, className: it="", spaceBetween: at=0, slidesPerGroup: lt, pauseOnMouseEnter: st, disableOnInteraction: ut},ct)=>{
        var pt, ft, yt, ht;
        const gt = useMotionValue(0)
          , mt = useContainer()
          , vt = reactExports.useRef(null)
          , [bt,Et] = reactExports.useState(0)
          , [xt,wt] = reactExports.useState(tt)
          , St = reactExports.useMemo(()=>ot === "horizontal", [ot])
          , Pt = St ? ((pt = mt.current) == null ? void 0 : pt.clientWidth) || 0 : ((ft = mt.current) == null ? void 0 : ft.clientHeight) || 0
          , Rt = St ? ((yt = vt.current) == null ? void 0 : yt.clientWidth) || 0 : ((ht = vt.current) == null ? void 0 : ht.clientHeight) || 0
          , At = reactExports.Children.toArray(_)
          , Nt = Rt / At.length
          , Ot = Rt - Pt
          , It = lt ? Math.ceil((Ot > 0 ? Ot : 0) / Nt) + 1 : At.length
          , Mt = ()=>Rt > Pt && lt && It ? -bt * Nt : -bt * (Pt + at)
          , Wt = lt ? Nt : Rt
          , jt = St ? "x" : "y"
          , Bt = (mr,wr)=>{
            Gt(!1);
            const {offset: Pr} = wr
              , nr = St ? Pr.x : Pr.y;
            if (bt < It - 1 && nr < 0) {
                Ut();
                return
            }
            if (bt > 0 && nr > 0) {
                Xt();
                return
            }
            if (nr > Wt / 4) {
                const pr = bt - Math.ceil(nr / Wt)
                  , Or = nt ? It - 1 : 0
                  , ur = pr < 0 ? Or : pr;
                Et(ur)
            } else if (nr < -Wt / 4) {
                const pr = bt + Math.ceil(-nr / Wt)
                  , Or = nt ? 0 : It - 1
                  , ur = pr >= It ? Or : pr;
                Et(ur)
            } else
                animate$1(gt, Mt(), transition)
        }
          , Ut = ()=>{
            const mr = nt ? 0 : bt
              , wr = bt === It - 1 ? mr : bt + 1;
            Et(wr)
        }
          , Xt = ()=>{
            const mr = nt ? It - 1 : 0
              , wr = bt === 0 ? mr : bt - 1;
            Et(wr)
        }
        ;
        reactExports.useEffect(()=>{
            if (!xt || It <= 1 || isNaN(It))
                return;
            const mr = setInterval(()=>Ut(), rt);
            return ()=>clearInterval(mr)
        }
        , [Ut, rt, xt]),
        reactExports.useImperativeHandle(ct, ()=>({
            handleNext: Ut,
            handlePrev: Xt,
            setIndex: Et
        }), [bt]),
        reactExports.useEffect(()=>animate$1(gt, Mt(), transition).stop, [bt]);
        const [Yt,Gt] = reactExports.useState(!1)
          , er = reactExports.useMemo(()=>St ? {
            x: gt
        } : {
            y: gt
        }, [St, gt])
          , lr = reactExports.useMemo(()=>lt ? _t($t({}, er), {
            pointerEvents: Yt ? "none" : "auto",
            flexDirection: St ? "row" : "column"
        }) : _t($t(_t($t({}, er), {
            pointerEvents: Yt ? "none" : "auto"
        }), St ? {
            width: `${At.length * 100}%`
        } : {
            height: `${At.length * 100}%`
        }), {
            flexDirection: St ? "row" : "column"
        }), [St, Yt, er, lt, At])
          , sr = reactExports.useCallback(()=>{
            st && wt(!1)
        }
        , [st, wt])
          , fr = reactExports.useCallback(()=>{
            !ut && st && wt(!0)
        }
        , [ut, st, wt])
          , Er = reactExports.useCallback((mr,wr)=>{
            Gt(!0)
        }
        , [Gt]);
        return jsxRuntimeExports.jsxs("div", {
            ref: mt,
            className: cx$1(containerStyle, ot, it),
            children: [jsxRuntimeExports.jsx(motion.div, {
                style: lr,
                drag: It > 1 && jt,
                onHoverStart: sr,
                onHoverEnd: fr,
                onPanEnd: Bt,
                onPanStart: Er,
                dragElastic: .3,
                ref: vt,
                className: "motion-container",
                children: At.map((mr,wr)=>{
                    const Pr = reactExports.Children.count(mr.children) > 0 || wr === At.length - 1 ? 0 : at
                      , nr = St ? {
                        marginRight: Pr
                    } : {
                        marginBottom: Pr
                    };
                    return jsxRuntimeExports.jsx("div", {
                        className: "swiper-slide",
                        style: nr,
                        children: mr
                    }, wr)
                }
                )
            }), k ? k({
                handlePrev: Xt,
                activeIndex: bt
            }) : jsxRuntimeExports.jsx(Arrow, {
                left: !0,
                onClick: Xt,
                children: "\u2190"
            }), J ? J({
                handleNext: Ut,
                activeIndex: bt
            }) : jsxRuntimeExports.jsx(Arrow, {
                onClick: Ut,
                children: "\u2192"
            }), et ? et({
                setActiveIndex: Et,
                activeIndex: bt
            }) : jsxRuntimeExports.jsx(Dots, {
                length: It,
                setActiveIndex: Et,
                activeIndex: bt
            })]
        })
    }
    );
    Swiper = function(_) {
        const {autoplay: k, spaceBetween: J, navigation: et, children: tt, speed: rt, threshold: nt, slidesPerView: ot, pagination: it, loop: at=!1, direction: lt="horizontal", className: st="", initialSlide: ut=0, slidesPerGroup: ct} = _
          , {disableOnInteraction: pt=!0, pauseOnMouseEnter: ft=!1, delay: yt=0} = k || {}
          , ht = reactExports.useRef()
          , [gt,mt] = reactExports.useState(yt !== 0);
        reactExports.useEffect(()=>{
            mt(yt !== 0)
        }
        , [yt]);
        const {prevEl: vt, nextEl: bt} = et || {};
        return reactExports.useEffect(()=>{
            const Et = xt=>{
                xt.composedPath().forEach(wt=>{
                    var St, Pt;
                    (St = wt.classList) != null && St.contains(vt == null ? void 0 : vt.slice(1)) && ht.current.handlePrev(),
                    (Pt = wt.classList) != null && Pt.contains(bt == null ? void 0 : bt.slice(1)) && ht.current.handleNext()
                }
                )
            }
            ;
            return window.addEventListener("click", Et),
            ()=>{
                window.removeEventListener("click", Et)
            }
        }
        , [vt, bt]),
        reactExports.useEffect(()=>{
            ht.current.setIndex(ut)
        }
        , []),
        jsxRuntimeExports.jsx(Carousel, {
            direction: lt,
            autoPlay: gt,
            interval: yt,
            loop: at,
            ref: ht,
            renderArrowLeft: ()=>null,
            renderArrowRight: ()=>null,
            renderDots: ({activeIndex: Et, setActiveIndex: xt})=>{
                if (it) {
                    const wt = document.querySelector(it.el);
                    return wt && reactDomExports.createPortal(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                        children: reactExports.Children.map(tt, (St,Pt)=>jsxRuntimeExports.jsx("span", {
                            className: Pt === Et ? "swiper-pagination-bullet-active" : "",
                            onClick: ()=>{
                                it.clickable && xt(Pt)
                            }
                        }))
                    }), wt)
                }
            }
            ,
            className: st,
            slidesPerGroup: ct,
            pauseOnMouseEnter: ft,
            disableOnInteraction: pt,
            spaceBetween: J,
            children: tt
        })
    }
    ;
    let navPathViews, useProxy$3, proxy$3;
    Breadcrumb = React.memo(function _({list: k}) {
        return jsxRuntimeExports.jsx("div", {
            className: `${navPathViews} ui-breadcrumb`,
            children: k.map((J,et)=>jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [et > 0 && jsxRuntimeExports.jsx(Icon, {
                    name: "Arrow"
                }), jsxRuntimeExports.jsx(Link, {
                    className: cx("path", et === k.length - 1 ? "active" : "hover"),
                    href: et < k.length - 1 ? J.path : "",
                    title: J.label,
                    children: J.label
                })]
            }, et))
        })
    }),
    navPathViews = "n35pyk1",
    {useProxy: useProxy$3, proxy: proxy$3} = valtio;
    class BcdStore extends State {
        constructor(k) {
            super(k),
            _e(this, "initData"),
            _e(this, "isInited", !1),
            this.initData = this.initFn(),
            this.initData.then(()=>this.isInited = !0)
        }
        async initFn() {
            await accountStore.initData,
            accountStore.state.login || accountStore.waitLogin().then(()=>this.initFn());
            try {
                const k = await http.get("/activity/recharge-bonus/dashboard/");
                if (k) {
                    const J = k.expiredTime || 0;
                    let et = k.rechargeValidNum || 0;
                    J < serverTime().getTime() && (et = 4);
                    try {
                        this.setState(_t($t({}, k), {
                            bonusItems: k.bonusItems || [],
                            bonusAmount: k.bonusAmount || "0",
                            bonusThreshold: k.bonusThreshold || "0",
                            expiredTime: J,
                            bonusLog: k.bonusLog || [],
                            firstExpiredTime: k.firstExpiredTime || 0,
                            maxBonusRatio: k.maxBonusRatio || {},
                            registerTime: k.registerTime || 0,
                            releaseAmount: k.releaseAmount || "0",
                            totalAmount: k.totalAmount || "0",
                            rechargeValidNum: et
                        }))
                    } catch (tt) {}
                }
            } catch (k) {}
            return this.state
        }
    }
    bcdStore = new BcdStore(proxy$3({
        bonusAmount: "0",
        bonusThreshold: "10",
        bonusItems: [],
        bonusLog: [],
        expiredTime: 0,
        firstExpiredTime: 0,
        maxBonusRatio: {},
        rechargeValidNum: 0,
        registerTime: 0,
        releaseAmount: "0",
        totalAmount: "0",
        specialDeposit: null,
        currencyName: "",
        currencyPrice: "",
        wagerRatio: "20%",
        fiatRecharge: null
    })),
    useBcd = function() {
        return useProxy$3(bcdStore.state)
    }
    ;
    const $Reader = $protobuf.Reader
      , $Writer = $protobuf.Writer;
    $protobuf.util;
    const $root = $protobuf.roots.user || ($protobuf.roots.user = {})
      , BalanceChange = $root.BalanceChange = (()=>{
        function _(k) {
            if (k)
                for (let J = Object.keys(k), et = 0; et < J.length; ++et)
                    k[J[et]] != null && (this[J[et]] = k[J[et]])
        }
        return _.prototype.frontgroundId = 0,
        _.prototype.amountLogId = "",
        _.prototype.currencyName = "",
        _.prototype.mixedBalance = "",
        _.prototype.generalBalance = "",
        _.prototype.bonusBalance = "",
        _.prototype.mixedChangeAmount = "",
        _.prototype.generalChangeAmount = "",
        _.prototype.bonusChangeAmount = "",
        _.encode = function(k, J) {
            return J || (J = $Writer.create()),
            k.frontgroundId != null && Object.hasOwnProperty.call(k, "frontgroundId") && J.uint32(8).int32(k.frontgroundId),
            k.amountLogId != null && Object.hasOwnProperty.call(k, "amountLogId") && J.uint32(18).string(k.amountLogId),
            k.currencyName != null && Object.hasOwnProperty.call(k, "currencyName") && J.uint32(26).string(k.currencyName),
            k.mixedBalance != null && Object.hasOwnProperty.call(k, "mixedBalance") && J.uint32(34).string(k.mixedBalance),
            k.generalBalance != null && Object.hasOwnProperty.call(k, "generalBalance") && J.uint32(42).string(k.generalBalance),
            k.bonusBalance != null && Object.hasOwnProperty.call(k, "bonusBalance") && J.uint32(50).string(k.bonusBalance),
            k.mixedChangeAmount != null && Object.hasOwnProperty.call(k, "mixedChangeAmount") && J.uint32(58).string(k.mixedChangeAmount),
            k.generalChangeAmount != null && Object.hasOwnProperty.call(k, "generalChangeAmount") && J.uint32(66).string(k.generalChangeAmount),
            k.bonusChangeAmount != null && Object.hasOwnProperty.call(k, "bonusChangeAmount") && J.uint32(74).string(k.bonusChangeAmount),
            J
        }
        ,
        _.decode = function(k, J) {
            k instanceof $Reader || (k = $Reader.create(k));
            let et = J === void 0 ? k.len : k.pos + J
              , tt = new $root.BalanceChange;
            for (; k.pos < et; ) {
                let rt = k.uint32();
                switch (rt >>> 3) {
                case 1:
                    tt.frontgroundId = k.int32();
                    break;
                case 2:
                    tt.amountLogId = k.string();
                    break;
                case 3:
                    tt.currencyName = k.string();
                    break;
                case 4:
                    tt.mixedBalance = k.string();
                    break;
                case 5:
                    tt.generalBalance = k.string();
                    break;
                case 6:
                    tt.bonusBalance = k.string();
                    break;
                case 7:
                    tt.mixedChangeAmount = k.string();
                    break;
                case 8:
                    tt.generalChangeAmount = k.string();
                    break;
                case 9:
                    tt.bonusChangeAmount = k.string();
                    break;
                default:
                    k.skipType(rt & 7);
                    break
                }
            }
            return tt
        }
        ,
        _
    }
    )()
      , {useProxy: useProxy$2, proxy: proxy$2} = valtio
      , Decimal1 = ref$4(new Decimal$1(1))
      , Decimal0$1 = ref$4(new Decimal$1(0));
    class SystemStore extends State {
        constructor(k) {
            super(k),
            _e(this, "initData"),
            _e(this, "getIntl", memoize$1((J,et)=>{
                var tt;
                et = getDefaultLang(et);
                const rt = Intl.NumberFormat(et, {
                    style: "currency",
                    currency: J.replace("FIAT", "")
                });
                return [rt, ((tt = rt.formatToParts(0).find(nt=>nt.type === "currency")) == null ? void 0 : tt.value) || "$"]
            }
            , (J,et)=>J + et)),
            this.initData = this.syncData(),
            isSSR || setInterval(()=>this.syncData(), 3e5)
        }
        amount2usd(k, J) {
            return k.mul(this.getUsdPrice(J))
        }
        convertCurrency(k, J, et="USD") {
            const tt = this.getUsdPrice(et) || Decimal0$1;
            return tt.eq(0) ? Decimal0$1 : k.mul(this.getUsdPrice(J)).div(tt)
        }
        bn2amount(k, J) {
            var et;
            return new Decimal$1(k.toNumber()).div(((et = this.state.currency[J]) == null ? void 0 : et.unitAmount) || 1)
        }
        getUsdPrice(k) {
            return this.state.usdPrice[k] || Decimal0$1
        }
        getCurrency(k) {
            return this.state.currency[k]
        }
        getPrecision(k) {
            var J;
            return ((J = this.state.currency[k]) == null ? void 0 : J.precisionUnit) || 8
        }
        getAlias(k) {
            var J;
            return ((J = this.state.currency[k]) == null ? void 0 : J.aliasCurrencyName) || k
        }
        getCurrencySymbol(k, J) {
            return J = getDefaultLang(J),
            this.getIntl(k, J)[1]
        }
        toFiatStr(k, J, et) {
            return et = getDefaultLang(et),
            J = J.replace(/FIAT$/, ""),
            this.getIntl(J, et)[0].format(k.toNumber())
        }
        toCryptoStr(k, J) {
            k = k.todp(this.getPrecision(J), Decimal$1.ROUND_DOWN);
            const et = Math.max(k.decimalPlaces(), 2);
            return k.toFixed(et)
        }
        async syncData() {
            const k = await http.get("/game/support/system/conf/", {
                cache: !0
            });
            k.currency = k.currencyV2.reduce((it,at)=>(it[at.currencyName] = at,
            it), {});
            const {currency: J, redPackageLimits: et, rewardTypes: tt, rainLimits: rt, usdPrice: nt, gameSockets: ot} = k;
            return Object.assign(this.state, this.formatData({
                currency: J,
                redPackageLimits: et,
                rewardTypes: tt,
                rainLimits: rt,
                usdPrice: nt,
                gameSockets: ot
            })),
            this.state
        }
        formatData(k) {
            function J(et) {
                for (let tt in et)
                    et[tt] = ref$4(new Decimal$1(et[tt]));
                return et
            }
            return k.rainLimits = J(k.rainLimits),
            k.redPackageLimits = J(k.redPackageLimits),
            k.usdPrice = J(k.usdPrice),
            k.usdPrice.USD = Decimal1,
            k.usdPrice.USDFIAT = Decimal1,
            k
        }
    }
    var Ct;
    const navigatorLanguage = ((Ct = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Ct.language) || "en-US";
    function getDefaultLang(_) {
        return _ || navigatorLanguage
    }
    systemStore = new SystemStore(proxy$2({
        currency: {},
        rewardTypes: {},
        usdPrice: {},
        redPackageLimits: {},
        rainLimits: {},
        gameSockets: []
    })),
    system = systemStore,
    useSystem = function() {
        return useProxy$2(systemStore.state)
    }
    ,
    useCurrencyConfig = function(_) {
        return useSystem().currency[_]
    }
    ;
    const {useProxy: useProxy$1, proxy: proxy$1, ref, subscribeKey, subscribe} = valtio
      , Decimal0 = ref(new Decimal$1(0))
      , Decimal_1 = ref(new Decimal$1(-1))
      , dt = class Yr {
        constructor(k) {
            _e(this, "preDeduId", 0),
            _e(this, "deductions", {}),
            _e(this, "state", {}),
            _e(this, "initData"),
            this.state = k,
            this.updateDisplay = debounce(this.updateDisplay, 5e3),
            this.initData = (async()=>{
                const J = localStorage.getItem("amount")
                  , et = this.syncData();
                if (J) {
                    const tt = JSON.parse(J);
                    this.syncDataDict(formatWalletData(tt))
                }
                return et
            }
            )(),
            accountStore.initData.then(()=>{
                subscribeKey(accountStore.state, "login", J=>{
                    J && this.syncData()
                }
                )
            }
            ),
            this.initData.then(()=>{
                const J = new Map;
                Object.values(this.state).forEach(({displayStatus: et, currencyName: tt})=>{
                    J.set(tt, et)
                }
                ),
                subscribe(this.state, ()=>{
                    let et = !1;
                    if (Object.values(this.state).forEach(({displayStatus: tt, currencyName: rt})=>{
                        J.get(rt) !== tt && (et = !0,
                        J.set(rt, tt),
                        tt === 1 ? this.state[rt].display = !0 : tt === 2 && (this.state[rt].display = !1))
                    }
                    ),
                    et) {
                        let tt = [];
                        J.forEach((rt,nt)=>{
                            tt.push({
                                currencyName: nt,
                                status: rt
                            })
                        }
                        ),
                        this.updateDisplay(tt)
                    }
                }
                )
            }
            ),
            userSocket.on("balance-change-v2", socket.decodeBind(this.onBalanceChange.bind(this), BalanceChange))
        }
        createDeduction(k, J, et="nomal", tt=2e4) {
            let rt = Date.now() % Yr.DEDU_MOD;
            rt == this.preDeduId && rt++;
            const nt = {
                id: rt,
                amount: k,
                currencyName: J,
                type: et,
                solved: !1,
                balance: Decimal_1,
                timer: 0
            };
            return tt > 0 && (nt.timer = window.setTimeout(()=>this.deleteDeduction(rt), tt)),
            this.deductions[rt] = nt,
            this.preDeduId = rt,
            this.addDeduction(J, k),
            rt
        }
        createStaticDeduction(k=0) {
            return Yr.DEDU_MOD + k
        }
        onBalanceChange({mixedBalance: k, currencyName: J, mixedChangeAmount: et, generalBalance: tt, bonusBalance: rt, frontgroundId: nt}) {
            const ot = this.state[J];
            if (!ot)
                return;
            let it = this.deductions[nt];
            const at = new Decimal$1(et || 0)
              , lt = new Decimal$1(k || 0);
            it ? (ot.deducting = ref(ot.deducting.add(at)),
            it.amount = it.amount.add(at),
            it.balance = lt,
            it.solved && this.deleteDeduction(it.id)) : nt >= Yr.DEDU_MOD && app.emit("deduction", {
                id: nt,
                amount: at,
                balance: lt,
                currency: J,
                type: "show",
                solved: !0,
                timer: 0
            }),
            Object.assign(ot, {
                amount: ref(lt.sub(ot.deducting)),
                generalAmount: ref(new Decimal$1(tt || 0)),
                bonusAmount: ref(new Decimal$1(rt || 0))
            })
        }
        resolveDeduction(k, J=!0) {
            const et = this.deductions[k];
            et && (J && (et.solved = !0,
            et.balance == Decimal_1) || this.deleteDeduction(et.id, J))
        }
        cancelDeduction(k) {
            Object.values(this.deductions).forEach(J=>{
                J.type === k && this.deleteDeduction(J.id, !1)
            }
            )
        }
        deleteDeduction(k, J=!0) {
            const et = this.deductions[k];
            et && (delete this.deductions[et.id],
            et.timer > 0 && window.clearTimeout(et.timer),
            this.addDeduction(et.currencyName, et.amount.negated()),
            J && app.emit("deduction", et))
        }
        addDeduction(k, J) {
            const et = this.state[k];
            et.amount = ref(et.amount.sub(J)),
            et.deducting = ref(et.deducting.add(J))
        }
        async syncData() {
            const k = await getWallet()
              , J = settingStore.state.currencyName;
            k.find(et=>et.currencyName === J) || settingStore.setState({
                currencyName: k[0].currencyName
            }),
            this.syncDataDict(formatWalletData(k.reduce((et,tt)=>(tt.deducting = Decimal0,
            et[tt.currencyName] = tt,
            et), {})))
        }
        async syncDataDict(k) {
            const J = Object.entries(k).reduce((et,[tt,rt])=>(et[tt] = rt,
            et), {});
            Object.entries(this.state).forEach(([et,tt])=>{
                J[et] && delete J[et]
            }
            ),
            Object.entries(k).forEach(([et,tt])=>{
                const rt = this.state[et];
                if (rt) {
                    let nt = tt
                      , {bonusAmount: ot, amount: it, generalAmount: at, deducting: lt} = nt
                      , st = Kt(nt, ["bonusAmount", "amount", "generalAmount", "deducting"]);
                    rt.bonusAmount.eq(ot) || (rt.bonusAmount = ref(ot)),
                    rt.amount.eq(it) || (rt.amount = ref(it)),
                    rt.generalAmount.eq(at) || (rt.generalAmount = ref(at)),
                    Object.assign(this.state[et], st)
                } else
                    this.state[et] = tt
            }
            )
        }
        updateDisplay(k) {
            http.post("/user/amount/display/", {
                list: k
            })
        }
    }
    ;
    _e(dt, "DEDU_MOD", 20736e5);
    let Wallet = dt;
    function formatWalletData(_) {
        return Object.entries(_).forEach(([k,J])=>{
            J.deducting = ref(new Decimal$1(J.deducting)),
            J.amount = ref(new Decimal$1(J.amount)),
            J.bonusAmount = ref(new Decimal$1(J.bonusAmount)),
            J.generalAmount = ref(new Decimal$1(J.generalAmount))
        }
        ),
        _
    }
    walletStore = new Wallet(proxy$1({})),
    wallet = walletStore,
    useWallet = function(_) {
        return useProxy$1(_ ? walletStore.state[_] : walletStore.state)
    }
    ,
    useLocalCurrency = function(_=!1) {
        let {localeCurrencyName: k, enableLocaleCurrency: J} = useSetting();
        const {i18n: et} = useTranslation$1()
          , tt = et.language;
        return J = J || _,
        k = J ? k : "",
        reactExports.useMemo(()=>{
            if (k) {
                const rt = {
                    currencyName: k,
                    local2amount: (nt,ot="USD")=>systemStore.convertCurrency(nt, k, ot),
                    amount2local: (nt,ot="USD")=>systemStore.convertCurrency(nt, ot, k),
                    amount2localStr: (nt,ot="USD")=>systemStore.toFiatStr(rt.amount2local(nt, ot), k, tt)
                };
                return rt
            } else
                return {
                    currencyName: k,
                    local2amount: (rt,nt="USD")=>rt,
                    amount2local: (rt,nt="USD")=>rt,
                    amount2localStr: (rt,nt="USD")=>systemStore.toCryptoStr(rt, nt)
                }
        }
        , [k, tt])
    }
    ,
    requestRecaptcha = async function(_) {
        return captchaClient || detectCaptcha(),
        (captchaClient == null ? void 0 : captchaClient.request(_)) || "No captcha!"
    }
    ;
    class Captcha {
        constructor(k) {
            _e(this, "key"),
            _e(this, "inited"),
            _e(this, "timeout", 0),
            this.key = k,
            this.inited = delay(8e3).then(()=>this.init())
        }
        async request(k) {
            await this.inited;
            const J = [this.requestCode(k)];
            return this.timeout > 0 && J.push(delay(this.timeout).then(()=>"time out")),
            await Promise.race(J)
        }
    }
    class Recaptcha extends Captcha {
        constructor() {
            super(...arguments),
            _e(this, "timeout", 8e3)
        }
        async init() {
            return await loadScript(`https://www.google.com/recaptcha/api.js?render=${this.key}`),
            new Promise(k=>{
                grecaptcha.ready(k)
            }
            )
        }
        async requestCode(k) {
            return env.isDev ? "" : grecaptcha.execute(this.key, {
                action: k
            })
        }
    }
    isSSR || setTimeout(()=>{
        detectCaptcha()
    }
    , 1e4);
    class Hcaptcha extends Captcha {
        async init() {
            await loadScript("https://js.hcaptcha.com/1/api.js");
            const k = "hcaptcha_container"
              , J = document.createElement("div");
            J.id = k,
            J.style.display = "none",
            document.body.appendChild(J),
            hcaptcha.render(k, {
                size: "invisible",
                sitekey: this.key
            })
        }
        async requestCode(k) {
            return env.isDev ? "" : (await hcaptcha.execute({
                async: !0
            })).response
        }
    }
    let captchaClient = null;
    function detectCaptcha() {
        const _ = env.RECAPTCHA_V3_ID
          , k = env.HCAPTCHA_ID;
        k ? captchaClient = new Hcaptcha(k) : _ && (captchaClient = new Recaptcha(_))
    }
    const CoinIcon = React.memo(function _(et) {
        var tt = et
          , {name: k} = tt
          , J = Kt(tt, ["name"]);
        const rt = `/coin/${systemStore.getAlias(k)}.black.png`;
        return jsxRuntimeExports.jsx("img", $t({
            className: "coin-icon",
            src: rt
        }, J))
    })
      , defaultSignStr = ["+", ""]
      , CoinFormat = React.memo(function _(lt) {
        var st = lt
          , {name: k, amount: J, className: et, icon: tt=!1, showName: rt=!1, disableLocal: nt=!1, sign: ot=!1, signStrs: it=defaultSignStr} = st
          , at = Kt(st, ["name", "amount", "className", "icon", "showName", "disableLocal", "sign", "signStrs"]);
        const ut = useLocalCurrency()
          , {enableLocaleCurrency: ct} = useSetting()
          , pt = !!systemStore.getUsdPrice(k).toNumber();
        let ft = nt ? systemStore.toCryptoStr(new Decimal$1(J), k) : ut.amount2localStr(new Decimal$1(J), k);
        return !tt && rt && (ft += ` ${systemStore.getAlias(k)}`),
        jsxRuntimeExports.jsxs("div", _t($t({
            className: cx(coinFormatWrap, "coin", "notranslate", et, ot && "has-sign")
        }, at), {
            children: [jsxRuntimeExports.jsx("div", {
                className: "amount amount-str",
                children: pt ? ft : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [systemStore.toCryptoStr(new Decimal$1(J), k), " ", ct && jsxRuntimeExports.jsx("span", {
                        className: "worthless",
                        children: systemStore.getAlias(k)
                    })]
                })
            }), tt && jsxRuntimeExports.jsx(CoinIcon, {
                name: k
            })]
        }))
    })
      , coinFormatWrap = "cq8kbks";
    VipLevelStatus = (_=>(_[_.None = 0] = "None",
    _[_.Bronze = 1] = "Bronze",
    _[_.Silver = 2] = "Silver",
    _[_.Gold = 3] = "Gold",
    _[_.Platinum_I = 4] = "Platinum_I",
    _[_.Platinum_II = 5] = "Platinum_II",
    _[_.Diamond_I = 6] = "Diamond_I",
    _[_.Diamond_II = 7] = "Diamond_II",
    _[_.Diamond_III = 8] = "Diamond_III",
    _))(VipLevelStatus || {});
    const vipLevelsList = [{
        level: 0,
        xp: 0,
        type: 0
    }, {
        level: 1,
        xp: 1,
        type: 0
    }, {
        level: 2,
        xp: 100,
        type: 1
    }, {
        level: 3,
        xp: 200,
        type: 1
    }, {
        level: 4,
        xp: 1e3,
        type: 1
    }, {
        level: 5,
        xp: 2e3,
        type: 1
    }, {
        level: 6,
        xp: 3e3,
        type: 1
    }, {
        level: 7,
        xp: 4e3,
        type: 1
    }, {
        level: 8,
        xp: 5e3,
        type: 2
    }, {
        level: 9,
        xp: 7e3,
        type: 2
    }, {
        level: 10,
        xp: 9e3,
        type: 2
    }, {
        level: 11,
        xp: 11e3,
        type: 2
    }, {
        level: 12,
        xp: 13e3,
        type: 2
    }, {
        level: 13,
        xp: 15e3,
        type: 2
    }, {
        level: 14,
        xp: 17e3,
        type: 2
    }, {
        level: 15,
        xp: 21e3,
        type: 2
    }, {
        level: 16,
        xp: 25e3,
        type: 2
    }, {
        level: 17,
        xp: 29e3,
        type: 2
    }, {
        level: 18,
        xp: 33e3,
        type: 2
    }, {
        level: 19,
        xp: 37e3,
        type: 2
    }, {
        level: 20,
        xp: 41e3,
        type: 2
    }, {
        level: 21,
        xp: 45e3,
        type: 2
    }, {
        level: 22,
        xp: 49e3,
        type: 3
    }, {
        level: 23,
        xp: 59e3,
        type: 3
    }, {
        level: 24,
        xp: 69e3,
        type: 3
    }, {
        level: 25,
        xp: 79e3,
        type: 3
    }, {
        level: 26,
        xp: 89e3,
        type: 3
    }, {
        level: 27,
        xp: 99e3,
        type: 3
    }, {
        level: 28,
        xp: 109e3,
        type: 3
    }, {
        level: 29,
        xp: 119e3,
        type: 3
    }, {
        level: 30,
        xp: 129e3,
        type: 3
    }, {
        level: 31,
        xp: 153e3,
        type: 3
    }, {
        level: 32,
        xp: 177e3,
        type: 3
    }, {
        level: 33,
        xp: 201e3,
        type: 3
    }, {
        level: 34,
        xp: 225e3,
        type: 3
    }, {
        level: 35,
        xp: 249e3,
        type: 3
    }, {
        level: 36,
        xp: 273e3,
        type: 3
    }, {
        level: 37,
        xp: 297e3,
        type: 3
    }, {
        level: 38,
        xp: 321e3,
        type: 4
    }, {
        level: 39,
        xp: 377e3,
        type: 4
    }, {
        level: 40,
        xp: 433e3,
        type: 4
    }, {
        level: 41,
        xp: 489e3,
        type: 4
    }, {
        level: 42,
        xp: 545e3,
        type: 4
    }, {
        level: 43,
        xp: 601e3,
        type: 4
    }, {
        level: 44,
        xp: 657e3,
        type: 4
    }, {
        level: 45,
        xp: 713e3,
        type: 4
    }, {
        level: 46,
        xp: 769e3,
        type: 4
    }, {
        level: 47,
        xp: 897e3,
        type: 4
    }, {
        level: 48,
        xp: 1025e3,
        type: 4
    }, {
        level: 49,
        xp: 1153e3,
        type: 4
    }, {
        level: 50,
        xp: 1281e3,
        type: 4
    }, {
        level: 51,
        xp: 1409e3,
        type: 4
    }, {
        level: 52,
        xp: 1537e3,
        type: 4
    }, {
        level: 53,
        xp: 1665e3,
        type: 4
    }, {
        level: 54,
        xp: 1793e3,
        type: 4
    }, {
        level: 55,
        xp: 2081e3,
        type: 4
    }, {
        level: 56,
        xp: 2369e3,
        type: 5
    }, {
        level: 57,
        xp: 2657e3,
        type: 5
    }, {
        level: 58,
        xp: 2945e3,
        type: 5
    }, {
        level: 59,
        xp: 3233e3,
        type: 5
    }, {
        level: 60,
        xp: 3521e3,
        type: 5
    }, {
        level: 61,
        xp: 3809e3,
        type: 5
    }, {
        level: 62,
        xp: 4097e3,
        type: 5
    }, {
        level: 63,
        xp: 4737e3,
        type: 5
    }, {
        level: 64,
        xp: 5377e3,
        type: 5
    }, {
        level: 65,
        xp: 6017e3,
        type: 5
    }, {
        level: 66,
        xp: 6657e3,
        type: 5
    }, {
        level: 67,
        xp: 7297e3,
        type: 5
    }, {
        level: 68,
        xp: 7937e3,
        type: 5
    }, {
        level: 69,
        xp: 8577e3,
        type: 5
    }, {
        level: 70,
        xp: 9217e3,
        type: 6
    }, {
        level: 71,
        xp: 10625e3,
        type: 6
    }, {
        level: 72,
        xp: 12033e3,
        type: 6
    }, {
        level: 73,
        xp: 13441e3,
        type: 6
    }, {
        level: 74,
        xp: 14849e3,
        type: 6
    }, {
        level: 75,
        xp: 16257e3,
        type: 6
    }, {
        level: 76,
        xp: 17665e3,
        type: 6
    }, {
        level: 77,
        xp: 19073e3,
        type: 6
    }, {
        level: 78,
        xp: 20481e3,
        type: 6
    }, {
        level: 79,
        xp: 23553e3,
        type: 6
    }, {
        level: 80,
        xp: 26625e3,
        type: 6
    }, {
        level: 81,
        xp: 29697e3,
        type: 6
    }, {
        level: 82,
        xp: 32769e3,
        type: 6
    }, {
        level: 83,
        xp: 35841e3,
        type: 6
    }, {
        level: 84,
        xp: 38913e3,
        type: 6
    }, {
        level: 85,
        xp: 41985e3,
        type: 7
    }, {
        level: 86,
        xp: 45057e3,
        type: 7
    }, {
        level: 87,
        xp: 51713e3,
        type: 7
    }, {
        level: 88,
        xp: 58369e3,
        type: 7
    }, {
        level: 89,
        xp: 65025e3,
        type: 7
    }, {
        level: 90,
        xp: 71681e3,
        type: 7
    }, {
        level: 91,
        xp: 78337e3,
        type: 7
    }, {
        level: 92,
        xp: 84993e3,
        type: 7
    }, {
        level: 93,
        xp: 91649e3,
        type: 7
    }, {
        level: 94,
        xp: 98305e3,
        type: 7
    }, {
        level: 95,
        xp: 112641e3,
        type: 7
    }, {
        level: 96,
        xp: 126977e3,
        type: 7
    }, {
        level: 97,
        xp: 141313e3,
        type: 7
    }, {
        level: 98,
        xp: 155649e3,
        type: 7
    }, {
        level: 99,
        xp: 169985e3,
        type: 7
    }, {
        level: 100,
        xp: 184321e3,
        type: 7
    }, {
        level: 101,
        xp: 198657e3,
        type: 7
    }, {
        level: 102,
        xp: 212993e3,
        type: 7
    }, {
        level: 103,
        xp: 243713e3,
        type: 7
    }, {
        level: 104,
        xp: 274433e3,
        type: 7
    }, {
        level: 105,
        xp: 305153e3,
        type: 7
    }, {
        level: 106,
        xp: 335873e3,
        type: 7
    }, {
        level: 107,
        xp: 366593e3,
        type: 8
    }, {
        level: 108,
        xp: 397313e3,
        type: 8
    }, {
        level: 109,
        xp: 428033e3,
        type: 8
    }, {
        level: 110,
        xp: 458753e3,
        type: 8
    }, {
        level: 111,
        xp: 524289e3,
        type: 8
    }, {
        level: 112,
        xp: 589825e3,
        type: 8
    }, {
        level: 113,
        xp: 655361e3,
        type: 8
    }, {
        level: 114,
        xp: 720897e3,
        type: 8
    }, {
        level: 115,
        xp: 786433e3,
        type: 8
    }, {
        level: 116,
        xp: 851969e3,
        type: 8
    }, {
        level: 117,
        xp: 917505e3,
        type: 8
    }, {
        level: 118,
        xp: 983041e3,
        type: 8
    }, {
        level: 119,
        xp: 1122305e3,
        type: 8
    }, {
        level: 120,
        xp: 1261569e3,
        type: 8
    }, {
        level: 121,
        xp: 1400833e3,
        type: 8
    }, {
        level: 122,
        xp: 1540097e3,
        type: 8
    }, {
        level: 123,
        xp: 1679361e3,
        type: 8
    }, {
        level: 124,
        xp: 1818625e3,
        type: 8
    }, {
        level: 125,
        xp: 1957889e3,
        type: 8
    }, {
        level: 126,
        xp: 2097153e3,
        type: 8
    }, {
        level: 127,
        xp: 2392065e3,
        type: 8
    }, {
        level: 128,
        xp: 2686977e3,
        type: 8
    }, {
        level: 129,
        xp: 2981889e3,
        type: 8
    }, {
        level: 130,
        xp: 3276801e3,
        type: 8
    }, {
        level: 131,
        xp: 3571713e3,
        type: 8
    }, {
        level: 132,
        xp: 3866625e3,
        type: 8
    }, {
        level: 133,
        xp: 4161537e3,
        type: 8
    }, {
        level: 134,
        xp: 4456449e3,
        type: 8
    }, {
        level: 135,
        xp: 5079041e3,
        type: 8
    }, {
        level: 136,
        xp: 5701633e3,
        type: 8
    }, {
        level: 137,
        xp: 6324225e3,
        type: 8
    }, {
        level: 138,
        xp: 6946817e3,
        type: 8
    }, {
        level: 139,
        xp: 7569409e3,
        type: 8
    }, {
        level: 140,
        xp: 8192001e3,
        type: 8
    }, {
        level: 141,
        xp: 8814593e3,
        type: 8
    }, {
        level: 142,
        xp: 9437185e3,
        type: 8
    }, {
        level: 143,
        xp: 10747905e3,
        type: 8
    }, {
        level: 144,
        xp: 12058625e3,
        type: 8
    }]
      , maxLevel = 144
      , overLevelXp = 139264e3
      , Oe = class hr {
        constructor(k) {
            _e(this, "userId", 0),
            _e(this, "name", ""),
            _e(this, "nameId", ""),
            _e(this, "key", ""),
            _e(this, "isCasino", !1),
            _e(this, "isOnline", !1),
            _e(this, "lastSyncOnlineTime", 0);
            let J = hr.userDict[k.userId];
            return J || (this.userId = k.userId,
            hr.addCache(this),
            J = this),
            k.name == hr.hiddenName || k.name && J.name !== k.name && (J.name = k.name,
            J.nameId = this.getNameId(J.name),
            J.key = this.nameId.toLowerCase()),
            J
        }
        async syncOnlineStatus() {
            const k = Date.now();
            k - this.lastSyncOnlineTime > 36e5 && (this.lastSyncOnlineTime = k,
            hr.syncOnline(this))
        }
        getNameId(k="") {
            k = k.replace(/\s(\w?)/, (tt,rt)=>rt.toUpperCase());
            let J = k.toLowerCase()
              , et = 1;
            for (; hr.keyDict[J]; )
                k = k + et,
                J = k.toLowerCase(),
                et++;
            return k
        }
        static search(k) {
            return k = k.toLowerCase(),
            hr.userList.filter(J=>J.userId != 0 && J.name && J.key.indexOf(k) != -1)
        }
        static findByName(k) {
            return hr.userList.find(J=>J.userId != 0 && J.name === k)
        }
        static findByKey(k) {
            return k = k.toLowerCase(),
            hr.userList.find(J=>J.userId != 0 && J.key === k)
        }
        static isFirend(k) {
            return hr.firendDict[k]
        }
        static addCache(k) {
            if (hr.userDict[k.userId] = k,
            hr.userList.push(k),
            hr.keyDict[k.nameId] = k,
            hr.userList.length > hr.MAX) {
                const J = hr.userList.shift();
                if (J == null)
                    return;
                delete hr.userDict[J.userId],
                delete hr.keyDict[J.nameId]
            }
        }
        static getName(k) {
            return k === hr.hiddenName ? instance.t("Hidden", {
                ns: instance.options.defaultNS
            }) : k
        }
    }
    ;
    _e(Oe, "MAX", 5e3),
    _e(Oe, "userList", []),
    _e(Oe, "userDict", {}),
    _e(Oe, "keyDict", {}),
    _e(Oe, "firendDict", {}),
    _e(Oe, "hiddenName", "****"),
    _e(Oe, "syncOnline", debounceQueue(_=>{
        const k = _.map(J=>J.userId);
        http.post("/account/online/status/", {
            userIds: k
        }).then(J=>{
            _.forEach(et=>{
                et.isOnline = J.indexOf(et.userId) != -1
            }
            )
        }
        )
    }
    , 2e3)),
    User = Oe;
    const {proxy, useProxy} = valtio;
    class UserRankStore {
        constructor() {
            _e(this, "state", proxy({
                list: []
            })),
            this.init()
        }
        async init() {
            const k = await http.get("/activity/contest/daily/list/");
            this.state.list = k
        }
        getRank(k) {
            for (const J of this.state.list)
                if (J.userId === k)
                    return J.rank;
            return 0
        }
    }
    const userRankStore = new UserRankStore
      , hiddenAvatar = "common/avatar.png"
      , logoPng = "logo/black.png"
      , Avatar = React.memo(function _(it) {
        var at = it
          , {userId: k, name: J, className: et="", size: tt="s", tooltip: rt=!1, showCrown: nt=!1} = at
          , ot = Kt(at, ["userId", "name", "className", "size", "tooltip", "showCrown"]);
        const lt = new User({
            userId: k,
            name: J
        })
          , st = useAccount();
        let ut = "";
        isSSR || (ut = `//img2.distributedresourcestorage.com/avatar/${k}/${tt}`,
        lt.userId === st.userId && (ut += `?t=${st.avatarUpdateTime}`)),
        J === User.hiddenName && (ut = app.assets(hiddenAvatar)),
        J === "BCGame" && (ut = app.assets(logoPng));
        const ct = userRankStore.getRank(k);
        return jsxRuntimeExports.jsx(WithOutSsr, {
            children: jsxRuntimeExports.jsxs("div", {
                className: `${avatarWrap} ${et}`,
                children: [jsxRuntimeExports.jsx("img", $t({
                    className: cx("avatar", ct > 3 && nt && "top-green", ct > 0 && ct <= 3 && nt && "top-yellow"),
                    src: ut
                }, ot)), ct === 1 && nt && jsxRuntimeExports.jsx(Icon_Crown, {})]
            })
        })
    })
      , UserRank = React.memo(function({userId: _}) {
        const k = userRankStore.getRank(_)
          , {t: J} = useTranslation(instance.options.defaultNS);
        return k > 0 ? jsxRuntimeExports.jsx("div", {
            className: userRankWrap,
            children: jsxRuntimeExports.jsx(Tooltip, {
                title: J("Daily Wager Contest Top{{rank}}", {
                    rank: k
                }),
                children: jsxRuntimeExports.jsxs("div", {
                    className: cx("label", k > 3 && "green"),
                    children: ["top", k]
                })
            })
        }) : null
    })
      , UserInfo = React.memo(function _(st) {
        var ut = st
          , {userId: k, name: J, avatar: et=!0, className: tt="", tooltip: rt=!1, children: nt, onClick: ot, at: it=!1, showName: at=!0} = ut
          , lt = Kt(ut, ["userId", "name", "avatar", "className", "tooltip", "children", "onClick", "at", "showName"]);
        let ct = `#/user/profile/${new User({
            userId: k,
            name: J
        }).userId}`;
        return J === User.hiddenName && (ct = ""),
        jsxRuntimeExports.jsxs(Link, _t($t({
            href: ct,
            className: cx(userWrap, "user-info", tt),
            onClick: ot
        }, lt), {
            children: [et && jsxRuntimeExports.jsx(Avatar, {
                tooltip: rt,
                userId: k,
                name: J
            }), at && jsxRuntimeExports.jsx(UserName, {
                at: it,
                className: "name",
                userId: k,
                name: J
            }), nt]
        }))
    })
      , UserName = React.memo(function _(rt) {
        var nt = rt
          , {userId: k, name: J, at: et=!1} = nt
          , tt = Kt(nt, ["userId", "name", "at"]);
        const ot = useAccount()
          , {t: it} = useTranslation(instance.options.defaultNS)
          , at = new User({
            userId: k,
            name: J
        });
        let lt;
        const st = J === User.hiddenName;
        return st ? lt = jsxRuntimeExports.jsxs("span", {
            className: "hidden-name",
            children: [jsxRuntimeExports.jsx(Icon, {
                name: "Hidden"
            }), it("Hidden")]
        }) : at.userId === ot.userId ? lt = jsxRuntimeExports.jsx(MyName, {}) : lt = J,
        jsxRuntimeExports.jsxs("div", _t($t({}, tt), {
            children: [et && !st && "@", lt]
        }))
    })
      , MyName = React.memo(function _() {
        const k = useAccount();
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: k.name
        })
    })
      , UserTitle = React.memo(function({code: _, desc: k, className: J}) {
        if (_.length == 0)
            return null;
        const et = _.find(ot=>ot === 80)
          , tt = Math.max(..._)
          , rt = et || tt
          , nt = (ot,it)=>it === rt ? ot : null;
        return jsxRuntimeExports.jsx("div", {
            className: cx(titleViews, J),
            children: _.map((ot,it)=>{
                let at = null, lt;
                switch (ot) {
                case 1:
                    at = jsxRuntimeExports.jsx(Icon_Badge, {}, it);
                    break;
                case 2:
                    at = jsxRuntimeExports.jsx(Icon_Diamond, {}, it);
                    break;
                case 3:
                    at = jsxRuntimeExports.jsx(Icon_Diamond, {}, it);
                    break;
                case 4:
                    at = jsxRuntimeExports.jsx(Icon_Crown, {}, it);
                    break;
                case -1:
                    at = jsxRuntimeExports.jsx(Icon, {
                        name: "Official",
                        className: "bc-game"
                    }, it);
                    break;
                case 97:
                    at = nt(jsxRuntimeExports.jsx("span", {
                        className: "xicon-mark xicon-mark-bot",
                        children: "BUGER BOT"
                    }, it), 97);
                    break;
                case 80:
                    if (lt = k && k[it],
                    !lt)
                        at = nt(jsxRuntimeExports.jsx("span", {
                            className: "xicon-mark xicon-mark-mod",
                            style: {
                                backgroundColor: "#bf6ba2"
                            },
                            children: "Host"
                        }, it), 80);
                    else {
                        const {name: st, color: ut} = getTitleColor(lt);
                        at = nt(jsxRuntimeExports.jsx("span", {
                            className: "xicon-mark xicon-mark-mod",
                            style: {
                                backgroundColor: ut || "#bf6ba2"
                            },
                            children: st || "Host"
                        }, it), 80)
                    }
                    break;
                case 89:
                    lt = k && k[it],
                    at = nt(jsxRuntimeExports.jsx("span", {
                        className: "xicon-mark xicon-mark-admin",
                        children: lt || "Admin"
                    }, it), 89);
                    break;
                case 98:
                    lt = k && k[it],
                    at = nt(jsxRuntimeExports.jsx("span", {
                        className: "xicon-mark xicon-mark-mod",
                        children: lt || "Mod"
                    }, it), 98);
                    break
                }
                return at
            }
            )
        })
    })
      , Icon_Badge = ()=>jsxRuntimeExports.jsx("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsxRuntimeExports.jsx("path", {
            fill: "#eb5858",
            d: "M26.026 18.723c-0.16 0.333-0.328 0.661-0.477 0.999-0.197 0.447-0.329 0.909-0.355 1.405-0.027 0.526-0.294 0.922-0.778 1.144-0.141 0.062-0.294 0.094-0.448 0.096-0.635 0.011-1.272 0.007-1.907 0.005-0.201 0-0.219-0.026-0.114-0.205 0.197-0.338 0.419-0.642 0.795-0.822 0.46-0.22 0.699-0.909 0.561-1.433-0.109-0.415-0.345-0.754-0.579-1.1-0.368-0.544-0.641-1.131-0.601-1.806 0.017-0.274 0.112-0.544 0.178-0.815 0.018-0.075 0.057-0.144 0.086-0.216l-0.057-0.028c-0.099 0.186-0.217 0.365-0.294 0.561-0.26 0.666-0.129 1.305 0.178 1.92 0.097 0.193 0.227 0.37 0.334 0.558 0.034 0.060 0.072 0.145 0.054 0.203-0.177 0.584-0.323 1.184-0.565 1.743-0.166 0.382-0.309 0.77-0.455 1.158-0.075 0.2-0.215 0.29-0.435 0.288-0.699-0.008-1.398-0.002-2.096-0.003-0.217 0-0.24-0.024-0.164-0.225 0.072-0.198 0.158-0.391 0.257-0.577 0.111-0.203 0.291-0.324 0.521-0.388 0.386-0.107 0.571-0.404 0.598-0.776 0.031-0.432 0.011-0.868 0.015-1.302 0.001-0.14-0.092-0.133-0.189-0.127-0.674 0.043-1.348 0.112-2.022 0.123-0.766 0.011-1.533-0.029-2.299-0.048-0.116-0.003-0.154-0.049-0.101-0.164 0.217-0.472 0.312-0.978 0.392-1.486 0.009-0.065-0.001-0.131-0.031-0.19-0.079 0.173-0.152 0.349-0.24 0.518-0.168 0.323-0.32 0.661-0.528 0.958-0.189 0.271-0.228 0.579-0.325 0.873-0.149 0.45-0.251 0.923-0.462 1.342-0.223 0.444-0.544 0.842-0.834 1.251-0.12 0.168-0.306 0.223-0.515 0.221-0.687-0.005-1.374 0-2.061 0.001-0.232 0-0.248-0.026-0.133-0.232 0.177-0.318 0.378-0.616 0.703-0.802 0.078-0.044 0.174-0.056 0.253-0.098 0.127-0.068 0.289-0.121 0.362-0.23 0.278-0.415 0.311-0.904 0.375-1.38-0.131 0.306-0.246 0.621-0.396 0.919-0.152 0.301-0.388 0.523-0.73 0.604-0.355 0.084-0.555 0.34-0.724 0.637-0.164 0.289-0.383 0.516-0.728 0.573-0.106 0.017-0.217 0.009-0.325 0.009-0.602 0.001-1.203 0.002-1.804 0-0.24-0.001-0.257-0.020-0.17-0.239 0.183-0.46 0.468-0.806 0.973-0.96 0.42-0.128 0.71-0.45 0.964-0.797 0.331-0.451 0.594-0.936 0.708-1.491 0.029-0.141 0.005-0.249-0.117-0.346-0.487-0.388-0.975-0.775-1.446-1.182-0.333-0.287-0.637-0.608-0.957-0.91-0.416-0.393-0.93-0.598-1.472-0.737-0.575-0.148-1.161-0.21-1.754-0.163-0.221 0.017-0.44 0.069-0.659 0.109-0.356 0.066-0.712 0.121-1.057-0.045-0.014-0.007-0.024-0.020-0.056-0.046l0.268-0.026 0.002-0.039c-0.162-0.040-0.323-0.084-0.487-0.118-0.13-0.027-0.223-0.067-0.274-0.215-0.036-0.103-0.14-0.192-0.231-0.266-0.186-0.154-0.239-0.306-0.094-0.482 0.091-0.11 0.237-0.216 0.373-0.241 0.487-0.090 0.849-0.343 1.12-0.747 0.635-0.945 1.46-1.653 2.562-1.989 0.406-0.124 0.831-0.157 1.256-0.067 0.056 0.012 0.133-0.018 0.182-0.053 0.078-0.056 0.136-0.14 0.213-0.198 0.283-0.213 0.635-0.061 0.669 0.291 0.015 0.152 0.003 0.306 0.003 0.491 0.047-0.069 0.087-0.114 0.112-0.167 0.085-0.181 0.208-0.267 0.423-0.28 0.886-0.052 1.771-0.156 2.657-0.044 0.278 0.035 0.469-0.105 0.688-0.203 0.645-0.289 1.306-0.558 2.019-0.551 0.456 0.004 0.855-0.107 1.267-0.274 1.452-0.589 2.96-0.885 4.529-0.724 0.492 0.050 0.978 0.177 1.458 0.301 0.737 0.191 1.454 0.443 2.134 0.795 1.181 0.612 1.977 1.569 2.509 2.767 0.479 1.079 0.762 2.215 0.927 3.379 0.066 0.469 0.303 0.848 0.54 1.228 0.412 0.659 0.836 1.311 1.283 1.947 0.235 0.334 0.5 0.655 0.904 0.819 0.16 0.065 0.192 0.249 0.047 0.345-0.2 0.133-0.423 0.266-0.654 0.312-0.816 0.163-1.512-0.094-2.089-0.684-0.53-0.542-0.855-1.195-1.037-1.926-0.019-0.074-0.048-0.146-0.073-0.219l-0.053-0.007zM2.994 14.481c0.135 0.148 0.141 0.165 0.023 0.364-0.081 0.136-0.050 0.201 0.095 0.254 0.287 0.107 0.599 0.123 0.895 0.045 0.816-0.215 1.645-0.327 2.484-0.408 1.239-0.119 2.447 0.015 3.629 0.374 0.715 0.217 1.415 0.485 2.122 0.728 0.032 0.011 0.071 0.001 0.125 0.001-0.023-0.054-0.031-0.094-0.053-0.124-0.461-0.618-0.904-1.251-1.394-1.845-0.344-0.417-0.783-0.745-1.281-0.956-0.461-0.197-0.942-0.209-1.431-0.204-0.426 0.004-0.809 0.133-1.168 0.349-0.465 0.28-0.922 0.575-1.396 0.838-0.304 0.168-0.633 0.301-0.998 0.221-0.21-0.046-0.253-0.125-0.142-0.31 0.129-0.215 0.263-0.431 0.426-0.619 0.507-0.584 1.106-1.042 1.86-1.264 0.221-0.065 0.447-0.113 0.721-0.182-0.136-0.039-0.226-0.077-0.319-0.089-0.396-0.050-0.776 0.024-1.136 0.189-0.855 0.394-1.51 1.019-2.030 1.792-0.153 0.227-0.334 0.419-0.567 0.563-0.154 0.095-0.309 0.19-0.466 0.286zM5.235 13.597c0.123-0.051 0.233-0.082 0.325-0.142 0.060-0.039 0.090-0.121 0.077-0.168s-0.061-0.101-0.153-0.104c-0.108-0.002-0.215 0.025-0.308 0.080-0.070 0.043-0.115 0.117-0.121 0.199-0.004 0.075 0.046 0.168 0.181 0.134z"
        })
    })
      , Icon_Diamond = ()=>jsxRuntimeExports.jsx("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsxRuntimeExports.jsx("path", {
            fill: "#d169e6",
            d: "M24.699 7.987h-17.489l-4.983 6.559 13.724 15.455 13.724-15.455-4.976-6.559zM25.41 14.969c-0.661 0.021-2.224 0.162-3.076 1.021-0.901 0.901-1.013 2.59-1.028 3.181-0.014-0.605-0.12-2.372-1.048-3.294-0.859-0.852-2.463-0.929-3.097-0.922-0.162 0.007-0.267 0.007-0.267 0.007s0.099-0.007 0.267-0.007c0.605-0.035 2.097-0.204 2.949-1.048 1.063-1.063 1.183-3.090 1.197-3.329v0c-0.007 0.239-0.056 2.372 0.985 3.406 0.852 0.859 2.449 0.971 3.118 0.985 0.19-0.007 0.31-0.007 0.31-0.007s-0.12 0.007-0.31 0.007zM21.828 1.998c0 0-0.078 1.506 0.633 2.217s2.217 0.633 2.217 0.633-1.478-0.049-2.189 0.661c-0.711 0.711-0.661 2.189-0.661 2.189s0.049-1.534-0.676-2.259c-0.697-0.697-2.175-0.584-2.175-0.584s1.379 0.014 2.076-0.683c0.732-0.739 0.774-2.175 0.774-2.175zM27.831 5.165c0 0-0.056 1.028 0.429 1.513s1.513 0.429 1.513 0.429-1.006-0.035-1.492 0.45c-0.485 0.486-0.451 1.492-0.451 1.492s0.035-1.049-0.465-1.541c-0.472-0.479-1.485-0.401-1.485-0.401s0.943 0.007 1.415-0.465c0.5-0.492 0.535-1.478 0.535-1.478z"
        })
    })
      , Icon_Crown = ()=>jsxRuntimeExports.jsx("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsxRuntimeExports.jsx("path", {
            fill: "#ffd308",
            d: "M27.924 14.807l-4.892 11.74h-14.063l-4.892-11.74c-1.198-0.105-2.14-1.099-2.14-2.324 0-1.294 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 0.498-0.157 0.957-0.421 1.336 0.827 1.307 2.274 2.18 3.937 2.18 2.182 0 3.999-1.497 4.522-3.516l0.035-0.197 0.131-2.472c-0.698-0.406-1.172-1.153-1.172-2.019 0-1.295 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 0.866-0.474 1.613-1.172 2.019l0.082 2.434 0.084 0.235c0.523 2.018 2.341 3.516 4.522 3.516 1.663 0 3.109-0.873 3.937-2.18-0.264-0.379-0.421-0.839-0.421-1.336 0-1.294 1.049-2.344 2.344-2.344s2.344 1.049 2.344 2.344c0 1.225-0.942 2.218-2.14 2.324z"
        })
    });
    function getTitleColor(_) {
        if (_.search(/\$\[#.+/) !== -1) {
            const k = _.match(/\$\[(#.+)\](.+)/);
            return {
                color: k && k[1],
                name: k && k[2]
            }
        } else
            return {
                color: null,
                name: _
            }
    }
    const levelColor = ["#B1CAEB", "#E09A6A", "#E1E1E1", "#FFC329", "#9D63F6", "#9D63F6", "#F450A9", "#F450A9", "#F450A9"]
      , getLevelInfo = _=>{
        const k = vipLevelsList.length;
        if (_ < 0)
            return vipLevelsList[0];
        if (_ >= k) {
            const J = _ - k + 1
              , et = vipLevelsList[k - 1].xp + J * overLevelXp;
            return {
                level: _,
                xp: et,
                type: VipLevelStatus.Diamond_III
            }
        }
        return vipLevelsList[_]
    }
      , getUserLevelInfo = _=>{
        const k = _ > 69
          , J = k ? "svip" : "vip"
          , et = k ? _ - 69 : _
          , tt = getLevelInfo(_)
          , rt = levelColor[tt.type];
        return {
            isSvip: k,
            vipLevel: et,
            vipType: J,
            vipLevelColor: rt,
            vipTypeNum: tt.type
        }
    }
      , UserLevel = React.memo(function _({level: k, className: J=""}) {
        const {isSvip: et, vipLevel: tt, vipLevelColor: rt} = getUserLevelInfo(k);
        return jsxRuntimeExports.jsx("div", {
            className: cx(userLevelWrap, "user-level", J, et && " svip"),
            style: {
                backgroundColor: rt
            },
            children: jsxRuntimeExports.jsxs("div", {
                className: "level-wrap",
                children: [jsxRuntimeExports.jsx("span", {
                    children: et ? "SV" : "V"
                }), jsxRuntimeExports.jsx("span", {
                    children: tt
                })]
            })
        })
    })
      , avatarWrap = "a1xn5uyu"
      , userRankWrap = "u12rvwmw"
      , userLevelWrap = "u8wsmvw"
      , userWrap = "ujrzws5"
      , titleViews = "tpmprmu"
      , getShareRes = memoize$1(()=>http.get("/agent/invitation/code/custom/"))
      , getShareLink = memoize$1((_,k)=>http.post(`/game/support/share/short-link/${_}/`, k));
    function getAssets(_) {
        return app.assets(`/share/share_${_}.png`)
    }
    function getShareLinks(_) {
        const k = [{
            name: "email",
            url: void 0,
            icon: getAssets(10)
        }, {
            name: "facebook",
            url: "https://www.facebook.com/sharer.php?u=",
            baseUrl: "https://www.facebook.com/sharer.php?",
            icon: getAssets(3)
        }, {
            name: "twitter",
            url: "https://twitter.com/share?url=",
            baseUrl: "https://twitter.com/share?",
            icon: getAssets(8)
        }, {
            name: "telegram",
            url: "https://t.me/share?url=",
            baseUrl: "https://t.me/share?",
            icon: getAssets(7)
        }, {
            name: "vk",
            url: "http://vk.com/share.php?",
            icon: getAssets(11)
        }, {
            name: "lineit",
            url: "https://lineit.line.me/share/ui?",
            icon: getAssets(12)
        }, {
            name: "vertical",
            url: void 0,
            icon: getAssets(6)
        }, {
            name: "skype",
            url: "https://web.skype.com/share?",
            icon: getAssets(13)
        }, {
            name: "connect",
            url: "https://connect.ok.ru/offer?url=",
            icon: getAssets(14)
        }, {
            name: "btc",
            url: void 0,
            icon: getAssets(1)
        }, {
            name: "pinterest",
            url: void 0,
            icon: getAssets(15)
        }, {
            name: "linkedin",
            url: "https://www.linkedin.com/sharing/share-offsite/?",
            icon: getAssets(16)
        }, {
            name: "whatsapp",
            url: "https://api.whatsapp.com/send?",
            icon: getAssets(17)
        }, {
            name: "reddit",
            url: void 0,
            icon: getAssets(18)
        }];
        return Promise.all(k.map(J=>shareLink($t({
            platform: $t({}, J)
        }, _))))
    }
    async function shareLink({platform: _, title: k, inviteUrl: J, inviteCode: et, content: tt="", imgUrl: rt, shareUrl: nt, isGame: ot=!0}) {
        let it = {
            invitationUrl: `${location.protocol}://${env.host}`,
            invitationCode: ""
        };
        if (J && et ? it = {
            invitationUrl: J,
            invitationCode: et
        } : accountStore.state.login && (it = await getShareRes()),
        !_.url)
            return _;
        rt = rt || `${location.protocol}//${env.host}/share_image.jpg`;
        const at = nt ? `${it.invitationUrl}?p=${nt}` : it.invitationUrl;
        let lt = "";
        if (_.name === "facebook" || _.name === "twitter" || _.name === "telegram") {
            const st = {
                title: k,
                desc: tt,
                image: rt
            }
              , ut = _.name === "facebook";
            if (!ot || !accountStore.state.login) {
                const ct = `title=${encodeURIComponent(k)}&text=${encodeURIComponent(tt)}&${ut ? "u" : "url"}=${encodeURIComponent(at)}`;
                lt = _.baseUrl + ct
            } else {
                const ct = await getShareLink(it.invitationCode, st);
                lt = _.url + ct
            }
        } else if (_.name === "linkedin") {
            let st = `url=${encodeURIComponent(at)}`;
            lt = _.url + st
        } else if (_.name === "connect") {
            let st = `url=${encodeURIComponent(at)}&title=${encodeURIComponent(k)}&imageUrl=${encodeURIComponent(rt)}`;
            lt = _.url + st
        } else {
            let st = `url=${encodeURIComponent(at)}&title=${encodeURIComponent(k)}&text=${encodeURIComponent(tt)}`;
            lt = _.url + st
        }
        return _t($t({}, _), {
            url: lt
        })
    }
    let ErrorCode, GoogleCode, googleCodeWrap;
    ErrorCode = {
        NORMAL: 4001,
        TWOFA_ERROR: 4002,
        INSUFFICIENT_BALANCE: 5002,
        SAME_EMAIL: 5801,
        IS_MUTE: 6001,
        NEED_LOGIN: 6002,
        SESSION_ERROR: 6003,
        NEED_VERIFY: 6004,
        IS_BLOCKED: 6005,
        LOCKED_BY_KYC: 6008,
        SELF_EXCLUSION: 6009,
        REMOTE_LOGIN: 6010,
        NEED_EMAIL_AND_BASIC_KYC: 6101,
        NEED_EMAIL_AND_ADVANCED_KYC: 6102,
        NEED_PHONE_AND_BASIC_KYC: 6103,
        NEED_PHONE_AND_ADVANCED_KYC: 6104,
        NEED_EMAIL_OR_PHONE_AND_BASIC_KYC: 6105,
        NEED_EMAIL_OR_PHONE_AND_ADVANCED_KYC: 6106,
        NEED_EMAIL_AND_PHONE_AND_BASIC_KYC: 6107,
        NEED_EMAIL_AND_PHONE_AND_ADVANCED_KYC: 6108,
        NEED_BASIC_KYC: 6109,
        NEED_ADVANCED_KYC: 6110,
        FINAL_REJECT_KYC: 6111,
        IS_UPDATING: 1999
    },
    GoogleCode = React.memo(function _({value: k, onChange: J, autoFocus: et=!1, className: tt}) {
        const [rt,nt] = reactExports.useState(et)
          , ot = reactExports.useRef(null)
          , it = at=>[1, 2, 3, 4, 5, 6].map((lt,st)=>jsxRuntimeExports.jsx("li", {
            className: at.length === st ? "active" : "",
            children: at.slice(st, st + 1)
        }, lt));
        return useIsomorphicEffect(()=>{
            et && ot.current && setTimeout(()=>{
                var at;
                return (at = ot.current) == null ? void 0 : at.focus()
            }
            , 300)
        }
        , []),
        jsxRuntimeExports.jsx("div", {
            className: cx(googleCodeWrap, tt),
            children: jsxRuntimeExports.jsxs("div", {
                className: "google-input",
                children: [jsxRuntimeExports.jsx("input", {
                    ref: ot,
                    value: k,
                    onBlur: ()=>{
                        nt(!1)
                    }
                    ,
                    onFocus: ()=>nt(!0),
                    onChange: at=>{
                        at.target.value.length > 6 || J(at.target.value)
                    }
                    ,
                    autoComplete: "off"
                }), jsxRuntimeExports.jsx("ul", {
                    className: rt ? "focus-list" : "",
                    onClick: ()=>{
                        var at;
                        (at = ot.current) == null || at.focus(),
                        nt(!0)
                    }
                    ,
                    children: it(k)
                })]
            })
        })
    }),
    googleCodeWrap = "gmdcq1k",
    BC = {
        CoinIcon,
        CoinFormat,
        UserInfo,
        UserName,
        Avatar,
        ErrorCode,
        GoogleCode,
        getShareLinks,
        vipLevelsList,
        UserLevel,
        UserTitle,
        UserRank,
        getUserLevelInfo,
        getLevelInfo,
        levelColor,
        maxLevel
    },
    minimal$2.util.Long = Long,
    minimal$2.configure()
}
)();
export {baseIsMatch as $, baseGetAllKeys as A, getTag$1 as B, nodeUtil$1 as C, baseUnary as D, isBuffer$3 as E, Stack as F, getAllKeys as G, arrayMap as H, baseIteratee as I, isTypedArray$2 as J, isArguments$1 as K, isFunction$1 as L, SetCache as M, cacheHas as N, baseSlice as O, mapToArray as P, basePropertyOf as Q, arrayFilter as R, Symbol$2 as S, hasPath as T, Uint8Array$2 as U, toFinite as V, WeakMap$2 as W, baseGet as X, castPath as Y, baseKeys as Z, baseIsEqual as _, __tla, app as a, camelToDash as a$, getMatchData as a0, coreJsData$1 as a1, stubFalse as a2, baseIsNative as a3, baseMatches as a4, baseMatchesProperty as a5, setToArray as a6, arraySome as a7, baseProperty as a8, hasIn as a9, mix as aA, moveItem as aB, motion as aC, interpolate as aD, useMotionValue as aE, useIsomorphicLayoutEffect$2 as aF, cancelFrame as aG, frame as aH, collectMotionValues as aI, isMotionValue as aJ, createDomVisualElement as aK, animations as aL, gestureAnimations as aM, drag as aN, layout as aO, animateValue as aP, frameData as aQ, millisecondsToSeconds as aR, resolveElements as aS, progress as aT, velocityPerSecond as aU, defaultOffset as aV, warning$1 as aW, motionValue as aX, MotionValue as aY, transformProps as aZ, isCSSVariableName as a_, baseSortedIndexBy as aa, baseTimes as ab, stringToPath$1 as ac, baseTrim as ad, trimmedEndIndex as ae, Set$2 as af, chunk as ag, sortedIndexBy as ah, now$1 as ai, before as aj, debounce as ak, memoize$1 as al, once$1 as am, throttle$1 as an, isLength as ao, unescape$2 as ap, property as aq, createMotionProxy as ar, createDomMotionConfig as as, loadExternalIsValidProp as at, MotionConfigContext as au, useConstant as av, loadFeatures as aw, LazyContext as ax, LayoutGroupContext as ay, useForceUpdate$1 as az, baseToString as b, mirrorEasing as b$, addUniqueItem as b0, removeItem as b1, hasReducedMotionListener as b2, initPrefersReducedMotion as b3, prefersReducedMotion as b4, useUnmountEffect as b5, createScopedAnimate as b6, wrap as b7, addDomEvent as b8, motionComponentSymbol as b9, animationControls as bA, anticipate as bB, backIn as bC, backInOut as bD, backOut as bE, buildTransform as bF, calcLength as bG, circIn as bH, circInOut as bI, circOut as bJ, clamp as bK, color as bL, complex as bM, createDomMotionComponent as bN, createMotionComponent as bO, cubicBezier as bP, delay$1 as bQ, distance as bR, distance2D as bS, easeIn as bT, easeInOut as bU, easeOut as bV, filterProps as bW, invariant$1 as bX, isBrowser$1 as bY, isDragActive as bZ, isValidMotionProp as b_, rootProjectionNode as ba, instantAnimationState as bb, optimizedAppearDataId as bc, animateStyle as bd, noop$4 as be, makeUseVisualState as bf, animateVisualElement as bg, VisualElement as bh, createBox as bi, getOrigin as bj, checkTargetForNewValues as bk, MotionContext as bl, observeTimeline as bm, supportsScrollTimeline as bn, easingDefinitionToFunction as bo, stepsOrder as bp, AnimatePresence as bq, DragControls as br, FlatTree as bs, MotionGlobalConfig as bt, PresenceContext as bu, SwitchLayoutGroupContext as bv, addPointerEvent as bw, addPointerInfo as bx, addScaleCorrector as by, animate$1 as bz, identity as c, RadioBase as c$, optimizedAppearDataAttribute as c0, pipe as c1, px as c2, resolveMotionValue as c3, reverseEasing as c4, spring as c5, steps as c6, useAnimation as c7, useAnimationControls as c8, useDragControls as c9, Empty as cA, ErrorBoundary as cB, ErrorCode$1 as cC, ErrorWithTip as cD, EventEmitter$2 as cE, FileSelect as cF, FlatList$1 as cG, HttpResponseError as cH, I18nProvider as cI, Icon as cJ, Image$1 as cK, Imgix as cL, Input as cM, InputNumber as cN, InputPassword as cO, InputWrap as cP, LayoutSizeProvider as cQ, LazyImage as cR, Link as cS, Loading$1 as cT, Long as cU, Lottie as cV, Overlayer as cW, Pagination as cX, Pop as cY, Portal as cZ, Radio as c_, useIsPresent as ca, usePresence as cb, visualElementStore as cc, howler as cd, Active as ce, ActiveProvider as cf, AnimatedNumber as cg, AppProvider as ch, BC as ci, Badge as cj, Breadcrumb as ck, Button2 as cl, ButtonGroup as cm, Carousel$1 as cn, CircleCountdown as co, CloseIcon as cp, CodeSegment as cq, Confirm as cr, Content as cs, Countdown$1 as ct, Decimal$1 as cu, DecimalUtils as cv, Dialog as cw, DialogHeader as cx, DialogTable as cy, DragDialog as cz, isObject$2 as d, useInOverlayer as d$, ScrollView as d0, Select$1 as d1, SelectBase as d2, Slider as d3, State as d4, SuspenseData as d5, SuspenseSource as d6, Swiper as d7, Switch$1 as d8, Table as d9, pickLazyComponent as dA, pickLazyFunction as dB, pop as dC, minimal$3 as dD, requestRecaptcha as dE, settingStore as dF, socket as dG, subscribePageContext as dH, supportSocket as dI, system as dJ, systemStore as dK, useAccount as dL, useActiveMemo as dM, useAnimatedFrames as dN, useAsync as dO, useAsyncFn as dP, useAsyncNode as dQ, useAutoRemove as dR, useBcd as dS, useChangeLang as dT, useCurrencyConfig as dU, useDelayHover as dV, useDialog as dW, useDisableBodyScroll as dX, useDisableParentScroll as dY, useForceUpdate as dZ, useHover as d_, Tabs$1 as da, Text as db, Textarea as dc, ToggleView as dd, Tooltip as de, TooltipBase as df, Trans as dg, UpdateInView$1 as dh, User as di, VipLevelStatus as dj, WithOutSsr as dk, accountStore as dl, addUserReceiptEvent as dm, AsyncQueue$1 as dn, bcdStore as dp, createI18nT as dq, dialog as dr, env as ds, formateContent as dt, http as du, instance as dv, langsLocaleToISO6391 as dw, lazyLoad as dx, notify as dy, parseI18Locales as dz, isObjectLike as e, useInView as e0, useIntersection as e1, useIsActive as e2, useIsDarken as e3, useIsFirstRender as e4, useIsMobile as e5, useIsomorphicEffect as e6, useLayoutSize as e7, useLinkIntercept as e8, useLocalCurrency as e9, valtio as eA, wallet as eB, walletStore as eC, F as eD, ReactDOM as eE, reactDomExports as eF, react_dom as eG, gsap as eH, gsapWithCSS as eI, react_router_dom as eJ, useLocation$1 as eK, commonjsGlobal as eL, getDefaultExportFromCjs as eM, useLocation as ea, useMergeRefs as eb, useMountedState as ec, useNavigate as ed, useNotify as ee, useOnClickOutside as ef, usePageContext as eg, usePageProps as eh, usePop as ei, usePortalContext as ej, usePortalList as ek, usePrevious as el, useQrcode as em, useResize as en, useRootClassName as eo, useSetSearch as ep, useSetState as eq, useSetting as er, useSmoothList as es, useSystem as et, useToggleDarken as eu, useTranslation as ev, useWallet as ew, useWindowSize as ex, userSocket as ey, index$1 as ez, isIndex as f, getNative as g, eq as h, isSymbol as i, isIterateeCall as j, isPrototype as k, isArrayLike as l, keys$1 as m, n0 as n, arrayLikeKeys as o, get$1 as p, overArg as q, root$1 as r, baseGetTag as s, toInteger as t, toKey as u, toNumber as v, toString$5 as w, getSymbols$1 as x, stubArray as y, arrayPush as z};
